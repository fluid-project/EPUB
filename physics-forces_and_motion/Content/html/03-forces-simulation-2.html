<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE HTML>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">

    <head>
        <meta charset="utf-8" />
      <meta name="phet-sim-level" content="production"/>
        <title>Chapter 3 - Forces Simulation</title>
    </head>
    
    <body>        
        <img id="splash" style="position: absolute;top: 50%;left: 50%;margin-top: -210px;margin-left: -252px;" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj4KPHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSJMYXllcl8yIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciICB4PSIwcHgiIHk9IjBweCIKCSB3aWR0aD0iNTA0cHgiIGhlaWdodD0iMzYwcHgiIHZpZXdCb3g9IjAgMCA1MDQgMzYwIiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCA1MDQgMzYwIiB4bWw6c3BhY2U9InByZXNlcnZlIj48L3N2Zz4K">
        <script type="text/javascript"><![CDATA[window.phetStrings={"FORCES_AND_MOTION_BASICS/go":"Go!","FORCES_AND_MOTION_BASICS/pause":"Pause","FORCES_AND_MOTION_BASICS/return":"Return","FORCES_AND_MOTION_BASICS/blueWins":"Blue Wins!","FORCES_AND_MOTION_BASICS/redWins":"Red Wins!","FORCES_AND_MOTION_BASICS/sumOfForces":"Sum of Forces","FORCES_AND_MOTION_BASICS/values":"Values","FORCES_AND_MOTION_BASICS/forceReadout.pattern":"{0}N","FORCES_AND_MOTION_BASICS/leftForce":"Left Force","FORCES_AND_MOTION_BASICS/rightForce":"Right Force","FORCES_AND_MOTION_BASICS/sumOfForcesEqualsZero":"Sum of Forces = 0","FORCES_AND_MOTION_BASICS/massDisplay.pattern":"{0} kg","FORCES_AND_MOTION_BASICS/appliedForce":"Applied Force","FORCES_AND_MOTION_BASICS/newtons":"Newtons","FORCES_AND_MOTION_BASICS/speed":"Speed","FORCES_AND_MOTION_BASICS/frictionForce":"Friction Force","FORCES_AND_MOTION_BASICS/acceleration":"Acceleration","FORCES_AND_MOTION_BASICS/force":"Force","FORCES_AND_MOTION_BASICS/forces":"Forces","FORCES_AND_MOTION_BASICS/masses":"Masses","FORCES_AND_MOTION_BASICS/friction":"Friction","FORCES_AND_MOTION_BASICS/lots":"Lots","FORCES_AND_MOTION_BASICS/none":"None","JOIST/credits.developmentTeam":"Development Team","JOIST/credits.leadDesign":"Lead Design: {0}","JOIST/credits.softwareDevelopment":"Software Development: {0}","JOIST/credits.designTeam":"Design Team: {0}","JOIST/credits.interviews":"Interviews: {0}","JOIST/credits.graphicArts":"Graphic Arts: {0}","JOIST/credits.translation":"Translation","JOIST/credits.thanks":"Thanks","JOIST/credits.qualityAssurance":"Quality Assurance: {0}","JOIST/showPointers":"Show Pointers","JOIST/done":"Done","JOIST/title.settings":"Settings","JOIST/menuItem.about":"About...","JOIST/menuItem.mailInputEventsLog":"Mail Input Events Log","JOIST/menuItem.outputInputEventsLog":"Output Input Events Log","JOIST/menuItem.phetWebsite":"PhET website...","JOIST/menuItem.reportAProblem":"Report a Problem...","JOIST/menuItem.settings":"Settings...","JOIST/menuItem.submitInputEventsLog":"Submit Input Events Log","FORCES_AND_MOTION_BASICS/forces-and-motion-basics.name":"Forces and Motion: Basics","FORCES_AND_MOTION_BASICS/tugOfWar":"Tug of War","FORCES_AND_MOTION_BASICS/motion":"Motion"}]]></script>
        <script type="text/javascript"><![CDATA[window.phetLocale='en';window.phetVersion='forces-and-motion-basics 1.0.0';]]></script>
        <script type="text/javascript"><![CDATA[
          window.phetStrings.get = function( key ) {
        
            //Support translation by query parameter to enable translation in the browser
            return window.phetcommon.getQueryParameter( key ) || window.phetStrings[key];
          };
        ]]></script>
        <script type="text/javascript"><![CDATA[!function(e,t,n,r,i,o){function a(e){var t,n=e.length,i=this,o=0,a=i.i=i.j=0,u=i.S=[];for(n||(e=[n++]);r>o;)u[o]=o++;for(o=0;r>o;o++)u[o]=u[a=h&a+e[o%n]+(t=u[o])],u[a]=t;(i.g=function(e){for(var t,n=0,o=i.i,a=i.j,u=i.S;e--;)t=u[o=h&o+1],n=n*r+u[h&(u[o]=u[a=h&a+t])+(u[a]=t)];return i.i=o,i.j=a,n})(r)}function u(e,t){var n,r=[],i=(typeof e)[0];if(t&&"o"==i)for(n in e)try{r.push(u(e[n],t-1))}catch(o){}return r.length?r:"s"==i?e:e+"\x00"}function s(e,t){for(var n,r=e+"",i=0;i<r.length;)t[h&i]=h&(n^=19*t[h&i])+r.charCodeAt(i++);return l(t)}function c(n){try{return e.crypto.getRandomValues(n=new Uint8Array(r)),l(n)}catch(i){return[+new Date,e,e.navigator.plugins,e.screen,l(t)]}}function l(e){return String.fromCharCode.apply(0,e)}var f=n.pow(r,i),p=n.pow(2,o),d=2*p,h=r-1;n.seedrandom=function(e,o){var h=[],g=s(u(o?[e,l(t)]:0 in arguments?e:c(),3),h),v=new a(h);return s(l(v.S),t),n.random=function(){for(var e=v.g(i),t=f,n=0;p>e;)e=(e+n)*r,t*=r,n=v.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t},g},s(n.random(),t)}(this,[],Math,256,6,52),function(e,t){"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(e,t){function n(e){var t=e.length,n=et.type(e);return"function"===n||et.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===n||0===t||"number"==typeof t&&t>0&&t-1 in e}function r(e,t,n){if(et.isFunction(t))return et.grep(e,function(e,r){return!!t.call(e,r,e)!==n});if(t.nodeType)return et.grep(e,function(e){return e===t!==n});if("string"==typeof t){if(ut.test(t))return et.filter(t,e,n);t=et.filter(t,e)}return et.grep(e,function(e){return X.call(t,e)>=0!==n})}function i(e,t){for(;(e=e[t])&&1!==e.nodeType;);return e}function o(e){var t=ht[e]={};return et.each(e.match(dt)||[],function(e,n){t[n]=!0}),t}function a(){J.removeEventListener("DOMContentLoaded",a,!1),e.removeEventListener("load",a,!1),et.ready()}function u(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=et.expando+Math.random()}function s(e,t,n){var r;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(wt,"-$1").toLowerCase(),n=e.getAttribute(r),"string"==typeof n){try{n="true"===n?!0:"false"===n?!1:"null"===n?null:+n+""===n?+n:bt.test(n)?et.parseJSON(n):n}catch(i){}yt.set(e,t,n)}else n=void 0;return n}function c(){return!0}function l(){return!1}function f(){try{return J.activeElement}catch(e){}}function p(e,t){return et.nodeName(e,"table")&&et.nodeName(11!==t.nodeType?t:t.firstChild,"tr")?e.getElementsByTagName("tbody")[0]||e.appendChild(e.ownerDocument.createElement("tbody")):e}function d(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function h(e){var t=Mt.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function g(e,t){for(var n=0,r=e.length;r>n;n++)mt.set(e[n],"globalEval",!t||mt.get(t[n],"globalEval"))}function v(e,t){var n,r,i,o,a,u,s,c;if(1===t.nodeType){if(mt.hasData(e)&&(o=mt.access(e),a=mt.set(t,o),c=o.events)){delete a.handle,a.events={};for(i in c)for(n=0,r=c[i].length;r>n;n++)et.event.add(t,i,c[i][n])}yt.hasData(e)&&(u=yt.access(e),s=et.extend({},u),yt.set(t,s))}}function m(e,t){var n=e.getElementsByTagName?e.getElementsByTagName(t||"*"):e.querySelectorAll?e.querySelectorAll(t||"*"):[];return void 0===t||t&&et.nodeName(e,t)?et.merge([e],n):n}function y(e,t){var n=t.nodeName.toLowerCase();"input"===n&&Et.test(e.type)?t.checked=e.checked:("input"===n||"textarea"===n)&&(t.defaultValue=e.defaultValue)}function b(t,n){var r=et(n.createElement(t)).appendTo(n.body),i=e.getDefaultComputedStyle?e.getDefaultComputedStyle(r[0]).display:et.css(r[0],"display");return r.detach(),i}function w(e){var t=J,n=Pt[e];return n||(n=b(e,t),"none"!==n&&n||(Ft=(Ft||et("<iframe frameborder='0' width='0' height='0'/>")).appendTo(t.documentElement),t=Ft[0].contentDocument,t.write(),t.close(),n=b(e,t),Ft.detach()),Pt[e]=n),n}function x(e,t,n){var r,i,o,a,u=e.style;return n=n||$t(e),n&&(a=n.getPropertyValue(t)||n[t]),n&&(""!==a||et.contains(e.ownerDocument,e)||(a=et.style(e,t)),Bt.test(a)&&Wt.test(t)&&(r=u.width,i=u.minWidth,o=u.maxWidth,u.minWidth=u.maxWidth=u.width=a,a=n.width,u.width=r,u.minWidth=i,u.maxWidth=o)),void 0!==a?a+"":a}function T(e,t){return{get:function(){return e()?void delete this.get:(this.get=t).apply(this,arguments)}}}function C(e,t){if(t in e)return t;for(var n=t[0].toUpperCase()+t.slice(1),r=t,i=Yt.length;i--;)if(t=Yt[i]+n,t in e)return t;return r}function E(e,t,n){var r=zt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function N(e,t,n,r,i){for(var o=n===(r?"border":"content")?4:"width"===t?1:0,a=0;4>o;o+=2)"margin"===n&&(a+=et.css(e,n+Tt[o],!0,i)),r?("content"===n&&(a-=et.css(e,"padding"+Tt[o],!0,i)),"margin"!==n&&(a-=et.css(e,"border"+Tt[o]+"Width",!0,i))):(a+=et.css(e,"padding"+Tt[o],!0,i),"padding"!==n&&(a+=et.css(e,"border"+Tt[o]+"Width",!0,i)));return a}function k(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=$t(e),a="border-box"===et.css(e,"boxSizing",!1,o);if(0>=i||null==i){if(i=x(e,t,o),(0>i||null==i)&&(i=e.style[t]),Bt.test(i))return i;r=a&&(K.boxSizingReliable()||i===e.style[t]),i=parseFloat(i)||0}return i+N(e,t,n||(a?"border":"content"),r,o)+"px"}function j(e,t){for(var n,r,i,o=[],a=0,u=e.length;u>a;a++)r=e[a],r.style&&(o[a]=mt.get(r,"olddisplay"),n=r.style.display,t?(o[a]||"none"!==n||(r.style.display=""),""===r.style.display&&Ct(r)&&(o[a]=mt.access(r,"olddisplay",w(r.nodeName)))):o[a]||(i=Ct(r),(n&&"none"!==n||!i)&&mt.set(r,"olddisplay",i?n:et.css(r,"display"))));for(a=0;u>a;a++)r=e[a],r.style&&(t&&"none"!==r.style.display&&""!==r.style.display||(r.style.display=t?o[a]||"":"none"));return e}function _(e,t,n,r,i){return new _.prototype.init(e,t,n,r,i)}function S(){return setTimeout(function(){Gt=void 0}),Gt=et.now()}function D(e,t){var n,r=0,i={height:e};for(t=t?1:0;4>r;r+=2-t)n=Tt[r],i["margin"+n]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function A(e,t,n){for(var r,i=(nn[t]||[]).concat(nn["*"]),o=0,a=i.length;a>o;o++)if(r=i[o].call(n,t,e))return r}function O(e,t,n){var r,i,o,a,u,s,c,l=this,f={},p=e.style,d=e.nodeType&&Ct(e),h=mt.get(e,"fxshow");n.queue||(u=et._queueHooks(e,"fx"),null==u.unqueued&&(u.unqueued=0,s=u.empty.fire,u.empty.fire=function(){u.unqueued||s()}),u.unqueued++,l.always(function(){l.always(function(){u.unqueued--,et.queue(e,"fx").length||u.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],c=et.css(e,"display"),"none"===c&&(c=w(e.nodeName)),"inline"===c&&"none"===et.css(e,"float")&&(p.display="inline-block")),n.overflow&&(p.overflow="hidden",l.always(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(r in t)if(i=t[r],Jt.exec(i)){if(delete t[r],o=o||"toggle"===i,i===(d?"hide":"show")){if("show"!==i||!h||void 0===h[r])continue;d=!0}f[r]=h&&h[r]||et.style(e,r)}if(!et.isEmptyObject(f)){h?"hidden"in h&&(d=h.hidden):h=mt.access(e,"fxshow",{}),o&&(h.hidden=!d),d?et(e).show():l.done(function(){et(e).hide()}),l.done(function(){var t;mt.remove(e,"fxshow");for(t in f)et.style(e,t,f[t])});for(r in f)a=A(d?h[r]:0,r,l),r in h||(h[r]=a.start,d&&(a.end=a.start,a.start="width"===r||"height"===r?1:0))}}function L(e,t){var n,r,i,o,a;for(n in e)if(r=et.camelCase(n),i=t[r],o=e[n],et.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),a=et.cssHooks[r],a&&"expand"in a){o=a.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}function q(e,t,n){var r,i,o=0,a=tn.length,u=et.Deferred().always(function(){delete s.elem}),s=function(){if(i)return!1;for(var t=Gt||S(),n=Math.max(0,c.startTime+c.duration-t),r=n/c.duration||0,o=1-r,a=0,s=c.tweens.length;s>a;a++)c.tweens[a].run(o);return u.notifyWith(e,[c,o,n]),1>o&&s?n:(u.resolveWith(e,[c]),!1)},c=u.promise({elem:e,props:et.extend({},t),opts:et.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Gt||S(),duration:n.duration,tweens:[],createTween:function(t,n){var r=et.Tween(e,c.opts,t,n,c.opts.specialEasing[t]||c.opts.easing);return c.tweens.push(r),r},stop:function(t){var n=0,r=t?c.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)c.tweens[n].run(1);return t?u.resolveWith(e,[c,t]):u.rejectWith(e,[c,t]),this}}),l=c.props;for(L(l,c.opts.specialEasing);a>o;o++)if(r=tn[o].call(c,e,l,c.opts))return r;return et.map(l,A,c),et.isFunction(c.opts.start)&&c.opts.start.call(e,c),et.fx.timer(et.extend(s,{elem:e,anim:c,queue:c.opts.queue})),c.progress(c.opts.progress).done(c.opts.done,c.opts.complete).fail(c.opts.fail).always(c.opts.always)}function I(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(dt)||[];if(et.isFunction(n))for(;r=o[i++];)"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function M(e,t,n,r){function i(u){var s;return o[u]=!0,et.each(e[u]||[],function(e,u){var c=u(t,n,r);return"string"!=typeof c||a||o[c]?a?!(s=c):void 0:(t.dataTypes.unshift(c),i(c),!1)}),s}var o={},a=e===Tn;return i(t.dataTypes[0])||!o["*"]&&i("*")}function R(e,t){var n,r,i=et.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&et.extend(!0,e,r),e}function H(e,t,n){for(var r,i,o,a,u=e.contents,s=e.dataTypes;"*"===s[0];)s.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in u)if(u[i]&&u[i].test(r)){s.unshift(i);break}if(s[0]in n)o=s[0];else{for(i in n){if(!s[0]||e.converters[i+" "+s[0]]){o=i;break}a||(a=i)}o=o||a}return o?(o!==s[0]&&s.unshift(o),n[o]):void 0}function F(e,t,n,r){var i,o,a,u,s,c={},l=e.dataTypes.slice();if(l[1])for(a in e.converters)c[a.toLowerCase()]=e.converters[a];for(o=l.shift();o;)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!s&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),s=o,o=l.shift())if("*"===o)o=s;else if("*"!==s&&s!==o){if(a=c[s+" "+o]||c["* "+o],!a)for(i in c)if(u=i.split(" "),u[1]===o&&(a=c[s+" "+u[0]]||c["* "+u[0]])){a===!0?a=c[i]:c[i]!==!0&&(o=u[0],l.unshift(u[1]));break}if(a!==!0)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(f){return{state:"parsererror",error:a?f:"No conversion from "+s+" to "+o}}}return{state:"success",data:t}}function P(e,t,n,r){var i;if(et.isArray(t))et.each(t,function(t,i){n||kn.test(e)?r(e,i):P(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==et.type(t))r(e,t);else for(i in t)P(e+"["+i+"]",t[i],n,r)}function W(e){return et.isWindow(e)?e:9===e.nodeType&&e.defaultView}var B=[],$=B.slice,U=B.concat,z=B.push,X=B.indexOf,V={},Q=V.toString,Y=V.hasOwnProperty,G="".trim,K={},J=e.document,Z="2.1.0",et=function(e,t){return new et.fn.init(e,t)},tt=/^-ms-/,nt=/-([\da-z])/gi,rt=function(e,t){return t.toUpperCase()};et.fn=et.prototype={jquery:Z,constructor:et,selector:"",length:0,toArray:function(){return $.call(this)},get:function(e){return null!=e?0>e?this[e+this.length]:this[e]:$.call(this)},pushStack:function(e){var t=et.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return et.each(this,e,t)},map:function(e){return this.pushStack(et.map(this,function(t,n){return e.call(t,n,t)}))},slice:function(){return this.pushStack($.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:z,sort:B.sort,splice:B.splice},et.extend=et.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},u=1,s=arguments.length,c=!1;for("boolean"==typeof a&&(c=a,a=arguments[u]||{},u++),"object"==typeof a||et.isFunction(a)||(a={}),u===s&&(a=this,u--);s>u;u++)if(null!=(e=arguments[u]))for(t in e)n=a[t],r=e[t],a!==r&&(c&&r&&(et.isPlainObject(r)||(i=et.isArray(r)))?(i?(i=!1,o=n&&et.isArray(n)?n:[]):o=n&&et.isPlainObject(n)?n:{},a[t]=et.extend(c,o,r)):void 0!==r&&(a[t]=r));return a},et.extend({expando:"jQuery"+(Z+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isFunction:function(e){return"function"===et.type(e)},isArray:Array.isArray,isWindow:function(e){return null!=e&&e===e.window},isNumeric:function(e){return e-parseFloat(e)>=0},isPlainObject:function(e){if("object"!==et.type(e)||e.nodeType||et.isWindow(e))return!1;try{if(e.constructor&&!Y.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(t){return!1}return!0},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?V[Q.call(e)]||"object":typeof e},globalEval:function(e){var t,n=eval;e=et.trim(e),e&&(1===e.indexOf("use strict")?(t=J.createElement("script"),t.text=e,J.head.appendChild(t).parentNode.removeChild(t)):n(e))},camelCase:function(e){return e.replace(tt,"ms-").replace(nt,rt)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,r){var i,o=0,a=e.length,u=n(e);if(r){if(u)for(;a>o&&(i=t.apply(e[o],r),i!==!1);o++);else for(o in e)if(i=t.apply(e[o],r),i===!1)break}else if(u)for(;a>o&&(i=t.call(e[o],o,e[o]),i!==!1);o++);else for(o in e)if(i=t.call(e[o],o,e[o]),i===!1)break;return e},trim:function(e){return null==e?"":G.call(e)},makeArray:function(e,t){var r=t||[];return null!=e&&(n(Object(e))?et.merge(r,"string"==typeof e?[e]:e):z.call(r,e)),r},inArray:function(e,t,n){return null==t?-1:X.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;n>r;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r,i=[],o=0,a=e.length,u=!n;a>o;o++)r=!t(e[o],o),r!==u&&i.push(e[o]);return i},map:function(e,t,r){var i,o=0,a=e.length,u=n(e),s=[];if(u)for(;a>o;o++)i=t(e[o],o,r),null!=i&&s.push(i);else for(o in e)i=t(e[o],o,r),null!=i&&s.push(i);return U.apply([],s)},guid:1,proxy:function(e,t){var n,r,i;return"string"==typeof t&&(n=e[t],t=e,e=n),et.isFunction(e)?(r=$.call(arguments,2),i=function(){return e.apply(t||this,r.concat($.call(arguments)))},i.guid=e.guid=e.guid||et.guid++,i):void 0},now:Date.now,support:K}),et.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){V["[object "+t+"]"]=t.toLowerCase()});var it=function(e){function t(e,t,n,r){var i,o,a,u,s,c,f,h,g,v;if((t?t.ownerDocument||t:P)!==O&&A(t),t=t||O,n=n||[],!e||"string"!=typeof e)return n;if(1!==(u=t.nodeType)&&9!==u)return[];if(q&&!r){if(i=yt.exec(e))if(a=i[1]){if(9===u){if(o=t.getElementById(a),!o||!o.parentNode)return n;if(o.id===a)return n.push(o),n}else if(t.ownerDocument&&(o=t.ownerDocument.getElementById(a))&&H(t,o)&&o.id===a)return n.push(o),n}else{if(i[2])return Z.apply(n,t.getElementsByTagName(e)),n;if((a=i[3])&&C.getElementsByClassName&&t.getElementsByClassName)return Z.apply(n,t.getElementsByClassName(a)),n}if(C.qsa&&(!I||!I.test(e))){if(h=f=F,g=t,v=9===u&&e,1===u&&"object"!==t.nodeName.toLowerCase()){for(c=p(e),(f=t.getAttribute("id"))?h=f.replace(wt,"\\$&"):t.setAttribute("id",h),h="[id='"+h+"'] ",s=c.length;s--;)c[s]=h+d(c[s]);g=bt.test(e)&&l(t.parentNode)||t,v=c.join(",")}if(v)try{return Z.apply(n,g.querySelectorAll(v)),n}catch(m){}finally{f||t.removeAttribute("id")}}}return x(e.replace(st,"$1"),t,n,r)}function n(){function e(n,r){return t.push(n+" ")>E.cacheLength&&delete e[t.shift()],e[n+" "]=r}var t=[];return e}function r(e){return e[F]=!0,e}function i(e){var t=O.createElement("div");try{return!!e(t)}catch(n){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function o(e,t){for(var n=e.split("|"),r=e.length;r--;)E.attrHandle[n[r]]=t}function a(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&(~t.sourceIndex||Q)-(~e.sourceIndex||Q);if(r)return r;if(n)for(;n=n.nextSibling;)if(n===t)return-1;return e?1:-1}function u(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function s(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function c(e){return r(function(t){return t=+t,r(function(n,r){for(var i,o=e([],n.length,t),a=o.length;a--;)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}function l(e){return e&&typeof e.getElementsByTagName!==V&&e}function f(){}function p(e,n){var r,i,o,a,u,s,c,l=U[e+" "];if(l)return n?0:l.slice(0);for(u=e,s=[],c=E.preFilter;u;){(!r||(i=ct.exec(u)))&&(i&&(u=u.slice(i[0].length)||u),s.push(o=[])),r=!1,(i=lt.exec(u))&&(r=i.shift(),o.push({value:r,type:i[0].replace(st," ")}),u=u.slice(r.length));for(a in E.filter)!(i=ht[a].exec(u))||c[a]&&!(i=c[a](i))||(r=i.shift(),o.push({value:r,type:a,matches:i}),u=u.slice(r.length));if(!r)break}return n?u.length:u?t.error(e):U(e,s).slice(0)}function d(e){for(var t=0,n=e.length,r="";n>t;t++)r+=e[t].value;return r}function h(e,t,n){var r=t.dir,i=n&&"parentNode"===r,o=B++;return t.first?function(t,n,o){for(;t=t[r];)if(1===t.nodeType||i)return e(t,n,o)}:function(t,n,a){var u,s,c=[W,o];if(a){for(;t=t[r];)if((1===t.nodeType||i)&&e(t,n,a))return!0}else for(;t=t[r];)if(1===t.nodeType||i){if(s=t[F]||(t[F]={}),(u=s[r])&&u[0]===W&&u[1]===o)return c[2]=u[2];if(s[r]=c,c[2]=e(t,n,a))return!0}}}function g(e){return e.length>1?function(t,n,r){for(var i=e.length;i--;)if(!e[i](t,n,r))return!1;return!0}:e[0]}function v(e,t,n,r,i){for(var o,a=[],u=0,s=e.length,c=null!=t;s>u;u++)(o=e[u])&&(!n||n(o,r,i))&&(a.push(o),c&&t.push(u));return a}function m(e,t,n,i,o,a){return i&&!i[F]&&(i=m(i)),o&&!o[F]&&(o=m(o,a)),r(function(r,a,u,s){var c,l,f,p=[],d=[],h=a.length,g=r||w(t||"*",u.nodeType?[u]:u,[]),m=!e||!r&&t?g:v(g,p,e,u,s),y=n?o||(r?e:h||i)?[]:a:m;if(n&&n(m,y,u,s),i)for(c=v(y,d),i(c,[],u,s),l=c.length;l--;)(f=c[l])&&(y[d[l]]=!(m[d[l]]=f));if(r){if(o||e){if(o){for(c=[],l=y.length;l--;)(f=y[l])&&c.push(m[l]=f);o(null,y=[],c,s)}for(l=y.length;l--;)(f=y[l])&&(c=o?tt.call(r,f):p[l])>-1&&(r[c]=!(a[c]=f))}}else y=v(y===a?y.splice(h,y.length):y),o?o(null,a,y,s):Z.apply(a,y)})}function y(e){for(var t,n,r,i=e.length,o=E.relative[e[0].type],a=o||E.relative[" "],u=o?1:0,s=h(function(e){return e===t},a,!0),c=h(function(e){return tt.call(t,e)>-1},a,!0),l=[function(e,n,r){return!o&&(r||n!==_)||((t=n).nodeType?s(e,n,r):c(e,n,r))}];i>u;u++)if(n=E.relative[e[u].type])l=[h(g(l),n)];else{if(n=E.filter[e[u].type].apply(null,e[u].matches),n[F]){for(r=++u;i>r&&!E.relative[e[r].type];r++);return m(u>1&&g(l),u>1&&d(e.slice(0,u-1).concat({value:" "===e[u-2].type?"*":""})).replace(st,"$1"),n,r>u&&y(e.slice(u,r)),i>r&&y(e=e.slice(r)),i>r&&d(e))}l.push(n)}return g(l)}function b(e,n){var i=n.length>0,o=e.length>0,a=function(r,a,u,s,c){var l,f,p,d=0,h="0",g=r&&[],m=[],y=_,b=r||o&&E.find.TAG("*",c),w=W+=null==y?1:Math.random()||.1,x=b.length;for(c&&(_=a!==O&&a);h!==x&&null!=(l=b[h]);h++){if(o&&l){for(f=0;p=e[f++];)if(p(l,a,u)){s.push(l);break}c&&(W=w)}i&&((l=!p&&l)&&d--,r&&g.push(l))}if(d+=h,i&&h!==d){for(f=0;p=n[f++];)p(g,m,a,u);if(r){if(d>0)for(;h--;)g[h]||m[h]||(m[h]=K.call(s));m=v(m)}Z.apply(s,m),c&&!r&&m.length>0&&d+n.length>1&&t.uniqueSort(s)}return c&&(W=w,_=y),g};return i?r(a):a}function w(e,n,r){for(var i=0,o=n.length;o>i;i++)t(e,n[i],r);return r}function x(e,t,n,r){var i,o,a,u,s,c=p(e);if(!r&&1===c.length){if(o=c[0]=c[0].slice(0),o.length>2&&"ID"===(a=o[0]).type&&C.getById&&9===t.nodeType&&q&&E.relative[o[1].type]){if(t=(E.find.ID(a.matches[0].replace(xt,Tt),t)||[])[0],!t)return n;e=e.slice(o.shift().value.length)}for(i=ht.needsContext.test(e)?0:o.length;i--&&(a=o[i],!E.relative[u=a.type]);)if((s=E.find[u])&&(r=s(a.matches[0].replace(xt,Tt),bt.test(o[0].type)&&l(t.parentNode)||t))){if(o.splice(i,1),e=r.length&&d(o),!e)return Z.apply(n,r),n;break}}return j(e,c)(r,t,!q,n,bt.test(e)&&l(t.parentNode)||t),n}var T,C,E,N,k,j,_,S,D,A,O,L,q,I,M,R,H,F="sizzle"+-new Date,P=e.document,W=0,B=0,$=n(),U=n(),z=n(),X=function(e,t){return e===t&&(D=!0),0},V="undefined",Q=1<<31,Y={}.hasOwnProperty,G=[],K=G.pop,J=G.push,Z=G.push,et=G.slice,tt=G.indexOf||function(e){for(var t=0,n=this.length;n>t;t++)if(this[t]===e)return t;return-1},nt="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",rt="[\\x20\\t\\r\\n\\f]",it="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",ot=it.replace("w","w#"),at="\\["+rt+"*("+it+")"+rt+"*(?:([*^$|!~]?=)"+rt+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+ot+")|)|)"+rt+"*\\]",ut=":("+it+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+at.replace(3,8)+")*)|.*)\\)|)",st=new RegExp("^"+rt+"+|((?:^|[^\\\\])(?:\\\\.)*)"+rt+"+$","g"),ct=new RegExp("^"+rt+"*,"+rt+"*"),lt=new RegExp("^"+rt+"*([>+~]|"+rt+")"+rt+"*"),ft=new RegExp("="+rt+"*([^\\]'\"]*?)"+rt+"*\\]","g"),pt=new RegExp(ut),dt=new RegExp("^"+ot+"$"),ht={ID:new RegExp("^#("+it+")"),CLASS:new RegExp("^\\.("+it+")"),TAG:new RegExp("^("+it.replace("w","w*")+")"),ATTR:new RegExp("^"+at),PSEUDO:new RegExp("^"+ut),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+rt+"*(even|odd|(([+-]|)(\\d*)n|)"+rt+"*(?:([+-]|)"+rt+"*(\\d+)|))"+rt+"*\\)|)","i"),bool:new RegExp("^(?:"+nt+")$","i"),needsContext:new RegExp("^"+rt+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+rt+"*((?:-\\d)?\\d*)"+rt+"*\\)|)(?=[^-]|$)","i")},gt=/^(?:input|select|textarea|button)$/i,vt=/^h\d$/i,mt=/^[^{]+\{\s*\[native \w/,yt=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,bt=/[+~]/,wt=/'|\\/g,xt=new RegExp("\\\\([\\da-f]{1,6}"+rt+"?|("+rt+")|.)","ig"),Tt=function(e,t,n){var r="0x"+t-65536;return r!==r||n?t:0>r?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320)};try{Z.apply(G=et.call(P.childNodes),P.childNodes),G[P.childNodes.length].nodeType}catch(Ct){Z={apply:G.length?function(e,t){J.apply(e,et.call(t))}:function(e,t){for(var n=e.length,r=0;e[n++]=t[r++];);e.length=n-1}}}C=t.support={},k=t.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},A=t.setDocument=function(e){var t,n=e?e.ownerDocument||e:P,r=n.defaultView;return n!==O&&9===n.nodeType&&n.documentElement?(O=n,L=n.documentElement,q=!k(n),r&&r!==r.top&&(r.addEventListener?r.addEventListener("unload",function(){A()},!1):r.attachEvent&&r.attachEvent("onunload",function(){A()})),C.attributes=i(function(e){return e.className="i",!e.getAttribute("className")}),C.getElementsByTagName=i(function(e){return e.appendChild(n.createComment("")),!e.getElementsByTagName("*").length}),C.getElementsByClassName=mt.test(n.getElementsByClassName)&&i(function(e){return e.innerHTML="<div class='a'></div><div class='a i'></div>",e.firstChild.className="i",2===e.getElementsByClassName("i").length}),C.getById=i(function(e){return L.appendChild(e).id=F,!n.getElementsByName||!n.getElementsByName(F).length}),C.getById?(E.find.ID=function(e,t){if(typeof t.getElementById!==V&&q){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},E.filter.ID=function(e){var t=e.replace(xt,Tt);return function(e){return e.getAttribute("id")===t}}):(delete E.find.ID,E.filter.ID=function(e){var t=e.replace(xt,Tt);return function(e){var n=typeof e.getAttributeNode!==V&&e.getAttributeNode("id");return n&&n.value===t}}),E.find.TAG=C.getElementsByTagName?function(e,t){return typeof t.getElementsByTagName!==V?t.getElementsByTagName(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){for(;n=o[i++];)1===n.nodeType&&r.push(n);return r}return o},E.find.CLASS=C.getElementsByClassName&&function(e,t){return typeof t.getElementsByClassName!==V&&q?t.getElementsByClassName(e):void 0},M=[],I=[],(C.qsa=mt.test(n.querySelectorAll))&&(i(function(e){e.innerHTML="<select t=''><option selected=''></option></select>",e.querySelectorAll("[t^='']").length&&I.push("[*^$]="+rt+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||I.push("\\["+rt+"*(?:value|"+nt+")"),e.querySelectorAll(":checked").length||I.push(":checked")}),i(function(e){var t=n.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&I.push("name"+rt+"*[*^$|!~]?="),e.querySelectorAll(":enabled").length||I.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),I.push(",.*:")})),(C.matchesSelector=mt.test(R=L.webkitMatchesSelector||L.mozMatchesSelector||L.oMatchesSelector||L.msMatchesSelector))&&i(function(e){C.disconnectedMatch=R.call(e,"div"),R.call(e,"[s!='']:x"),M.push("!=",ut)}),I=I.length&&new RegExp(I.join("|")),M=M.length&&new RegExp(M.join("|")),t=mt.test(L.compareDocumentPosition),H=t||mt.test(L.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)for(;t=t.parentNode;)if(t===e)return!0;return!1},X=t?function(e,t){if(e===t)return D=!0,0;var r=!e.compareDocumentPosition-!t.compareDocumentPosition;return r?r:(r=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1,1&r||!C.sortDetached&&t.compareDocumentPosition(e)===r?e===n||e.ownerDocument===P&&H(P,e)?-1:t===n||t.ownerDocument===P&&H(P,t)?1:S?tt.call(S,e)-tt.call(S,t):0:4&r?-1:1)}:function(e,t){if(e===t)return D=!0,0;var r,i=0,o=e.parentNode,u=t.parentNode,s=[e],c=[t];if(!o||!u)return e===n?-1:t===n?1:o?-1:u?1:S?tt.call(S,e)-tt.call(S,t):0;if(o===u)return a(e,t);for(r=e;r=r.parentNode;)s.unshift(r);for(r=t;r=r.parentNode;)c.unshift(r);for(;s[i]===c[i];)i++;return i?a(s[i],c[i]):s[i]===P?-1:c[i]===P?1:0},n):O},t.matches=function(e,n){return t(e,null,null,n)},t.matchesSelector=function(e,n){if((e.ownerDocument||e)!==O&&A(e),n=n.replace(ft,"='$1']"),!(!C.matchesSelector||!q||M&&M.test(n)||I&&I.test(n)))try{var r=R.call(e,n);if(r||C.disconnectedMatch||e.document&&11!==e.document.nodeType)return r}catch(i){}return t(n,O,null,[e]).length>0},t.contains=function(e,t){return(e.ownerDocument||e)!==O&&A(e),H(e,t)},t.attr=function(e,t){(e.ownerDocument||e)!==O&&A(e);var n=E.attrHandle[t.toLowerCase()],r=n&&Y.call(E.attrHandle,t.toLowerCase())?n(e,t,!q):void 0;return void 0!==r?r:C.attributes||!q?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},t.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},t.uniqueSort=function(e){var t,n=[],r=0,i=0;if(D=!C.detectDuplicates,S=!C.sortStable&&e.slice(0),e.sort(X),D){for(;t=e[i++];)t===e[i]&&(r=n.push(i));for(;r--;)e.splice(n[r],1)}return S=null,e},N=t.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=N(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r++];)n+=N(t);return n},E=t.selectors={cacheLength:50,createPseudo:r,match:ht,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(xt,Tt),e[3]=(e[4]||e[5]||"").replace(xt,Tt),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||t.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&t.error(e[0]),e},PSEUDO:function(e){var t,n=!e[5]&&e[2];return ht.CHILD.test(e[0])?null:(e[3]&&void 0!==e[4]?e[2]=e[4]:n&&pt.test(n)&&(t=p(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(xt,Tt).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=$[e+" "];return t||(t=new RegExp("(^|"+rt+")"+e+"("+rt+"|$)"))&&$(e,function(e){return t.test("string"==typeof e.className&&e.className||typeof e.getAttribute!==V&&e.getAttribute("class")||"")})},ATTR:function(e,n,r){return function(i){var o=t.attr(i,e);return null==o?"!="===n:n?(o+="","="===n?o===r:"!="===n?o!==r:"^="===n?r&&0===o.indexOf(r):"*="===n?r&&o.indexOf(r)>-1:"$="===n?r&&o.slice(-r.length)===r:"~="===n?(" "+o+" ").indexOf(r)>-1:"|="===n?o===r||o.slice(0,r.length+1)===r+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),u="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,s){var c,l,f,p,d,h,g=o!==a?"nextSibling":"previousSibling",v=t.parentNode,m=u&&t.nodeName.toLowerCase(),y=!s&&!u;if(v){if(o){for(;g;){for(f=t;f=f[g];)if(u?f.nodeName.toLowerCase()===m:1===f.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?v.firstChild:v.lastChild],a&&y){for(l=v[F]||(v[F]={}),c=l[e]||[],d=c[0]===W&&c[1],p=c[0]===W&&c[2],f=d&&v.childNodes[d];f=++d&&f&&f[g]||(p=d=0)||h.pop();)if(1===f.nodeType&&++p&&f===t){l[e]=[W,d,p];break}}else if(y&&(c=(t[F]||(t[F]={}))[e])&&c[0]===W)p=c[1];else for(;(f=++d&&f&&f[g]||(p=d=0)||h.pop())&&((u?f.nodeName.toLowerCase()!==m:1!==f.nodeType)||!++p||(y&&((f[F]||(f[F]={}))[e]=[W,p]),f!==t)););return p-=i,p===r||p%r===0&&p/r>=0}}},PSEUDO:function(e,n){var i,o=E.pseudos[e]||E.setFilters[e.toLowerCase()]||t.error("unsupported pseudo: "+e);return o[F]?o(n):o.length>1?(i=[e,e,"",n],E.setFilters.hasOwnProperty(e.toLowerCase())?r(function(e,t){for(var r,i=o(e,n),a=i.length;a--;)r=tt.call(e,i[a]),e[r]=!(t[r]=i[a])}):function(e){return o(e,0,i)}):o}},pseudos:{not:r(function(e){var t=[],n=[],i=j(e.replace(st,"$1"));return i[F]?r(function(e,t,n,r){for(var o,a=i(e,null,r,[]),u=e.length;u--;)(o=a[u])&&(e[u]=!(t[u]=o))}):function(e,r,o){return t[0]=e,i(t,null,o,n),!n.pop()}}),has:r(function(e){return function(n){return t(e,n).length>0}}),contains:r(function(e){return function(t){return(t.textContent||t.innerText||N(t)).indexOf(e)>-1}}),lang:r(function(e){return dt.test(e||"")||t.error("unsupported lang: "+e),e=e.replace(xt,Tt).toLowerCase(),function(t){var n;do if(n=q?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===L},focus:function(e){return e===O.activeElement&&(!O.hasFocus||O.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!E.pseudos.empty(e)},header:function(e){return vt.test(e.nodeName)},input:function(e){return gt.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:c(function(){return[0]}),last:c(function(e,t){return[t-1]}),eq:c(function(e,t,n){return[0>n?n+t:n]}),even:c(function(e,t){for(var n=0;t>n;n+=2)e.push(n);return e}),odd:c(function(e,t){for(var n=1;t>n;n+=2)e.push(n);return e}),lt:c(function(e,t,n){for(var r=0>n?n+t:n;--r>=0;)e.push(r);return e}),gt:c(function(e,t,n){for(var r=0>n?n+t:n;++r<t;)e.push(r);return e})}},E.pseudos.nth=E.pseudos.eq;for(T in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})E.pseudos[T]=u(T);for(T in{submit:!0,reset:!0})E.pseudos[T]=s(T);return f.prototype=E.filters=E.pseudos,E.setFilters=new f,j=t.compile=function(e,t){var n,r=[],i=[],o=z[e+" "];if(!o){for(t||(t=p(e)),n=t.length;n--;)o=y(t[n]),o[F]?r.push(o):i.push(o);o=z(e,b(i,r))}return o},C.sortStable=F.split("").sort(X).join("")===F,C.detectDuplicates=!!D,A(),C.sortDetached=i(function(e){return 1&e.compareDocumentPosition(O.createElement("div"))}),i(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||o("type|href|height|width",function(e,t,n){return n?void 0:e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),C.attributes&&i(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")
        })||o("value",function(e,t,n){return n||"input"!==e.nodeName.toLowerCase()?void 0:e.defaultValue}),i(function(e){return null==e.getAttribute("disabled")})||o(nt,function(e,t,n){var r;return n?void 0:e[t]===!0?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),t}(e);et.find=it,et.expr=it.selectors,et.expr[":"]=et.expr.pseudos,et.unique=it.uniqueSort,et.text=it.getText,et.isXMLDoc=it.isXML,et.contains=it.contains;var ot=et.expr.match.needsContext,at=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,ut=/^.[^:#\[\.,]*$/;et.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?et.find.matchesSelector(r,e)?[r]:[]:et.find.matches(e,et.grep(t,function(e){return 1===e.nodeType}))},et.fn.extend({find:function(e){var t,n=this.length,r=[],i=this;if("string"!=typeof e)return this.pushStack(et(e).filter(function(){for(t=0;n>t;t++)if(et.contains(i[t],this))return!0}));for(t=0;n>t;t++)et.find(e,i[t],r);return r=this.pushStack(n>1?et.unique(r):r),r.selector=this.selector?this.selector+" "+e:e,r},filter:function(e){return this.pushStack(r(this,e||[],!1))},not:function(e){return this.pushStack(r(this,e||[],!0))},is:function(e){return!!r(this,"string"==typeof e&&ot.test(e)?et(e):e||[],!1).length}});var st,ct=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,lt=et.fn.init=function(e,t){var n,r;if(!e)return this;if("string"==typeof e){if(n="<"===e[0]&&">"===e[e.length-1]&&e.length>=3?[null,e,null]:ct.exec(e),!n||!n[1]&&t)return!t||t.jquery?(t||st).find(e):this.constructor(t).find(e);if(n[1]){if(t=t instanceof et?t[0]:t,et.merge(this,et.parseHTML(n[1],t&&t.nodeType?t.ownerDocument||t:J,!0)),at.test(n[1])&&et.isPlainObject(t))for(n in t)et.isFunction(this[n])?this[n](t[n]):this.attr(n,t[n]);return this}return r=J.getElementById(n[2]),r&&r.parentNode&&(this.length=1,this[0]=r),this.context=J,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):et.isFunction(e)?"undefined"!=typeof st.ready?st.ready(e):e(et):(void 0!==e.selector&&(this.selector=e.selector,this.context=e.context),et.makeArray(e,this))};lt.prototype=et.fn,st=et(J);var ft=/^(?:parents|prev(?:Until|All))/,pt={children:!0,contents:!0,next:!0,prev:!0};et.extend({dir:function(e,t,n){for(var r=[],i=void 0!==n;(e=e[t])&&9!==e.nodeType;)if(1===e.nodeType){if(i&&et(e).is(n))break;r.push(e)}return r},sibling:function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}}),et.fn.extend({has:function(e){var t=et(e,this),n=t.length;return this.filter(function(){for(var e=0;n>e;e++)if(et.contains(this,t[e]))return!0})},closest:function(e,t){for(var n,r=0,i=this.length,o=[],a=ot.test(e)||"string"!=typeof e?et(e,t||this.context):0;i>r;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?a.index(n)>-1:1===n.nodeType&&et.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(o.length>1?et.unique(o):o)},index:function(e){return e?"string"==typeof e?X.call(et(e),this[0]):X.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(et.unique(et.merge(this.get(),et(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),et.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return et.dir(e,"parentNode")},parentsUntil:function(e,t,n){return et.dir(e,"parentNode",n)},next:function(e){return i(e,"nextSibling")},prev:function(e){return i(e,"previousSibling")},nextAll:function(e){return et.dir(e,"nextSibling")},prevAll:function(e){return et.dir(e,"previousSibling")},nextUntil:function(e,t,n){return et.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return et.dir(e,"previousSibling",n)},siblings:function(e){return et.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return et.sibling(e.firstChild)},contents:function(e){return e.contentDocument||et.merge([],e.childNodes)}},function(e,t){et.fn[e]=function(n,r){var i=et.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=et.filter(r,i)),this.length>1&&(pt[e]||et.unique(i),ft.test(e)&&i.reverse()),this.pushStack(i)}});var dt=/\S+/g,ht={};et.Callbacks=function(e){e="string"==typeof e?ht[e]||o(e):et.extend({},e);var t,n,r,i,a,u,s=[],c=!e.once&&[],l=function(o){for(t=e.memory&&o,n=!0,u=i||0,i=0,a=s.length,r=!0;s&&a>u;u++)if(s[u].apply(o[0],o[1])===!1&&e.stopOnFalse){t=!1;break}r=!1,s&&(c?c.length&&l(c.shift()):t?s=[]:f.disable())},f={add:function(){if(s){var n=s.length;!function o(t){et.each(t,function(t,n){var r=et.type(n);"function"===r?e.unique&&f.has(n)||s.push(n):n&&n.length&&"string"!==r&&o(n)})}(arguments),r?a=s.length:t&&(i=n,l(t))}return this},remove:function(){return s&&et.each(arguments,function(e,t){for(var n;(n=et.inArray(t,s,n))>-1;)s.splice(n,1),r&&(a>=n&&a--,u>=n&&u--)}),this},has:function(e){return e?et.inArray(e,s)>-1:!(!s||!s.length)},empty:function(){return s=[],a=0,this},disable:function(){return s=c=t=void 0,this},disabled:function(){return!s},lock:function(){return c=void 0,t||f.disable(),this},locked:function(){return!c},fireWith:function(e,t){return!s||n&&!c||(t=t||[],t=[e,t.slice?t.slice():t],r?c.push(t):l(t)),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!n}};return f},et.extend({Deferred:function(e){var t=[["resolve","done",et.Callbacks("once memory"),"resolved"],["reject","fail",et.Callbacks("once memory"),"rejected"],["notify","progress",et.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return et.Deferred(function(n){et.each(t,function(t,o){var a=et.isFunction(e[t])&&e[t];i[o[1]](function(){var e=a&&a.apply(this,arguments);e&&et.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[o[0]+"With"](this===r?n.promise():this,a?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?et.extend(e,r):r}},i={};return r.pipe=r.then,et.each(t,function(e,o){var a=o[2],u=o[3];r[o[1]]=a.add,u&&a.add(function(){n=u},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=a.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t,n,r,i=0,o=$.call(arguments),a=o.length,u=1!==a||e&&et.isFunction(e.promise)?a:0,s=1===u?e:et.Deferred(),c=function(e,n,r){return function(i){n[e]=this,r[e]=arguments.length>1?$.call(arguments):i,r===t?s.notifyWith(n,r):--u||s.resolveWith(n,r)}};if(a>1)for(t=new Array(a),n=new Array(a),r=new Array(a);a>i;i++)o[i]&&et.isFunction(o[i].promise)?o[i].promise().done(c(i,r,o)).fail(s.reject).progress(c(i,n,t)):--u;return u||s.resolveWith(r,o),s.promise()}});var gt;et.fn.ready=function(e){return et.ready.promise().done(e),this},et.extend({isReady:!1,readyWait:1,holdReady:function(e){e?et.readyWait++:et.ready(!0)},ready:function(e){(e===!0?--et.readyWait:et.isReady)||(et.isReady=!0,e!==!0&&--et.readyWait>0||(gt.resolveWith(J,[et]),et.fn.trigger&&et(J).trigger("ready").off("ready")))}}),et.ready.promise=function(t){return gt||(gt=et.Deferred(),"complete"===J.readyState?setTimeout(et.ready):(J.addEventListener("DOMContentLoaded",a,!1),e.addEventListener("load",a,!1))),gt.promise(t)},et.ready.promise();var vt=et.access=function(e,t,n,r,i,o,a){var u=0,s=e.length,c=null==n;if("object"===et.type(n)){i=!0;for(u in n)et.access(e,t,u,n[u],!0,o,a)}else if(void 0!==r&&(i=!0,et.isFunction(r)||(a=!0),c&&(a?(t.call(e,r),t=null):(c=t,t=function(e,t,n){return c.call(et(e),n)})),t))for(;s>u;u++)t(e[u],n,a?r:r.call(e[u],u,t(e[u],n)));return i?e:c?t.call(e):s?t(e[0],n):o};et.acceptData=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType},u.uid=1,u.accepts=et.acceptData,u.prototype={key:function(e){if(!u.accepts(e))return 0;var t={},n=e[this.expando];if(!n){n=u.uid++;try{t[this.expando]={value:n},Object.defineProperties(e,t)}catch(r){t[this.expando]=n,et.extend(e,t)}}return this.cache[n]||(this.cache[n]={}),n},set:function(e,t,n){var r,i=this.key(e),o=this.cache[i];if("string"==typeof t)o[t]=n;else if(et.isEmptyObject(o))et.extend(this.cache[i],t);else for(r in t)o[r]=t[r];return o},get:function(e,t){var n=this.cache[this.key(e)];return void 0===t?n:n[t]},access:function(e,t,n){var r;return void 0===t||t&&"string"==typeof t&&void 0===n?(r=this.get(e,t),void 0!==r?r:this.get(e,et.camelCase(t))):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r,i,o=this.key(e),a=this.cache[o];if(void 0===t)this.cache[o]={};else{et.isArray(t)?r=t.concat(t.map(et.camelCase)):(i=et.camelCase(t),t in a?r=[t,i]:(r=i,r=r in a?[r]:r.match(dt)||[])),n=r.length;for(;n--;)delete a[r[n]]}},hasData:function(e){return!et.isEmptyObject(this.cache[e[this.expando]]||{})},discard:function(e){e[this.expando]&&delete this.cache[e[this.expando]]}};var mt=new u,yt=new u,bt=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,wt=/([A-Z])/g;et.extend({hasData:function(e){return yt.hasData(e)||mt.hasData(e)},data:function(e,t,n){return yt.access(e,t,n)},removeData:function(e,t){yt.remove(e,t)},_data:function(e,t,n){return mt.access(e,t,n)},_removeData:function(e,t){mt.remove(e,t)}}),et.fn.extend({data:function(e,t){var n,r,i,o=this[0],a=o&&o.attributes;if(void 0===e){if(this.length&&(i=yt.get(o),1===o.nodeType&&!mt.get(o,"hasDataAttrs"))){for(n=a.length;n--;)r=a[n].name,0===r.indexOf("data-")&&(r=et.camelCase(r.slice(5)),s(o,r,i[r]));mt.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof e?this.each(function(){yt.set(this,e)}):vt(this,function(t){var n,r=et.camelCase(e);if(o&&void 0===t){if(n=yt.get(o,e),void 0!==n)return n;if(n=yt.get(o,r),void 0!==n)return n;if(n=s(o,r,void 0),void 0!==n)return n}else this.each(function(){var n=yt.get(this,r);yt.set(this,r,t),-1!==e.indexOf("-")&&void 0!==n&&yt.set(this,e,t)})},null,t,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){yt.remove(this,e)})}}),et.extend({queue:function(e,t,n){var r;return e?(t=(t||"fx")+"queue",r=mt.get(e,t),n&&(!r||et.isArray(n)?r=mt.access(e,t,et.makeArray(n)):r.push(n)),r||[]):void 0},dequeue:function(e,t){t=t||"fx";var n=et.queue(e,t),r=n.length,i=n.shift(),o=et._queueHooks(e,t),a=function(){et.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return mt.get(e,n)||mt.access(e,n,{empty:et.Callbacks("once memory").add(function(){mt.remove(e,[t+"queue",n])})})}}),et.fn.extend({queue:function(e,t){var n=2;return"string"!=typeof e&&(t=e,e="fx",n--),arguments.length<n?et.queue(this[0],e):void 0===t?this:this.each(function(){var n=et.queue(this,e,t);et._queueHooks(this,e),"fx"===e&&"inprogress"!==n[0]&&et.dequeue(this,e)})},dequeue:function(e){return this.each(function(){et.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=et.Deferred(),o=this,a=this.length,u=function(){--r||i.resolveWith(o,[o])};for("string"!=typeof e&&(t=e,e=void 0),e=e||"fx";a--;)n=mt.get(o[a],e+"queueHooks"),n&&n.empty&&(r++,n.empty.add(u));return u(),i.promise(t)}});var xt=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,Tt=["Top","Right","Bottom","Left"],Ct=function(e,t){return e=t||e,"none"===et.css(e,"display")||!et.contains(e.ownerDocument,e)},Et=/^(?:checkbox|radio)$/i;!function(){var e=J.createDocumentFragment(),t=e.appendChild(J.createElement("div"));t.innerHTML="<input type='radio' checked='checked' name='t'/>",K.checkClone=t.cloneNode(!0).cloneNode(!0).lastChild.checked,t.innerHTML="<textarea>x</textarea>",K.noCloneChecked=!!t.cloneNode(!0).lastChild.defaultValue}();var Nt="undefined";K.focusinBubbles="onfocusin"in e;var kt=/^key/,jt=/^(?:mouse|contextmenu)|click/,_t=/^(?:focusinfocus|focusoutblur)$/,St=/^([^.]*)(?:\.(.+)|)$/;et.event={global:{},add:function(e,t,n,r,i){var o,a,u,s,c,l,f,p,d,h,g,v=mt.get(e);if(v)for(n.handler&&(o=n,n=o.handler,i=o.selector),n.guid||(n.guid=et.guid++),(s=v.events)||(s=v.events={}),(a=v.handle)||(a=v.handle=function(t){return typeof et!==Nt&&et.event.triggered!==t.type?et.event.dispatch.apply(e,arguments):void 0}),t=(t||"").match(dt)||[""],c=t.length;c--;)u=St.exec(t[c])||[],d=g=u[1],h=(u[2]||"").split(".").sort(),d&&(f=et.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=et.event.special[d]||{},l=et.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&et.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=s[d])||(p=s[d]=[],p.delegateCount=0,f.setup&&f.setup.call(e,r,h,a)!==!1||e.addEventListener&&e.addEventListener(d,a,!1)),f.add&&(f.add.call(e,l),l.handler.guid||(l.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,l):p.push(l),et.event.global[d]=!0)},remove:function(e,t,n,r,i){var o,a,u,s,c,l,f,p,d,h,g,v=mt.hasData(e)&&mt.get(e);if(v&&(s=v.events)){for(t=(t||"").match(dt)||[""],c=t.length;c--;)if(u=St.exec(t[c])||[],d=g=u[1],h=(u[2]||"").split(".").sort(),d){for(f=et.event.special[d]||{},d=(r?f.delegateType:f.bindType)||d,p=s[d]||[],u=u[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;o--;)l=p[o],!i&&g!==l.origType||n&&n.guid!==l.guid||u&&!u.test(l.namespace)||r&&r!==l.selector&&("**"!==r||!l.selector)||(p.splice(o,1),l.selector&&p.delegateCount--,f.remove&&f.remove.call(e,l));a&&!p.length&&(f.teardown&&f.teardown.call(e,h,v.handle)!==!1||et.removeEvent(e,d,v.handle),delete s[d])}else for(d in s)et.event.remove(e,d+t[c],n,r,!0);et.isEmptyObject(s)&&(delete v.handle,mt.remove(e,"events"))}},trigger:function(t,n,r,i){var o,a,u,s,c,l,f,p=[r||J],d=Y.call(t,"type")?t.type:t,h=Y.call(t,"namespace")?t.namespace.split("."):[];if(a=u=r=r||J,3!==r.nodeType&&8!==r.nodeType&&!_t.test(d+et.event.triggered)&&(d.indexOf(".")>=0&&(h=d.split("."),d=h.shift(),h.sort()),c=d.indexOf(":")<0&&"on"+d,t=t[et.expando]?t:new et.Event(d,"object"==typeof t&&t),t.isTrigger=i?2:3,t.namespace=h.join("."),t.namespace_re=t.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,t.result=void 0,t.target||(t.target=r),n=null==n?[t]:et.makeArray(n,[t]),f=et.event.special[d]||{},i||!f.trigger||f.trigger.apply(r,n)!==!1)){if(!i&&!f.noBubble&&!et.isWindow(r)){for(s=f.delegateType||d,_t.test(s+d)||(a=a.parentNode);a;a=a.parentNode)p.push(a),u=a;u===(r.ownerDocument||J)&&p.push(u.defaultView||u.parentWindow||e)}for(o=0;(a=p[o++])&&!t.isPropagationStopped();)t.type=o>1?s:f.bindType||d,l=(mt.get(a,"events")||{})[t.type]&&mt.get(a,"handle"),l&&l.apply(a,n),l=c&&a[c],l&&l.apply&&et.acceptData(a)&&(t.result=l.apply(a,n),t.result===!1&&t.preventDefault());return t.type=d,i||t.isDefaultPrevented()||f._default&&f._default.apply(p.pop(),n)!==!1||!et.acceptData(r)||c&&et.isFunction(r[d])&&!et.isWindow(r)&&(u=r[c],u&&(r[c]=null),et.event.triggered=d,r[d](),et.event.triggered=void 0,u&&(r[c]=u)),t.result}},dispatch:function(e){e=et.event.fix(e);var t,n,r,i,o,a=[],u=$.call(arguments),s=(mt.get(this,"events")||{})[e.type]||[],c=et.event.special[e.type]||{};if(u[0]=e,e.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,e)!==!1){for(a=et.event.handlers.call(this,e,s),t=0;(i=a[t++])&&!e.isPropagationStopped();)for(e.currentTarget=i.elem,n=0;(o=i.handlers[n++])&&!e.isImmediatePropagationStopped();)(!e.namespace_re||e.namespace_re.test(o.namespace))&&(e.handleObj=o,e.data=o.data,r=((et.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,u),void 0!==r&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()));return c.postDispatch&&c.postDispatch.call(this,e),e.result}},handlers:function(e,t){var n,r,i,o,a=[],u=t.delegateCount,s=e.target;if(u&&s.nodeType&&(!e.button||"click"!==e.type))for(;s!==this;s=s.parentNode||this)if(s.disabled!==!0||"click"!==e.type){for(r=[],n=0;u>n;n++)o=t[n],i=o.selector+" ",void 0===r[i]&&(r[i]=o.needsContext?et(i,this).index(s)>=0:et.find(i,this,null,[s]).length),r[i]&&r.push(o);r.length&&a.push({elem:s,handlers:r})}return u<t.length&&a.push({elem:this,handlers:t.slice(u)}),a},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,t){var n,r,i,o=t.button;return null==e.pageX&&null!=t.clientX&&(n=e.target.ownerDocument||J,r=n.documentElement,i=n.body,e.pageX=t.clientX+(r&&r.scrollLeft||i&&i.scrollLeft||0)-(r&&r.clientLeft||i&&i.clientLeft||0),e.pageY=t.clientY+(r&&r.scrollTop||i&&i.scrollTop||0)-(r&&r.clientTop||i&&i.clientTop||0)),e.which||void 0===o||(e.which=1&o?1:2&o?3:4&o?2:0),e}},fix:function(e){if(e[et.expando])return e;var t,n,r,i=e.type,o=e,a=this.fixHooks[i];for(a||(this.fixHooks[i]=a=jt.test(i)?this.mouseHooks:kt.test(i)?this.keyHooks:{}),r=a.props?this.props.concat(a.props):this.props,e=new et.Event(o),t=r.length;t--;)n=r[t],e[n]=o[n];return e.target||(e.target=J),3===e.target.nodeType&&(e.target=e.target.parentNode),a.filter?a.filter(e,o):e},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==f()&&this.focus?(this.focus(),!1):void 0},delegateType:"focusin"},blur:{trigger:function(){return this===f()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&et.nodeName(this,"input")?(this.click(),!1):void 0},_default:function(e){return et.nodeName(e.target,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=et.extend(new et.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?et.event.trigger(i,null,t):et.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},et.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)},et.Event=function(e,t){return this instanceof et.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&e.getPreventDefault&&e.getPreventDefault()?c:l):this.type=e,t&&et.extend(this,t),this.timeStamp=e&&e.timeStamp||et.now(),void(this[et.expando]=!0)):new et.Event(e,t)},et.Event.prototype={isDefaultPrevented:l,isPropagationStopped:l,isImmediatePropagationStopped:l,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=c,e&&e.preventDefault&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=c,e&&e.stopPropagation&&e.stopPropagation()},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=c,this.stopPropagation()}},et.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){et.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return(!i||i!==r&&!et.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),K.focusinBubbles||et.each({focus:"focusin",blur:"focusout"},function(e,t){var n=function(e){et.event.simulate(t,e.target,et.event.fix(e),!0)};et.event.special[t]={setup:function(){var r=this.ownerDocument||this,i=mt.access(r,t);i||r.addEventListener(e,n,!0),mt.access(r,t,(i||0)+1)},teardown:function(){var r=this.ownerDocument||this,i=mt.access(r,t)-1;i?mt.access(r,t,i):(r.removeEventListener(e,n,!0),mt.remove(r,t))}}}),et.fn.extend({on:function(e,t,n,r,i){var o,a;if("object"==typeof e){"string"!=typeof t&&(n=n||t,t=void 0);for(a in e)this.on(a,t,n,e[a],i);return this}if(null==n&&null==r?(r=t,n=t=void 0):null==r&&("string"==typeof t?(r=n,n=void 0):(r=n,n=t,t=void 0)),r===!1)r=l;else if(!r)return this;return 1===i&&(o=r,r=function(e){return et().off(e),o.apply(this,arguments)},r.guid=o.guid||(o.guid=et.guid++)),this.each(function(){et.event.add(this,e,r,n,t)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,et(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return(t===!1||"function"==typeof t)&&(n=t,t=void 0),n===!1&&(n=l),this.each(function(){et.event.remove(this,e,n,t)})},trigger:function(e,t){return this.each(function(){et.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];return n?et.event.trigger(e,t,n,!0):void 0}});var Dt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,At=/<([\w:]+)/,Ot=/<|&#?\w+;/,Lt=/<(?:script|style|link)/i,qt=/checked\s*(?:[^=]|=\s*.checked.)/i,It=/^$|\/(?:java|ecma)script/i,Mt=/^true\/(.*)/,Rt=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,Ht={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};Ht.optgroup=Ht.option,Ht.tbody=Ht.tfoot=Ht.colgroup=Ht.caption=Ht.thead,Ht.th=Ht.td,et.extend({clone:function(e,t,n){var r,i,o,a,u=e.cloneNode(!0),s=et.contains(e.ownerDocument,e);if(!(K.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||et.isXMLDoc(e)))for(a=m(u),o=m(e),r=0,i=o.length;i>r;r++)y(o[r],a[r]);if(t)if(n)for(o=o||m(e),a=a||m(u),r=0,i=o.length;i>r;r++)v(o[r],a[r]);else v(e,u);return a=m(u,"script"),a.length>0&&g(a,!s&&m(e,"script")),u},buildFragment:function(e,t,n,r){for(var i,o,a,u,s,c,l=t.createDocumentFragment(),f=[],p=0,d=e.length;d>p;p++)if(i=e[p],i||0===i)if("object"===et.type(i))et.merge(f,i.nodeType?[i]:i);else if(Ot.test(i)){for(o=o||l.appendChild(t.createElement("div")),a=(At.exec(i)||["",""])[1].toLowerCase(),u=Ht[a]||Ht._default,o.innerHTML=u[1]+i.replace(Dt,"<$1></$2>")+u[2],c=u[0];c--;)o=o.lastChild;et.merge(f,o.childNodes),o=l.firstChild,o.textContent=""}else f.push(t.createTextNode(i));for(l.textContent="",p=0;i=f[p++];)if((!r||-1===et.inArray(i,r))&&(s=et.contains(i.ownerDocument,i),o=m(l.appendChild(i),"script"),s&&g(o),n))for(c=0;i=o[c++];)It.test(i.type||"")&&n.push(i);return l},cleanData:function(e){for(var t,n,r,i,o,a,u=et.event.special,s=0;void 0!==(n=e[s]);s++){if(et.acceptData(n)&&(o=n[mt.expando],o&&(t=mt.cache[o]))){if(r=Object.keys(t.events||{}),r.length)for(a=0;void 0!==(i=r[a]);a++)u[i]?et.event.remove(n,i):et.removeEvent(n,i,t.handle);mt.cache[o]&&delete mt.cache[o]}delete yt.cache[n[yt.expando]]}}}),et.fn.extend({text:function(e){return vt(this,function(e){return void 0===e?et.text(this):this.empty().each(function(){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&(this.textContent=e)})},null,e,arguments.length)},append:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=p(this,e);t.appendChild(e)}})},prepend:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=p(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){for(var n,r=e?et.filter(e,this):this,i=0;null!=(n=r[i]);i++)t||1!==n.nodeType||et.cleanData(m(n)),n.parentNode&&(t&&et.contains(n.ownerDocument,n)&&g(m(n,"script")),n.parentNode.removeChild(n));return this},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(et.cleanData(m(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return et.clone(this,e,t)})},html:function(e){return vt(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!Lt.test(e)&&!Ht[(At.exec(e)||["",""])[1].toLowerCase()]){e=e.replace(Dt,"<$1></$2>");try{for(;r>n;n++)t=this[n]||{},1===t.nodeType&&(et.cleanData(m(t,!1)),t.innerHTML=e);t=0}catch(i){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=arguments[0];return this.domManip(arguments,function(t){e=this.parentNode,et.cleanData(m(this)),e&&e.replaceChild(t,this)}),e&&(e.length||e.nodeType)?this:this.remove()},detach:function(e){return this.remove(e,!0)},domManip:function(e,t){e=U.apply([],e);var n,r,i,o,a,u,s=0,c=this.length,l=this,f=c-1,p=e[0],g=et.isFunction(p);if(g||c>1&&"string"==typeof p&&!K.checkClone&&qt.test(p))return this.each(function(n){var r=l.eq(n);g&&(e[0]=p.call(this,n,r.html())),r.domManip(e,t)});if(c&&(n=et.buildFragment(e,this[0].ownerDocument,!1,this),r=n.firstChild,1===n.childNodes.length&&(n=r),r)){for(i=et.map(m(n,"script"),d),o=i.length;c>s;s++)a=n,s!==f&&(a=et.clone(a,!0,!0),o&&et.merge(i,m(a,"script"))),t.call(this[s],a,s);if(o)for(u=i[i.length-1].ownerDocument,et.map(i,h),s=0;o>s;s++)a=i[s],It.test(a.type||"")&&!mt.access(a,"globalEval")&&et.contains(u,a)&&(a.src?et._evalUrl&&et._evalUrl(a.src):et.globalEval(a.textContent.replace(Rt,"")))}return this}}),et.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){et.fn[e]=function(e){for(var n,r=[],i=et(e),o=i.length-1,a=0;o>=a;a++)n=a===o?this:this.clone(!0),et(i[a])[t](n),z.apply(r,n.get());return this.pushStack(r)}});var Ft,Pt={},Wt=/^margin/,Bt=new RegExp("^("+xt+")(?!px)[a-z%]+$","i"),$t=function(e){return e.ownerDocument.defaultView.getComputedStyle(e,null)};!function(){function t(){u.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%",o.appendChild(a);var t=e.getComputedStyle(u,null);n="1%"!==t.top,r="4px"===t.width,o.removeChild(a)}var n,r,i="padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box",o=J.documentElement,a=J.createElement("div"),u=J.createElement("div");u.style.backgroundClip="content-box",u.cloneNode(!0).style.backgroundClip="",K.clearCloneStyle="content-box"===u.style.backgroundClip,a.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",a.appendChild(u),e.getComputedStyle&&et.extend(K,{pixelPosition:function(){return t(),n},boxSizingReliable:function(){return null==r&&t(),r},reliableMarginRight:function(){var t,n=u.appendChild(J.createElement("div"));return n.style.cssText=u.style.cssText=i,n.style.marginRight=n.style.width="0",u.style.width="1px",o.appendChild(a),t=!parseFloat(e.getComputedStyle(n,null).marginRight),o.removeChild(a),u.innerHTML="",t}})}(),et.swap=function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i};var Ut=/^(none|table(?!-c[ea]).+)/,zt=new RegExp("^("+xt+")(.*)$","i"),Xt=new RegExp("^([+-])=("+xt+")","i"),Vt={position:"absolute",visibility:"hidden",display:"block"},Qt={letterSpacing:0,fontWeight:400},Yt=["Webkit","O","Moz","ms"];et.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=x(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,u=et.camelCase(t),s=e.style;return t=et.cssProps[u]||(et.cssProps[u]=C(s,u)),a=et.cssHooks[t]||et.cssHooks[u],void 0===n?a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:s[t]:(o=typeof n,"string"===o&&(i=Xt.exec(n))&&(n=(i[1]+1)*i[2]+parseFloat(et.css(e,t)),o="number"),null!=n&&n===n&&("number"!==o||et.cssNumber[u]||(n+="px"),K.clearCloneStyle||""!==n||0!==t.indexOf("background")||(s[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(s[t]="",s[t]=n)),void 0)}},css:function(e,t,n,r){var i,o,a,u=et.camelCase(t);return t=et.cssProps[u]||(et.cssProps[u]=C(e.style,u)),a=et.cssHooks[t]||et.cssHooks[u],a&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=x(e,t,r)),"normal"===i&&t in Qt&&(i=Qt[t]),""===n||n?(o=parseFloat(i),n===!0||et.isNumeric(o)?o||0:i):i}}),et.each(["height","width"],function(e,t){et.cssHooks[t]={get:function(e,n,r){return n?0===e.offsetWidth&&Ut.test(et.css(e,"display"))?et.swap(e,Vt,function(){return k(e,t,r)}):k(e,t,r):void 0},set:function(e,n,r){var i=r&&$t(e);return E(e,n,r?N(e,t,r,"border-box"===et.css(e,"boxSizing",!1,i),i):0)}}}),et.cssHooks.marginRight=T(K.reliableMarginRight,function(e,t){return t?et.swap(e,{display:"inline-block"},x,[e,"marginRight"]):void 0}),et.each({margin:"",padding:"",border:"Width"},function(e,t){et.cssHooks[e+t]={expand:function(n){for(var r=0,i={},o="string"==typeof n?n.split(" "):[n];4>r;r++)i[e+Tt[r]+t]=o[r]||o[r-2]||o[0];return i}},Wt.test(e)||(et.cssHooks[e+t].set=E)}),et.fn.extend({css:function(e,t){return vt(this,function(e,t,n){var r,i,o={},a=0;if(et.isArray(t)){for(r=$t(e),i=t.length;i>a;a++)o[t[a]]=et.css(e,t[a],!1,r);return o}return void 0!==n?et.style(e,t,n):et.css(e,t)},e,t,arguments.length>1)},show:function(){return j(this,!0)},hide:function(){return j(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){Ct(this)?et(this).show():et(this).hide()})}}),et.Tween=_,_.prototype={constructor:_,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(et.cssNumber[n]?"":"px")},cur:function(){var e=_.propHooks[this.prop];return e&&e.get?e.get(this):_.propHooks._default.get(this)},run:function(e){var t,n=_.propHooks[this.prop];return this.pos=t=this.options.duration?et.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):_.propHooks._default.set(this),this}},_.prototype.init.prototype=_.prototype,_.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=et.css(e.elem,e.prop,""),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){et.fx.step[e.prop]?et.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[et.cssProps[e.prop]]||et.cssHooks[e.prop])?et.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},_.propHooks.scrollTop=_.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},et.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},et.fx=_.prototype.init,et.fx.step={};var Gt,Kt,Jt=/^(?:toggle|show|hide)$/,Zt=new RegExp("^(?:([+-])=|)("+xt+")([a-z%]*)$","i"),en=/queueHooks$/,tn=[O],nn={"*":[function(e,t){var n=this.createTween(e,t),r=n.cur(),i=Zt.exec(t),o=i&&i[3]||(et.cssNumber[e]?"":"px"),a=(et.cssNumber[e]||"px"!==o&&+r)&&Zt.exec(et.css(n.elem,e)),u=1,s=20;if(a&&a[3]!==o){o=o||a[3],i=i||[],a=+r||1;do u=u||".5",a/=u,et.style(n.elem,e,a+o);while(u!==(u=n.cur()/r)&&1!==u&&--s)}return i&&(a=n.start=+a||+r||0,n.unit=o,n.end=i[1]?a+(i[1]+1)*i[2]:+i[2]),n}]};et.Animation=et.extend(q,{tweener:function(e,t){et.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");for(var n,r=0,i=e.length;i>r;r++)n=e[r],nn[n]=nn[n]||[],nn[n].unshift(t)},prefilter:function(e,t){t?tn.unshift(e):tn.push(e)}}),et.speed=function(e,t,n){var r=e&&"object"==typeof e?et.extend({},e):{complete:n||!n&&t||et.isFunction(e)&&e,duration:e,easing:n&&t||t&&!et.isFunction(t)&&t};return r.duration=et.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in et.fx.speeds?et.fx.speeds[r.duration]:et.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue="fx"),r.old=r.complete,r.complete=function(){et.isFunction(r.old)&&r.old.call(this),r.queue&&et.dequeue(this,r.queue)},r},et.fn.extend({fadeTo:function(e,t,n,r){return this.filter(Ct).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=et.isEmptyObject(e),o=et.speed(t,n,r),a=function(){var t=q(this,et.extend({},e),o);(i||mt.get(this,"finish"))&&t.stop(!0)
        };return a.finish=a,i||o.queue===!1?this.each(a):this.queue(o.queue,a)},stop:function(e,t,n){var r=function(e){var t=e.stop;delete e.stop,t(n)};return"string"!=typeof e&&(n=t,t=e,e=void 0),t&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,i=null!=e&&e+"queueHooks",o=et.timers,a=mt.get(this);if(i)a[i]&&a[i].stop&&r(a[i]);else for(i in a)a[i]&&a[i].stop&&en.test(i)&&r(a[i]);for(i=o.length;i--;)o[i].elem!==this||null!=e&&o[i].queue!==e||(o[i].anim.stop(n),t=!1,o.splice(i,1));(t||!n)&&et.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=mt.get(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=et.timers,a=r?r.length:0;for(n.finish=!0,et.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;a>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}}),et.each(["toggle","show","hide"],function(e,t){var n=et.fn[t];et.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(D(t,!0),e,r,i)}}),et.each({slideDown:D("show"),slideUp:D("hide"),slideToggle:D("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){et.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),et.timers=[],et.fx.tick=function(){var e,t=0,n=et.timers;for(Gt=et.now();t<n.length;t++)e=n[t],e()||n[t]!==e||n.splice(t--,1);n.length||et.fx.stop(),Gt=void 0},et.fx.timer=function(e){et.timers.push(e),e()?et.fx.start():et.timers.pop()},et.fx.interval=13,et.fx.start=function(){Kt||(Kt=setInterval(et.fx.tick,et.fx.interval))},et.fx.stop=function(){clearInterval(Kt),Kt=null},et.fx.speeds={slow:600,fast:200,_default:400},et.fn.delay=function(e,t){return e=et.fx?et.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},function(){var e=J.createElement("input"),t=J.createElement("select"),n=t.appendChild(J.createElement("option"));e.type="checkbox",K.checkOn=""!==e.value,K.optSelected=n.selected,t.disabled=!0,K.optDisabled=!n.disabled,e=J.createElement("input"),e.value="t",e.type="radio",K.radioValue="t"===e.value}();var rn,on,an=et.expr.attrHandle;et.fn.extend({attr:function(e,t){return vt(this,et.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){et.removeAttr(this,e)})}}),et.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(e&&3!==o&&8!==o&&2!==o)return typeof e.getAttribute===Nt?et.prop(e,t,n):(1===o&&et.isXMLDoc(e)||(t=t.toLowerCase(),r=et.attrHooks[t]||(et.expr.match.bool.test(t)?on:rn)),void 0===n?r&&"get"in r&&null!==(i=r.get(e,t))?i:(i=et.find.attr(e,t),null==i?void 0:i):null!==n?r&&"set"in r&&void 0!==(i=r.set(e,n,t))?i:(e.setAttribute(t,n+""),n):void et.removeAttr(e,t))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(dt);if(o&&1===e.nodeType)for(;n=o[i++];)r=et.propFix[n]||n,et.expr.match.bool.test(n)&&(e[r]=!1),e.removeAttribute(n)},attrHooks:{type:{set:function(e,t){if(!K.radioValue&&"radio"===t&&et.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}}}),on={set:function(e,t,n){return t===!1?et.removeAttr(e,n):e.setAttribute(n,n),n}},et.each(et.expr.match.bool.source.match(/\w+/g),function(e,t){var n=an[t]||et.find.attr;an[t]=function(e,t,r){var i,o;return r||(o=an[t],an[t]=i,i=null!=n(e,t,r)?t.toLowerCase():null,an[t]=o),i}});var un=/^(?:input|select|textarea|button)$/i;et.fn.extend({prop:function(e,t){return vt(this,et.prop,e,t,arguments.length>1)},removeProp:function(e){return this.each(function(){delete this[et.propFix[e]||e]})}}),et.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(e,t,n){var r,i,o,a=e.nodeType;if(e&&3!==a&&8!==a&&2!==a)return o=1!==a||!et.isXMLDoc(e),o&&(t=et.propFix[t]||t,i=et.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){return e.hasAttribute("tabindex")||un.test(e.nodeName)||e.href?e.tabIndex:-1}}}}),K.optSelected||(et.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null}}),et.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){et.propFix[this.toLowerCase()]=this});var sn=/[\t\r\n\f]/g;et.fn.extend({addClass:function(e){var t,n,r,i,o,a,u="string"==typeof e&&e,s=0,c=this.length;if(et.isFunction(e))return this.each(function(t){et(this).addClass(e.call(this,t,this.className))});if(u)for(t=(e||"").match(dt)||[];c>s;s++)if(n=this[s],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(sn," "):" ")){for(o=0;i=t[o++];)r.indexOf(" "+i+" ")<0&&(r+=i+" ");a=et.trim(r),n.className!==a&&(n.className=a)}return this},removeClass:function(e){var t,n,r,i,o,a,u=0===arguments.length||"string"==typeof e&&e,s=0,c=this.length;if(et.isFunction(e))return this.each(function(t){et(this).removeClass(e.call(this,t,this.className))});if(u)for(t=(e||"").match(dt)||[];c>s;s++)if(n=this[s],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(sn," "):"")){for(o=0;i=t[o++];)for(;r.indexOf(" "+i+" ")>=0;)r=r.replace(" "+i+" "," ");a=e?et.trim(r):"",n.className!==a&&(n.className=a)}return this},toggleClass:function(e,t){var n=typeof e;return"boolean"==typeof t&&"string"===n?t?this.addClass(e):this.removeClass(e):this.each(et.isFunction(e)?function(n){et(this).toggleClass(e.call(this,n,this.className,t),t)}:function(){if("string"===n)for(var t,r=0,i=et(this),o=e.match(dt)||[];t=o[r++];)i.hasClass(t)?i.removeClass(t):i.addClass(t);else(n===Nt||"boolean"===n)&&(this.className&&mt.set(this,"__className__",this.className),this.className=this.className||e===!1?"":mt.get(this,"__className__")||"")})},hasClass:function(e){for(var t=" "+e+" ",n=0,r=this.length;r>n;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(sn," ").indexOf(t)>=0)return!0;return!1}});var cn=/\r/g;et.fn.extend({val:function(e){var t,n,r,i=this[0];{if(arguments.length)return r=et.isFunction(e),this.each(function(n){var i;1===this.nodeType&&(i=r?e.call(this,n,et(this).val()):e,null==i?i="":"number"==typeof i?i+="":et.isArray(i)&&(i=et.map(i,function(e){return null==e?"":e+""})),t=et.valHooks[this.type]||et.valHooks[this.nodeName.toLowerCase()],t&&"set"in t&&void 0!==t.set(this,i,"value")||(this.value=i))});if(i)return t=et.valHooks[i.type]||et.valHooks[i.nodeName.toLowerCase()],t&&"get"in t&&void 0!==(n=t.get(i,"value"))?n:(n=i.value,"string"==typeof n?n.replace(cn,""):null==n?"":n)}}}),et.extend({valHooks:{select:{get:function(e){for(var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||0>i,a=o?null:[],u=o?i+1:r.length,s=0>i?u:o?i:0;u>s;s++)if(n=r[s],!(!n.selected&&s!==i||(K.optDisabled?n.disabled:null!==n.getAttribute("disabled"))||n.parentNode.disabled&&et.nodeName(n.parentNode,"optgroup"))){if(t=et(n).val(),o)return t;a.push(t)}return a},set:function(e,t){for(var n,r,i=e.options,o=et.makeArray(t),a=i.length;a--;)r=i[a],(r.selected=et.inArray(et(r).val(),o)>=0)&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),et.each(["radio","checkbox"],function(){et.valHooks[this]={set:function(e,t){return et.isArray(t)?e.checked=et.inArray(et(e).val(),t)>=0:void 0}},K.checkOn||(et.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),et.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){et.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),et.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}});var ln=et.now(),fn=/\?/;et.parseJSON=function(e){return JSON.parse(e+"")},et.parseXML=function(e){var t,n;if(!e||"string"!=typeof e)return null;try{n=new DOMParser,t=n.parseFromString(e,"text/xml")}catch(r){t=void 0}return(!t||t.getElementsByTagName("parsererror").length)&&et.error("Invalid XML: "+e),t};var pn,dn,hn=/#.*$/,gn=/([?&])_=[^&]*/,vn=/^(.*?):[ \t]*([^\r\n]*)$/gm,mn=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,yn=/^(?:GET|HEAD)$/,bn=/^\/\//,wn=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,xn={},Tn={},Cn="*/".concat("*");try{dn=location.href}catch(En){dn=J.createElement("a"),dn.href="",dn=dn.href}pn=wn.exec(dn.toLowerCase())||[],et.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:dn,type:"GET",isLocal:mn.test(pn[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Cn,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":et.parseJSON,"text xml":et.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?R(R(e,et.ajaxSettings),t):R(et.ajaxSettings,e)},ajaxPrefilter:I(xn),ajaxTransport:I(Tn),ajax:function(e,t){function n(e,t,n,a){var s,l,m,y,w,T=t;2!==b&&(b=2,u&&clearTimeout(u),r=void 0,o=a||"",x.readyState=e>0?4:0,s=e>=200&&300>e||304===e,n&&(y=H(f,x,n)),y=F(f,y,x,s),s?(f.ifModified&&(w=x.getResponseHeader("Last-Modified"),w&&(et.lastModified[i]=w),w=x.getResponseHeader("etag"),w&&(et.etag[i]=w)),204===e||"HEAD"===f.type?T="nocontent":304===e?T="notmodified":(T=y.state,l=y.data,m=y.error,s=!m)):(m=T,(e||!T)&&(T="error",0>e&&(e=0))),x.status=e,x.statusText=(t||T)+"",s?h.resolveWith(p,[l,T,x]):h.rejectWith(p,[x,T,m]),x.statusCode(v),v=void 0,c&&d.trigger(s?"ajaxSuccess":"ajaxError",[x,f,s?l:m]),g.fireWith(p,[x,T]),c&&(d.trigger("ajaxComplete",[x,f]),--et.active||et.event.trigger("ajaxStop")))}"object"==typeof e&&(t=e,e=void 0),t=t||{};var r,i,o,a,u,s,c,l,f=et.ajaxSetup({},t),p=f.context||f,d=f.context&&(p.nodeType||p.jquery)?et(p):et.event,h=et.Deferred(),g=et.Callbacks("once memory"),v=f.statusCode||{},m={},y={},b=0,w="canceled",x={readyState:0,getResponseHeader:function(e){var t;if(2===b){if(!a)for(a={};t=vn.exec(o);)a[t[1].toLowerCase()]=t[2];t=a[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===b?o:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return b||(e=y[n]=y[n]||e,m[e]=t),this},overrideMimeType:function(e){return b||(f.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>b)for(t in e)v[t]=[v[t],e[t]];else x.always(e[x.status]);return this},abort:function(e){var t=e||w;return r&&r.abort(t),n(0,t),this}};if(h.promise(x).complete=g.add,x.success=x.done,x.error=x.fail,f.url=((e||f.url||dn)+"").replace(hn,"").replace(bn,pn[1]+"//"),f.type=t.method||t.type||f.method||f.type,f.dataTypes=et.trim(f.dataType||"*").toLowerCase().match(dt)||[""],null==f.crossDomain&&(s=wn.exec(f.url.toLowerCase()),f.crossDomain=!(!s||s[1]===pn[1]&&s[2]===pn[2]&&(s[3]||("http:"===s[1]?"80":"443"))===(pn[3]||("http:"===pn[1]?"80":"443")))),f.data&&f.processData&&"string"!=typeof f.data&&(f.data=et.param(f.data,f.traditional)),M(xn,f,t,x),2===b)return x;c=f.global,c&&0===et.active++&&et.event.trigger("ajaxStart"),f.type=f.type.toUpperCase(),f.hasContent=!yn.test(f.type),i=f.url,f.hasContent||(f.data&&(i=f.url+=(fn.test(i)?"&":"?")+f.data,delete f.data),f.cache===!1&&(f.url=gn.test(i)?i.replace(gn,"$1_="+ln++):i+(fn.test(i)?"&":"?")+"_="+ln++)),f.ifModified&&(et.lastModified[i]&&x.setRequestHeader("If-Modified-Since",et.lastModified[i]),et.etag[i]&&x.setRequestHeader("If-None-Match",et.etag[i])),(f.data&&f.hasContent&&f.contentType!==!1||t.contentType)&&x.setRequestHeader("Content-Type",f.contentType),x.setRequestHeader("Accept",f.dataTypes[0]&&f.accepts[f.dataTypes[0]]?f.accepts[f.dataTypes[0]]+("*"!==f.dataTypes[0]?", "+Cn+"; q=0.01":""):f.accepts["*"]);for(l in f.headers)x.setRequestHeader(l,f.headers[l]);if(f.beforeSend&&(f.beforeSend.call(p,x,f)===!1||2===b))return x.abort();w="abort";for(l in{success:1,error:1,complete:1})x[l](f[l]);if(r=M(Tn,f,t,x)){x.readyState=1,c&&d.trigger("ajaxSend",[x,f]),f.async&&f.timeout>0&&(u=setTimeout(function(){x.abort("timeout")},f.timeout));try{b=1,r.send(m,n)}catch(T){if(!(2>b))throw T;n(-1,T)}}else n(-1,"No Transport");return x},getJSON:function(e,t,n){return et.get(e,t,n,"json")},getScript:function(e,t){return et.get(e,void 0,t,"script")}}),et.each(["get","post"],function(e,t){et[t]=function(e,n,r,i){return et.isFunction(n)&&(i=i||r,r=n,n=void 0),et.ajax({url:e,type:t,dataType:i,data:n,success:r})}}),et.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){et.fn[t]=function(e){return this.on(t,e)}}),et._evalUrl=function(e){return et.ajax({url:e,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},et.fn.extend({wrapAll:function(e){var t;return et.isFunction(e)?this.each(function(t){et(this).wrapAll(e.call(this,t))}):(this[0]&&(t=et(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){for(var e=this;e.firstElementChild;)e=e.firstElementChild;return e}).append(this)),this)},wrapInner:function(e){return this.each(et.isFunction(e)?function(t){et(this).wrapInner(e.call(this,t))}:function(){var t=et(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=et.isFunction(e);return this.each(function(n){et(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){et.nodeName(this,"body")||et(this).replaceWith(this.childNodes)}).end()}}),et.expr.filters.hidden=function(e){return e.offsetWidth<=0&&e.offsetHeight<=0},et.expr.filters.visible=function(e){return!et.expr.filters.hidden(e)};var Nn=/%20/g,kn=/\[\]$/,jn=/\r?\n/g,_n=/^(?:submit|button|image|reset|file)$/i,Sn=/^(?:input|select|textarea|keygen)/i;et.param=function(e,t){var n,r=[],i=function(e,t){t=et.isFunction(t)?t():null==t?"":t,r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(void 0===t&&(t=et.ajaxSettings&&et.ajaxSettings.traditional),et.isArray(e)||e.jquery&&!et.isPlainObject(e))et.each(e,function(){i(this.name,this.value)});else for(n in e)P(n,e[n],t,i);return r.join("&").replace(Nn,"+")},et.fn.extend({serialize:function(){return et.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=et.prop(this,"elements");return e?et.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!et(this).is(":disabled")&&Sn.test(this.nodeName)&&!_n.test(e)&&(this.checked||!Et.test(e))}).map(function(e,t){var n=et(this).val();return null==n?null:et.isArray(n)?et.map(n,function(e){return{name:t.name,value:e.replace(jn,"\r\n")}}):{name:t.name,value:n.replace(jn,"\r\n")}}).get()}}),et.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(e){}};var Dn=0,An={},On={0:200,1223:204},Ln=et.ajaxSettings.xhr();e.ActiveXObject&&et(e).on("unload",function(){for(var e in An)An[e]()}),K.cors=!!Ln&&"withCredentials"in Ln,K.ajax=Ln=!!Ln,et.ajaxTransport(function(e){var t;return K.cors||Ln&&!e.crossDomain?{send:function(n,r){var i,o=e.xhr(),a=++Dn;if(o.open(e.type,e.url,e.async,e.username,e.password),e.xhrFields)for(i in e.xhrFields)o[i]=e.xhrFields[i];e.mimeType&&o.overrideMimeType&&o.overrideMimeType(e.mimeType),e.crossDomain||n["X-Requested-With"]||(n["X-Requested-With"]="XMLHttpRequest");for(i in n)o.setRequestHeader(i,n[i]);t=function(e){return function(){t&&(delete An[a],t=o.onload=o.onerror=null,"abort"===e?o.abort():"error"===e?r(o.status,o.statusText):r(On[o.status]||o.status,o.statusText,"string"==typeof o.responseText?{text:o.responseText}:void 0,o.getAllResponseHeaders()))}},o.onload=t(),o.onerror=t("error"),t=An[a]=t("abort"),o.send(e.hasContent&&e.data||null)},abort:function(){t&&t()}}:void 0}),et.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return et.globalEval(e),e}}}),et.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),et.ajaxTransport("script",function(e){if(e.crossDomain){var t,n;return{send:function(r,i){t=et("<script>").prop({async:!0,charset:e.scriptCharset,src:e.url}).on("load error",n=function(e){t.remove(),n=null,e&&i("error"===e.type?404:200,e.type)}),J.head.appendChild(t[0])},abort:function(){n&&n()}}}});var qn=[],In=/(=)\?(?=&|$)|\?\?/;et.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=qn.pop()||et.expando+"_"+ln++;return this[e]=!0,e}}),et.ajaxPrefilter("json jsonp",function(t,n,r){var i,o,a,u=t.jsonp!==!1&&(In.test(t.url)?"url":"string"==typeof t.data&&!(t.contentType||"").indexOf("application/x-www-form-urlencoded")&&In.test(t.data)&&"data");return u||"jsonp"===t.dataTypes[0]?(i=t.jsonpCallback=et.isFunction(t.jsonpCallback)?t.jsonpCallback():t.jsonpCallback,u?t[u]=t[u].replace(In,"$1"+i):t.jsonp!==!1&&(t.url+=(fn.test(t.url)?"&":"?")+t.jsonp+"="+i),t.converters["script json"]=function(){return a||et.error(i+" was not called"),a[0]},t.dataTypes[0]="json",o=e[i],e[i]=function(){a=arguments},r.always(function(){e[i]=o,t[i]&&(t.jsonpCallback=n.jsonpCallback,qn.push(i)),a&&et.isFunction(o)&&o(a[0]),a=o=void 0}),"script"):void 0}),et.parseHTML=function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||J;var r=at.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=et.buildFragment([e],t,i),i&&i.length&&et(i).remove(),et.merge([],r.childNodes))};var Mn=et.fn.load;et.fn.load=function(e,t,n){if("string"!=typeof e&&Mn)return Mn.apply(this,arguments);var r,i,o,a=this,u=e.indexOf(" ");return u>=0&&(r=e.slice(u),e=e.slice(0,u)),et.isFunction(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),a.length>0&&et.ajax({url:e,type:i,dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?et("<div>").append(et.parseHTML(e)).find(r):e)}).complete(n&&function(e,t){a.each(n,o||[e.responseText,t,e])}),this},et.expr.filters.animated=function(e){return et.grep(et.timers,function(t){return e===t.elem}).length};var Rn=e.document.documentElement;et.offset={setOffset:function(e,t,n){var r,i,o,a,u,s,c,l=et.css(e,"position"),f=et(e),p={};"static"===l&&(e.style.position="relative"),u=f.offset(),o=et.css(e,"top"),s=et.css(e,"left"),c=("absolute"===l||"fixed"===l)&&(o+s).indexOf("auto")>-1,c?(r=f.position(),a=r.top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(s)||0),et.isFunction(t)&&(t=t.call(e,n,u)),null!=t.top&&(p.top=t.top-u.top+a),null!=t.left&&(p.left=t.left-u.left+i),"using"in t?t.using.call(e,p):f.css(p)}},et.fn.extend({offset:function(e){if(arguments.length)return void 0===e?this:this.each(function(t){et.offset.setOffset(this,e,t)});var t,n,r=this[0],i={top:0,left:0},o=r&&r.ownerDocument;if(o)return t=o.documentElement,et.contains(t,r)?(typeof r.getBoundingClientRect!==Nt&&(i=r.getBoundingClientRect()),n=W(o),{top:i.top+n.pageYOffset-t.clientTop,left:i.left+n.pageXOffset-t.clientLeft}):i},position:function(){if(this[0]){var e,t,n=this[0],r={top:0,left:0};return"fixed"===et.css(n,"position")?t=n.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),et.nodeName(e[0],"html")||(r=e.offset()),r.top+=et.css(e[0],"borderTopWidth",!0),r.left+=et.css(e[0],"borderLeftWidth",!0)),{top:t.top-r.top-et.css(n,"marginTop",!0),left:t.left-r.left-et.css(n,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){for(var e=this.offsetParent||Rn;e&&!et.nodeName(e,"html")&&"static"===et.css(e,"position");)e=e.offsetParent;return e||Rn})}}),et.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,n){var r="pageYOffset"===n;et.fn[t]=function(i){return vt(this,function(t,i,o){var a=W(t);return void 0===o?a?a[n]:t[i]:void(a?a.scrollTo(r?e.pageXOffset:o,r?o:e.pageYOffset):t[i]=o)},t,i,arguments.length,null)}}),et.each(["top","left"],function(e,t){et.cssHooks[t]=T(K.pixelPosition,function(e,n){return n?(n=x(e,t),Bt.test(n)?et(e).position()[t]+"px":n):void 0})}),et.each({Height:"height",Width:"width"},function(e,t){et.each({padding:"inner"+e,content:t,"":"outer"+e},function(n,r){et.fn[r]=function(r,i){var o=arguments.length&&(n||"boolean"!=typeof r),a=n||(r===!0||i===!0?"margin":"border");return vt(this,function(t,n,r){var i;return et.isWindow(t)?t.document.documentElement["client"+e]:9===t.nodeType?(i=t.documentElement,Math.max(t.body["scroll"+e],i["scroll"+e],t.body["offset"+e],i["offset"+e],i["client"+e])):void 0===r?et.css(t,n,a):et.style(t,n,r,a)},t,o?r:void 0,o,null)}})}),et.fn.size=function(){return this.length},et.fn.andSelf=et.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return et});var Hn=e.jQuery,Fn=e.$;return et.noConflict=function(t){return e.$===et&&(e.$=Fn),t&&e.jQuery===et&&(e.jQuery=Hn),et},typeof t===Nt&&(e.jQuery=e.$=et),et}),function(){function e(e,t,n){for(var r=(n||0)-1,i=e?e.length:0;++r<i;)if(e[r]===t)return r;return-1}function t(t,n){var r=typeof n;if(t=t.cache,"boolean"==r||null==n)return t[n]?0:-1;"number"!=r&&"string"!=r&&(r="object");var i="number"==r?n:m+n;return t=(t=t[r])&&t[i],"object"==r?t&&e(t,n)>-1?0:-1:t?0:-1}function n(e){var t=this.cache,n=typeof e;if("boolean"==n||null==e)t[e]=!0;else{"number"!=n&&"string"!=n&&(n="object");var r="number"==n?e:m+e,i=t[n]||(t[n]={});"object"==n?(i[r]||(i[r]=[])).push(e):i[r]=!0}}function r(e){return e.charCodeAt(0)}function i(e,t){for(var n=e.criteria,r=t.criteria,i=-1,o=n.length;++i<o;){var a=n[i],u=r[i];if(a!==u){if(a>u||"undefined"==typeof a)return 1;if(u>a||"undefined"==typeof u)return-1}}return e.index-t.index}function o(e){var t=-1,r=e.length,i=e[0],o=e[r/2|0],a=e[r-1];if(i&&"object"==typeof i&&o&&"object"==typeof o&&a&&"object"==typeof a)return!1;var u=s();u["false"]=u["null"]=u["true"]=u.undefined=!1;var c=s();for(c.array=e,c.cache=u,c.push=n;++t<r;)c.push(e[t]);return c}function a(e){return"\\"+V[e]}function u(){return h.pop()||[]}function s(){return g.pop()||{array:null,cache:null,criteria:null,"false":!1,index:0,"null":!1,number:null,object:null,push:null,string:null,"true":!1,undefined:!1,value:null}}function c(e){e.length=0,h.length<b&&h.push(e)}function l(e){var t=e.cache;t&&l(t),e.array=e.cache=e.criteria=e.object=e.number=e.string=e.value=null,g.length<b&&g.push(e)}function f(e,t,n){t||(t=0),"undefined"==typeof n&&(n=e?e.length:0);for(var r=-1,i=n-t||0,o=Array(0>i?0:i);++r<i;)o[r]=e[t+r];return o}function p(n){function h(e){return e&&"object"==typeof e&&!Jr(e)&&qr.call(e,"__wrapped__")?e:new g(e)}function g(e,t){this.__chain__=!!t,this.__wrapped__=e}function b(e){function t(){if(r){var e=f(r);Ir.apply(e,arguments)}if(this instanceof t){var o=Y(n.prototype),a=n.apply(o,e||arguments);return Dt(a)?a:o}return n.apply(i,e||arguments)}var n=e[0],r=e[2],i=e[4];return Kr(t,e),t}function V(e,t,n,r,i){if(n){var o=n(e);if("undefined"!=typeof o)return o}var a=Dt(e);if(!a)return e;var s=jr.call(e);if(!$[s])return e;var l=Yr[s];switch(s){case M:case R:return new l(+e);case F:case B:return new l(e);case W:return o=l(e.source,N.exec(e)),o.lastIndex=e.lastIndex,o}var p=Jr(e);if(t){var d=!r;r||(r=u()),i||(i=u());for(var h=r.length;h--;)if(r[h]==e)return i[h];o=p?l(e.length):{}}else o=p?f(e):oi({},e);return p&&(qr.call(e,"index")&&(o.index=e.index),qr.call(e,"input")&&(o.input=e.input)),t?(r.push(e),i.push(o),(p?Gt:si)(e,function(e,a){o[a]=V(e,t,n,r,i)}),d&&(c(r),c(i)),o):o}function Y(e){return Dt(e)?Pr(e):{}}function G(e,t,n){if("function"!=typeof e)return Jn;if("undefined"==typeof t||!("prototype"in e))return e;var r=e.__bindData__;if("undefined"==typeof r&&(Gr.funcNames&&(r=!e.name),r=r||!Gr.funcDecomp,!r)){var i=Or.call(e);Gr.funcNames||(r=!k.test(i)),r||(r=D.test(i),Kr(e,r))}if(r===!1||r!==!0&&1&r[1])return e;switch(n){case 1:return function(n){return e.call(t,n)};case 2:return function(n,r){return e.call(t,n,r)};case 3:return function(n,r,i){return e.call(t,n,r,i)};case 4:return function(n,r,i,o){return e.call(t,n,r,i,o)}}return In(e,t)}function K(e){function t(){var e=s?a:this;if(i){var h=f(i);Ir.apply(h,arguments)}if((o||l)&&(h||(h=f(arguments)),o&&Ir.apply(h,o),l&&h.length<u))return r|=16,K([n,p?r:-4&r,h,null,a,u]);if(h||(h=arguments),c&&(n=e[d]),this instanceof t){e=Y(n.prototype);var g=n.apply(e,h);return Dt(g)?g:e}return n.apply(e,h)}var n=e[0],r=e[1],i=e[2],o=e[3],a=e[4],u=e[5],s=1&r,c=2&r,l=4&r,p=8&r,d=n;return Kr(t,e),t}function J(n,r){var i=-1,a=st(),u=n?n.length:0,s=u>=y&&a===e,c=[];if(s){var f=o(r);f?(a=t,r=f):s=!1}for(;++i<u;){var p=n[i];a(r,p)<0&&c.push(p)}return s&&l(r),c}function et(e,t,n,r){for(var i=(r||0)-1,o=e?e.length:0,a=[];++i<o;){var u=e[i];if(u&&"object"==typeof u&&"number"==typeof u.length&&(Jr(u)||pt(u))){t||(u=et(u,t,n));var s=-1,c=u.length,l=a.length;for(a.length+=c;++s<c;)a[l++]=u[s]}else n||a.push(u)}return a}function tt(e,t,n,r,i,o){if(n){var a=n(e,t);if("undefined"!=typeof a)return!!a}if(e===t)return 0!==e||1/e==1/t;var s=typeof e,l=typeof t;if(!(e!==e||e&&X[s]||t&&X[l]))return!1;if(null==e||null==t)return e===t;var f=jr.call(e),p=jr.call(t);if(f==q&&(f=P),p==q&&(p=P),f!=p)return!1;switch(f){case M:case R:return+e==+t;case F:return e!=+e?t!=+t:0==e?1/e==1/t:e==+t;case W:case B:return e==Tr(t)}var d=f==I;if(!d){var h=qr.call(e,"__wrapped__"),g=qr.call(t,"__wrapped__");if(h||g)return tt(h?e.__wrapped__:e,g?t.__wrapped__:t,n,r,i,o);if(f!=P)return!1;var v=e.constructor,m=t.constructor;if(v!=m&&!(St(v)&&v instanceof v&&St(m)&&m instanceof m)&&"constructor"in e&&"constructor"in t)return!1}var y=!i;i||(i=u()),o||(o=u());for(var b=i.length;b--;)if(i[b]==e)return o[b]==t;var w=0;if(a=!0,i.push(e),o.push(t),d){if(b=e.length,w=t.length,a=w==b,a||r)for(;w--;){var x=b,T=t[w];if(r)for(;x--&&!(a=tt(e[x],T,n,r,i,o)););else if(!(a=tt(e[w],T,n,r,i,o)))break}}else ui(t,function(t,u,s){return qr.call(s,u)?(w++,a=qr.call(e,u)&&tt(e[u],t,n,r,i,o)):void 0}),a&&!r&&ui(e,function(e,t,n){return qr.call(n,t)?a=--w>-1:void 0});return i.pop(),o.pop(),y&&(c(i),c(o)),a}function nt(e,t,n,r,i){(Jr(t)?Gt:si)(t,function(t,o){var a,u,s=t,c=e[o];if(t&&((u=Jr(t))||ci(t))){for(var l=r.length;l--;)if(a=r[l]==t){c=i[l];break}if(!a){var f;n&&(s=n(c,t),(f="undefined"!=typeof s)&&(c=s)),f||(c=u?Jr(c)?c:[]:ci(c)?c:{}),r.push(t),i.push(c),f||nt(c,t,n,r,i)}}else n&&(s=n(c,t),"undefined"==typeof s&&(s=t)),"undefined"!=typeof s&&(c=s);e[o]=c})}function rt(e,t){return e+Ar(Qr()*(t-e+1))}function it(n,r,i){var a=-1,s=st(),f=n?n.length:0,p=[],d=!r&&f>=y&&s===e,h=i||d?u():p;if(d){var g=o(h);s=t,h=g}for(;++a<f;){var v=n[a],m=i?i(v,a,n):v;(r?!a||h[h.length-1]!==m:s(h,m)<0)&&((i||d)&&h.push(m),p.push(v))}return d?(c(h.array),l(h)):i&&c(h),p}function ot(e){return function(t,n,r){var i={};n=h.createCallback(n,r,3);var o=-1,a=t?t.length:0;if("number"==typeof a)for(;++o<a;){var u=t[o];e(i,u,n(u,o,t),t)}else si(t,function(t,r,o){e(i,t,n(t,r,o),o)});return i}}function at(e,t,n,r,i,o){var a=1&t,u=2&t,s=4&t,c=16&t,l=32&t;if(!u&&!St(e))throw new Cr;c&&!n.length&&(t&=-17,c=n=!1),l&&!r.length&&(t&=-33,l=r=!1);var p=e&&e.__bindData__;if(p&&p!==!0)return p=f(p),p[2]&&(p[2]=f(p[2])),p[3]&&(p[3]=f(p[3])),!a||1&p[1]||(p[4]=i),!a&&1&p[1]&&(t|=8),!s||4&p[1]||(p[5]=o),c&&Ir.apply(p[2]||(p[2]=[]),n),l&&Hr.apply(p[3]||(p[3]=[]),r),p[1]|=t,at.apply(null,p);var d=1==t||17===t?b:K;return d([e,t,n,r,i,o])}function ut(e){return ti[e]}function st(){var t=(t=h.indexOf)===yn?e:t;return t}function ct(e){return"function"==typeof e&&_r.test(e)}function lt(e){var t,n;return e&&jr.call(e)==P&&(t=e.constructor,!St(t)||t instanceof t)?(ui(e,function(e,t){n=t}),"undefined"==typeof n||qr.call(e,n)):!1}function ft(e){return ni[e]}function pt(e){return e&&"object"==typeof e&&"number"==typeof e.length&&jr.call(e)==q||!1}function dt(e,t,n,r){return"boolean"!=typeof t&&null!=t&&(r=n,n=t,t=!1),V(e,t,"function"==typeof n&&G(n,r,1))}function ht(e,t,n){return V(e,!0,"function"==typeof t&&G(t,n,1))}function gt(e,t){var n=Y(e);return t?oi(n,t):n}function vt(e,t,n){var r;return t=h.createCallback(t,n,3),si(e,function(e,n,i){return t(e,n,i)?(r=n,!1):void 0}),r}function mt(e,t,n){var r;return t=h.createCallback(t,n,3),bt(e,function(e,n,i){return t(e,n,i)?(r=n,!1):void 0}),r}function yt(e,t,n){var r=[];ui(e,function(e,t){r.push(t,e)});var i=r.length;for(t=G(t,n,3);i--&&t(r[i--],r[i],e)!==!1;);return e}function bt(e,t,n){var r=ei(e),i=r.length;for(t=G(t,n,3);i--;){var o=r[i];if(t(e[o],o,e)===!1)break}return e}function wt(e){var t=[];return ui(e,function(e,n){St(e)&&t.push(n)}),t.sort()}function xt(e,t){return e?qr.call(e,t):!1}function Tt(e){for(var t=-1,n=ei(e),r=n.length,i={};++t<r;){var o=n[t];i[e[o]]=o}return i}function Ct(e){return e===!0||e===!1||e&&"object"==typeof e&&jr.call(e)==M||!1}function Et(e){return e&&"object"==typeof e&&jr.call(e)==R||!1}function Nt(e){return e&&1===e.nodeType||!1}function kt(e){var t=!0;if(!e)return t;var n=jr.call(e),r=e.length;return n==I||n==B||n==q||n==P&&"number"==typeof r&&St(e.splice)?!r:(si(e,function(){return t=!1}),t)}function jt(e,t,n,r){return tt(e,t,"function"==typeof n&&G(n,r,2))}function _t(e){return Br(e)&&!$r(parseFloat(e))}function St(e){return"function"==typeof e}function Dt(e){return!(!e||!X[typeof e])}function At(e){return Lt(e)&&e!=+e}function Ot(e){return null===e}function Lt(e){return"number"==typeof e||e&&"object"==typeof e&&jr.call(e)==F||!1}function qt(e){return e&&"object"==typeof e&&jr.call(e)==W||!1}function It(e){return"string"==typeof e||e&&"object"==typeof e&&jr.call(e)==B||!1}function Mt(e){return"undefined"==typeof e}function Rt(e,t,n){var r={};return t=h.createCallback(t,n,3),si(e,function(e,n,i){r[n]=t(e,n,i)}),r}function Ht(e){var t=arguments,n=2;if(!Dt(e))return e;if("number"!=typeof t[2]&&(n=t.length),n>3&&"function"==typeof t[n-2])var r=G(t[--n-1],t[n--],2);else n>2&&"function"==typeof t[n-1]&&(r=t[--n]);for(var i=f(arguments,1,n),o=-1,a=u(),s=u();++o<n;)nt(e,i[o],r,a,s);return c(a),c(s),e}function Ft(e,t,n){var r={};if("function"!=typeof t){var i=[];ui(e,function(e,t){i.push(t)}),i=J(i,et(arguments,!0,!1,1));for(var o=-1,a=i.length;++o<a;){var u=i[o];r[u]=e[u]}}else t=h.createCallback(t,n,3),ui(e,function(e,n,i){t(e,n,i)||(r[n]=e)});return r}function Pt(e){for(var t=-1,n=ei(e),r=n.length,i=hr(r);++t<r;){var o=n[t];i[t]=[o,e[o]]}return i}function Wt(e,t,n){var r={};if("function"!=typeof t)for(var i=-1,o=et(arguments,!0,!1,1),a=Dt(e)?o.length:0;++i<a;){var u=o[i];u in e&&(r[u]=e[u])}else t=h.createCallback(t,n,3),ui(e,function(e,n,i){t(e,n,i)&&(r[n]=e)});return r}function Bt(e,t,n,r){var i=Jr(e);if(null==n)if(i)n=[];else{var o=e&&e.constructor,a=o&&o.prototype;n=Y(a)}return t&&(t=h.createCallback(t,r,4),(i?Gt:si)(e,function(e,r,i){return t(n,e,r,i)})),n}function $t(e){for(var t=-1,n=ei(e),r=n.length,i=hr(r);++t<r;)i[t]=e[n[t]];return i}function Ut(e){for(var t=arguments,n=-1,r=et(t,!0,!1,1),i=t[2]&&t[2][t[1]]===e?1:r.length,o=hr(i);++n<i;)o[n]=e[r[n]];return o}function zt(e,t,n){var r=-1,i=st(),o=e?e.length:0,a=!1;return n=(0>n?zr(0,o+n):n)||0,Jr(e)?a=i(e,t,n)>-1:"number"==typeof o?a=(It(e)?e.indexOf(t,n):i(e,t,n))>-1:si(e,function(e){return++r>=n?!(a=e===t):void 0}),a}function Xt(e,t,n){var r=!0;t=h.createCallback(t,n,3);var i=-1,o=e?e.length:0;if("number"==typeof o)for(;++i<o&&(r=!!t(e[i],i,e)););else si(e,function(e,n,i){return r=!!t(e,n,i)});return r}function Vt(e,t,n){var r=[];t=h.createCallback(t,n,3);var i=-1,o=e?e.length:0;if("number"==typeof o)for(;++i<o;){var a=e[i];t(a,i,e)&&r.push(a)}else si(e,function(e,n,i){t(e,n,i)&&r.push(e)});return r}function Qt(e,t,n){t=h.createCallback(t,n,3);var r=-1,i=e?e.length:0;if("number"!=typeof i){var o;return si(e,function(e,n,r){return t(e,n,r)?(o=e,!1):void 0}),o}for(;++r<i;){var a=e[r];if(t(a,r,e))return a}}function Yt(e,t,n){var r;return t=h.createCallback(t,n,3),Kt(e,function(e,n,i){return t(e,n,i)?(r=e,!1):void 0}),r}function Gt(e,t,n){var r=-1,i=e?e.length:0;
        if(t=t&&"undefined"==typeof n?t:G(t,n,3),"number"==typeof i)for(;++r<i&&t(e[r],r,e)!==!1;);else si(e,t);return e}function Kt(e,t,n){var r=e?e.length:0;if(t=t&&"undefined"==typeof n?t:G(t,n,3),"number"==typeof r)for(;r--&&t(e[r],r,e)!==!1;);else{var i=ei(e);r=i.length,si(e,function(e,n,o){return n=i?i[--r]:--r,t(o[n],n,o)})}return e}function Jt(e,t){var n=f(arguments,2),r=-1,i="function"==typeof t,o=e?e.length:0,a=hr("number"==typeof o?o:0);return Gt(e,function(e){a[++r]=(i?t:e[t]).apply(e,n)}),a}function Zt(e,t,n){var r=-1,i=e?e.length:0;if(t=h.createCallback(t,n,3),"number"==typeof i)for(var o=hr(i);++r<i;)o[r]=t(e[r],r,e);else o=[],si(e,function(e,n,i){o[++r]=t(e,n,i)});return o}function en(e,t,n){var i=-1/0,o=i;if("function"!=typeof t&&n&&n[t]===e&&(t=null),null==t&&Jr(e))for(var a=-1,u=e.length;++a<u;){var s=e[a];s>o&&(o=s)}else t=null==t&&It(e)?r:h.createCallback(t,n,3),Gt(e,function(e,n,r){var a=t(e,n,r);a>i&&(i=a,o=e)});return o}function tn(e,t,n){var i=1/0,o=i;if("function"!=typeof t&&n&&n[t]===e&&(t=null),null==t&&Jr(e))for(var a=-1,u=e.length;++a<u;){var s=e[a];o>s&&(o=s)}else t=null==t&&It(e)?r:h.createCallback(t,n,3),Gt(e,function(e,n,r){var a=t(e,n,r);i>a&&(i=a,o=e)});return o}function nn(e,t,n,r){if(!e)return n;var i=arguments.length<3;t=h.createCallback(t,r,4);var o=-1,a=e.length;if("number"==typeof a)for(i&&(n=e[++o]);++o<a;)n=t(n,e[o],o,e);else si(e,function(e,r,o){n=i?(i=!1,e):t(n,e,r,o)});return n}function rn(e,t,n,r){var i=arguments.length<3;return t=h.createCallback(t,r,4),Kt(e,function(e,r,o){n=i?(i=!1,e):t(n,e,r,o)}),n}function on(e,t,n){return t=h.createCallback(t,n,3),Vt(e,function(e,n,r){return!t(e,n,r)})}function an(e,t,n){if(e&&"number"!=typeof e.length&&(e=$t(e)),null==t||n)return e?e[rt(0,e.length-1)]:d;var r=un(e);return r.length=Xr(zr(0,t),r.length),r}function un(e){var t=-1,n=e?e.length:0,r=hr("number"==typeof n?n:0);return Gt(e,function(e){var n=rt(0,++t);r[t]=r[n],r[n]=e}),r}function sn(e){var t=e?e.length:0;return"number"==typeof t?t:ei(e).length}function cn(e,t,n){var r;t=h.createCallback(t,n,3);var i=-1,o=e?e.length:0;if("number"==typeof o)for(;++i<o&&!(r=t(e[i],i,e)););else si(e,function(e,n,i){return!(r=t(e,n,i))});return!!r}function ln(e,t,n){var r=-1,o=Jr(t),a=e?e.length:0,f=hr("number"==typeof a?a:0);for(o||(t=h.createCallback(t,n,3)),Gt(e,function(e,n,i){var a=f[++r]=s();o?a.criteria=Zt(t,function(t){return e[t]}):(a.criteria=u())[0]=t(e,n,i),a.index=r,a.value=e}),a=f.length,f.sort(i);a--;){var p=f[a];f[a]=p.value,o||c(p.criteria),l(p)}return f}function fn(e){return e&&"number"==typeof e.length?f(e):$t(e)}function pn(e){for(var t=-1,n=e?e.length:0,r=[];++t<n;){var i=e[t];i&&r.push(i)}return r}function dn(e){return J(e,et(arguments,!0,!0,1))}function hn(e,t,n){var r=-1,i=e?e.length:0;for(t=h.createCallback(t,n,3);++r<i;)if(t(e[r],r,e))return r;return-1}function gn(e,t,n){var r=e?e.length:0;for(t=h.createCallback(t,n,3);r--;)if(t(e[r],r,e))return r;return-1}function vn(e,t,n){var r=0,i=e?e.length:0;if("number"!=typeof t&&null!=t){var o=-1;for(t=h.createCallback(t,n,3);++o<i&&t(e[o],o,e);)r++}else if(r=t,null==r||n)return e?e[0]:d;return f(e,0,Xr(zr(0,r),i))}function mn(e,t,n,r){return"boolean"!=typeof t&&null!=t&&(r=n,n="function"!=typeof t&&r&&r[t]===e?null:t,t=!1),null!=n&&(e=Zt(e,n,r)),et(e,t)}function yn(t,n,r){if("number"==typeof r){var i=t?t.length:0;r=0>r?zr(0,i+r):r||0}else if(r){var o=jn(t,n);return t[o]===n?o:-1}return e(t,n,r)}function bn(e,t,n){var r=0,i=e?e.length:0;if("number"!=typeof t&&null!=t){var o=i;for(t=h.createCallback(t,n,3);o--&&t(e[o],o,e);)r++}else r=null==t||n?1:t||r;return f(e,0,Xr(zr(0,i-r),i))}function wn(){for(var n=[],r=-1,i=arguments.length,a=u(),s=st(),f=s===e,p=u();++r<i;){var d=arguments[r];(Jr(d)||pt(d))&&(n.push(d),a.push(f&&d.length>=y&&o(r?n[r]:p)))}var h=n[0],g=-1,v=h?h.length:0,m=[];e:for(;++g<v;){var b=a[0];if(d=h[g],(b?t(b,d):s(p,d))<0){for(r=i,(b||p).push(d);--r;)if(b=a[r],(b?t(b,d):s(n[r],d))<0)continue e;m.push(d)}}for(;i--;)b=a[i],b&&l(b);return c(a),c(p),m}function xn(e,t,n){var r=0,i=e?e.length:0;if("number"!=typeof t&&null!=t){var o=i;for(t=h.createCallback(t,n,3);o--&&t(e[o],o,e);)r++}else if(r=t,null==r||n)return e?e[i-1]:d;return f(e,zr(0,i-r))}function Tn(e,t,n){var r=e?e.length:0;for("number"==typeof n&&(r=(0>n?zr(0,r+n):Xr(n,r-1))+1);r--;)if(e[r]===t)return r;return-1}function Cn(e){for(var t=arguments,n=0,r=t.length,i=e?e.length:0;++n<r;)for(var o=-1,a=t[n];++o<i;)e[o]===a&&(Rr.call(e,o--,1),i--);return e}function En(e,t,n){e=+e||0,n="number"==typeof n?n:+n||1,null==t&&(t=e,e=0);for(var r=-1,i=zr(0,Sr((t-e)/(n||1))),o=hr(i);++r<i;)o[r]=e,e+=n;return o}function Nn(e,t,n){var r=-1,i=e?e.length:0,o=[];for(t=h.createCallback(t,n,3);++r<i;){var a=e[r];t(a,r,e)&&(o.push(a),Rr.call(e,r--,1),i--)}return o}function kn(e,t,n){if("number"!=typeof t&&null!=t){var r=0,i=-1,o=e?e.length:0;for(t=h.createCallback(t,n,3);++i<o&&t(e[i],i,e);)r++}else r=null==t||n?1:zr(0,t);return f(e,r)}function jn(e,t,n,r){var i=0,o=e?e.length:i;for(n=n?h.createCallback(n,r,1):Jn,t=n(t);o>i;){var a=i+o>>>1;n(e[a])<t?i=a+1:o=a}return i}function _n(){return it(et(arguments,!0,!0))}function Sn(e,t,n,r){return"boolean"!=typeof t&&null!=t&&(r=n,n="function"!=typeof t&&r&&r[t]===e?null:t,t=!1),null!=n&&(n=h.createCallback(n,r,3)),it(e,t,n)}function Dn(e){return J(e,f(arguments,1))}function An(){for(var e=-1,t=arguments.length;++e<t;){var n=arguments[e];if(Jr(n)||pt(n))var r=r?it(J(r,n).concat(J(n,r))):n}return r||[]}function On(){for(var e=arguments.length>1?arguments:arguments[0],t=-1,n=e?en(di(e,"length")):0,r=hr(0>n?0:n);++t<n;)r[t]=di(e,t);return r}function Ln(e,t){var n=-1,r=e?e.length:0,i={};for(t||!r||Jr(e[0])||(t=[]);++n<r;){var o=e[n];t?i[o]=t[n]:o&&(i[o[0]]=o[1])}return i}function qn(e,t){if(!St(t))throw new Cr;return function(){return--e<1?t.apply(this,arguments):void 0}}function In(e,t){return arguments.length>2?at(e,17,f(arguments,2),null,t):at(e,1,null,null,t)}function Mn(e){for(var t=arguments.length>1?et(arguments,!0,!1,1):wt(e),n=-1,r=t.length;++n<r;){var i=t[n];e[i]=at(e[i],1,null,null,e)}return e}function Rn(e,t){return arguments.length>2?at(t,19,f(arguments,2),null,e):at(t,3,null,null,e)}function Hn(){for(var e=arguments,t=e.length;t--;)if(!St(e[t]))throw new Cr;return function(){for(var t=arguments,n=e.length;n--;)t=[e[n].apply(this,t)];return t[0]}}function Fn(e,t){return t="number"==typeof t?t:+t||e.length,at(e,4,null,null,null,t)}function Pn(e,t,n){var r,i,o,a,u,s,c,l=0,f=!1,p=!0;if(!St(e))throw new Cr;if(t=zr(0,t)||0,n===!0){var h=!0;p=!1}else Dt(n)&&(h=n.leading,f="maxWait"in n&&(zr(t,n.maxWait)||0),p="trailing"in n?n.trailing:p);var g=function(){var n=t-(gi()-a);if(0>=n){i&&Dr(i);var f=c;i=s=c=d,f&&(l=gi(),o=e.apply(u,r),s||i||(r=u=null))}else s=Mr(g,n)},v=function(){s&&Dr(s),i=s=c=d,(p||f!==t)&&(l=gi(),o=e.apply(u,r),s||i||(r=u=null))};return function(){if(r=arguments,a=gi(),u=this,c=p&&(s||!h),f===!1)var n=h&&!s;else{i||h||(l=a);var d=f-(a-l),m=0>=d;m?(i&&(i=Dr(i)),l=a,o=e.apply(u,r)):i||(i=Mr(v,d))}return m&&s?s=Dr(s):s||t===f||(s=Mr(g,t)),n&&(m=!0,o=e.apply(u,r)),!m||s||i||(r=u=null),o}}function Wn(e){if(!St(e))throw new Cr;var t=f(arguments,1);return Mr(function(){e.apply(d,t)},1)}function Bn(e,t){if(!St(e))throw new Cr;var n=f(arguments,2);return Mr(function(){e.apply(d,n)},t)}function $n(e,t){if(!St(e))throw new Cr;var n=function(){var r=n.cache,i=t?t.apply(this,arguments):m+arguments[0];return qr.call(r,i)?r[i]:r[i]=e.apply(this,arguments)};return n.cache={},n}function Un(e){var t,n;if(!St(e))throw new Cr;return function(){return t?n:(t=!0,n=e.apply(this,arguments),e=null,n)}}function zn(e){return at(e,16,f(arguments,1))}function Xn(e){return at(e,32,null,f(arguments,1))}function Vn(e,t,n){var r=!0,i=!0;if(!St(e))throw new Cr;return n===!1?r=!1:Dt(n)&&(r="leading"in n?n.leading:r,i="trailing"in n?n.trailing:i),U.leading=r,U.maxWait=t,U.trailing=i,Pn(e,t,U)}function Qn(e,t){return at(t,16,[e])}function Yn(e){return function(){return e}}function Gn(e,t,n){var r=typeof e;if(null==e||"function"==r)return G(e,t,n);if("object"!=r)return nr(e);var i=ei(e),o=i[0],a=e[o];return 1!=i.length||a!==a||Dt(a)?function(t){for(var n=i.length,r=!1;n--&&(r=tt(t[i[n]],e[i[n]],null,!0)););return r}:function(e){var t=e[o];return a===t&&(0!==a||1/a==1/t)}}function Kn(e){return null==e?"":Tr(e).replace(ii,ut)}function Jn(e){return e}function Zn(e,t,n){var r=!0,i=t&&wt(t);t&&(n||i.length)||(null==n&&(n=t),o=g,t=e,e=h,i=wt(t)),n===!1?r=!1:Dt(n)&&"chain"in n&&(r=n.chain);var o=e,a=St(o);Gt(i,function(n){var i=e[n]=t[n];a&&(o.prototype[n]=function(){var t=this.__chain__,n=this.__wrapped__,a=[n];Ir.apply(a,arguments);var u=i.apply(e,a);if(r||t){if(n===u&&Dt(u))return this;u=new o(u),u.__chain__=t}return u})})}function er(){return n._=kr,this}function tr(){}function nr(e){return function(t){return t[e]}}function rr(e,t,n){var r=null==e,i=null==t;if(null==n&&("boolean"==typeof e&&i?(n=e,e=1):i||"boolean"!=typeof t||(n=t,i=!0)),r&&i&&(t=1),e=+e||0,i?(t=e,e=0):t=+t||0,n||e%1||t%1){var o=Qr();return Xr(e+o*(t-e+parseFloat("1e-"+((o+"").length-1))),t)}return rt(e,t)}function ir(e,t){if(e){var n=e[t];return St(n)?e[t]():n}}function or(e,t,n){var r=h.templateSettings;e=Tr(e||""),n=ai({},n,r);var i,o=ai({},n.imports,r.imports),u=ei(o),s=$t(o),c=0,l=n.interpolate||S,f="__p += '",p=xr((n.escape||S).source+"|"+l.source+"|"+(l===j?E:S).source+"|"+(n.evaluate||S).source+"|$","g");e.replace(p,function(t,n,r,o,u,s){return r||(r=o),f+=e.slice(c,s).replace(A,a),n&&(f+="' +\n__e("+n+") +\n'"),u&&(i=!0,f+="';\n"+u+";\n__p += '"),r&&(f+="' +\n((__t = ("+r+")) == null ? '' : __t) +\n'"),c=s+t.length,t}),f+="';\n";var g=n.variable,v=g;v||(g="obj",f="with ("+g+") {\n"+f+"\n}\n"),f=(i?f.replace(x,""):f).replace(T,"$1").replace(C,"$1;"),f="function("+g+") {\n"+(v?"":g+" || ("+g+" = {});\n")+"var __t, __p = '', __e = _.escape"+(i?", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n":";\n")+f+"return __p\n}";var m="\n/*\n//# sourceURL="+(n.sourceURL||"/lodash/template/source["+L++ +"]")+"\n*/";try{var y=mr(u,"return "+f+m).apply(d,s)}catch(b){throw b.source=f,b}return t?y(t):(y.source=f,y)}function ar(e,t,n){e=(e=+e)>-1?e:0;var r=-1,i=hr(e);for(t=G(t,n,1);++r<e;)i[r]=t(r);return i}function ur(e){return null==e?"":Tr(e).replace(ri,ft)}function sr(e){var t=++v;return Tr(null==e?"":e)+t}function cr(e){return e=new g(e),e.__chain__=!0,e}function lr(e,t){return t(e),e}function fr(){return this.__chain__=!0,this}function pr(){return Tr(this.__wrapped__)}function dr(){return this.__wrapped__}n=n?Z.defaults(Q.Object(),n,Z.pick(Q,O)):Q;var hr=n.Array,gr=n.Boolean,vr=n.Date,mr=n.Function,yr=n.Math,br=n.Number,wr=n.Object,xr=n.RegExp,Tr=n.String,Cr=n.TypeError,Er=[],Nr=wr.prototype,kr=n._,jr=Nr.toString,_r=xr("^"+Tr(jr).replace(/[.*+?^${}()|[\]\\]/g,"\\$&").replace(/toString| for [^\]]+/g,".*?")+"$"),Sr=yr.ceil,Dr=n.clearTimeout,Ar=yr.floor,Or=mr.prototype.toString,Lr=ct(Lr=wr.getPrototypeOf)&&Lr,qr=Nr.hasOwnProperty,Ir=Er.push,Mr=n.setTimeout,Rr=Er.splice,Hr=Er.unshift,Fr=function(){try{var e={},t=ct(t=wr.defineProperty)&&t,n=t(e,e,e)&&t}catch(r){}return n}(),Pr=ct(Pr=wr.create)&&Pr,Wr=ct(Wr=hr.isArray)&&Wr,Br=n.isFinite,$r=n.isNaN,Ur=ct(Ur=wr.keys)&&Ur,zr=yr.max,Xr=yr.min,Vr=n.parseInt,Qr=yr.random,Yr={};Yr[I]=hr,Yr[M]=gr,Yr[R]=vr,Yr[H]=mr,Yr[P]=wr,Yr[F]=br,Yr[W]=xr,Yr[B]=Tr,g.prototype=h.prototype;var Gr=h.support={};Gr.funcDecomp=!ct(n.WinRTError)&&D.test(p),Gr.funcNames="string"==typeof mr.name,h.templateSettings={escape:/<%-([\s\S]+?)%>/g,evaluate:/<%([\s\S]+?)%>/g,interpolate:j,variable:"",imports:{_:h}},Pr||(Y=function(){function e(){}return function(t){if(Dt(t)){e.prototype=t;var r=new e;e.prototype=null}return r||n.Object()}}());var Kr=Fr?function(e,t){z.value=t,Fr(e,"__bindData__",z)}:tr,Jr=Wr||function(e){return e&&"object"==typeof e&&"number"==typeof e.length&&jr.call(e)==I||!1},Zr=function(e){var t,n=e,r=[];if(!n)return r;if(!X[typeof e])return r;for(t in n)qr.call(n,t)&&r.push(t);return r},ei=Ur?function(e){return Dt(e)?Ur(e):[]}:Zr,ti={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},ni=Tt(ti),ri=xr("("+ei(ni).join("|")+")","g"),ii=xr("["+ei(ti).join("")+"]","g"),oi=function(e,t,n){var r,i=e,o=i;if(!i)return o;var a=arguments,u=0,s="number"==typeof n?2:a.length;if(s>3&&"function"==typeof a[s-2])var c=G(a[--s-1],a[s--],2);else s>2&&"function"==typeof a[s-1]&&(c=a[--s]);for(;++u<s;)if(i=a[u],i&&X[typeof i])for(var l=-1,f=X[typeof i]&&ei(i),p=f?f.length:0;++l<p;)r=f[l],o[r]=c?c(o[r],i[r]):i[r];return o},ai=function(e,t,n){var r,i=e,o=i;if(!i)return o;for(var a=arguments,u=0,s="number"==typeof n?2:a.length;++u<s;)if(i=a[u],i&&X[typeof i])for(var c=-1,l=X[typeof i]&&ei(i),f=l?l.length:0;++c<f;)r=l[c],"undefined"==typeof o[r]&&(o[r]=i[r]);return o},ui=function(e,t,n){var r,i=e,o=i;if(!i)return o;if(!X[typeof i])return o;t=t&&"undefined"==typeof n?t:G(t,n,3);for(r in i)if(t(i[r],r,e)===!1)return o;return o},si=function(e,t,n){var r,i=e,o=i;if(!i)return o;if(!X[typeof i])return o;t=t&&"undefined"==typeof n?t:G(t,n,3);for(var a=-1,u=X[typeof i]&&ei(i),s=u?u.length:0;++a<s;)if(r=u[a],t(i[r],r,e)===!1)return o;return o},ci=Lr?function(e){if(!e||jr.call(e)!=P)return!1;var t=e.valueOf,n=ct(t)&&(n=Lr(t))&&Lr(n);return n?e==n||Lr(e)==n:lt(e)}:lt,li=ot(function(e,t,n){qr.call(e,n)?e[n]++:e[n]=1}),fi=ot(function(e,t,n){(qr.call(e,n)?e[n]:e[n]=[]).push(t)}),pi=ot(function(e,t,n){e[n]=t}),di=Zt,hi=Vt,gi=ct(gi=vr.now)&&gi||function(){return(new vr).getTime()},vi=8==Vr(w+"08")?Vr:function(e,t){return Vr(It(e)?e.replace(_,""):e,t||0)};return h.after=qn,h.assign=oi,h.at=Ut,h.bind=In,h.bindAll=Mn,h.bindKey=Rn,h.chain=cr,h.compact=pn,h.compose=Hn,h.constant=Yn,h.countBy=li,h.create=gt,h.createCallback=Gn,h.curry=Fn,h.debounce=Pn,h.defaults=ai,h.defer=Wn,h.delay=Bn,h.difference=dn,h.filter=Vt,h.flatten=mn,h.forEach=Gt,h.forEachRight=Kt,h.forIn=ui,h.forInRight=yt,h.forOwn=si,h.forOwnRight=bt,h.functions=wt,h.groupBy=fi,h.indexBy=pi,h.initial=bn,h.intersection=wn,h.invert=Tt,h.invoke=Jt,h.keys=ei,h.map=Zt,h.mapValues=Rt,h.max=en,h.memoize=$n,h.merge=Ht,h.min=tn,h.omit=Ft,h.once=Un,h.pairs=Pt,h.partial=zn,h.partialRight=Xn,h.pick=Wt,h.pluck=di,h.property=nr,h.pull=Cn,h.range=En,h.reject=on,h.remove=Nn,h.rest=kn,h.shuffle=un,h.sortBy=ln,h.tap=lr,h.throttle=Vn,h.times=ar,h.toArray=fn,h.transform=Bt,h.union=_n,h.uniq=Sn,h.values=$t,h.where=hi,h.without=Dn,h.wrap=Qn,h.xor=An,h.zip=On,h.zipObject=Ln,h.collect=Zt,h.drop=kn,h.each=Gt,h.eachRight=Kt,h.extend=oi,h.methods=wt,h.object=Ln,h.select=Vt,h.tail=kn,h.unique=Sn,h.unzip=On,Zn(h),h.clone=dt,h.cloneDeep=ht,h.contains=zt,h.escape=Kn,h.every=Xt,h.find=Qt,h.findIndex=hn,h.findKey=vt,h.findLast=Yt,h.findLastIndex=gn,h.findLastKey=mt,h.has=xt,h.identity=Jn,h.indexOf=yn,h.isArguments=pt,h.isArray=Jr,h.isBoolean=Ct,h.isDate=Et,h.isElement=Nt,h.isEmpty=kt,h.isEqual=jt,h.isFinite=_t,h.isFunction=St,h.isNaN=At,h.isNull=Ot,h.isNumber=Lt,h.isObject=Dt,h.isPlainObject=ci,h.isRegExp=qt,h.isString=It,h.isUndefined=Mt,h.lastIndexOf=Tn,h.mixin=Zn,h.noConflict=er,h.noop=tr,h.now=gi,h.parseInt=vi,h.random=rr,h.reduce=nn,h.reduceRight=rn,h.result=ir,h.runInContext=p,h.size=sn,h.some=cn,h.sortedIndex=jn,h.template=or,h.unescape=ur,h.uniqueId=sr,h.all=Xt,h.any=cn,h.detect=Qt,h.findWhere=Qt,h.foldl=nn,h.foldr=rn,h.include=zt,h.inject=nn,Zn(function(){var e={};return si(h,function(t,n){h.prototype[n]||(e[n]=t)}),e}(),!1),h.first=vn,h.last=xn,h.sample=an,h.take=vn,h.head=vn,si(h,function(e,t){var n="sample"!==t;h.prototype[t]||(h.prototype[t]=function(t,r){var i=this.__chain__,o=e(this.__wrapped__,t,r);return i||null!=t&&(!r||n&&"function"==typeof t)?new g(o,i):o})}),h.VERSION="2.4.1",h.prototype.chain=fr,h.prototype.toString=pr,h.prototype.value=dr,h.prototype.valueOf=dr,Gt(["join","pop","shift"],function(e){var t=Er[e];h.prototype[e]=function(){var e=this.__chain__,n=t.apply(this.__wrapped__,arguments);return e?new g(n,e):n}}),Gt(["push","reverse","sort","unshift"],function(e){var t=Er[e];h.prototype[e]=function(){return t.apply(this.__wrapped__,arguments),this}}),Gt(["concat","slice","splice"],function(e){var t=Er[e];h.prototype[e]=function(){return new g(t.apply(this.__wrapped__,arguments),this.__chain__)}}),h}var d,h=[],g=[],v=0,m=+new Date+"",y=75,b=40,w="\f ﻿\n\r\u2028\u2029 ᠎",x=/\b__p \+= '';/g,T=/\b(__p \+=) '' \+/g,C=/(__e\(.*?\)|\b__t\)) \+\n'';/g,E=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,N=/\w*$/,k=/^\s*function[ \n\r\t]+\w/,j=/<%=([\s\S]+?)%>/g,_=RegExp("^["+w+"]*0+(?=.$)"),S=/($^)/,D=/\bthis\b/,A=/['\n\r\t\u2028\u2029\\]/g,O=["Array","Boolean","Date","Function","Math","Number","Object","RegExp","String","_","attachEvent","clearTimeout","isFinite","isNaN","parseInt","setTimeout"],L=0,q="[object Arguments]",I="[object Array]",M="[object Boolean]",R="[object Date]",H="[object Function]",F="[object Number]",P="[object Object]",W="[object RegExp]",B="[object String]",$={};$[H]=!1,$[q]=$[I]=$[M]=$[R]=$[F]=$[P]=$[W]=$[B]=!0;var U={leading:!1,maxWait:0,trailing:!1},z={configurable:!1,enumerable:!1,value:null,writable:!1},X={"boolean":!1,"function":!0,object:!0,number:!1,string:!1,undefined:!1},V={"\\":"\\","'":"'","\n":"n","\r":"r","	":"t","\u2028":"u2028","\u2029":"u2029"},Q=X[typeof window]&&window||this,Y=X[typeof exports]&&exports&&!exports.nodeType&&exports,G=X[typeof module]&&module&&!module.nodeType&&module,K=G&&G.exports===Y&&Y,J=X[typeof global]&&global;!J||J.global!==J&&J.window!==J||(Q=J);var Z=p();"function"==typeof define&&"object"==typeof define.amd&&define.amd?(Q._=Z,define(function(){return Z})):Y&&G?K?(G.exports=Z)._=Z:Y._=Z:Q._=Z}.call(this),function(e){function t(t){return"function"==typeof d[t]&&(d[t]=d[t](e,c,l)),d[t]}function n(t,n,r){d[t]=r?n(e,c,l):n}function r(e,t){var n=!1,r=e.charAt(0).toUpperCase()+e.slice(1),i=s.length,o=t.style;if("string"==typeof o[e])n=!0;else for(;i--;)if("string"==typeof o[s[i]+r]){n=!0;break}return n}function i(e){if(e)for(;e.lastChild;)e.removeChild(e.lastChild);return e}function o(e,t){var n=typeof e[t];return"object"==n?!!e[t]:!u[n]}function a(){var e,n={};for(e in d)try{n[e]=t(e)}catch(r){n[e]="error",n[e].ERROR_MSG=r.toString()}return n}var u={"boolean":1,number:1,string:1,undefined:1},s=["Webkit","Moz","O","ms","Khtml"],c=o(e,"document")&&e.document,l=c&&o(c,"createElement")&&c.createElement("DiV"),f="object"==typeof exports&&exports,p="object"==typeof module&&module,d={};t.all=a,t.add=n,t.clearElement=i,t.cssprop=r,t.isHostType=o,t._tests=d,t.add("dom",function(e,t,n){return t&&n&&o(e,"location")&&o(t,"documentElement")&&o(t,"getElementById")&&o(t,"getElementsByName")&&o(t,"getElementsByTagName")&&o(t,"createComment")&&o(t,"createElement")&&o(t,"createTextNode")&&o(n,"appendChild")&&o(n,"insertBefore")&&o(n,"removeChild")&&o(n,"getAttribute")&&o(n,"setAttribute")&&o(n,"removeAttribute")&&o(n,"style")&&"string"==typeof n.style.cssText});try{document.execCommand("BackgroundImageCache",!1,!0)}catch(h){}"function"==typeof define&&"object"==typeof define.amd&&define.amd?define("has",function(){return t}):f?p&&p.exports==f?(p.exports=t).has=t:f.has=t:e.has=t}(this);var saveAs=saveAs||"undefined"!=typeof navigator&&navigator.msSaveOrOpenBlob&&navigator.msSaveOrOpenBlob.bind(navigator)||function(e){"use strict";if("undefined"==typeof navigator||!/MSIE [1-9]\./.test(navigator.userAgent)){var t=e.document,n=function(){return e.URL||e.webkitURL||e},r=t.createElementNS("http://www.w3.org/1999/xhtml","a"),i=!e.externalHost&&"download"in r,o=function(n){var r=t.createEvent("MouseEvents");r.initMouseEvent("click",!0,!1,e,0,0,0,0,0,!1,!1,!1,!1,0,null),n.dispatchEvent(r)},a=e.webkitRequestFileSystem,u=e.requestFileSystem||a||e.mozRequestFileSystem,s=function(t){(e.setImmediate||e.setTimeout)(function(){throw t},0)},c="application/octet-stream",l=0,f=[],p=function(){for(var e=f.length;e--;){var t=f[e];"string"==typeof t?n().revokeObjectURL(t):t.remove()}f.length=0},d=function(e,t,n){t=[].concat(t);for(var r=t.length;r--;){var i=e["on"+t[r]];if("function"==typeof i)try{i.call(e,n||e)}catch(o){s(o)}}},h=function(t,s){var p,h,g,v=this,m=t.type,y=!1,b=function(){var e=n().createObjectURL(t);return f.push(e),e},w=function(){d(v,"writestart progress write writeend".split(" "))},x=function(){(y||!p)&&(p=b(t)),h?h.location.href=p:window.open(p,"_blank"),v.readyState=v.DONE,w()},T=function(e){return function(){return v.readyState!==v.DONE?e.apply(this,arguments):void 0}},C={create:!0,exclusive:!1};return v.readyState=v.INIT,s||(s="download"),i?(p=b(t),r.href=p,r.download=s,o(r),v.readyState=v.DONE,void w()):(e.chrome&&m&&m!==c&&(g=t.slice||t.webkitSlice,t=g.call(t,0,t.size,c),y=!0),a&&"download"!==s&&(s+=".download"),(m===c||a)&&(h=e),u?(l+=t.size,void u(e.TEMPORARY,l,T(function(e){e.root.getDirectory("saved",C,T(function(e){var n=function(){e.getFile(s,C,T(function(e){e.createWriter(T(function(n){n.onwriteend=function(t){h.location.href=e.toURL(),f.push(e),v.readyState=v.DONE,d(v,"writeend",t)},n.onerror=function(){var e=n.error;e.code!==e.ABORT_ERR&&x()},"writestart progress write abort".split(" ").forEach(function(e){n["on"+e]=v["on"+e]}),n.write(t),v.abort=function(){n.abort(),v.readyState=v.DONE},v.readyState=v.WRITING}),x)}),x)};e.getFile(s,{create:!1},T(function(e){e.remove(),n()}),T(function(e){e.code===e.NOT_FOUND_ERR?n():x()}))}),x)}),x)):void x())},g=h.prototype,v=function(e,t){return new h(e,t)};return g.abort=function(){var e=this;e.readyState=e.DONE,d(e,"abort")},g.readyState=g.INIT=0,g.WRITING=1,g.DONE=2,g.error=g.onwritestart=g.onprogress=g.onwrite=g.onabort=g.onerror=g.onwriteend=null,e.addEventListener("unload",p,!1),v.unload=function(){p(),e.removeEventListener("unload",p,!1)},v}}("undefined"!=typeof self&&self||"undefined"!=typeof window&&window||this.content);"undefined"!=typeof module&&null!==module?module.exports=saveAs:"undefined"!=typeof define&&null!==define&&null!=define.amd&&define([],function(){return saveAs}),function(){"use strict";window.phetcommon||(window.phetcommon={});var e={};if("undefined"!=typeof window&&window.location.search)for(var t=window.location.search.slice(1).split("&"),n=0;n<t.length;n++){var r=t[n].split("=");e[r[0]]=decodeURIComponent(r[1])}window.phetcommon.getQueryParameter=function(t){return e[t]}}(),function(){"use strict";var e="production"===$("meta[name=phet-sim-level]").attr("content"),t=!e&&!!window.phetcommon.getQueryParameter("eall"),n=t||!e&&!!window.phetcommon.getQueryParameter("ea"),r=window.has&&window.has("assert.basic"),i=window.has&&window.has("assert.slow");window.has?((!e&&void 0===r&&n||r)&&console.log("enabling basic assertions"),(!e&&void 0===i&&t||i)&&console.log("enabling slow assertions"),void 0===r&&window.has.add("assert.basic",function(){return n}),void 0===i&&window.has.add("assert.slow",function(){return t})):console.log("has.js not found, using default assertion levels")}();var _gaq=_gaq||[];_gaq.push(["_setAccount","UA-5033201-1"]),_gaq.push(["_setDomainName",document.domain]),_gaq.push(["_setAllowLinker",!0]),_gaq.push(["_setCustomVar",1,"Sim Version",window.phetVersion,3]),_gaq.push(["_setCustomVar",2,"Sim Locale",window.phetLocale,3]),_gaq.push(["_trackPageview"]),_gaq.push(["_trackPageLoadTime"]),function(){"use strict";var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src=("https:"===document.location.protocol?"https://ssl":"http://www")+".google-analytics.com/ga.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}(),function(e,t,n,r,i,o,a){"use strict";e.GoogleAnalyticsObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,o=t.createElement(n),a=t.getElementsByTagName(n)[0],o.async=1,o.src=r,a.parentNode.insertBefore(o,a)}(window,document,"script","//www.google-analytics.com/analytics.js","hewlettOERTracker"),window.hewlettOERTracker("create","UA-5033010-1","phet.colorado.edu"),window.hewlettOERTracker("send","pageview"),void 0===Date.now&&(Date.now=function(){return(new Date).valueOf()});var TWEEN=TWEEN||function(){var e=[];return{REVISION:"12",getAll:function(){return e},removeAll:function(){e=[]},add:function(t){e.push(t)},remove:function(t){var n=e.indexOf(t);-1!==n&&e.splice(n,1)},update:function(t){if(0===e.length)return!1;var n=0;for(t=void 0!==t?t:"undefined"!=typeof window&&void 0!==window.performance&&void 0!==window.performance.now?window.performance.now():Date.now();n<e.length;)e[n].update(t)?n++:e.splice(n,1);return!0}}}();TWEEN.Tween=function(e){var t=e,n={},r={},i={},o=1e3,a=0,u=!1,s=!1,c=!1,l=0,f=null,p=TWEEN.Easing.Linear.None,d=TWEEN.Interpolation.Linear,h=[],g=null,v=!1,m=null,y=null;for(var b in e)n[b]=parseFloat(e[b],10);this.to=function(e,t){return void 0!==t&&(o=t),r=e,this},this.start=function(e){TWEEN.add(this),s=!0,v=!1,f=void 0!==e?e:"undefined"!=typeof window&&void 0!==window.performance&&void 0!==window.performance.now?window.performance.now():Date.now(),f+=l;for(var o in r){if(r[o]instanceof Array){if(0===r[o].length)continue;r[o]=[t[o]].concat(r[o])}n[o]=t[o],n[o]instanceof Array==!1&&(n[o]*=1),i[o]=n[o]||0}return this},this.stop=function(){return s?(TWEEN.remove(this),s=!1,this.stopChainedTweens(),this):this},this.stopChainedTweens=function(){for(var e=0,t=h.length;t>e;e++)h[e].stop()},this.delay=function(e){return l=e,this},this.repeat=function(e){return a=e,this},this.yoyo=function(e){return u=e,this},this.easing=function(e){return p=e,this},this.interpolation=function(e){return d=e,this},this.chain=function(){return h=arguments,this},this.onStart=function(e){return g=e,this},this.onUpdate=function(e){return m=e,this},this.onComplete=function(e){return y=e,this},this.update=function(e){var s;if(f>e)return!0;v===!1&&(null!==g&&g.call(t),v=!0);var b=(e-f)/o;b=b>1?1:b;var w=p(b);for(s in r){var x=n[s]||0,T=r[s];T instanceof Array?t[s]=d(T,w):("string"==typeof T&&(T=x+parseFloat(T,10)),"number"==typeof T&&(t[s]=x+(T-x)*w))}if(null!==m&&m.call(t,w),1==b){if(a>0){isFinite(a)&&a--;for(s in i){if("string"==typeof r[s]&&(i[s]=i[s]+parseFloat(r[s],10)),u){var C=i[s];i[s]=r[s],r[s]=C,c=!c}n[s]=i[s]}return f=e+l,!0}null!==y&&y.call(t);for(var E=0,N=h.length;N>E;E++)h[E].start(e);return!1}return!0}},TWEEN.Easing={Linear:{None:function(e){return e}},Quadratic:{In:function(e){return e*e},Out:function(e){return e*(2-e)},InOut:function(e){return(e*=2)<1?.5*e*e:-.5*(--e*(e-2)-1)}},Cubic:{In:function(e){return e*e*e},Out:function(e){return--e*e*e+1},InOut:function(e){return(e*=2)<1?.5*e*e*e:.5*((e-=2)*e*e+2)}},Quartic:{In:function(e){return e*e*e*e},Out:function(e){return 1- --e*e*e*e},InOut:function(e){return(e*=2)<1?.5*e*e*e*e:-.5*((e-=2)*e*e*e-2)}},Quintic:{In:function(e){return e*e*e*e*e},Out:function(e){return--e*e*e*e*e+1},InOut:function(e){return(e*=2)<1?.5*e*e*e*e*e:.5*((e-=2)*e*e*e*e+2)}},Sinusoidal:{In:function(e){return 1-Math.cos(e*Math.PI/2)},Out:function(e){return Math.sin(e*Math.PI/2)},InOut:function(e){return.5*(1-Math.cos(Math.PI*e))}},Exponential:{In:function(e){return 0===e?0:Math.pow(1024,e-1)},Out:function(e){return 1===e?1:1-Math.pow(2,-10*e)},InOut:function(e){return 0===e?0:1===e?1:(e*=2)<1?.5*Math.pow(1024,e-1):.5*(-Math.pow(2,-10*(e-1))+2)}},Circular:{In:function(e){return 1-Math.sqrt(1-e*e)},Out:function(e){return Math.sqrt(1- --e*e)},InOut:function(e){return(e*=2)<1?-.5*(Math.sqrt(1-e*e)-1):.5*(Math.sqrt(1-(e-=2)*e)+1)}},Elastic:{In:function(e){var t,n=.1,r=.4;return 0===e?0:1===e?1:(!n||1>n?(n=1,t=r/4):t=r*Math.asin(1/n)/(2*Math.PI),-(n*Math.pow(2,10*(e-=1))*Math.sin(2*(e-t)*Math.PI/r)))},Out:function(e){var t,n=.1,r=.4;return 0===e?0:1===e?1:(!n||1>n?(n=1,t=r/4):t=r*Math.asin(1/n)/(2*Math.PI),n*Math.pow(2,-10*e)*Math.sin(2*(e-t)*Math.PI/r)+1)},InOut:function(e){var t,n=.1,r=.4;return 0===e?0:1===e?1:(!n||1>n?(n=1,t=r/4):t=r*Math.asin(1/n)/(2*Math.PI),(e*=2)<1?-.5*n*Math.pow(2,10*(e-=1))*Math.sin(2*(e-t)*Math.PI/r):n*Math.pow(2,-10*(e-=1))*Math.sin(2*(e-t)*Math.PI/r)*.5+1)}},Back:{In:function(e){var t=1.70158;return e*e*((t+1)*e-t)},Out:function(e){var t=1.70158;return--e*e*((t+1)*e+t)+1},InOut:function(e){var t=2.5949095;return(e*=2)<1?.5*e*e*((t+1)*e-t):.5*((e-=2)*e*((t+1)*e+t)+2)}},Bounce:{In:function(e){return 1-TWEEN.Easing.Bounce.Out(1-e)},Out:function(e){return 1/2.75>e?7.5625*e*e:2/2.75>e?7.5625*(e-=1.5/2.75)*e+.75:2.5/2.75>e?7.5625*(e-=2.25/2.75)*e+.9375:7.5625*(e-=2.625/2.75)*e+.984375},InOut:function(e){return.5>e?.5*TWEEN.Easing.Bounce.In(2*e):.5*TWEEN.Easing.Bounce.Out(2*e-1)+.5}}},TWEEN.Interpolation={Linear:function(e,t){var n=e.length-1,r=n*t,i=Math.floor(r),o=TWEEN.Interpolation.Utils.Linear;return 0>t?o(e[0],e[1],r):t>1?o(e[n],e[n-1],n-r):o(e[i],e[i+1>n?n:i+1],r-i)},Bezier:function(e,t){var n,r=0,i=e.length-1,o=Math.pow,a=TWEEN.Interpolation.Utils.Bernstein;for(n=0;i>=n;n++)r+=o(1-t,i-n)*o(t,n)*e[n]*a(i,n);return r},CatmullRom:function(e,t){var n=e.length-1,r=n*t,i=Math.floor(r),o=TWEEN.Interpolation.Utils.CatmullRom;return e[0]===e[n]?(0>t&&(i=Math.floor(r=n*(1+t))),o(e[(i-1+n)%n],e[i],e[(i+1)%n],e[(i+2)%n],r-i)):0>t?e[0]-(o(e[0],e[0],e[1],e[1],-r)-e[0]):t>1?e[n]-(o(e[n],e[n],e[n-1],e[n-1],r-n)-e[n]):o(e[i?i-1:0],e[i],e[i+1>n?n:i+1],e[i+2>n?n:i+2],r-i)},Utils:{Linear:function(e,t,n){return(t-e)*n+e},Bernstein:function(e,t){var n=TWEEN.Interpolation.Utils.Factorial;return n(e)/n(t)/n(e-t)},Factorial:function(){var e=[1];return function(t){var n,r=1;if(e[t])return e[t];for(n=t;n>1;n--)r*=n;return e[t]=r}}(),CatmullRom:function(e,t,n,r,i){var o=.5*(n-e),a=.5*(r-t),u=i*i,s=i*u;return(2*t-2*n+o+a)*s+(-3*t+3*n-2*o-a)*u+o*i+t}}};
        //# sourceMappingURL=preload.js.map]]></script>
        <script type="text/javascript"><![CDATA[(function () {/**
         * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
         * Available via the MIT or new BSD license.
         * see: http://github.com/jrburke/almond for details
         */
        //Going sloppy to avoid 'use strict' string cost, but strict practices should
        //be followed.
        /*jslint sloppy: true */
        /*global setTimeout: false */
        
        var requirejs, require, define;
        (function (undef) {
            var main, req, makeMap, handlers,
                defined = {},
                waiting = {},
                config = {},
                defining = {},
                hasOwn = Object.prototype.hasOwnProperty,
                aps = [].slice,
                jsSuffixRegExp = /\.js$/;
        
            function hasProp(obj, prop) {
                return hasOwn.call(obj, prop);
            }
        
            /**
             * Given a relative module name, like ./something, normalize it to
             * a real name that can be mapped to a path.
             * @param {String} name the relative name
             * @param {String} baseName a real name that the name arg is relative
             * to.
             * @returns {String} normalized name
             */
            function normalize(name, baseName) {
                var nameParts, nameSegment, mapValue, foundMap, lastIndex,
                    foundI, foundStarMap, starI, i, j, part,
                    baseParts = baseName && baseName.split("/"),
                    map = config.map,
                    starMap = (map && map['*']) || {};
        
                //Adjust any relative paths.
                if (name && name.charAt(0) === ".") {
                    //If have a base name, try to normalize against it,
                    //otherwise, assume it is a top-level require that will
                    //be relative to baseUrl in the end.
                    if (baseName) {
                        //Convert baseName to array, and lop off the last part,
                        //so that . matches that "directory" and not name of the baseName's
                        //module. For instance, baseName of "one/two/three", maps to
                        //"one/two/three.js", but we want the directory, "one/two" for
                        //this normalization.
                        baseParts = baseParts.slice(0, baseParts.length - 1);
                        name = name.split('/');
                        lastIndex = name.length - 1;
        
                        // Node .js allowance:
                        if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                            name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                        }
        
                        name = baseParts.concat(name);
        
                        //start trimDots
                        for (i = 0; i < name.length; i += 1) {
                            part = name[i];
                            if (part === ".") {
                                name.splice(i, 1);
                                i -= 1;
                            } else if (part === "..") {
                                if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                                    //End of the line. Keep at least one non-dot
                                    //path segment at the front so it can be mapped
                                    //correctly to disk. Otherwise, there is likely
                                    //no path mapping for a path starting with '..'.
                                    //This can still fail, but catches the most reasonable
                                    //uses of ..
                                    break;
                                } else if (i > 0) {
                                    name.splice(i - 1, 2);
                                    i -= 2;
                                }
                            }
                        }
                        //end trimDots
        
                        name = name.join("/");
                    } else if (name.indexOf('./') === 0) {
                        // No baseName, so this is ID is resolved relative
                        // to baseUrl, pull off the leading dot.
                        name = name.substring(2);
                    }
                }
        
                //Apply map config if available.
                if ((baseParts || starMap) && map) {
                    nameParts = name.split('/');
        
                    for (i = nameParts.length; i > 0; i -= 1) {
                        nameSegment = nameParts.slice(0, i).join("/");
        
                        if (baseParts) {
                            //Find the longest baseName segment match in the config.
                            //So, do joins on the biggest to smallest lengths of baseParts.
                            for (j = baseParts.length; j > 0; j -= 1) {
                                mapValue = map[baseParts.slice(0, j).join('/')];
        
                                //baseName segment has  config, find if it has one for
                                //this name.
                                if (mapValue) {
                                    mapValue = mapValue[nameSegment];
                                    if (mapValue) {
                                        //Match, update name to the new value.
                                        foundMap = mapValue;
                                        foundI = i;
                                        break;
                                    }
                                }
                            }
                        }
        
                        if (foundMap) {
                            break;
                        }
        
                        //Check for a star map match, but just hold on to it,
                        //if there is a shorter segment match later in a matching
                        //config, then favor over this star map.
                        if (!foundStarMap && starMap && starMap[nameSegment]) {
                            foundStarMap = starMap[nameSegment];
                            starI = i;
                        }
                    }
        
                    if (!foundMap && foundStarMap) {
                        foundMap = foundStarMap;
                        foundI = starI;
                    }
        
                    if (foundMap) {
                        nameParts.splice(0, foundI, foundMap);
                        name = nameParts.join('/');
                    }
                }
        
                return name;
            }
        
            function makeRequire(relName, forceSync) {
                return function () {
                    //A version of a require function that passes a moduleName
                    //value for items that may need to
                    //look up paths relative to the moduleName
                    return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
                };
            }
        
            function makeNormalize(relName) {
                return function (name) {
                    return normalize(name, relName);
                };
            }
        
            function makeLoad(depName) {
                return function (value) {
                    defined[depName] = value;
                };
            }
        
            function callDep(name) {
                if (hasProp(waiting, name)) {
                    var args = waiting[name];
                    delete waiting[name];
                    defining[name] = true;
                    main.apply(undef, args);
                }
        
                if (!hasProp(defined, name) && !hasProp(defining, name)) {
                    throw new Error('No ' + name);
                }
                return defined[name];
            }
        
            //Turns a plugin!resource to [plugin, resource]
            //with the plugin being undefined if the name
            //did not have a plugin prefix.
            function splitPrefix(name) {
                var prefix,
                    index = name ? name.indexOf('!') : -1;
                if (index > -1) {
                    prefix = name.substring(0, index);
                    name = name.substring(index + 1, name.length);
                }
                return [prefix, name];
            }
        
            /**
             * Makes a name map, normalizing the name, and using a plugin
             * for normalization if necessary. Grabs a ref to plugin
             * too, as an optimization.
             */
            makeMap = function (name, relName) {
                var plugin,
                    parts = splitPrefix(name),
                    prefix = parts[0];
        
                name = parts[1];
        
                if (prefix) {
                    prefix = normalize(prefix, relName);
                    plugin = callDep(prefix);
                }
        
                //Normalize according
                if (prefix) {
                    if (plugin && plugin.normalize) {
                        name = plugin.normalize(name, makeNormalize(relName));
                    } else {
                        name = normalize(name, relName);
                    }
                } else {
                    name = normalize(name, relName);
                    parts = splitPrefix(name);
                    prefix = parts[0];
                    name = parts[1];
                    if (prefix) {
                        plugin = callDep(prefix);
                    }
                }
        
                //Using ridiculous property names for space reasons
                return {
                    f: prefix ? prefix + '!' + name : name, //fullName
                    n: name,
                    pr: prefix,
                    p: plugin
                };
            };
        
            function makeConfig(name) {
                return function () {
                    return (config && config.config && config.config[name]) || {};
                };
            }
        
            handlers = {
                require: function (name) {
                    return makeRequire(name);
                },
                exports: function (name) {
                    var e = defined[name];
                    if (typeof e !== 'undefined') {
                        return e;
                    } else {
                        return (defined[name] = {});
                    }
                },
                module: function (name) {
                    return {
                        id: name,
                        uri: '',
                        exports: defined[name],
                        config: makeConfig(name)
                    };
                }
            };
        
            main = function (name, deps, callback, relName) {
                var cjsModule, depName, ret, map, i,
                    args = [],
                    callbackType = typeof callback,
                    usingExports;
        
                //Use name if no relName
                relName = relName || name;
        
                //Call the callback to define the module, if necessary.
                if (callbackType === 'undefined' || callbackType === 'function') {
                    //Pull out the defined dependencies and pass the ordered
                    //values to the callback.
                    //Default to [require, exports, module] if no deps
                    deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
                    for (i = 0; i < deps.length; i += 1) {
                        map = makeMap(deps[i], relName);
                        depName = map.f;
        
                        //Fast path CommonJS standard dependencies.
                        if (depName === "require") {
                            args[i] = handlers.require(name);
                        } else if (depName === "exports") {
                            //CommonJS module spec 1.1
                            args[i] = handlers.exports(name);
                            usingExports = true;
                        } else if (depName === "module") {
                            //CommonJS module spec 1.1
                            cjsModule = args[i] = handlers.module(name);
                        } else if (hasProp(defined, depName) ||
                                   hasProp(waiting, depName) ||
                                   hasProp(defining, depName)) {
                            args[i] = callDep(depName);
                        } else if (map.p) {
                            map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                            args[i] = defined[depName];
                        } else {
                            throw new Error(name + ' missing ' + depName);
                        }
                    }
        
                    ret = callback ? callback.apply(defined[name], args) : undefined;
        
                    if (name) {
                        //If setting exports via "module" is in play,
                        //favor that over return value and exports. After that,
                        //favor a non-undefined return value over exports use.
                        if (cjsModule && cjsModule.exports !== undef &&
                                cjsModule.exports !== defined[name]) {
                            defined[name] = cjsModule.exports;
                        } else if (ret !== undef || !usingExports) {
                            //Use the return value from the function.
                            defined[name] = ret;
                        }
                    }
                } else if (name) {
                    //May just be an object definition for the module. Only
                    //worry about defining if have a module name.
                    defined[name] = callback;
                }
            };
        
            requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
                if (typeof deps === "string") {
                    if (handlers[deps]) {
                        //callback in this case is really relName
                        return handlers[deps](callback);
                    }
                    //Just return the module wanted. In this scenario, the
                    //deps arg is the module name, and second arg (if passed)
                    //is just the relName.
                    //Normalize module name, if it contains . or ..
                    return callDep(makeMap(deps, callback).f);
                } else if (!deps.splice) {
                    //deps is a config object, not an array.
                    config = deps;
                    if (config.deps) {
                        req(config.deps, config.callback);
                    }
                    if (!callback) {
                        return;
                    }
        
                    if (callback.splice) {
                        //callback is an array, which means it is a dependency list.
                        //Adjust args if there are dependencies
                        deps = callback;
                        callback = relName;
                        relName = null;
                    } else {
                        deps = undef;
                    }
                }
        
                //Support require(['a'])
                callback = callback || function () {};
        
                //If relName is a function, it is an errback handler,
                //so remove it.
                if (typeof relName === 'function') {
                    relName = forceSync;
                    forceSync = alt;
                }
        
                //Simulate async callback;
                if (forceSync) {
                    main(undef, deps, callback, relName);
                } else {
                    //Using a non-zero value because of concern for what old browsers
                    //do, and latest browsers "upgrade" to 4 if lower value is used:
                    //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
                    //If want a value immediately, use require('id') instead -- something
                    //that works in almond on the global level, but not guaranteed and
                    //unlikely to work in other AMD implementations.
                    setTimeout(function () {
                        main(undef, deps, callback, relName);
                    }, 4);
                }
        
                return req;
            };
        
            /**
             * Just drops the config on the floor, but returns req in case
             * the config return value is used.
             */
            req.config = function (cfg) {
                return req(cfg);
            };
        
            /**
             * Expose module registry for debugging and tooling
             */
            requirejs._defined = defined;
        
            define = function (name, deps, callback) {
        
                //This module may not have dependencies
                if (!deps.splice) {
                    //deps is not an array, so probably means
                    //an object literal or factory function for
                    //the value. Adjust args.
                    callback = deps;
                    deps = [];
                }
        
                if (!hasProp(defined, name) && !hasProp(waiting, name)) {
                    waiting[name] = [name, deps, callback];
                }
            };
        
            define.amd = {
                jQuery: true
            };
        }());
        
        define("almond", function(){});
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        define( 'AXON/axon',['require'],function( require ) {
          
        
          var axon = {};
        
          // will be filled in by other modules
          return axon;
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /*
         * Usage:
         * var assert = require( '<assert>' )( 'flagName' );
         *
         * assert && assert( <simple value or big computation>, "<message here>" );
         *
         * TODO: decide on usages and viability, and if so document further
         *
         * NOTE: for changing build, add has.js tests for 'assert.' + flagName
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'ASSERT/assert',[],function() {
          
        
          // CAUTION: if using the AST modifier for assertions, do not separate this out into its own 'assert' variable
          return function assert( name, excludeByDefault ) {
            var hasName = 'assert.' + name;
        
            var flagDefined = window.has && window.has( hasName ) !== undefined;
            var skipAssert = flagDefined ? !window.has( hasName ) : excludeByDefault;
        
            if ( skipAssert ) {
              return null;
            }
            else {
              return function( predicate, message ) {
                var result = typeof predicate === 'function' ? predicate() : predicate;
        
                if ( !result ) {
        
                  //Log the stack trace to IE.  Just creating an Error is not enough, it has to be caught to get a stack.
                  //TODO: What will this do for IE9?  Probably just print stack = undefined.
                  if ( window.navigator && window.navigator.appName === 'Microsoft Internet Explorer' ) {
                    try { throw new Error(); }
                    catch( e ) { message = message + ", stack=\n" + e.stack; }
                  }
        
                  // TODO: custom error?
                  throw new Error( 'Assertion failed: ' + message );
                }
              };
            }
          };
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        define( 'PHET_CORE/core',['require','ASSERT/assert','ASSERT/assert'],function( require ) {
          
        
          window.assert = window.assert || require( 'ASSERT/assert' )( 'basic' );
          window.assertSlow = window.assertSlow || require( 'ASSERT/assert' )( 'slow', true );
        
          // no phetAllocation initialized, since we don't need it with just phet-core, and this file is required before that
        
          // will be filled in by other modules
          return {};
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Like Underscore's _.extend, but with hardcoded support for ES5 getters/setters.
         *
         * See https://github.com/documentcloud/underscore/pull/986.
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'PHET_CORE/extend',['require','PHET_CORE/core'],function( require ) {
          
        
          var core = require( 'PHET_CORE/core' );
        
          core.extend = function extend( obj ) {
            _.each( Array.prototype.slice.call( arguments, 1 ), function( source ) {
              if ( source ) {
                for ( var prop in source ) {
                  Object.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );
                }
              }
            } );
            return obj;
          };
        
          return core.extend;
        } );
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Utility function for setting up prototypal inheritance.
         * Maintains supertype.prototype.constructor while properly copying ES5 getters and setters.
         * Supports adding functions to both the prototype itself and the constructor function.
         *
         * Usage:
         *
         * // Call the supertype constructor somewhere in the subtype's constructor.
         * function A() { scenery.Node.call( this ); };
         *
         * // Add prototype functions and/or 'static' functions
         * return inherit( scenery.Node, A, {
         *   customBehavior: function() { ... },
         *   isAnA: true
         * }, {
         *   someStaticFunction: function() { ...}
         * } );
         *
         * // client calls
         * new A().isAnA; // true
         * new scenery.Node().isAnA; // undefined
         * new A().constructor.name; // 'A'
         * A.someStaticFunction();
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        define( 'PHET_CORE/inherit',['require','PHET_CORE/core','PHET_CORE/extend'],function( require ) {
          
        
          var core = require( 'PHET_CORE/core' );
          var extend = require( 'PHET_CORE/extend' );
        
          /**
           * @param supertype           Constructor for the supertype.
           * @param subtype             Constructor for the subtype. Generally should contain supertype.call( this, ... )
           * @param prototypeProperties [optional] object containing properties that will be set on the prototype.
           * @param staticProperties [optional] object containing properties that will be set on the constructor function itself
           */
          core.inherit = function inherit( supertype, subtype, prototypeProperties, staticProperties ) {
            assert && assert( typeof supertype === 'function' );
        
            function F() {}
        
            F.prototype = supertype.prototype; // so new F().__proto__ === supertype.prototype
        
            subtype.prototype = extend( // extend will combine the properties and constructor into the new F copy
              new F(),                  // so new F().__proto__ === supertype.prototype, and the prototype chain is set up nicely
              { constructor: subtype }, // overrides the constructor properly
              prototypeProperties       // [optional] additional properties for the prototype, as an object.
            );
        
            //Copy the static properties onto the subtype constructor so they can be accessed 'statically'
            extend( subtype, staticProperties );
        
            return subtype; // pass back the subtype so it can be returned immediately as a module export
          };
        
          return core.inherit;
        } );
        //  Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * A Multilink is an instance that can be used to link to multiple properties.  It is very similar to a DerivedProperty, but has no value and does not conform to the Property API,
         * because it is intended for use with callbacks that do not compute a value.  Multilink should not be created through calling its constructor directly,
         * but through the Property.multilink and Property.lazyMultilink functions.
         *
         * @author Sam Reid
         */
        define( 'AXON/Multilink',['require','AXON/axon','PHET_CORE/inherit'],function( require ) {
          
        
          var axon = require( 'AXON/axon' );
          var inherit = require( 'PHET_CORE/inherit' );
        
          /**
           * @param {Array<Property>} dependencies
           * @param {Function} callback function that expects args in the same order as dependencies
           * @param {Boolean} lazy Optional parameter that can be set to true if this should be a lazy multilink (no immediate callback)
           * @constructor
           */
          axon.Multilink = function Multilink( dependencies, callback, lazy ) {
            this.dependencies = dependencies;
        
            //Keep track of each dependency and only update the changed value, for speed
            this.dependencyValues = dependencies.map( function( property ) {return property.get();} );
        
            var multilink = this;
        
            //Keep track of listeners so they can be detached
            this.dependencyListeners = [];
        
            //When a dependency value changes, update the list of dependencies and call back to the callback
            for ( var i = 0; i < dependencies.length; i++ ) {
              var dependency = dependencies[i];
              (function( dependency, i ) {
                var listener = function( newValue ) {
                  multilink.dependencyValues[i] = newValue;
                  callback.apply( null, multilink.dependencyValues );
                };
                multilink.dependencyListeners.push( listener );
                dependency.lazyLink( listener );
              })( dependency, i );
            }
        
            //Send initial call back but only if we are non-lazy
            if ( !lazy ) {
              callback.apply( null, this.dependencyValues );
            }
          };
        
          return inherit( Object, axon.Multilink, {
        
              /**
               * Detaches this derived property from its dependencies.
               */
              detach: function() {
                for ( var i = 0; i < this.dependencies.length; i++ ) {
                  var dependency = this.dependencies[i];
                  dependency.unlink( this.dependencyListeners[i] );
                }
              }
            }
          );
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * An observable property, notifies registered observers when the value changes.
         *
         * Uses the 'Constructor' pattern for object creation, which has the downside that
         * all properties are created once for each instance. It would be nice if our functions
         * were shared. But since the only way to create private fields is in the constructor,
         * and the functions need access to those private fields, there doesn't seem to be
         * any choice but to define the functions in the constructor.
         *
         * @author Sam Reid
         * @author Chris Malley (PixelZoom, Inc.)
         */
        define( 'AXON/Property',['require','AXON/axon','AXON/Multilink'],function( require ) {
          
        
          var axon = require( 'AXON/axon' );
          require( 'AXON/Multilink' );
        
          /**
           * @param {*} value
           * @constructor
           */
          axon.Property = function Property( value ) {
        
            //Store the internal value and the initial value
            this.storeValue( value );        // typically sets this._value
            this.storeInitialValue( value ); // typically sets this._initialValue
            this._observers = [];
          };
        
          axon.Property.prototype = {
        
            /**
             * Gets the value.  You can also use the es5 getter (property.value) but this means is provided for inner loops or internal code that must be fast.
             * @return {*}
             */
            get: function() {
              return this._value;
            },
        
            /**
             * Sets the value and notifies registered observers.  You can also use the es5 getter (property.value) but this means is provided for inner loops or internal code that must be fast.
             * If the value hasn't changed, this is a no-op.
             *
             * @param {*} value
             */
            set: function( value ) {
              if ( !this.equalsValue( value ) ) {
                this._setAndNotifyObservers( value );
              }
              return this;
            },
        
            // whether this property will not "change" when the passed-in value is set
            equalsValue: function( value ) {
              return value === this._value;
            },
        
            // store the current (new) value
            storeValue: function( value ) {
              this._value = value;
            },
        
            // store the initial value
            storeInitialValue: function( value ) {
              this._initialValue = value;
            },
        
            get initialValue() {
              return this._initialValue;
            },
        
            _setAndNotifyObservers: function( value ) {
              var oldValue = this.get();
              this.storeValue( value );
              this._notifyObservers( oldValue );
            },
        
            _notifyObservers: function( oldValue ) {
              var value = this.get();
              // TODO: JO: avoid slice() by storing observers array correctly
              var observersCopy = this._observers.slice(); // make a copy, in case notification results in removeObserver
              for ( var i = 0; i < observersCopy.length; i++ ) {
                observersCopy[i]( value, oldValue );
              }
            },
        
            //Use this method when mutating a value (not replacing with a new instance) and you want to send notifications about the change.
            //This is different from the normal axon strategy, but may be necessary to prevent memory allocations.
            //This method is unsafe for removing observers because it assumes the observer list not modified, to save another allocation
            //Only provides the new reference as a callback (no oldvalue)
            //See https://github.com/phetsims/axon/issues/6
            notifyObserversStatic: function() {
              var value = this.get();
              for ( var i = 0; i < this._observers.length; i++ ) {
                this._observers[i]( value );
              }
            },
        
            /**
             * Resets the value to the initial value.
             */
            reset: function() {
              this.set( this._initialValue );
            },
        
            /**
             * This function returns a bound function that sets the specified value.  For use in creating closures e.g. with gui classes.
             * For instance, to have a button that sets a property to true, instead of using
             * button.click(function(){property.set(true);});
             * you could use
             * button.click(property._set(true));
             * @param value the value to use when the setter is called.
             * @return a function that can be used to set the specified value.
             */
            _set: function( value ) {
              return this.set.bind( this, value );
            },
        
            get value() { return this.get(); },
        
            set value( newValue ) { this.set( newValue ); },
        
            /**
             * Adds an observer and notifies it immediately.
             * If observer is already registered, this is a no-op.
             * The initial notification provides the current value for newValue and null for oldValue.
             *
             * @param {Function} observer a function of the form observer(newValue,oldValue)
             */
            link: function( observer ) {
              if ( this._observers.indexOf( observer ) === -1 ) {
                this._observers.push( observer );
                observer( this.get(), null ); // null should be used when an object is expected but unavailable
              }
            },
        
            /**
             * Removes an observer.
             * If observer is not registered, this is a no-op.
             *
             * @param {Function} observer
             */
            unlink: function( observer ) {
              var index = this._observers.indexOf( observer );
              if ( index !== -1 ) {
                this._observers.splice( index, 1 );
              }
            },
        
            /**
             * Add an observer to the Property, without calling it back right away.  This is used when you need to register a listener without an immediate callback.
             * @param {Function} observer  a function with a single argument, which is the value of the property at the time the function is called.
             */
            lazyLink: function( observer ) {
              if ( this._observers.indexOf( observer ) === -1 ) {
                this._observers.push( observer );
              }
            },
        
            //Provide toString for console debugging, see http://stackoverflow.com/questions/2485632/valueof-vs-tostring-in-javascript
            toString: function() {return 'Property{' + this.get() + '}'; },
            valueOf: function() {return this.toString();},
        
            /**
             * Add a listener so that it will only fire once (and not on registration)
             *
             * I can see two ways to implement this:
             * (a) add a field to the observer so after notifications it can be checked and possibly removed. Disadvantage: will make everything slower even if not using 'once'
             * (b) wrap the observer in a new function which will call the observer and then remove itself.  Disadvantage: cannot remove an observer added using 'once'
             * To avoid possible performance problems, use a wrapper function, and return it as a handle in case the 'once' listener must be removed before it is called once
             *
             * @param observer the listener which should be called back only for one property change (and not on registration)
             * @returns {Function} the wrapper handle in case the wrapped function needs to be removed with 'unlink' before it is called once
             */
            once: function( observer ) {
              var property = this;
              var wrapper = function( newValue, oldValue ) {
                property.unlink( wrapper );
                observer( newValue, oldValue );
              };
              this.lazyLink( wrapper );
              return wrapper;
            },
        
            /**
             * Links an object's named attribute to this property.  Returns a handle so it can be removed using Property.unlink();
             * Example: modelVisibleProperty.linkAttribute(view,'visible');
             *
             * @param object
             * @param attributeName
             */
            linkAttribute: function( object, attributeName ) {
              var handle = function( value ) {object[attributeName] = value;};
              this.link( handle );
              return handle;
            },
        
            /**
             * Returns a new DerivedProperty which is true/false based on whether the value matches (based on ===) the passed in argument.
             * @param value
             * @returns {axon.DerivedProperty}
             */
            valueEquals: function( value ) {
              return new axon.DerivedProperty( [this], function( propertyValue ) { return propertyValue === value; } );
            },
        
            /**
             * Returns a new boolean DerivedProperty which is true/false based on && operator.
             * @param otherProperty
             * @returns {DerivedProperty<boolean>}
             */
            and: function( otherProperty ) {
              return new axon.DerivedProperty( [this, otherProperty], function( thisValue, otherValue ) { return thisValue && otherValue; } );
            },
        
            /**
             * Returns a new boolean DerivedProperty which is true/false based on || operator.
             * @param otherProperty
             * @returns {DerivedProperty<boolean>}
             */
            or: function( otherProperty ) {
              return new axon.DerivedProperty( [this, otherProperty], function( thisValue, otherValue ) { return thisValue || otherValue; } );
            },
        
            /**
             * Multiply this property's value by a constant scalar number, and return the derived property.
             *
             * @param scalar
             * @returns {axon.DerivedProperty}
             */
            times: function( scalar ) {
              return new axon.DerivedProperty( [this], function( thisValue ) { return thisValue * scalar; } );
            },
        
            /**
             * Not property, which does not propagate changes to dependents.
             * @returns {DerivedProperty}
             */
            derivedNot: function() {
              return new axon.DerivedProperty( [this], function( thisValue ) { return !thisValue; } );
            },
        
            /**
             * Two way communication for not, so you can set the value and have it come back to the parent
             * Note that noting about the following code is specific to booleans, although this should probably be used mostly for booleans.
             * To unlink both listeners attached unlink a property created with not(), use detach()
             */
            not: function() {
              var parentProperty = this;
              var childProperty = new axon.Property( !this.value );
        
              var setParentToChild = function( value ) {childProperty.set( !value );};
              parentProperty.link( setParentToChild );
        
              var setChildToParent = function( value ) {parentProperty.set( !value );};
              childProperty.link( setChildToParent );
        
              childProperty.detach = function() {
                parentProperty.unlink( setParentToChild );
                childProperty.unlink( setChildToParent );
              };
              return childProperty;
            },
        
            /**
             * Convenience function for debugging a property values.  It prints the new value on registration and when changed.
             * @param name debug name to be printed on the console
             * @returns {Function} the handle to the linked listener in case it needs to be removed later
             */
            debug: function( name ) {
              var listener = function( value ) { console.log( name, value ); };
              this.link( listener );
              return listener;
            },
        
            //Returns a new Property that maps its values using the specified lookup table.
            //If the parent property value does not appear as a key in the lookup table, the returned property value is undefined
            mapValues: function( values ) {
              return new axon.DerivedProperty( [this], function( thisValue ) { return values[thisValue];} );
            },
        
            //Returns a new Property that maps its values using the specified function
            //See https://github.com/phetsims/axon/issues/25
            map: function( f ) {
              return new axon.DerivedProperty( [this], function( thisValue ) {return f( thisValue );} );
            },
        
            /**
             * Returns a function that can be used to toggle the property (using !)
             * @returns {f}
             */
            get toggleFunction() {
              return this.toggle.bind( this );
            },
        
            /**
             * Modifies the value of this Property with the ! operator.  Works for booleans and non-booleans.
             */
            toggle: function() {
              this.value = !this.value;
            },
        
            /**
             * Adds a listener that is fired when the property takes the specified value.  If the property has the value already, the listener is called back
             * immediately.  A reference to the listener is returned so that it can be removed.
             *
             * @param value the value to match
             * @param the listener that is called when this Property
             */
            onValue: function( value, listener ) {
              var observer = function( v ) {
                if ( v === value ) {
                  listener();
                }
              };
              this.link( observer );
              return observer;
            }
          };
        
          /**
           * Registers an observer with multiple properties, then notifies the observer immediately.
           * @param {Array<Property>} properties
           * @param {function} observer no params, returns nothing
           * @static
           */
          axon.Property.multilink = function( properties, observer ) {
            return new axon.Multilink( properties, observer, false );
          };
        
          axon.Property.lazyMultilink = function( properties, observer ) {
            return new axon.Multilink( properties, observer, true );
          };
        
          return axon.Property;
        } );
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * A DerivedProperty is computed based on other properties.  This implementation inherits from Property to (a) simplify implementation and (b) ensure it remains consistent.
         * Note that the setters should not be called directly, so the setters (set, reset and es5 setter) throw an error if used directly.
         *
         * @author Sam Reid
         */
        
        define( 'AXON/DerivedProperty',['require','AXON/Property','AXON/axon','PHET_CORE/inherit'],function( require ) {
          
        
          var Property = require( 'AXON/Property' );
          var axon = require( 'AXON/axon' );
          var inherit = require( 'PHET_CORE/inherit' );
        
          /**
           * @param {Array<Property>} dependencies
           * @param {Function} derivation function that expects args in the same order as dependencies
           * @constructor
           */
          axon.DerivedProperty = function DerivedProperty( dependencies, derivation ) {
            this.dependencies = dependencies;
        
            //Keep track of each dependency and only update the changed value, for speed
            this.dependencyValues = dependencies.map( function( property ) {return property.get();} );
        
            var initialValue = derivation.apply( null, this.dependencyValues );
            Property.call( this, initialValue );
        
            var derivedProperty = this;
        
            //Keep track of listeners so they can be detached
            this.dependencyListeners = [];
        
            for ( var i = 0; i < dependencies.length; i++ ) {
              var dependency = dependencies[i];
              (function( dependency, i ) {
                var listener = function( newValue ) {
                  derivedProperty.dependencyValues[i] = newValue;
                  Property.prototype.set.call( derivedProperty, derivation.apply( null, derivedProperty.dependencyValues ) );
                };
                derivedProperty.dependencyListeners.push( listener );
                dependency.lazyLink( listener );
              })( dependency, i );
        
            }
          };
        
          return inherit( Property, axon.DerivedProperty, {
        
              /**
               * Detaches this derived property from its dependencies.
               */
              detach: function() {
                for ( var i = 0; i < this.dependencies.length; i++ ) {
                  var dependency = this.dependencies[i];
                  dependency.unlink( this.dependencyListeners[i] );
                }
              },
        
              //Override the mutators to provide an error message.  These should not be called directly, the value should only be modified when the dependencies change
              set: function( value ) { throw new Error( 'Cannot set values directly to a derived property, tried to set: ' + value ); },
        
              //Override the mutators to provide an error message.  These should not be called directly, the value should only be modified when the dependencies change
              //Keep the newValue output in the string so the argument won't be stripped by minifier (which would cause crashes like https://github.com/phetsims/axon/issues/15)
              set value( newValue ) { throw new Error( 'Cannot es5-set values directly to a derived property, tried to set: ' + newValue ); },
        
              //Override get value as well to satisfy the linter which wants get/set pairs (even though it just uses the same code as the superclass).
              get value() {return Property.prototype.get.call( this );},
        
              //Override the mutators to provide an error message.  These should not be called directly, the value should only be modified when the dependencies change
              reset: function() { throw new Error( 'Cannot reset a derived property directly' ); }
            },
        
            //statics
            {
              //Create a DerivedProperty using a static create method to avoid the linting error: W031: Do not use 'new' for side effects.
              //This should be used only when using DerivedProperty to create side effects (and not to assign a property value)
              multilink: function( dependencies, derivation ) { return new axon.DerivedProperty( dependencies, derivation ); }}
          );
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Lightweight event & listener abstraction.
         * @author Sam Reid
         */
        define( 'AXON/Events',['require','AXON/axon'],function( require ) {
          
        
          var axon = require( 'AXON/axon' );
        
          /**
           * @class Events
           * @constructor
           */
          axon.Events = function Events() {
            this._eventListeners = {}; // @private
            this._staticEventListeners = {}; // @private
          };
        
          axon.Events.prototype = {
        
            /////////////////////////////////////////////
            // Below this point are the functions for event handling, basically orthogonal to property value change notifications
        
            /**
             * Register a listener when the specified eventName is triggered. Use off() to remove.
             * Concurrent modification of listeners (on/off) from within the callback is acceptable.
             * @param eventName {String} the name for the event channel
             * @param callback {Function}
             */
            on: function( eventName, callback ) {
              assert && assert( typeof eventName === 'string', 'eventName should be a string' );
              assert && assert( typeof callback === 'function', 'callback should be a function' );
        
              this._eventListeners[eventName] = this._eventListeners[eventName] || [];
              this._eventListeners[eventName].push( callback );
            },
        
            /**
             * Register a listener when the specified eventName is triggered. Listener should be "static", meaning:
             *   1. It shall not add/remove any "static" listeners (including itself) while it is being called (as any type of side-effect), and
             *   2. "static" listeners should not be added while a non-static listener (on the same object) is being called.
             * These restrictions allow us to guarantee that all listeners attached when an event is triggered are called.
             * Since static listeners are stored separately, use offStatic() to remove listeners added with onStatic()
             * @param eventName {String} the name for the event channel
             * @param callback {Function}
             */
            onStatic: function( eventName, callback ) {
              assert && assert( typeof eventName === 'string', 'eventName should be a string' );
              assert && assert( typeof callback === 'function', 'callback should be a function' );
        
              this._staticEventListeners[eventName] = this._staticEventListeners[eventName] || [];
              this._staticEventListeners[eventName].push( callback );
            },
        
            /**
             * Adds a function which will only be called back once, after which it is removed as a listener.
             * If you need to remove a function added with 'once' you will have to remove its handle, which is returned by the function.
             * @param eventName {String} the name for the event channel
             * @param callback function to be called back once (if at all)
             */
            once: function( eventName, callback ) {
              assert && assert( typeof eventName === 'string', 'eventName should be a string' );
              assert && assert( typeof callback === 'function', 'callback should be a function' );
        
              var events = this;
              var wrappedCallback = function() {
                events.off( eventName, wrappedCallback );
        
                //If no arguments being passed through, call back without processing arguments, for possible speed
                if ( arguments.length === 0 ) {
                  callback();
                }
                else {
        
                  //General case of passing events through to the wrapped callback function
                  callback.apply( this, Array.prototype.slice.call( arguments, 0 ) );
                }
              };
              this.on( eventName, wrappedCallback );
        
              //Return the handle in case it needs to be removed.
              return wrappedCallback;
            },
        
            /**
             * Remove a listener added with on() from the specified event type.  Does nothing if the listener did not exist.
             * @param eventName {String} the name for the event channel
             * @param callback {Function}
             */
            off: function( eventName, callback ) {
              assert && assert( typeof eventName === 'string', 'eventName should be a string' );
              assert && assert( typeof callback === 'function', 'callback should be a function' );
        
              var index = -1;
              if ( this._eventListeners[eventName] ) {
                index = this._eventListeners[eventName].indexOf( callback );
                if ( index !== -1 ) {
                  this._eventListeners[eventName].splice( index, 1 );
                }
              }
        
              return index; // so we can tell if we actually removed a listener
            },
        
            /**
             * Remove a listener added with onStatic() from the specified event type.  Does nothing if the listener did not exist.
             * @param eventName {String} the name for the event channel
             * @param callback {Function}
             */
            offStatic: function( eventName, callback ) {
              assert && assert( typeof eventName === 'string', 'eventName should be a string' );
              assert && assert( typeof callback === 'function', 'callback should be a function' );
        
              var index = -1;
              if ( this._staticEventListeners[eventName] ) {
                index = this._staticEventListeners[eventName].indexOf( callback );
                if ( index !== -1 ) {
                  this._staticEventListeners[eventName].splice( index, 1 );
                }
              }
        
              return index; // so we can tell if we actually removed a listener
            },
        
            /**
             * Checks for the existence of a specific listener, attached to a specific event name. Doesn't check for static listeners
             * @param eventName {String} the name for the event channel
             * @param callback {Function}
             * @returns {Boolean}
             */
            hasListener: function( eventName, callback ) {
              assert && assert( typeof eventName === 'string', 'eventName should be a string' );
              assert && assert( typeof callback === 'function', 'callback should be a function' );
        
              var array = this._eventListeners[eventName];
              return !!array && array.indexOf( callback ) >= 0;
            },
        
            /**
             * Checks for the existence of a specific static listener, attached to a specific event name. Doesn't check for non-static listeners
             * @param eventName {String} the name for the event channel
             * @param callback {Function}
             * @returns {Boolean}
             */
            hasStaticListener: function( eventName, callback ) {
              assert && assert( typeof eventName === 'string', 'eventName should be a string' );
              assert && assert( typeof callback === 'function', 'callback should be a function' );
        
              var array = this._staticEventListeners[eventName];
              return !!array && array.indexOf( callback ) >= 0;
            },
        
            /**
             * Trigger an event with the specified name and arguments.
             * @param eventName {String} the name for the event channel
             * @param args... optional arguments to pass to the listeners
             */
            trigger: function( eventName ) {
              assert && assert( typeof eventName === 'string', 'eventName should be a string' );
        
              var listeners = this._eventListeners[eventName];
              var staticListeners = this._staticEventListeners[eventName];
        
              // listener quantities for normal and static
              var count = listeners ? listeners.length : 0;
              var staticCount = staticListeners ? staticListeners.length : 0;
        
              // only compute our arguments suffix once, instead of in our inner loop
              var suffix;
              var hasNoArguments = arguments.length === 1;
              if ( !hasNoArguments && ( count > 0 || staticCount > 0 ) ) {
                phetAllocation && phetAllocation( 'Array' );
                suffix = Array.prototype.slice.call( arguments, 1 );
              }
        
              // make a copy of non-static listeners, in case callback removes listener
              if ( count > 0 ) {
                listeners = listeners.slice();
              }
        
              var i;
        
              for ( i = 0; i < count; i++ ) {
                var listener = listeners[i];
        
                //Simple case of no arguments, call it separately for improved performance in case it is faster (untested)
                if ( hasNoArguments ) {
                  listener( arguments );
                }
                else {
                  listener.apply( this, suffix );
                }
        
                assert && assert( !staticListeners || staticListeners.length === staticCount, 'Concurrent modifications of static listeners from within non-static listeners are forbidden' );
              }
        
              for ( i = 0; i < staticCount; i++ ) {
                var staticListener = staticListeners[i];
        
                //Simple case of no arguments, call it separately for improved performance in case it is faster (untested)
                if ( hasNoArguments ) {
                  staticListener( arguments );
                }
                else {
                  staticListener.apply( this, suffix );
                }
        
                assert && assert( staticListeners.length === staticCount, 'Concurrent modifications from static listeners are forbidden' );
              }
            },
        
            /**
             * Trigger an event with the specified name, with no arguments. Should get optimized in browsers better than trigger, so we have code duplication for now.
             * @param eventName {String} the name for the event channel
             */
            trigger0: function( eventName ) {
              assert && assert( typeof eventName === 'string', 'eventName should be a string' );
        
              var listeners = this._eventListeners[eventName];
              var staticListeners = this._staticEventListeners[eventName];
        
              // listener quantities for normal and static
              var count = listeners ? listeners.length : 0;
              var staticCount = staticListeners ? staticListeners.length : 0;
        
              // make a copy of non-static listeners, in case callback removes listener
              if ( count > 0 ) {
                listeners = listeners.slice();
              }
        
              var i;
        
              for ( i = 0; i < count; i++ ) {
                listeners[i]();
        
                assert && assert( !staticListeners || staticListeners.length === staticCount, 'Concurrent modifications of static listeners from within non-static listeners are forbidden' );
              }
        
              for ( i = 0; i < staticCount; i++ ) {
                staticListeners[i]();
        
                assert && assert( staticListeners.length === staticCount, 'Concurrent modifications from static listeners are forbidden' );
              }
            },
        
            /**
             * Trigger an event with the specified name, with a single argument. Should get optimized in browsers better than trigger, so we have code duplication for now.
             * @param eventName {String} the name for the event channel
             */
            trigger1: function( eventName, param1 ) {
              assert && assert( typeof eventName === 'string', 'eventName should be a string' );
        
              var listeners = this._eventListeners[eventName];
              var staticListeners = this._staticEventListeners[eventName];
        
              // listener quantities for normal and static
              var count = listeners ? listeners.length : 0;
              var staticCount = staticListeners ? staticListeners.length : 0;
        
              // make a copy of non-static listeners, in case callback removes listener
              if ( count > 0 ) {
                listeners = listeners.slice();
              }
        
              var i;
        
              for ( i = 0; i < count; i++ ) {
                listeners[i]( param1 );
        
                assert && assert( !staticListeners || staticListeners.length === staticCount, 'Concurrent modifications of static listeners from within non-static listeners are forbidden' );
              }
        
              for ( i = 0; i < staticCount; i++ ) {
                staticListeners[i]( param1 );
        
                assert && assert( staticListeners.length === staticCount, 'Concurrent modifications from static listeners are forbidden' );
              }
            },
        
            /**
             * Trigger an event with the specified name, with a two arguments. Should get optimized in browsers better than trigger, so we have code duplication for now.
             * @param eventName {String} the name for the event channel
             */
            trigger2: function( eventName, param1, param2 ) {
              assert && assert( typeof eventName === 'string', 'eventName should be a string' );
        
              var listeners = this._eventListeners[eventName];
              var staticListeners = this._staticEventListeners[eventName];
        
              // listener quantities for normal and static
              var count = listeners ? listeners.length : 0;
              var staticCount = staticListeners ? staticListeners.length : 0;
        
              // make a copy of non-static listeners, in case callback removes listener
              if ( count > 0 ) {
                listeners = listeners.slice();
              }
        
              var i;
        
              for ( i = 0; i < count; i++ ) {
                listeners[i]( param1, param2 );
        
                assert && assert( !staticListeners || staticListeners.length === staticCount, 'Concurrent modifications of static listeners from within non-static listeners are forbidden' );
              }
        
              for ( i = 0; i < staticCount; i++ ) {
                staticListeners[i]( param1, param2 );
        
                assert && assert( staticListeners.length === staticCount, 'Concurrent modifications from static listeners are forbidden' );
              }
            }
          };
        
          return axon.Events;
        } );
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * PropertySet facilitates creation and use of multiple named Property instances.  There are still several API design issues in question, but this
         * class is ready for use.
         *
         * A PropertySet is a set of Property instances that provides support for:
         * -Easily creating several properties using an object literal (hash)
         * -Resetting them as a group
         * -Set multiple values at once, using propertySet.set({x:100,y:200,name:'alice'});
         * -Support for derived properties, which appear with the same interface as basic properties
         * -Convenient toString that prints e.g., PropertySet{name:'larry',age:101,kids:['alice','bob']}
         * -Wiring up to listen to multiple properties simultaneously
         * -Add properties after the PropertySet is created?  Don't forget to add to the key list as well.
         * -Remove properties that were added using addProperty or the constructor
         *
         * Sample usage:
         * var p = new PropertySet( {name: 'larry', age: 100, kids: ['alice', 'bob']} );
         * p.nameProperty.link( function( n ) {console.log( 'hello ' + n );} );
         * p.name = 'jensen';
         * p.age = 101;//Happy Birthday!
         * console.log( p );
         * p.reset();
         * console.log( p );
         * p.set({name:'clark',age:102,kids:['alice','bob','charlie']});
         *
         * How would this be done without PropertySet (for comparison)?
         * //Normally would be created in a class but that is omitted here for brevity.
         * var p ={name: new Property('larry'), age: new Property('age'), kids: new Property(['alice','bob'])}
         * p.reset = function(){
         *   this.name.reset(); 
         *   this.age.reset();
         *   this.kids.reset();
         * }
         * p.name.set('clark');
         * p.age.set('102');
         * p.kids.set(['alice','bob','charlie']);
         *
         * Note: If a subclass ever substitutes a property like this: person.ageProperty = new Property(person.age), then it would break the getter/setter
         * @author Sam Reid
         */
        
        define( 'AXON/PropertySet',['require','AXON/Property','AXON/DerivedProperty','AXON/Events','AXON/axon','PHET_CORE/inherit'],function( require ) {
          
        
          var Property = require( 'AXON/Property' );
          var DerivedProperty = require( 'AXON/DerivedProperty' );
          var Events = require( 'AXON/Events' );
          var axon = require( 'AXON/axon' );
          var inherit = require( 'PHET_CORE/inherit' );
        
          /**
           * @class PropertySet
           * @constructor
           * @param values an object hash with the initial values for the properties
           */
          axon.PropertySet = function PropertySet( values ) {
            var propertySet = this;
        
            Events.call( this );
        
            //Keep track of the keys so we know which to reset
            this.keys = [];
        
            Object.getOwnPropertyNames( values ).forEach( function( value ) {
              propertySet.addProperty( value, values[value] );
            } );
          };
        
          return inherit( Events, axon.PropertySet, {
        
            /**
             * Adds a new property to this PropertySet
             *
             * @param {String} name
             * @param value
             */
            addProperty: function( name, value ) {
              this[name + 'Property'] = new Property( value );
              this.addGetterAndSetter( name );
              this.keys.push( name );
            },
        
            /**
             * Remove any property (whether a derived property or not) that was added to this PropertySet
             * @param name
             */
            removeProperty: function( name ) {
        
              //Remove from the keys (only for non-derived properties)
              var index = this.keys.indexOf( name );
              if ( index !== -1 ) {
                this.keys.splice( index, 1 );
              }
        
              //Unregister the Property instance from the PropertySet
              delete this[name + 'Property'];
        
              //Unregister the getter/setter, if they exist
              delete this[name];
            },
        
            //Add a getter and setter using ES5 get/set syntax, similar to https://gist.github.com/dandean/1292057, same as in github/Atlas
            addGetterAndSetter: function( name ) {
              var property = this[name + 'Property'];
        
              Object.defineProperty( this, name, {
        
                // Getter proxies to Model#get()...
                get: function() { return property.get();},
        
                // Setter proxies to Model#set(attributes)
                set: function( value ) { property.set( value );},
        
                // Make it configurable and enumerable so it's easy to override...
                configurable: true,
                enumerable: true
              } );
            },
        
            addGetter: function( name ) {
              var property = this[name + 'Property'];
        
              Object.defineProperty( this, name, {
        
                get: function() { return property.get();},
        
                // Make it configurable and enumerable so it's easy to override...
                configurable: true,
                enumerable: true
              } );
            },
        
            //Resets all of the properties associated with this PropertySet
            reset: function() {
              var propertySet = this;
              this.keys.forEach( function( key ) {
                propertySet[key + 'Property'].reset();
              } );
            },
        
            /**
             * Creates a DerivedProperty from the given dependency names and derivation.
             * @param dependencyNames {Array<String>}
             * @param derivation {Function}
             * @returns {DerivedProperty}
             */
            toDerivedProperty: function( dependencyNames, derivation ) {
              var propertySet = this;
              var dependencies = dependencyNames.map( function( dependency ) {
                return propertySet[dependency + 'Property'];
              } );
              return new DerivedProperty( dependencies, derivation );
            },
        
            addDerivedProperty: function( name, dependencyNames, derivation ) {
              this[name + 'Property'] = this.toDerivedProperty( dependencyNames, derivation );
              this.addGetter( name );
            },
        
            /**
             * Set all of the values specified in the object hash
             * Allows you to use this form:
             * puller.set( {x: knot.x, y: knot.y, knot: knot} );
             *
             * instead of this:
             * puller.x.value = knot.x;
             * puller.y.value = knot.y;
             * puller.knot.value = knot;
             *
             * Throws an error if you try to set a value for which there is no property.
             */
            set: function( values ) {
              var propertySet = this;
              Object.getOwnPropertyNames( values ).forEach( function( val ) {
                if ( typeof(propertySet[val + 'Property'] === 'Property') ) {
                  propertySet[val + 'Property'].set( values[val] );
                }
                else {
                  throw new Error( 'property not found: ' + val );
                }
              } );
            },
        
            /**
             * Get a JS object literal with all the current values of the properties in this property set, say for serialization.  See `set`
             * TODO: this works well to serialize numbers, strings, booleans.  How to handle complex state values such as Vector2 or nested Property?  Maybe that must be up to the client code.
             * TODO: This was named 'get' to mirror the 'set' method above, but I'm concerned this will make them difficult to find/replace and may confuse with real getters & setters.  Maybe setState/getState would be better?
             */
            get: function() {
              var state = {};
              for ( var i = 0; i < this.keys.length; i++ ) {
                var key = this.keys[i];
                state[key] = this.property( key ).value;
              }
              return state;
            },
        
            /**
             * Add a listener to zero or more properties in this PropertySet, useful when you have an update function
             * that relies on several properties.  Similar to DerivedProperty.
             * Discussion result: Let's use 'multilink' for now, and in the future we may change it to link.
             * @param dependencyNames {Array<String>} the list of dependencies to use
             * @param listener {Function} the listener to call back, with signature matching the dependency names
             */
            multilink: function( dependencyNames, listener ) {
              return this.toDerivedProperty( dependencyNames, listener );
            },
        
            /**
             * Removes the multilinked listener from this PropertySet.
             * Same as calling detach() on the handle (which happens to be a DerivedProperty instance)
             * @param derivedProperty
             */
            unmultilink: function( derivedProperty ) {
              derivedProperty.detach();
            },
        
            toString: function() {
              var text = 'PropertySet{';
              var propertySet = this;
              for ( var i = 0; i < this.keys.length; i++ ) {
                var key = this.keys[i];
                text = text + key + ':' + propertySet[key].toString();
                if ( i < this.keys.length - 1 ) {
                  text = text + ',';
                }
              }
              return text + '}';
            },
        
            /**
             * Link to a property by name, see https://github.com/phetsims/axon/issues/16
             * @param {string} propertyName the name of the property to link to
             * @param {function }observer the callback to link to the property
             */
            link: function( propertyName, observer ) {
              this[propertyName + 'Property'].link( observer );
            },
        
            /**
             * Get a property by name, see https://github.com/phetsims/axon/issues/16
             * @param {string} propertyName the name of the property to get
             */
            property: function( propertyName ) {
              return this[propertyName + 'Property'];
            },
        
            /**
             * Link an attribute to a property by name.  Return a handle to the listener so it can be removed using unlink().
             * @param {string} propertyName the property to link to
             * @param {object} object the object for which the attribute will be set
             * @param {string} attributeName the name of the attribute to set on the object
             */
            linkAttribute: function( propertyName, object, attributeName ) {
              return this.property( propertyName ).linkAttribute( object, attributeName );
            }
          } );
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Object instance allocation tracking, so we can cut down on garbage collection.
         *
         * Sample usage:
         * 1. Run the sim and set up the scenario that you wish to profile
         * 2. In the JS console, type: window.alloc={}
         * 3. Wait until you have taken enough data
         * 4. Type x = window.alloc; delete window.alloc;
         *
         * Now you can inspect the x variable which contains the allocation information.
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'PHET_CORE/phetAllocation',['require','PHET_CORE/core'],function( require ) {
          
        
          var core = require( 'PHET_CORE/core' );
        
          core.phetAllocation = function phetAllocation( name ) {
            if ( window.alloc ) {
              var stack;
              try { throw new Error(); }
              catch( e ) { stack = e.stack; }
        
              if ( !window.alloc[name] ) {
                window.alloc[name] = { count: 0, stacks: {} };
              }
              var log = window.alloc[name];
        
              log.count++;
              if ( !log.stacks[stack] ) {
                log.stacks[stack] = 1;
              }
              else {
                log.stacks[stack] += 1;
              }
              log.report = function() {
                var stacks = Object.keys( log.stacks );
                stacks = _.sortBy( stacks, function( key ) { return log.stacks[key]; } );
                _.each( stacks, function( stack ) {
                  console.log( log.stacks[stack] + ': ' + stack );
                } );
              };
            }
          };
        
          return core.phetAllocation;
        } );
        // Copyright 2002-2014, University of Colorado Boulder
        
        define( 'DOT/dot',['require','ASSERT/assert','ASSERT/assert','PHET_CORE/phetAllocation'],function( require ) {
          
        
          window.assert = window.assert || require( 'ASSERT/assert' )( 'basic' );
          window.assertSlow = window.assertSlow || require( 'ASSERT/assert' )( 'slow', true );
        
          // object allocation tracking
          window.phetAllocation = require( 'PHET_CORE/phetAllocation' );
        
          var dot = function dot() {
            switch( arguments.length ) {
              case 2:
                return new dot.Vector2( arguments[0], arguments[1] );
              case 3:
                return new dot.Vector3( arguments[0], arguments[1], arguments[2] );
              case 4:
                return new dot.Vector4( arguments[0], arguments[1], arguments[2], arguments[3] );
              default:
                throw new Error( 'dot takes 2-4 arguments' );
            }
          };
        
          // TODO: performance: check browser speed to compare how fast this is. We may need to add a 32 option for GL ES.
          dot.FastArray = window.Float64Array ? window.Float64Array : window.Array;
        
          // will be filled in by other modules
          return dot;
        } );
        
        // Copyright 2002-2014, University of Colorado
        
        /**
         * Experimental object pooling mix-in
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'PHET_CORE/Poolable',['require','PHET_CORE/core','PHET_CORE/extend'],function( require ) {
          
        
          var core = require( 'PHET_CORE/core' );
          var extend = require( 'PHET_CORE/extend' );
        
          /*
           * For option details, please see documentation inside this constructor body for now
           */
          core.Poolable = function Poolable( type, options ) {
            var proto = type.prototype;
        
            // defaults
            options = extend( {
              maxPoolSize: 50, // since we don't want to blow too much memory
              initialSize: 0
            }, options );
        
            var pool = type.pool = [];
        
            /*
             * For example: defaultFactory: function() { return new Vector2(); }
             */
            if ( options.defaultFactory ) {
              type.dirtyFromPool = function() {
                if ( pool.length ) {
                  // return an instance in an arbitrary (dirty) state
                  return pool.pop();
                }
                else {
                  // else return a new default instance
                  return options.defaultFactory();
                }
              };
        
              // fills the object pool up to n instances
              type.fillPool = function( n ) {
                // fill up the object pool to the initial size
                while ( pool.length < n ) {
                  pool.push( options.defaultFactory() );
                }
              };
        
              // fill the pool initially to the initial size
              type.fillPool( options.initialSize );
            }
        
            /*
             * For example: constructorDuplicateFactory:
             *                function( pool ) {
             *                  return function( x, y ) {
             *                    if ( pool.length ) {
             *                      return pool.pop().set( x, y );
             *                    } else {
             *                      return new Vector2( x, y );
             *                    }
             *                  }
             *                }
             * It allows arbitrary creation (from the constructor / etc) or mutation (from the pooled instance).
             */
            if ( options.constructorDuplicateFactory ) {
              type.createFromPool = options.constructorDuplicateFactory( pool );
            }
        
            /*
             * Frees the object to the pool (instance.freeToPool())
             */
            proto.freeToPool = function() {
              if ( pool.length < options.maxPoolSize ) {
                pool.push( this );
              }
            };
          };
        
          return core.Poolable;
        } );
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Utility functions for Dot, placed into the dot.X namespace.
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'DOT/Util',['require','DOT/dot'],function( require ) {
          
        
          var dot = require( 'DOT/dot' );
          // require( 'DOT/Vector2' ); // Require.js doesn't like the circular reference
        
          dot.Util = {
            testAssert: function() {
              return 'assert.dot: ' + ( assert ? 'true' : 'false' );
            },
        
            clamp: function( value, min, max ) {
              if ( value < min ) {
                return min;
              }
              else if ( value > max ) {
                return max;
              }
              else {
                return value;
              }
            },
        
            // returns a number between [min,max) with the same equivalence class as value mod (max-min)
            moduloBetweenDown: function( value, min, max ) {
              assert && assert( max > min, 'max > min required for moduloBetween' );
        
              var divisor = max - min;
        
              // get a partial result of value-min between [0,divisor)
              var partial = ( value - min ) % divisor;
              if ( partial < 0 ) {
                // since if value-min < 0, the remainder will give us a negative number
                partial += divisor;
              }
        
              return partial + min; // add back in the minimum value
            },
        
            // returns a number between (min,max] with the same equivalence class as value mod (max-min)
            moduloBetweenUp: function( value, min, max ) {
              return -Util.moduloBetweenDown( -value, -max, -min );
            },
        
            // Returns an array of integers from A to B (including both A to B)
            rangeInclusive: function( a, b ) {
              if ( b < a ) {
                return [];
              }
              var result = new Array( b - a + 1 );
              for ( var i = a; i <= b; i++ ) {
                result[i - a] = i;
              }
              return result;
            },
        
            // Returns an array of integers between A and B (excluding both A to B)
            rangeExclusive: function( a, b ) {
              return Util.rangeInclusive( a + 1, b - 1 );
            },
        
            toRadians: function( degrees ) {
              return Math.PI * degrees / 180;
            },
        
            toDegrees: function( radians ) {
              return 180 * radians / Math.PI;
            },
        
            // find the greatest common denominator using the classic algorithm
            gcd: function( a, b ) {
              return b === 0 ? a : this.gcd( b, a % b );
            },
        
            // intersection between the line from p1-p2 and the line from p3-p4
            lineLineIntersection: function( p1, p2, p3, p4 ) {
              var x12 = p1.x - p2.x;
              var x34 = p3.x - p4.x;
              var y12 = p1.y - p2.y;
              var y34 = p3.y - p4.y;
        
              var denom = x12 * y34 - y12 * x34;
        
              var a = p1.x * p2.y - p1.y * p2.x;
              var b = p3.x * p4.y - p3.y * p4.x;
        
              return new dot.Vector2(
                  ( a * x34 - x12 * b ) / denom,
                  ( a * y34 - y12 * b ) / denom
              );
            },
        
            // assumes a sphere with the specified radius, centered at the origin
            sphereRayIntersection: function( radius, ray, epsilon ) {
              epsilon = epsilon === undefined ? 1e-5 : epsilon;
        
              // center is the origin for now, but leaving in computations so that we can change that in the future. optimize away if needed
              var center = new dot.Vector3();
        
              var rayDir = ray.dir;
              var pos = ray.pos;
              var centerToRay = pos.minus( center );
        
              // basically, we can use the quadratic equation to solve for both possible hit points (both +- roots are the hit points)
              var tmp = rayDir.dot( centerToRay );
              var centerToRayDistSq = centerToRay.magnitudeSquared();
              var det = 4 * tmp * tmp - 4 * ( centerToRayDistSq - radius * radius );
              if ( det < epsilon ) {
                // ray misses sphere entirely
                return null;
              }
        
              var base = rayDir.dot( center ) - rayDir.dot( pos );
              var sqt = Math.sqrt( det ) / 2;
        
              // the "first" entry point distance into the sphere. if we are inside the sphere, it is behind us
              var ta = base - sqt;
        
              // the "second" entry point distance
              var tb = base + sqt;
        
              if ( tb < epsilon ) {
                // sphere is behind ray, so don't return an intersection
                return null;
              }
        
              var hitPositionB = ray.pointAtDistance( tb );
              var normalB = hitPositionB.minus( center ).normalized();
        
              if ( ta < epsilon ) {
                // we are inside the sphere
                // in => out
                return {
                  distance: tb,
                  hitPoint: hitPositionB,
                  normal: normalB.negated(),
                  fromOutside: false
                };
              }
              else {
                // two possible hits
                var hitPositionA = ray.pointAtDistance( ta );
                var normalA = hitPositionA.minus( center ).normalized();
        
                // close hit, we have out => in
                return {
                  distance: ta,
                  hitPoint: hitPositionA,
                  normal: normalA,
                  fromOutside: true
                };
              }
            },
        
            // return an array of real roots of ax^2 + bx + c = 0
            solveQuadraticRootsReal: function( a, b, c ) {
              var epsilon = 1E7;
        
              //We need to test whether a is several orders of magnitude less than b or c. If so, return the result as a solution to the linear (easy) equation
              if ( a === 0 || Math.abs( b / a ) > epsilon || Math.abs( c / a ) > epsilon ) {
                return [ -c / b ];
              }
        
              var discriminant = b * b - 4 * a * c;
              if ( discriminant < 0 ) {
                return [];
              }
              var sqrt = Math.sqrt( discriminant );
              // TODO: how to handle if discriminant is 0? give unique root or double it?
              // TODO: probably just use Complex for the future
              return [
                  ( -b - sqrt ) / ( 2 * a ),
                  ( -b + sqrt ) / ( 2 * a )
              ];
            },
        
            // return an array of real roots of ax^3 + bx^2 + cx + d = 0
            solveCubicRootsReal: function( a, b, c, d ) {
              // TODO: a Complex type!
        
              //We need to test whether a is several orders of magnitude less than b, c, d
              var epsilon = 1E7;
        
              if ( a === 0 || Math.abs( b / a ) > epsilon || Math.abs( c / a ) > epsilon || Math.abs( d / a ) > epsilon ) {
                return Util.solveQuadraticRootsReal( b, c, d );
              }
              if ( d === 0 || Math.abs( a / d ) > epsilon || Math.abs( b / d ) > epsilon || Math.abs( c / d ) > epsilon ) {
                return Util.solveQuadraticRootsReal( a, b, c );
              }
        
              b /= a;
              c /= a;
              d /= a;
        
              var q = ( 3.0 * c - ( b * b ) ) / 9;
              var r = ( -(27 * d) + b * (9 * c - 2 * (b * b)) ) / 54;
              var discriminant = q * q * q + r * r;
              var b3 = b / 3;
        
              if ( discriminant > 0 ) {
                // a single real root
                var dsqrt = Math.sqrt( discriminant );
                return [ Util.cubeRoot( r + dsqrt ) + Util.cubeRoot( r - dsqrt ) - b3 ];
              }
        
              // three real roots
              if ( discriminant === 0 ) {
                // contains a double root
                var rsqrt = Util.cubeRoot( r );
                var doubleRoot = b3 - rsqrt;
                return [ -b3 + 2 * rsqrt, doubleRoot, doubleRoot ];
              }
              else {
                // all unique
                var qX = -q * q * q;
                qX = Math.acos( r / Math.sqrt( qX ) );
                var rr = 2 * Math.sqrt( -q );
                return [
                    -b3 + rr * Math.cos( qX / 3 ),
                    -b3 + rr * Math.cos( ( qX + 2 * Math.PI ) / 3 ),
                    -b3 + rr * Math.cos( ( qX + 4 * Math.PI ) / 3 )
                ];
              }
            },
        
            cubeRoot: function( x ) {
              return x >= 0 ? Math.pow( x, 1 / 3 ) : -Math.pow( -x, 1 / 3 );
            },
        
            // Linearly interpolate two points and evaluate the line equation for a third point
            // f( a1 ) = b1, f( a2 ) = b2, f( a3 ) = <linear mapped value>
            linear: function( a1, a2, b1, b2, a3 ) {
              return ( b2 - b1 ) / ( a2 - a1 ) * ( a3 - a1 ) + b1;
            },
        
            /**
             * A predictable implementation of toFixed.
             * JavaScript's toFixed is notoriously buggy, behavior differs depending on browser,
             * because the spec doesn't specify whether to round or floor.
             * @param {number} number
             * @param {number} decimalPlaces
             * @returns {string}
             */
            toFixed: function( number, decimalPlaces ) {
              var multiplier = Math.pow( 10, decimalPlaces );
              var value = Math.round( number * multiplier ) / multiplier;
              return value.toFixed( decimalPlaces );
            },
        
            // Convenience for returning a number instead of a string.
            toFixedNumber: function( number, decimalPlaces ) {
              return parseFloat( Util.toFixed( number, decimalPlaces ) );
            },
        
            isInteger: function( n ) {
              return ( typeof n === 'number' ) && ( n % 1 === 0 );
            },
        
            /*
             * Computes the intersection of two line segments. Algorithm taked from Paul Bourke, 1989:
             * http://astronomy.swin.edu.au/~pbourke/geometry/lineline2d/
             * Ported from MathUtil.java on 9/20/2013 by @samreid
             * line a goes from point 1->2 and line b goes from 3->4
             * @returns a Vector2 of the intersection point, or null if no intersection
             */
            lineSegmentIntersection: function( x1, y1, x2, y2, x3, y3, x4, y4 ) {
              var numA = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 );
              var numB = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 );
              var denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 );
        
              // If denominator is 0, the lines are parallel or coincident
              if ( denom === 0 ) {
                return null;
              }
              else {
                var ua = numA / denom;
                var ub = numB / denom;
        
                // ua and ub must both be in the range 0 to 1 for the segments to have an intersection pt.
                if ( !( ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1 ) ) {
                  return null;
                }
                else {
                  var x = x1 + ua * ( x2 - x1 );
                  var y = y1 + ua * ( y2 - y1 );
                  return new dot.Vector2( x, y );
                }
              }
            },
        
            /**
             * Squared distance from a point to a line segment squared.
             * See http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
             *
             * @param point the point
             * @param a start point of a line segment
             * @param b end point of a line segment
             * @returns {Number}
             */
            distToSegmentSquared: function( point, a, b ) {
              var segmentLength = a.distanceSquared( b );
              if ( segmentLength === 0 ) { return point.distanceSquared( a ); }
              var t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / segmentLength;
              return t < 0 ? point.distanceSquared( a ) :
                     t > 1 ? point.distanceSquared( b ) :
                     point.distanceSquared( new dot.Vector2( a.x + t * (b.x - a.x), a.y + t * (b.y - a.y) ) );
            },
        
            /**
             * Squared distance from a point to a line segment squared.
             * @param point the point
             * @param a start point of a line segment
             * @param b end point of a line segment
             * @returns {Number}
             */
            distToSegment: function( point, a, b ) { return Math.sqrt( this.distToSegmentSquared( point, a, b ) ); },
        
            arePointsCollinear: function( a, b, c, epsilon ) {
              if ( epsilon === undefined ) {
                epsilon = 0;
              }
              return Util.triangleArea( a, b, c ) <= epsilon;
            },
        
            triangleArea: function( a, b, c ) {
              return Math.abs( Util.triangleAreaSigned( a, b, c ) );
            },
        
            // TODO: investigate which way we want the sign (Canvas or WebGL style)
            triangleAreaSigned: function( a, b, c ) {
              return a.x * ( b.y - c.y ) + b.x * ( c.y - a.y ) + c.x * ( a.y - b.y );
            },
        
            log10: function( val ) {
              return Math.log( val ) / Math.LN10;
            }
          };
          var Util = dot.Util;
        
          // make these available in the main namespace directly (for now)
          dot.testAssert = Util.testAssert;
          dot.clamp = Util.clamp;
          dot.moduloBetweenDown = Util.moduloBetweenDown;
          dot.moduloBetweenUp = Util.moduloBetweenUp;
          dot.rangeInclusive = Util.rangeInclusive;
          dot.rangeExclusive = Util.rangeExclusive;
          dot.toRadians = Util.toRadians;
          dot.toDegrees = Util.toDegrees;
          dot.lineLineIntersection = Util.lineLineIntersection;
          dot.sphereRayIntersection = Util.sphereRayIntersection;
          dot.solveQuadraticRootsReal = Util.solveQuadraticRootsReal;
          dot.solveCubicRootsReal = Util.solveCubicRootsReal;
          dot.cubeRoot = Util.cubeRoot;
          dot.linear = Util.linear;
        
          return Util;
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Basic 2-dimensional vector
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'DOT/Vector2',['require','DOT/dot','PHET_CORE/inherit','PHET_CORE/Poolable','DOT/Util'],function( require ) {
          
        
          var dot = require( 'DOT/dot' );
        
          var inherit = require( 'PHET_CORE/inherit' );
          var Poolable = require( 'PHET_CORE/Poolable' );
          require( 'DOT/Util' );
          // require( 'DOT/Vector3' ); // commented out since Require.js complains about the circular dependency
        
          dot.Vector2 = function Vector2( x, y ) {
            // allow optional parameters
            this.x = x || 0;
            this.y = y || 0;
        
            assert && assert( typeof this.x === 'number', 'x needs to be a number' );
            assert && assert( typeof this.y === 'number', 'y needs to be a number' );
        
            phetAllocation && phetAllocation( 'Vector2' );
          };
          var Vector2 = dot.Vector2;
        
          Vector2.createPolar = function( magnitude, angle ) {
            return new Vector2().setPolar( magnitude, angle );
          };
        
          Vector2.prototype = {
            constructor: Vector2,
            isVector2: true,
            dimension: 2,
        
            magnitude: function() {
              return Math.sqrt( this.magnitudeSquared() );
            },
        
            magnitudeSquared: function() {
              return this.x * this.x + this.y * this.y;
            },
        
            // the distance between this vector (treated as a point) and another point
            distance: function( point ) {
              return Math.sqrt( this.distanceSquared( point ) );
            },
        
            // the distance between this vector (treated as a point) and another point specified as x:Number, y:Number
            distanceXY: function( x, y ) {
              var dx = this.x - x;
              var dy = this.y - y;
              return Math.sqrt( dx * dx + dy * dy );
            },
        
            // the squared distance between this vector (treated as a point) and another point
            distanceSquared: function( point ) {
              var dx = this.x - point.x;
              var dy = this.y - point.y;
              return dx * dx + dy * dy;
            },
        
            // the squared distance between this vector (treated as a point) and another point as (x,y)
            distanceSquaredXY: function( x, y ) {
              var dx = this.x - x;
              var dy = this.y - y;
              return dx * dx + dy * dy;
            },
        
            dot: function( v ) {
              return this.x * v.x + this.y * v.y;
            },
        
            dotXY: function( vx, vy ) {
              return this.x * vx + this.y * vy;
            },
        
            equals: function( other ) {
              return this.x === other.x && this.y === other.y;
            },
        
            equalsEpsilon: function( other, epsilon ) {
              if ( !epsilon ) {
                epsilon = 0;
              }
              return Math.max( Math.abs( this.x - other.x ), Math.abs( this.y - other.y ) ) <= epsilon;
            },
        
            isFinite: function() {
              return isFinite( this.x ) && isFinite( this.y );
            },
        
            /*---------------------------------------------------------------------------*
             * Immutables
             *----------------------------------------------------------------------------*/
        
            // create a copy, or if a vector is passed in, set that vector to our value
            copy: function( vector ) {
              if ( vector ) {
                return vector.set( this );
              }
              else {
                return new Vector2( this.x, this.y );
              }
            },
        
            // z component of the equivalent 3-dimensional cross product (this.x, this.y,0) x (v.x, v.y, 0)
            crossScalar: function( v ) {
              return this.x * v.y - this.y * v.x;
            },
        
            normalized: function() {
              var mag = this.magnitude();
              if ( mag === 0 ) {
                throw new Error( "Cannot normalize a zero-magnitude vector" );
              }
              else {
                return new Vector2( this.x / mag, this.y / mag );
              }
            },
        
            timesScalar: function( scalar ) {
              return new Vector2( this.x * scalar, this.y * scalar );
            },
        
            times: function( scalar ) {
              // make sure it's not a vector!
              assert && assert( scalar.dimension === undefined );
              return this.timesScalar( scalar );
            },
        
            componentTimes: function( v ) {
              return new Vector2( this.x * v.x, this.y * v.y );
            },
        
            plus: function( v ) {
              return new Vector2( this.x + v.x, this.y + v.y );
            },
        
            plusXY: function( x, y ) {
              return new Vector2( this.x + x, this.y + y );
            },
        
            plusScalar: function( scalar ) {
              return new Vector2( this.x + scalar, this.y + scalar );
            },
        
            minus: function( v ) {
              return new Vector2( this.x - v.x, this.y - v.y );
            },
        
            minusXY: function( x, y ) {
              return new Vector2( this.x - x, this.y - y );
            },
        
            minusScalar: function( scalar ) {
              return new Vector2( this.x - scalar, this.y - scalar );
            },
        
            dividedScalar: function( scalar ) {
              return new Vector2( this.x / scalar, this.y / scalar );
            },
        
            negated: function() {
              return new Vector2( -this.x, -this.y );
            },
        
            angle: function() {
              return Math.atan2( this.y, this.x );
            },
        
            // equivalent to a -PI/2 rotation (right hand rotation)
            perpendicular: function() {
              return new Vector2( this.y, -this.x );
            },
        
            angleBetween: function( v ) {
              var thisMagnitude = this.magnitude();
              var vMagnitude = v.magnitude();
              return Math.acos( dot.clamp( ( this.x * v.x + this.y * v.y ) / ( thisMagnitude * vMagnitude ), -1, 1 ) );
            },
        
            rotated: function( angle ) {
              var newAngle = this.angle() + angle;
              var mag = this.magnitude();
              return new Vector2( mag * Math.cos( newAngle ), mag * Math.sin( newAngle ) );
            },
        
            // linear interpolation from this (ratio=0) to vector (ratio=1)
            blend: function( vector, ratio ) {
              return new Vector2( this.x + (vector.x - this.x) * ratio, this.y + (vector.y - this.y) * ratio );
            },
        
            // average position between this and the provided vector
            average: function( vector ) {
              return this.blend( vector, 0.5 );
            },
        
            toString: function() {
              return 'Vector2(' + this.x + ', ' + this.y + ')';
            },
        
            toVector3: function() {
              return new dot.Vector3( this.x, this.y );
            },
        
            /*---------------------------------------------------------------------------*
             * Mutables
             *----------------------------------------------------------------------------*/
        
            // our core three functions which all mutation should go through
            setXY: function( x, y ) {
              this.x = x;
              this.y = y;
              return this;
            },
            setX: function( x ) {
              this.x = x;
              return this;
            },
            setY: function( y ) {
              this.y = y;
              return this;
            },
        
            set: function( v ) {
              return this.setXY( v.x, v.y );
            },
        
            //Sets the magnitude of the vector, keeping the same direction (though a negative magnitude will flip the vector direction)
            setMagnitude: function( m ) {
              var scale = m / this.magnitude();
              return this.multiplyScalar( scale );
            },
        
            add: function( v ) {
              return this.setXY( this.x + v.x, this.y + v.y );
            },
        
            addXY: function( x, y ) {
              return this.setXY( this.x + x, this.y + y );
            },
        
            addScalar: function( scalar ) {
              return this.setXY( this.x + scalar, this.y + scalar );
            },
        
            subtract: function( v ) {
              return this.setXY( this.x - v.x, this.y - v.y );
            },
        
            subtractScalar: function( scalar ) {
              return this.setXY( this.x - scalar, this.y - scalar );
            },
        
            multiplyScalar: function( scalar ) {
              return this.setXY( this.x * scalar, this.y * scalar );
            },
        
            multiply: function( scalar ) {
              // make sure it's not a vector!
              assert && assert( scalar.dimension === undefined );
              return this.multiplyScalar( scalar );
            },
        
            componentMultiply: function( v ) {
              return this.setXY( this.x * v.x, this.y * v.y );
            },
        
            divideScalar: function( scalar ) {
              return this.setXY( this.x / scalar, this.y / scalar );
            },
        
            negate: function() {
              return this.setXY( -this.x, -this.y );
            },
        
            normalize: function() {
              var mag = this.magnitude();
              if ( mag === 0 ) {
                throw new Error( "Cannot normalize a zero-magnitude vector" );
              }
              else {
                return this.divideScalar( mag );
              }
            },
        
            rotate: function( angle ) {
              var newAngle = this.angle() + angle;
              var mag = this.magnitude();
              return this.setXY( mag * Math.cos( newAngle ), mag * Math.sin( newAngle ) );
            },
        
            setPolar: function( magnitude, angle ) {
              return this.setXY( magnitude * Math.cos( angle ), magnitude * Math.sin( angle ) );
            }
        
          };
        
          // experimental object pooling
          /* jshint -W064 */
          Poolable( Vector2, {
            defaultFactory: function() { return new Vector2(); },
            constructorDuplicateFactory: function( pool ) {
              return function( x, y ) {
                if ( pool.length ) {
                  return pool.pop().setXY( x, y );
                }
                else {
                  return new Vector2( x, y );
                }
              };
            }
          } );
        
          /*---------------------------------------------------------------------------*
           * Immutable Vector form
           *----------------------------------------------------------------------------*/
          Vector2.Immutable = function ImmutableVector2( x, y ) {
            Vector2.call( this, x, y );
          };
          var Immutable = Vector2.Immutable;
        
          inherit( Vector2, Immutable );
        
          // throw errors whenever a mutable method is called on our immutable vector
          Immutable.mutableOverrideHelper = function( mutableFunctionName ) {
            Immutable.prototype[mutableFunctionName] = function() {
              throw new Error( "Cannot call mutable method '" + mutableFunctionName + "' on immutable Vector2" );
            };
          };
        
          // TODO: better way to handle this list?
          Immutable.mutableOverrideHelper( 'setXY' );
          Immutable.mutableOverrideHelper( 'setX' );
          Immutable.mutableOverrideHelper( 'setY' );
        
          // helpful immutable constants
          Vector2.ZERO = new Immutable( 0, 0 );
          Vector2.X_UNIT = new Immutable( 1, 0 );
          Vector2.Y_UNIT = new Immutable( 0, 1 );
        
          return Vector2;
        } );
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Model for the red/blue pullers which can be dragged to the rope, and exert a force on the rope.
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/tugofwar/model/Puller',['require','AXON/PropertySet','PHET_CORE/inherit','DOT/Vector2'],function( require ) {
          
        
          var
            PropertySet = require( 'AXON/PropertySet' ),
            inherit = require( 'PHET_CORE/inherit' ),
            Vector2 = require( 'DOT/Vector2' );
        
          /**
           *
           * @param x initial x-coordinate (in meters)
           * @param y initial y-coordinate (in meters)
           * @param type 'red'|'blue'
           * @param size 'small'|'medium'|'large'
           * @param dragOffsetX horizontal offset (in stage coordinates) to offset the puller image when pulling
           * @param standOffsetX horizontal offset in stage coordinates when attached to a knot but not pulling (standing)
           * @constructor
           */
          function Puller( x, y, type, size, dragOffsetX, standOffsetX ) {
            var puller = this;
        
            this.dragOffsetX = dragOffsetX;
            this.standOffsetX = standOffsetX || 0;
            this.type = type;
            this.size = size;
            this.force = this.size === 'small' ? 10 * 5 :
                         this.size === 'medium' ? 20 * 5 :
                         this.size === 'large' ? 30 * 5 :
                         NaN;
        
            //Create the properties and mix them in
            PropertySet.call( this, {dragging: false, knot: null, position: new Vector2( x, y ), lastLocation: 'home'} );
        
            //Move with the knot
            var updatePosition = function( knotX ) { puller.position = new Vector2( knotX, puller.position.y ); };
        
            //When the knot changes, wire up as a listener to the new knot
            this.knotProperty.link( function( newKnot, oldKnot ) {
        
              //Unlink from the previous knot if there was one
              if ( oldKnot ) {
                oldKnot.xProperty.unlink( updatePosition );
              }
        
              //Synchronize our location with the knot.
              if ( newKnot ) {
                newKnot.xProperty.link( updatePosition );
              }
            } );
          }
        
          return inherit( PropertySet, Puller, {
        
            //Detach the puller from the knot.
            disconnect: function() {this.knot = null;},
        
            //Get the name for the puller, used in a11y
            get name() { return this.size + ' ' + this.type + ' Puller';} //TODO localize accessibility
          } );
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Model for the 8 knots that appear on the rope.
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/tugofwar/model/Knot',['require','AXON/PropertySet','PHET_CORE/inherit'],function( require ) {
          
        
          var PropertySet = require( 'AXON/PropertySet' );
          var inherit = require( 'PHET_CORE/inherit' );
        
          /**
           * Constructor for the 8 knots that appear along the rope.
           *
           * @param x the horizontal position (in meters) of the knot
           * @param type whether the knot is for red or blue pullers
           * @constructor
           */
          function Knot( x, type ) {
            this.initX = x;
            this.type = type;
            PropertySet.call( this, {x: x, visible: false} );
          }
        
          return inherit( PropertySet, Knot, { y: 285 } );
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Model for the cart, which has a position (x) and velocity (v).
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/tugofwar/model/Cart',['require','AXON/PropertySet','PHET_CORE/inherit'],function( require ) {
          
        
          var PropertySet = require( 'AXON/PropertySet' );
          var inherit = require( 'PHET_CORE/inherit' );
        
          //Cart constructor
          function Cart() {
            PropertySet.call( this, {x: 0, v: 0} );//Position and velocity are in MKS
          }
        
          return inherit( PropertySet, Cart );
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Model for the Tug of War screen, in which Pullers can pull on a rope with different forces.
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/tugofwar/model/TugOfWarModel',['require','AXON/PropertySet','PHET_CORE/inherit','FORCES_AND_MOTION_BASICS/tugofwar/model/Puller','FORCES_AND_MOTION_BASICS/tugofwar/model/Knot','DOT/Vector2','FORCES_AND_MOTION_BASICS/tugofwar/model/Cart'],function( require ) {
          
        
          var
            PropertySet = require( 'AXON/PropertySet' ),
            inherit = require( 'PHET_CORE/inherit' ),
            Puller = require( 'FORCES_AND_MOTION_BASICS/tugofwar/model/Puller' ),
            Knot = require( 'FORCES_AND_MOTION_BASICS/tugofwar/model/Knot' ),
            Vector2 = require( 'DOT/Vector2' ),
            Cart = require( 'FORCES_AND_MOTION_BASICS/tugofwar/model/Cart' );
        
          /**
           * Constructor for the tug of war model.
           * @constructor
           */
          function TugOfWarModel() {
            var tugOfWarModel = this;
        
            //Call the super class, with initial values for observable properties
            PropertySet.call( this, {
              started: false,
              running: false,
              numberPullersAttached: 0,
              state: 'experimenting',
              time: 0,
              netForce: 0,
              leftForce: 0,
              rightForce: 0,
        
              //User settings
              showSumOfForces: false,
              showValues: false,
              volumeOn: false
            } );
        
            this.cart = new Cart();
        
            //Create the pullers from left to right so the tab order (for accessibility) will be as expected.
            var bigPullerY = 473;
            var mediumPullerY = 426;
            var smallPullerY = 394;
        
            this.pullers = [
              new Puller( 38, smallPullerY, 'blue', 'large', 70, -18 ),
              new Puller( 127, mediumPullerY, 'blue', 'medium', 50, -5 ),
              new Puller( 208, bigPullerY, 'blue', 'small', 10 ),
              new Puller( 278, bigPullerY, 'blue', 'small', 10 ),
              new Puller( 648, bigPullerY, 'red', 'small', 10 ),
              new Puller( 717, bigPullerY, 'red', 'small', 10 ),
              new Puller( 789, mediumPullerY, 'red', 'medium', 20 ),
              new Puller( 860, smallPullerY, 'red', 'large', 30 )
            ];
        
            //Create a knot given a color and index (0-3)
            function createKnot( color, index ) { return new Knot( (color === 'blue' ? 62 : 680) + index * 80, color ); }
        
            //Create the knots
            this.knots = [
              createKnot( 'blue', 0 ),
              createKnot( 'blue', 1 ),
              createKnot( 'blue', 2 ),
              createKnot( 'blue', 3 ),
              createKnot( 'red', 0 ),
              createKnot( 'red', 1 ),
              createKnot( 'red', 2 ),
              createKnot( 'red', 3 )
            ];
        
            //When any puller is dragged, update the closest knots to be visible
            this.pullers.forEach( function( puller ) {
        
              puller.positionProperty.link( tugOfWarModel.updateVisibleKnots.bind( tugOfWarModel ) );
              puller.on( 'dragged', function() {
                tugOfWarModel.numberPullersAttached = tugOfWarModel.countAttachedPullers();
              } );
              puller.on( 'dropped', function() {
                var knot = tugOfWarModel.getTargetKnot( puller );
        
                //try to snap to a knot
                if ( knot ) {
                  puller.set( {position: new Vector2( knot.x, knot.y ), knot: knot} );
                }
        
                //Or go back home
                else {
                  puller.positionProperty.reset();
                }
        
                //Keep track of their location to change the attach/detach thresholds, see TugOfWarModel.getTargetKnot
                puller.lastLocation = knot ? 'knot' : 'home';
        
                tugOfWarModel.numberPullersAttached = tugOfWarModel.countAttachedPullers();
              } );
            } );
        
            //Update the started flag
            this.runningProperty.link( function( running ) { if ( running ) { tugOfWarModel.started = true; }} );
        
            //Update the forces when the number of attached pullers changes
            this.numberPullersAttachedProperty.link( function() {tugOfWarModel.netForce = tugOfWarModel.getNetForce();} );
            this.numberPullersAttachedProperty.link( function() {tugOfWarModel.leftForce = tugOfWarModel.getLeftForce();} );
            this.numberPullersAttachedProperty.link( function() {tugOfWarModel.rightForce = tugOfWarModel.getRightForce();} );
          }
        
          return inherit( PropertySet, TugOfWarModel, {
        
            //Count the number of pullers attached to the rope
            countAttachedPullers: function() {
              return this.pullers.filter(function( puller ) {return puller.knot;} ).length;
            },
        
            //Change knot visibility (halo highlight) when the pullers are dragged
            updateVisibleKnots: function() {
              var model = this;
              this.knots.forEach( function( knot ) {knot.visible = false;} );
              this.pullers.forEach( function( puller ) {
                if ( puller.dragging ) {
                  var knot = model.getTargetKnot( puller );
                  if ( knot ) {
                    knot.visible = true;
                  }
                }
              } );
            },
        
            //Gets the puller attached to a knot, or null if none attached to that knot.
            getPuller: function( knot ) {
              var find = _.find( this.pullers, function( puller ) {return puller.knot === knot;} );
              return typeof(find) !== 'undefined' ? find : null;
            },
        
            //Given a puller, returns a function that computes the distance between that puller and any knot
            getKnotPullerDistance: function( puller ) {
              return function( knot ) { return Math.sqrt( Math.pow( knot.x - puller.position.x, 2 ) + Math.pow( knot.y - puller.position.y, 2 ) ); };
            },
        
            //Gets the closest unoccupied knot to the given puller, which is being dragged.
            getClosestOpenKnot: function( puller ) {
              var tugOfWarModel = this;
              var filter = this.knots.filter( function( knot ) { return knot.type === puller.type && tugOfWarModel.getPuller( knot ) === null; } );
              return _.min( filter, this.getKnotPullerDistance( puller ) );
            },
        
            //Gets the closest unoccupied knot to the given puller if it is close enough to grab
            getTargetKnot: function( puller ) {
              var target = this.getClosestOpenKnot( puller );
              var distanceToTarget = this.getKnotPullerDistance( puller )( target );
        
              //Only accept a target knot if the puller's head is close enough to the knot
              var threshold = puller.lastLocation === 'home' ? 370 : 300;
              return distanceToTarget < 220 && puller.position.y < threshold ? target : null;
            },
        
            //Return the cart and prepare the model for another "go" run
            returnCart: function() {
              this.cart.reset();
              this.knots.forEach( function( knot ) {knot.reset();} );
              this.running = false;
              this.state = 'experimenting';
              this.trigger( 'cart-returned' );
              this.started = false;
            },
        
            //Reset the entire model when "reset all" is pressed
            reset: function() {
              PropertySet.prototype.reset.call( this );
        
              //Unset the knots before calling reset since the change of the number of attached pullers causes the force arrows to update
              this.pullers.forEach( function( puller ) {puller.disconnect();} );
        
              this.cart.reset();
              this.pullers.forEach( function( puller ) { puller.reset(); } );
              this.knots.forEach( function( knot ) {knot.reset();} );
              this.trigger( 'reset-all' );
            },
        
            //Update the physics when the clock ticks
            step: function( dt ) {
              if ( this.running ) {
                var newV = this.cart.v + this.getNetForce() * dt * 0.003;
                var newX = this.cart.x + newV * dt * 60.0;
                this.cart.set( {v: newV, x: newX} );
                this.knots.forEach( function( knot ) { knot.x = knot.initX + newX; } );
        
                //If the cart made it to the end, then stop and signify completion
                if ( this.cart.x > 200 || this.cart.x < -200 ) {
                  this.running = false;
                  this.state = 'completed';
                }
              }
              this.time = this.time + dt;
            },
        
            //Gets the net force on the cart, applied by both left and right pullers
            getNetForce: function() { return this.getLeftForce() + this.getRightForce(); },
        
            //Get an array of pullers of the specified type (color string)
            getPullers: function( type ) { return _.filter( this.pullers, function( p ) {return p.type === type && p.knot;} ); },
        
            //Function for internal use that helps to sum forces in _.reduce, see getLeftForce, getRightForce
            sumForces: function( memo, puller ) {return memo + puller.force;},
        
            //Gets the left force on the cart, applied by left and pullers
            getLeftForce: function() { return -_.reduce( this.getPullers( 'blue' ), this.sumForces, 0 ); },
        
            //Gets the right force on the cart, applied by right pullers
            getRightForce: function() { return _.reduce( this.getPullers( 'red' ), this.sumForces, 0 ); }
          } );
        } );
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * A 2D rectangle-shaped bounded area (bounding box)
         *
         * There are a number of convenience functions to get locations and points on the Bounds. Currently we do not
         * store these with the Bounds2 instance, since we want to lower the memory footprint.
         *
         * minX, minY, maxX, and maxY are actually stored. We don't do x,y,width,height because this can't properly express
         * semi-infinite bounds (like a half-plane), or easily handle what Bounds2.NOTHING and Bounds2.EVERYTHING do with
         * the constructive solid areas.
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'DOT/Bounds2',['require','DOT/dot','PHET_CORE/Poolable','DOT/Vector2'],function( require ) {
          
        
          var dot = require( 'DOT/dot' );
          var Poolable = require( 'PHET_CORE/Poolable' );
        
          require( 'DOT/Vector2' );
        
          //Temporary instances to be used in the transform method.
          var scratchVector2 = new dot.Vector2();
        
          // not using x,y,width,height so that it can handle infinity-based cases in a better way
          dot.Bounds2 = function Bounds2( minX, minY, maxX, maxY ) {
            assert && assert( maxY !== undefined, 'Bounds2 requires 4 parameters' );
            this.minX = minX;
            this.minY = minY;
            this.maxX = maxX;
            this.maxY = maxY;
        
            phetAllocation && phetAllocation( 'Bounds2' );
          };
          var Bounds2 = dot.Bounds2;
        
          Bounds2.prototype = {
            constructor: Bounds2,
        
            isBounds: true,
            dimension: 2,
        
            /*---------------------------------------------------------------------------*
            * Properties
            *----------------------------------------------------------------------------*/
        
            getWidth: function() { return this.maxX - this.minX; },
            get width() { return this.getWidth(); },
        
            getHeight: function() { return this.maxY - this.minY; },
            get height() { return this.getHeight(); },
        
            /*
             * Convenience locations
             * upper is in terms of the visual layout in Scenery and other programs, so the minY is the "upper", and minY is the "lower"
             *
             *             minX (x)     centerX        maxX
             *          ---------------------------------------
             * minY (y) | leftTop     centerTop     rightTop
             * centerY  | leftCenter  center        rightCenter
             * maxY     | leftBottom  centerBottom  rightBottom
             */
            getX: function() { return this.minX; },
            get x() { return this.getX(); },
            getY: function() { return this.minY; },
            get y() { return this.getY(); },
        
            getMinX: function() { return this.minX; },
            get left() { return this.minX; },
            getMinY: function() { return this.minY; },
            get top() { return this.minY; },
            getMaxX: function() { return this.maxX; },
            get right() { return this.maxX; },
            getMaxY: function() { return this.maxY; },
            get bottom() { return this.maxY; },
        
            getCenterX: function() { return ( this.maxX + this.minX ) / 2; },
            get centerX() { return this.getCenterX(); },
            getCenterY: function() { return ( this.maxY + this.minY ) / 2; },
            get centerY() { return this.getCenterY(); },
        
            getLeftTop: function() { return new dot.Vector2( this.minX, this.minY ); },
            get leftTop() { return this.getLeftTop(); },
            getCenterTop: function() { return new dot.Vector2( this.getCenterX(), this.minY ); },
            get centerTop() { return this.getCenterTop(); },
            getRightTop: function() { return new dot.Vector2( this.maxX, this.minY ); },
            get rightTop() { return this.getRightTop(); },
            getLeftCenter: function() { return new dot.Vector2( this.minX, this.getCenterY() ); },
            get leftCenter() { return this.getLeftCenter(); },
            getCenter: function() { return new dot.Vector2( this.getCenterX(), this.getCenterY() ); },
            get center() { return this.getCenter(); },
            getRightCenter: function() { return new dot.Vector2( this.maxX, this.getCenterY() ); },
            get rightCenter() { return this.getRightCenter(); },
            getLeftBottom: function() { return new dot.Vector2( this.minX, this.maxY ); },
            get leftBottom() { return this.getLeftBottom(); },
            getCenterBottom: function() { return new dot.Vector2( this.getCenterX(), this.maxY ); },
            get centerBottom() { return this.getCenterBottom(); },
            getRightBottom: function() { return new dot.Vector2( this.maxX, this.maxY ); },
            get rightBottom() { return this.getRightBottom(); },
        
            isEmpty: function() { return this.getWidth() < 0 || this.getHeight() < 0; },
        
            isFinite: function() {
              return isFinite( this.minX ) && isFinite( this.minY ) && isFinite( this.maxX ) && isFinite( this.maxY );
            },
        
            hasNonzeroArea: function() {
              return this.getWidth() > 0 && this.getHeight() > 0;
            },
        
            isValid: function() {
              return !this.isEmpty() && this.isFinite();
            },
        
            // whether the coordinates are inside the bounding box (or on the boundary)
            containsCoordinates: function( x, y ) {
              return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
            },
        
            // whether the point is inside the bounding box (or on the boundary)
            containsPoint: function( point ) {
              return this.containsCoordinates( point.x, point.y );
            },
        
            // whether this bounding box completely contains the argument bounding box
            containsBounds: function( bounds ) {
              return this.minX <= bounds.minX && this.maxX >= bounds.maxX && this.minY <= bounds.minY && this.maxY >= bounds.maxY;
            },
        
            // whether the intersection is non-empty (if they share any part of a boundary, this will be true)
            intersectsBounds: function( bounds ) {
              // TODO: more efficient way of doing this?
              return !this.intersection( bounds ).isEmpty();
            },
        
            // distance to the closest point inside the Bounds2
            minimumDistanceToPointSquared: function( point ) {
              var closeX = point.x < this.minX ? this.minX : ( point.x > this.maxX ? this.maxX : null );
              var closeY = point.y < this.minY ? this.minY : ( point.y > this.maxY ? this.maxY : null );
              var d;
              if ( closeX === null && closeY === null ) {
                // inside, or on the boundary
                return 0;
              }
              else if ( closeX === null ) {
                // vertically directly above/below
                d = closeY - point.y;
                return d * d;
              }
              else if ( closeY === null ) {
                // horizontally directly to the left/right
                d = closeX - point.x;
                return d * d;
              }
              else {
                // corner case
                var dx = closeX - point.x;
                var dy = closeY - point.y;
                return dx * dx + dy * dy;
              }
            },
        
            // distance to the farthest point inside the Bounds2
            maximumDistanceToPointSquared: function( point ) {
              var x = point.x > this.getCenterX() ? this.minX : this.maxX;
              var y = point.y > this.getCenterY() ? this.minY : this.maxY;
              x -= point.x;
              y -= point.y;
              return x * x + y * y;
            },
        
            toString: function() {
              return '[x:(' + this.minX + ',' + this.maxX + '),y:(' + this.minY + ',' + this.maxY + ')]';
            },
        
            equals: function( other ) {
              return this.minX === other.minX && this.minY === other.minY && this.maxX === other.maxX && this.maxY === other.maxY;
            },
        
            equalsEpsilon: function( other, epsilon ) {
              epsilon = epsilon || 0;
              var thisFinite = this.isFinite();
              var otherFinite = other.isFinite();
              if ( thisFinite && otherFinite ) {
                // both are finite, so we can use Math.abs() - it would fail with non-finite values like Infinity
                return Math.abs( this.minX - other.minX ) < epsilon &&
                       Math.abs( this.minY - other.minY ) < epsilon &&
                       Math.abs( this.maxX - other.maxX ) < epsilon &&
                       Math.abs( this.maxY - other.maxY ) < epsilon;
              }
              else if ( thisFinite !== otherFinite ) {
                return false; // one is finite, the other is not. definitely not equal
              }
              else if ( this === other ) {
                return true; // exact same instance, must be equal
              }
              else {
                // epsilon only applies on finite dimensions. due to JS's handling of isFinite(), it's faster to check the sum of both
                return ( isFinite( this.minX + other.minX ) ? ( Math.abs( this.minX - other.minX ) < epsilon ) : ( this.minX === other.minX ) ) &&
                       ( isFinite( this.minY + other.minY ) ? ( Math.abs( this.minY - other.minY ) < epsilon ) : ( this.minY === other.minY ) ) &&
                       ( isFinite( this.maxX + other.maxX ) ? ( Math.abs( this.maxX - other.maxX ) < epsilon ) : ( this.maxX === other.maxX ) ) &&
                       ( isFinite( this.maxY + other.maxY ) ? ( Math.abs( this.maxY - other.maxY ) < epsilon ) : ( this.maxY === other.maxY ) );
              }
            },
        
            /*---------------------------------------------------------------------------*
            * Immutable operations
            *----------------------------------------------------------------------------*/
        
            // create a copy, or if bounds is passed in, set that bounds to our value
            copy: function( bounds ) {
              if ( bounds ) {
                return bounds.set( this );
              }
              else {
                return new Bounds2( this.minX, this.minY, this.maxX, this.maxY );
              }
            },
        
            // immutable operations (bounding-box style handling, so that the relevant bounds contain everything)
            union: function( bounds ) {
              return new Bounds2(
                Math.min( this.minX, bounds.minX ),
                Math.min( this.minY, bounds.minY ),
                Math.max( this.maxX, bounds.maxX ),
                Math.max( this.maxY, bounds.maxY )
              );
            },
            intersection: function( bounds ) {
              return new Bounds2(
                Math.max( this.minX, bounds.minX ),
                Math.max( this.minY, bounds.minY ),
                Math.min( this.maxX, bounds.maxX ),
                Math.min( this.maxY, bounds.maxY )
              );
            },
            // TODO: difference should be well-defined, but more logic is needed to compute
        
            withCoordinates: function( x, y ) {
              return new Bounds2(
                Math.min( this.minX, x ),
                Math.min( this.minY, y ),
                Math.max( this.maxX, x ),
                Math.max( this.maxY, y )
              );
            },
        
            // like a union with a point-sized bounding box
            withPoint: function( point ) {
              return this.withCoordinates( point.x, point.y );
            },
        
            withMinX: function( minX ) { return new Bounds2( minX, this.minY, this.maxX, this.maxY ); },
            withMinY: function( minY ) { return new Bounds2( this.minX, minY, this.maxX, this.maxY ); },
            withMaxX: function( maxX ) { return new Bounds2( this.minX, this.minY, maxX, this.maxY ); },
            withMaxY: function( maxY ) { return new Bounds2( this.minX, this.minY, this.maxX, maxY ); },
        
            // copy rounded to integral values, expanding where necessary
            roundedOut: function() {
              return new Bounds2(
                Math.floor( this.minX ),
                Math.floor( this.minY ),
                Math.ceil( this.maxX ),
                Math.ceil( this.maxY )
              );
            },
        
            // copy rounded to integral values, contracting where necessary
            roundedIn: function() {
              return new Bounds2(
                Math.ceil( this.minX ),
                Math.ceil( this.minY ),
                Math.floor( this.maxX ),
                Math.floor( this.maxY )
              );
            },
        
            // transform a bounding box.
            // NOTE that box.transformed( matrix ).transformed( inverse ) may be larger than the original box
            transformed: function( matrix ) {
              return this.copy().transform( matrix );
            },
        
            // returns copy expanded on all sides by length d
            dilated: function( d ) {
              return new Bounds2( this.minX - d, this.minY - d, this.maxX + d, this.maxY + d );
            },
        
            // dilates only in the x direction
            dilatedX: function( x ) {
              return new Bounds2( this.minX - x, this.minY, this.maxX + x, this.maxY );
            },
        
            // dilates only in the y direction
            dilatedY: function( y ) {
              return new Bounds2( this.minX, this.minY - y, this.maxX, this.maxY + y );
            },
        
            // dilate with different amounts in the x and y directions
            dilatedXY: function( x, y ) {
              return new Bounds2( this.minX - x, this.minY - y, this.maxX + x, this.maxY + y );
            },
        
            // returns copy contracted on all sides by length d, or for x/y independently
            eroded: function( d ) { return this.dilated( -d ); },
            erodedX: function( x ) { return this.dilatedX( -x ); },
            erodedY: function( y ) { return this.dilatedY( -y ); },
            erodedXY: function( x, y ) { return this.dilatedXY( -x, -y ); },
        
            shiftedX: function( x ) {
              return new Bounds2( this.minX + x, this.minY, this.maxX + x, this.maxY );
            },
        
            shiftedY: function( y ) {
              return new Bounds2( this.minX, this.minY + y, this.maxX, this.maxY + y );
            },
        
            shifted: function( x, y ) {
              return new Bounds2( this.minX + x, this.minY + y, this.maxX + x, this.maxY + y );
            },
        
            /*---------------------------------------------------------------------------*
            * Mutable operations
            *----------------------------------------------------------------------------*/
        
            // mutable core opreations (all other mutations should be called through these)
            setMinMax: function( minX, minY, maxX, maxY ) {
              this.minX = minX;
              this.minY = minY;
              this.maxX = maxX;
              this.maxY = maxY;
              return this;
            },
            setMinX: function( minX ) {
              this.minX = minX;
              return this;
            },
            setMinY: function( minY ) {
              this.minY = minY;
              return this;
            },
            setMaxX: function( maxX ) {
              this.maxX = maxX;
              return this;
            },
            setMaxY: function( maxY ) {
              this.maxY = maxY;
              return this;
            },
        
            set: function( bounds ) {
              return this.setMinMax( bounds.minX, bounds.minY, bounds.maxX, bounds.maxY );
            },
        
            // mutable union
            includeBounds: function( bounds ) {
              return this.setMinMax(
                Math.min( this.minX, bounds.minX ),
                Math.min( this.minY, bounds.minY ),
                Math.max( this.maxX, bounds.maxX ),
                Math.max( this.maxY, bounds.maxY )
              );
            },
        
            // mutable intersection
            constrainBounds: function( bounds ) {
              return this.setMinMax(
                Math.max( this.minX, bounds.minX ),
                Math.max( this.minY, bounds.minY ),
                Math.min( this.maxX, bounds.maxX ),
                Math.min( this.maxY, bounds.maxY )
              );
            },
        
            addCoordinates: function( x, y ) {
              return this.setMinMax(
                Math.min( this.minX, x ),
                Math.min( this.minY, y ),
                Math.max( this.maxX, x ),
                Math.max( this.maxY, y )
              );
            },
        
            addPoint: function( point ) {
              return this.addCoordinates( point.x, point.y );
            },
        
            // round to integral values, expanding where necessary
            roundOut: function() {
              return this.setMinMax(
                Math.floor( this.minX ),
                Math.floor( this.minY ),
                Math.ceil( this.maxX ),
                Math.ceil( this.maxY )
              );
            },
        
            // round to integral values, contracting where necessary
            roundIn: function() {
              return this.setMinMax(
                Math.ceil( this.minX ),
                Math.ceil( this.minY ),
                Math.floor( this.maxX ),
                Math.floor( this.maxY )
              );
            },
        
            // transform a bounding box.
            // NOTE that box.transformed( matrix ).transformed( inverse ) may be larger than the original box
            transform: function( matrix ) {
              // if we contain no area, no change is needed
              if ( this.isEmpty() ) {
                return this;
              }
        
              // optimization to bail for identity matrices
              if ( matrix.isIdentity() ) {
                return this;
              }
        
              var minX = this.minX;
              var minY = this.minY;
              var maxX = this.maxX;
              var maxY = this.maxY;
              this.set( dot.Bounds2.NOTHING );
        
              // using mutable vector so we don't create excessive instances of Vector2 during this
              // make sure all 4 corners are inside this transformed bounding box
        
              this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( minX, minY ) ) );
              this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( minX, maxY ) ) );
              this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( maxX, minY ) ) );
              this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( maxX, maxY ) ) );
              return this;
            },
        
            // expands on all sides by length d
            dilate: function( d ) {
              return this.setMinMax( this.minX - d, this.minY - d, this.maxX + d, this.maxY + d );
            },
        
            // dilates only in the x direction
            dilateX: function( x ) {
              return this.setMinMax( this.minX - x, this.minY, this.maxX + x, this.maxY );
            },
        
            // dilates only in the y direction
            dilateY: function( y ) {
              return this.setMinMax( this.minX, this.minY - y, this.maxX, this.maxY + y );
            },
        
            // dilate with different amounts in the x and y directions
            dilateXY: function( x, y ) {
              return this.setMinMax( this.minX - x, this.minY - y, this.maxX + x, this.maxY + y );
            },
        
            // contracts on all sides by length d, or for x/y independently
            erode: function( d ) { return this.dilate( -d ); },
            erodeX: function( x ) { return this.dilateX( -x ); },
            erodeY: function( y ) { return this.dilateY( -y ); },
            erodeXY: function( x, y ) { return this.dilateXY( -x, -y ); },
        
            shiftX: function( x ) {
              return this.setMinMax( this.minX + x, this.minY, this.maxX + x, this.maxY );
            },
        
            shiftY: function( y ) {
              return this.setMinMax( this.minX, this.minY + y, this.maxX, this.maxY + y );
            },
        
            shift: function( x, y ) {
              return this.setMinMax( this.minX + x, this.minY + y, this.maxX + x, this.maxY + y );
            },
        
            /**
             * Find a point in the Bounds2 closest to the specified point.  Used for making sure a dragged object doesn't get outside the visible play area.
             * @param x x point to test
             * @param y y point to test
             * @param {Vector2} result optional Vector2 that can store the return value to avoid allocations
             * @returns {Vector2}
             */
            getClosestPoint: function( x, y, result ) {
              if ( result ) {
                result.setXY( x, y );
              }
              else {
                result = new dot.Vector2( x, y );
              }
              if ( result.x < this.minX ) { result.x = this.minX; }
              if ( result.x > this.maxX ) { result.x = this.maxX; }
              if ( result.y < this.minY ) { result.y = this.minY; }
              if ( result.y > this.maxY ) { result.y = this.maxY; }
              return result;
            }
          };
        
          Bounds2.rect = function( x, y, width, height ) {
            return new Bounds2( x, y, x + width, y + height );
          };
        
          // a volume-less point bounds, which can be dilated to form a centered bounds
          Bounds2.point = function( x, y ) {
            if ( x instanceof dot.Vector2 ) {
              var p = x;
              return new Bounds2( p.x, p.y, p.x, p.y );
            }
            else {
              return new Bounds2( x, y, x, y );
            }
          };
        
          // experimental object pooling
          /* jshint -W064 */
          Poolable( Bounds2, {
            defaultFactory: function() { return Bounds2.NOTHING.copy(); },
            constructorDuplicateFactory: function( pool ) {
              return function( minX, minY, maxX, maxY ) {
                if ( pool.length ) {
                  return pool.pop().setMinMax( minX, minY, maxX, maxY );
                }
                else {
                  return new Bounds2( minX, minY, maxX, maxY );
                }
              };
            }
          } );
        
          // specific bounds useful for operations
          Bounds2.EVERYTHING = new Bounds2( Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY );
          Bounds2.NOTHING = new Bounds2( Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY );
        
          return Bounds2;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * The main 'scenery' namespace object for the exported (non-Require.js) API. Used internally
         * since it prevents Require.js issues with circular dependencies.
         *
         * The returned scenery object namespace may be incomplete if not all modules are listed as
         * dependencies. Please use the 'main' module for that purpose if all of Scenery is desired.
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/scenery',['require','ASSERT/assert','ASSERT/assert','PHET_CORE/phetAllocation'],function( require ) {
          
          
          window.assert = window.assert || require( 'ASSERT/assert' )( 'basic' );
          window.assertSlow = window.assertSlow || require( 'ASSERT/assert' )( 'slow', true );
          
          window.sceneryLayerLog = null;
          window.sceneryEventLog = null;
          window.sceneryAccessibilityLog = null;
          
          // object allocation tracking
          window.phetAllocation = require( 'PHET_CORE/phetAllocation' );
          
          var scratchCanvas = document.createElement( 'canvas' );
          var scratchContext = scratchCanvas.getContext( '2d' );
          
          // will be filled in by other modules
          return {
            assert: assert,
            
            scratchCanvas: scratchCanvas,   // a canvas used for convenience functions (think of it as having arbitrary state)
            scratchContext: scratchContext, // a context used for convenience functions (think of it as having arbitrary state)
            
            svgns: 'http://www.w3.org/2000/svg',     // svg namespace
            xlinkns: 'http://www.w3.org/1999/xlink', // x-link namespace
            
            enableLayerLogging: function() {
              window.sceneryLayerLog = function( ob ) { console.log( ob ); };
            },
          
            disableLayerLogging: function() {
              window.sceneryLayerLog = null;
            },
            
            enableEventLogging: function() {
              window.sceneryEventLog = function( ob ) { console.log( ob ); };
            },
          
            disableEventLogging: function() {
              window.sceneryEventLog = null;
            },
            
            enableAccessibilityLogging: function() {
              window.sceneryAccessibilityLog = function( ob ) { console.log( ob ); };
            },
          
            disableAccessibilityLogging: function() {
              window.sceneryAccessibilityLog = null;
            },
            
            bitmaskAll:            0xFFFFFFF, // 28 bits for now (don't go over 31 bits, or we'll see a 32-bit platform slowdown!)
            bitmaskNodeDefault:    0x00001FF,
            bitmaskPaintedDefault: 0x0000000,
            
            bitmaskSupportsCanvas: 0x0000001,
            bitmaskSupportsSVG:    0x0000002,
            bitmaskSupportsDOM:    0x0000004,
            bitmaskSupportsWebGL:  0x0000008,
            // 10, 20, 40, 80 reserved for future renderers
            bitmaskNotPainted:     0x0000100
            // TODO: what else would we need?
          };
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Basic 4-dimensional vector
         *
         * TODO: sync with Vector2 changes
         * TODO: add quaternion extension
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'DOT/Vector4',['require','DOT/dot','DOT/Util'],function( require ) {
          
        
          var dot = require( 'DOT/dot' );
        
          require( 'DOT/Util' );
          // require( 'DOT/Vector3' ); // commented out so Require.js doesn't complain about the circular dependency
        
          dot.Vector4 = function Vector4( x, y, z, w ) {
            // allow optional parameters
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w !== undefined ? w : 1; // since w could be zero!
          };
          var Vector4 = dot.Vector4;
        
          Vector4.prototype = {
            constructor: Vector4,
            isVector4: true,
            dimension: 4,
        
            magnitude: function() {
              return Math.sqrt( this.magnitudeSquared() );
            },
        
            magnitudeSquared: function() {
              this.dot( this );
            },
        
            // the distance between this vector (treated as a point) and another point
            distance: function( point ) {
              return this.minus( point ).magnitude();
            },
        
            // the squared distance between this vector (treated as a point) and another point
            distanceSquared: function( point ) {
              return this.minus( point ).magnitudeSquared();
            },
        
            dot: function( v ) {
              return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
            },
        
            isFinite: function() {
              return isFinite( this.x ) && isFinite( this.y ) && isFinite( this.z ) && isFinite( this.w );
            },
        
            equals: function( other ) {
              return this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
            },
        
            equalsEpsilon: function( other, epsilon ) {
              if ( !epsilon ) {
                epsilon = 0;
              }
              return Math.abs( this.x - other.x ) + Math.abs( this.y - other.y ) + Math.abs( this.z - other.z ) + Math.abs( this.w - other.w ) <= epsilon;
            },
        
            /*---------------------------------------------------------------------------*
             * Immutables
             *----------------------------------------------------------------------------*/
        
            // create a copy, or if a vector is passed in, set that vector to our value
            copy: function( vector ) {
              if ( vector ) {
                return vector.set( this );
              }
              else {
                return new Vector4( this.x, this.y, this.z, this.w );
              }
            },
        
            normalized: function() {
              var mag = this.magnitude();
              if ( mag === 0 ) {
                throw new Error( "Cannot normalize a zero-magnitude vector" );
              }
              else {
                return new Vector4( this.x / mag, this.y / mag, this.z / mag, this.w / mag );
              }
            },
        
            timesScalar: function( scalar ) {
              return new Vector4( this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar );
            },
        
            times: function( scalar ) {
              // make sure it's not a vector!
              assert && assert( scalar.dimension === undefined );
              return this.timesScalar( scalar );
            },
        
            componentTimes: function( v ) {
              return new Vector4( this.x * v.x, this.y * v.y, this.z * v.z, this.w * v.w );
            },
        
            plus: function( v ) {
              return new Vector4( this.x + v.x, this.y + v.y, this.z + v.z, this.w + v.w );
            },
        
            plusScalar: function( scalar ) {
              return new Vector4( this.x + scalar, this.y + scalar, this.z + scalar, this.w + scalar );
            },
        
            minus: function( v ) {
              return new Vector4( this.x - v.x, this.y - v.y, this.z - v.z, this.w - v.w );
            },
        
            minusScalar: function( scalar ) {
              return new Vector4( this.x - scalar, this.y - scalar, this.z - scalar, this.w - scalar );
            },
        
            dividedScalar: function( scalar ) {
              return new Vector4( this.x / scalar, this.y / scalar, this.z / scalar, this.w / scalar );
            },
        
            negated: function() {
              return new Vector4( -this.x, -this.y, -this.z, -this.w );
            },
        
            angleBetween: function( v ) {
              return Math.acos( dot.clamp( this.normalized().dot( v.normalized() ), -1, 1 ) );
            },
        
            // linear interpolation from this (ratio=0) to vector (ratio=1)
            blend: function( vector, ratio ) {
              return this.plus( vector.minus( this ).times( ratio ) );
            },
        
            // average position between this and the provided vector
            average: function( vector ) {
              return this.blend( vector, 0.5 );
            },
        
            toString: function() {
              return "Vector4(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
            },
        
            toVector3: function() {
              return new dot.Vector3( this.x, this.y, this.z );
            },
        
            /*---------------------------------------------------------------------------*
             * Mutables
             *----------------------------------------------------------------------------*/
        
            // our core mutables (all mutation should go through these)
            setXYZW: function( x, y, z, w ) {
              this.x = x;
              this.y = y;
              this.z = z;
              this.w = w;
              return this;
            },
            setX: function( x ) {
              this.x = x;
              return this;
            },
            setY: function( y ) {
              this.y = y;
              return this;
            },
            setZ: function( z ) {
              this.z = z;
              return this;
            },
            setW: function( w ) {
              this.w = w;
              return this;
            },
        
            set: function( v ) {
              return this.setXYZW( v.x, v.y, v.z, v.w );
            },
        
            add: function( v ) {
              return this.setXYZW( this.x + v.x, this.y + v.y, this.z + v.z, this.w + v.w );
            },
        
            addScalar: function( scalar ) {
              return this.setXYZW( this.x + scalar, this.y + scalar, this.z + scalar, this.w + scalar );
            },
        
            subtract: function( v ) {
              return this.setXYZW( this.x - v.x, this.y - v.y, this.z - v.z, this.w - v.w );
            },
        
            subtractScalar: function( scalar ) {
              return this.setXYZW( this.x - scalar, this.y - scalar, this.z - scalar, this.w - scalar );
            },
        
            multiplyScalar: function( scalar ) {
              return this.setXYZW( this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar );
            },
        
            multiply: function( scalar ) {
              // make sure it's not a vector!
              assert && assert( scalar.dimension === undefined );
              return this.multiplyScalar( scalar );
            },
        
            componentMultiply: function( v ) {
              return this.setXYZW( this.x * v.x, this.y * v.y, this.z * v.z, this.w * v.w );
            },
        
            divideScalar: function( scalar ) {
              return this.setXYZW( this.x / scalar, this.y / scalar, this.z / scalar, this.w / scalar );
            },
        
            negate: function() {
              return this.setXYZW( -this.x, -this.y, -this.z, -this.w );
            },
        
            normalize: function() {
              var mag = this.magnitude();
              if ( mag === 0 ) {
                throw new Error( "Cannot normalize a zero-magnitude vector" );
              }
              else {
                return this.divideScalar( mag );
              }
              return this;
            }
          };
        
          /*---------------------------------------------------------------------------*
           * Immutable Vector form
           *----------------------------------------------------------------------------*/
          Vector4.Immutable = function( x, y, z, w ) {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w !== undefined ? w : 1;
          };
          var Immutable = Vector4.Immutable;
        
          Immutable.prototype = new Vector4();
          Immutable.prototype.constructor = Immutable;
        
          // throw errors whenever a mutable method is called on our immutable vector
          Immutable.mutableOverrideHelper = function( mutableFunctionName ) {
            Immutable.prototype[mutableFunctionName] = function() {
              throw new Error( "Cannot call mutable method '" + mutableFunctionName + "' on immutable Vector4" );
            };
          };
        
          // TODO: better way to handle this list?
          Immutable.mutableOverrideHelper( 'setXYZW' );
          Immutable.mutableOverrideHelper( 'setX' );
          Immutable.mutableOverrideHelper( 'setY' );
          Immutable.mutableOverrideHelper( 'setZ' );
          Immutable.mutableOverrideHelper( 'setW' );
        
          // helpful immutable constants
          Vector4.ZERO = new Immutable( 0, 0, 0, 0 );
          Vector4.X_UNIT = new Immutable( 1, 0, 0, 0 );
          Vector4.Y_UNIT = new Immutable( 0, 1, 0, 0 );
          Vector4.Z_UNIT = new Immutable( 0, 0, 1, 0 );
          Vector4.W_UNIT = new Immutable( 0, 0, 0, 1 );
        
          return Vector4;
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Basic 3-dimensional vector
         *
         * TODO: sync with Vector2 changes
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'DOT/Vector3',['require','DOT/dot','DOT/Util','DOT/Vector2','DOT/Vector4'],function( require ) {
          
        
          var dot = require( 'DOT/dot' );
        
          require( 'DOT/Util' );
          require( 'DOT/Vector2' );
          require( 'DOT/Vector4' );
        
          dot.Vector3 = function Vector3( x, y, z ) {
            // allow optional parameters
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
          };
          var Vector3 = dot.Vector3;
        
          Vector3.prototype = {
            constructor: Vector3,
            isVector3: true,
            dimension: 3,
        
            magnitude: function() {
              return Math.sqrt( this.magnitudeSquared() );
            },
        
            magnitudeSquared: function() {
              return this.dot( this );
            },
        
            // the distance between this vector (treated as a point) and another point
            distance: function( point ) {
              return this.minus( point ).magnitude();
            },
        
            // the squared distance between this vector (treated as a point) and another point
            distanceSquared: function( point ) {
              return this.minus( point ).magnitudeSquared();
            },
        
            dot: function( v ) {
              return this.x * v.x + this.y * v.y + this.z * v.z;
            },
        
            isFinite: function() {
              return isFinite( this.x ) && isFinite( this.y ) && isFinite( this.z );
            },
        
            equals: function( other ) {
              return this.x === other.x && this.y === other.y && this.z === other.z;
            },
        
            equalsEpsilon: function( other, epsilon ) {
              if ( !epsilon ) {
                epsilon = 0;
              }
              return Math.abs( this.x - other.x ) + Math.abs( this.y - other.y ) + Math.abs( this.z - other.z ) <= epsilon;
            },
        
            /*---------------------------------------------------------------------------*
             * Immutables
             *----------------------------------------------------------------------------*/
        
            // create a copy, or if a vector is passed in, set that vector to our value
            copy: function( vector ) {
              if ( vector ) {
                return vector.set( this );
              }
              else {
                return new Vector3( this.x, this.y, this.z );
              }
            },
        
            cross: function( v ) {
              return new Vector3(
                  this.y * v.z - this.z * v.y,
                  this.z * v.x - this.x * v.z,
                  this.x * v.y - this.y * v.x
              );
            },
        
            normalized: function() {
              var mag = this.magnitude();
              if ( mag === 0 ) {
                throw new Error( "Cannot normalize a zero-magnitude vector" );
              }
              else {
                return new Vector3( this.x / mag, this.y / mag, this.z / mag );
              }
            },
        
            timesScalar: function( scalar ) {
              return new Vector3( this.x * scalar, this.y * scalar, this.z * scalar );
            },
        
            times: function( scalar ) {
              // make sure it's not a vector!
              assert && assert( scalar.dimension === undefined );
              return this.timesScalar( scalar );
            },
        
            componentTimes: function( v ) {
              return new Vector3( this.x * v.x, this.y * v.y, this.z * v.z );
            },
        
            plus: function( v ) {
              return new Vector3( this.x + v.x, this.y + v.y, this.z + v.z );
            },
        
            plusScalar: function( scalar ) {
              return new Vector3( this.x + scalar, this.y + scalar, this.z + scalar );
            },
        
            minus: function( v ) {
              return new Vector3( this.x - v.x, this.y - v.y, this.z - v.z );
            },
        
            minusScalar: function( scalar ) {
              return new Vector3( this.x - scalar, this.y - scalar, this.z - scalar );
            },
        
            dividedScalar: function( scalar ) {
              return new Vector3( this.x / scalar, this.y / scalar, this.z / scalar );
            },
        
            negated: function() {
              return new Vector3( -this.x, -this.y, -this.z );
            },
        
            angleBetween: function( v ) {
              return Math.acos( dot.clamp( this.normalized().dot( v.normalized() ), -1, 1 ) );
            },
        
            // linear interpolation from this (ratio=0) to vector (ratio=1)
            blend: function( vector, ratio ) {
              return this.plus( vector.minus( this ).times( ratio ) );
            },
        
            // average position between this and the provided vector
            average: function( vector ) {
              return this.blend( vector, 0.5 );
            },
        
            toString: function() {
              return "Vector3(" + this.x + ", " + this.y + ", " + this.z + ")";
            },
        
            toVector2: function() {
              return new dot.Vector2( this.x, this.y );
            },
        
            toVector4: function() {
              return new dot.Vector4( this.x, this.y, this.z );
            },
        
            /*---------------------------------------------------------------------------*
             * Mutables
             *----------------------------------------------------------------------------*/
        
            // our core mutables, all mutation should go through these
            setXYZ: function( x, y, z ) {
              this.x = x;
              this.y = y;
              this.z = z;
              return this;
            },
            setX: function( x ) {
              this.x = x;
              return this;
            },
            setY: function( y ) {
              this.y = y;
              return this;
            },
            setZ: function( z ) {
              this.z = z;
              return this;
            },
        
            set: function( v ) {
              return this.setXYZ( v.x, v.y, v.z );
            },
        
            add: function( v ) {
              return this.setXYZ( this.x + v.x, this.y + v.y, this.z + v.z );
            },
        
            addScalar: function( scalar ) {
              return this.setXYZ( this.x + scalar, this.y + scalar, this.z + scalar );
            },
        
            subtract: function( v ) {
              return this.setXYZ( this.x - v.x, this.y - v.y, this.z - v.z );
            },
        
            subtractScalar: function( scalar ) {
              return this.setXYZ( this.x - scalar, this.y - scalar, this.z - scalar );
            },
        
            multiplyScalar: function( scalar ) {
              return this.setXYZ( this.x * scalar, this.y * scalar, this.z * scalar );
            },
        
            multiply: function( scalar ) {
              // make sure it's not a vector!
              assert && assert( scalar.dimension === undefined );
              return this.multiplyScalar( scalar );
            },
        
            componentMultiply: function( v ) {
              return this.setXYZ( this.x * v.x, this.y * v.y, this.z * v.z );
            },
        
            divideScalar: function( scalar ) {
              return this.setXYZ( this.x / scalar, this.y / scalar, this.z / scalar );
            },
        
            negate: function() {
              return this.setXYZ( -this.x, -this.y, -this.z );
            },
        
            normalize: function() {
              var mag = this.magnitude();
              if ( mag === 0 ) {
                throw new Error( "Cannot normalize a zero-magnitude vector" );
              }
              else {
                return this.divideScalar( mag );
              }
            }
          };
        
          /*---------------------------------------------------------------------------*
           * Immutable Vector form
           *----------------------------------------------------------------------------*/
          Vector3.Immutable = function( x, y, z ) {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
          };
          var Immutable = Vector3.Immutable;
        
          Immutable.prototype = new Vector3();
          Immutable.prototype.constructor = Immutable;
        
          // throw errors whenever a mutable method is called on our immutable vector
          Immutable.mutableOverrideHelper = function( mutableFunctionName ) {
            Immutable.prototype[mutableFunctionName] = function() {
              throw new Error( "Cannot call mutable method '" + mutableFunctionName + "' on immutable Vector3" );
            };
          };
        
          // TODO: better way to handle this list?
          Immutable.mutableOverrideHelper( 'setXYZ' );
          Immutable.mutableOverrideHelper( 'setX' );
          Immutable.mutableOverrideHelper( 'setY' );
          Immutable.mutableOverrideHelper( 'setZ' );
        
          // helpful immutable constants
          Vector3.ZERO = new Immutable( 0, 0, 0 );
          Vector3.X_UNIT = new Immutable( 1, 0, 0 );
          Vector3.Y_UNIT = new Immutable( 0, 1, 0 );
          Vector3.Z_UNIT = new Immutable( 0, 0, 1 );
        
          return Vector3;
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * 4-dimensional Matrix
         *
         * TODO: consider adding affine flag if it will help performance (a la Matrix3)
         * TODO: get rotation angles
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'DOT/Matrix4',['require','DOT/dot','DOT/Vector3','DOT/Vector4'],function( require ) {
          
        
          var dot = require( 'DOT/dot' );
        
          require( 'DOT/Vector3' );
          require( 'DOT/Vector4' );
        
          var Float32Array = window.Float32Array || Array;
        
          dot.Matrix4 = function Matrix4( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type ) {
        
            // entries stored in column-major format
            this.entries = new Float32Array( 16 );
        
            this.rowMajor(
                v00 === undefined ? 1 : v00, v01 || 0, v02 || 0, v03 || 0,
                v10 || 0, v11 === undefined ? 1 : v11, v12 || 0, v13 || 0,
                v20 || 0, v21 || 0, v22 === undefined ? 1 : v22, v23 || 0,
                v30 || 0, v31 || 0, v32 || 0, v33 === undefined ? 1 : v33,
              type );
          };
          var Matrix4 = dot.Matrix4;
        
          Matrix4.Types = {
            OTHER: 0, // default
            IDENTITY: 1,
            TRANSLATION_3D: 2,
            SCALING: 3,
            AFFINE: 4
        
            // TODO: possibly add rotations
          };
        
          var Types = Matrix4.Types;
        
          Matrix4.identity = function() {
            return new Matrix4(
              1, 0, 0, 0,
              0, 1, 0, 0,
              0, 0, 1, 0,
              0, 0, 0, 1,
              Types.IDENTITY );
          };
        
          Matrix4.translation = function( x, y, z ) {
            return new Matrix4(
              1, 0, 0, x,
              0, 1, 0, y,
              0, 0, 1, z,
              0, 0, 0, 1,
              Types.TRANSLATION_3D );
          };
        
          Matrix4.translationFromVector = function( v ) { return Matrix4.translation( v.x, v.y, v.z ); };
        
          Matrix4.scaling = function( x, y, z ) {
            // allow using one parameter to scale everything
            y = y === undefined ? x : y;
            z = z === undefined ? x : z;
        
            return new Matrix4(
              x, 0, 0, 0,
              0, y, 0, 0,
              0, 0, z, 0,
              0, 0, 0, 1,
              Types.SCALING );
          };
        
          // axis is a normalized Vector3, angle in radians.
          Matrix4.rotationAxisAngle = function( axis, angle ) {
            var c = Math.cos( angle );
            var s = Math.sin( angle );
            var C = 1 - c;
        
            return new Matrix4(
                axis.x * axis.x * C + c, axis.x * axis.y * C - axis.z * s, axis.x * axis.z * C + axis.y * s, 0,
                axis.y * axis.x * C + axis.z * s, axis.y * axis.y * C + c, axis.y * axis.z * C - axis.x * s, 0,
                axis.z * axis.x * C - axis.y * s, axis.z * axis.y * C + axis.x * s, axis.z * axis.z * C + c, 0,
              0, 0, 0, 1,
              Types.AFFINE );
          };
        
          // TODO: add in rotation from quaternion, and from quat + translation
        
          Matrix4.rotationX = function( angle ) {
            var c = Math.cos( angle );
            var s = Math.sin( angle );
        
            return new Matrix4(
              1, 0, 0, 0,
              0, c, -s, 0,
              0, s, c, 0,
              0, 0, 0, 1,
              Types.AFFINE );
          };
        
          Matrix4.rotationY = function( angle ) {
            var c = Math.cos( angle );
            var s = Math.sin( angle );
        
            return new Matrix4(
              c, 0, s, 0,
              0, 1, 0, 0,
              -s, 0, c, 0,
              0, 0, 0, 1,
              Types.AFFINE );
          };
        
          Matrix4.rotationZ = function( angle ) {
            var c = Math.cos( angle );
            var s = Math.sin( angle );
        
            return new Matrix4(
              c, -s, 0, 0,
              s, c, 0, 0,
              0, 0, 1, 0,
              0, 0, 0, 1,
              Types.AFFINE );
          };
        
          // aspect === width / height
          Matrix4.gluPerspective = function( fovYRadians, aspect, zNear, zFar ) {
            var cotangent = Math.cos( fovYRadians ) / Math.sin( fovYRadians );
        
            return new Matrix4(
                cotangent / aspect, 0, 0, 0,
              0, cotangent, 0, 0,
              0, 0, ( zFar + zNear ) / ( zNear - zFar ), ( 2 * zFar * zNear ) / ( zNear - zFar ),
              0, 0, -1, 0 );
          };
        
          Matrix4.prototype = {
            constructor: Matrix4,
        
            rowMajor: function( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type ) {
              this.entries[0] = v00;
              this.entries[1] = v10;
              this.entries[2] = v20;
              this.entries[3] = v30;
              this.entries[4] = v01;
              this.entries[5] = v11;
              this.entries[6] = v21;
              this.entries[7] = v31;
              this.entries[8] = v02;
              this.entries[9] = v12;
              this.entries[10] = v22;
              this.entries[11] = v32;
              this.entries[12] = v03;
              this.entries[13] = v13;
              this.entries[14] = v23;
              this.entries[15] = v33;
        
              // TODO: consider performance of the affine check here
              this.type = type === undefined ? ( ( v30 === 0 && v31 === 0 && v32 === 0 && v33 === 1 ) ? Types.AFFINE : Types.OTHER ) : type;
              return this;
            },
        
            columnMajor: function( v00, v10, v20, v30, v01, v11, v21, v31, v02, v12, v22, v32, v03, v13, v23, v33, type ) {
              return this.rowMajor( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type );
            },
        
            // convenience getters. inline usages of these when performance is critical? TODO: test performance of inlining these, with / without closure compiler
            m00: function() { return this.entries[0]; },
            m01: function() { return this.entries[4]; },
            m02: function() { return this.entries[8]; },
            m03: function() { return this.entries[12]; },
            m10: function() { return this.entries[1]; },
            m11: function() { return this.entries[5]; },
            m12: function() { return this.entries[9]; },
            m13: function() { return this.entries[13]; },
            m20: function() { return this.entries[2]; },
            m21: function() { return this.entries[6]; },
            m22: function() { return this.entries[10]; },
            m23: function() { return this.entries[14]; },
            m30: function() { return this.entries[3]; },
            m31: function() { return this.entries[7]; },
            m32: function() { return this.entries[11]; },
            m33: function() { return this.entries[15]; },
        
            isFinite: function() {
              return isFinite( this.m00() ) &&
                     isFinite( this.m01() ) &&
                     isFinite( this.m02() ) &&
                     isFinite( this.m03() ) &&
                     isFinite( this.m10() ) &&
                     isFinite( this.m11() ) &&
                     isFinite( this.m12() ) &&
                     isFinite( this.m13() ) &&
                     isFinite( this.m20() ) &&
                     isFinite( this.m21() ) &&
                     isFinite( this.m22() ) &&
                     isFinite( this.m23() ) &&
                     isFinite( this.m30() ) &&
                     isFinite( this.m31() ) &&
                     isFinite( this.m32() ) &&
                     isFinite( this.m33() );
            },
        
            // the 3D translation, assuming multiplication with a homogeneous vector
            getTranslation: function() {
              return new dot.Vector3( this.m03(), this.m13(), this.m23() );
            },
            get translation() { return this.getTranslation(); },
        
            // returns a vector that is equivalent to ( T(1,0,0).magnitude(), T(0,1,0).magnitude(), T(0,0,1).magnitude() )
            // where T is a relative transform
            getScaleVector: function() {
              var m0003 = this.m00() + this.m03();
              var m1013 = this.m10() + this.m13();
              var m2023 = this.m20() + this.m23();
              var m3033 = this.m30() + this.m33();
              var m0103 = this.m01() + this.m03();
              var m1113 = this.m11() + this.m13();
              var m2123 = this.m21() + this.m23();
              var m3133 = this.m31() + this.m33();
              var m0203 = this.m02() + this.m03();
              var m1213 = this.m12() + this.m13();
              var m2223 = this.m22() + this.m23();
              var m3233 = this.m32() + this.m33();
              return new dot.Vector3(
                Math.sqrt( m0003 * m0003 + m1013 * m1013 + m2023 * m2023 + m3033 * m3033 ),
                Math.sqrt( m0103 * m0103 + m1113 * m1113 + m2123 * m2123 + m3133 * m3133 ),
                Math.sqrt( m0203 * m0203 + m1213 * m1213 + m2223 * m2223 + m3233 * m3233 ) );
            },
            get scaleVector() { return this.getScaleVector(); },
        
            getCSSTransform: function() {
              // See http://www.w3.org/TR/css3-transforms/, particularly Section 13 that discusses the SVG compatibility
        
              // we need to prevent the numbers from being in an exponential toString form, since the CSS transform does not support that
              // 20 is the largest guaranteed number of digits according to https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed
        
              // the inner part of a CSS3 transform, but remember to add the browser-specific parts!
              // NOTE: the toFixed calls are inlined for performance reasons
              return 'matrix3d(' +
                     this.entries[0].toFixed( 20 ) + ',' +
                     this.entries[1].toFixed( 20 ) + ',' +
                     this.entries[2].toFixed( 20 ) + ',' +
                     this.entries[3].toFixed( 20 ) + ',' +
                     this.entries[4].toFixed( 20 ) + ',' +
                     this.entries[5].toFixed( 20 ) + ',' +
                     this.entries[6].toFixed( 20 ) + ',' +
                     this.entries[7].toFixed( 20 ) + ',' +
                     this.entries[8].toFixed( 20 ) + ',' +
                     this.entries[9].toFixed( 20 ) + ',' +
                     this.entries[10].toFixed( 20 ) + ',' +
                     this.entries[11].toFixed( 20 ) + ',' +
                     this.entries[12].toFixed( 20 ) + ',' +
                     this.entries[13].toFixed( 20 ) + ',' +
                     this.entries[14].toFixed( 20 ) + ',' +
                     this.entries[15].toFixed( 20 ) + ')';
            },
            get cssTransform() { return this.getCSSTransform(); },
        
            // exact equality
            equals: function( m ) {
              return this.m00() === m.m00() && this.m01() === m.m01() && this.m02() === m.m02() && this.m03() === m.m03() &&
                     this.m10() === m.m10() && this.m11() === m.m11() && this.m12() === m.m12() && this.m13() === m.m13() &&
                     this.m20() === m.m20() && this.m21() === m.m21() && this.m22() === m.m22() && this.m23() === m.m23() &&
                     this.m30() === m.m30() && this.m31() === m.m31() && this.m32() === m.m32() && this.m33() === m.m33();
            },
        
            // equality within a margin of error
            equalsEpsilon: function( m, epsilon ) {
              return Math.abs( this.m00() - m.m00() ) < epsilon &&
                     Math.abs( this.m01() - m.m01() ) < epsilon &&
                     Math.abs( this.m02() - m.m02() ) < epsilon &&
                     Math.abs( this.m03() - m.m03() ) < epsilon &&
                     Math.abs( this.m10() - m.m10() ) < epsilon &&
                     Math.abs( this.m11() - m.m11() ) < epsilon &&
                     Math.abs( this.m12() - m.m12() ) < epsilon &&
                     Math.abs( this.m13() - m.m13() ) < epsilon &&
                     Math.abs( this.m20() - m.m20() ) < epsilon &&
                     Math.abs( this.m21() - m.m21() ) < epsilon &&
                     Math.abs( this.m22() - m.m22() ) < epsilon &&
                     Math.abs( this.m23() - m.m23() ) < epsilon &&
                     Math.abs( this.m30() - m.m30() ) < epsilon &&
                     Math.abs( this.m31() - m.m31() ) < epsilon &&
                     Math.abs( this.m32() - m.m32() ) < epsilon &&
                     Math.abs( this.m33() - m.m33() ) < epsilon;
            },
        
            /*---------------------------------------------------------------------------*
            * Immutable operations (returning a new matrix)
            *----------------------------------------------------------------------------*/
        
            copy: function() {
              return new Matrix4(
                this.m00(), this.m01(), this.m02(), this.m03(),
                this.m10(), this.m11(), this.m12(), this.m13(),
                this.m20(), this.m21(), this.m22(), this.m23(),
                this.m30(), this.m31(), this.m32(), this.m33(),
                this.type
              );
            },
        
            plus: function( m ) {
              return new Matrix4(
                  this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(), this.m03() + m.m03(),
                  this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(), this.m13() + m.m13(),
                  this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22(), this.m23() + m.m23(),
                  this.m30() + m.m30(), this.m31() + m.m31(), this.m32() + m.m32(), this.m33() + m.m33()
              );
            },
        
            minus: function( m ) {
              return new Matrix4(
                  this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(), this.m03() - m.m03(),
                  this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(), this.m13() - m.m13(),
                  this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22(), this.m23() - m.m23(),
                  this.m30() - m.m30(), this.m31() - m.m31(), this.m32() - m.m32(), this.m33() - m.m33()
              );
            },
        
            transposed: function() {
              return new Matrix4(
                this.m00(), this.m10(), this.m20(), this.m30(),
                this.m01(), this.m11(), this.m21(), this.m31(),
                this.m02(), this.m12(), this.m22(), this.m32(),
                this.m03(), this.m13(), this.m23(), this.m33() );
            },
        
            negated: function() {
              return new Matrix4(
                -this.m00(), -this.m01(), -this.m02(), -this.m03(),
                -this.m10(), -this.m11(), -this.m12(), -this.m13(),
                -this.m20(), -this.m21(), -this.m22(), -this.m23(),
                -this.m30(), -this.m31(), -this.m32(), -this.m33() );
            },
        
            inverted: function() {
              switch( this.type ) {
                case Types.IDENTITY:
                  return this;
                case Types.TRANSLATION_3D:
                  return new Matrix4(
                    1, 0, 0, -this.m03(),
                    0, 1, 0, -this.m13(),
                    0, 0, 1, -this.m23(),
                    0, 0, 0, 1, Types.TRANSLATION_3D );
                case Types.SCALING:
                  return new Matrix4(
                      1 / this.m00(), 0, 0, 0,
                    0, 1 / this.m11(), 0, 0,
                    0, 0, 1 / this.m22(), 0,
                    0, 0, 0, 1 / this.m33(), Types.SCALING );
                case Types.AFFINE:
                case Types.OTHER:
                  var det = this.getDeterminant();
                  if ( det !== 0 ) {
                    return new Matrix4(
                        ( -this.m31() * this.m22() * this.m13() + this.m21() * this.m32() * this.m13() + this.m31() * this.m12() * this.m23() - this.m11() * this.m32() * this.m23() - this.m21() * this.m12() * this.m33() + this.m11() * this.m22() * this.m33() ) / det,
                        ( this.m31() * this.m22() * this.m03() - this.m21() * this.m32() * this.m03() - this.m31() * this.m02() * this.m23() + this.m01() * this.m32() * this.m23() + this.m21() * this.m02() * this.m33() - this.m01() * this.m22() * this.m33() ) / det,
                        ( -this.m31() * this.m12() * this.m03() + this.m11() * this.m32() * this.m03() + this.m31() * this.m02() * this.m13() - this.m01() * this.m32() * this.m13() - this.m11() * this.m02() * this.m33() + this.m01() * this.m12() * this.m33() ) / det,
                        ( this.m21() * this.m12() * this.m03() - this.m11() * this.m22() * this.m03() - this.m21() * this.m02() * this.m13() + this.m01() * this.m22() * this.m13() + this.m11() * this.m02() * this.m23() - this.m01() * this.m12() * this.m23() ) / det,
                        ( this.m30() * this.m22() * this.m13() - this.m20() * this.m32() * this.m13() - this.m30() * this.m12() * this.m23() + this.m10() * this.m32() * this.m23() + this.m20() * this.m12() * this.m33() - this.m10() * this.m22() * this.m33() ) / det,
                        ( -this.m30() * this.m22() * this.m03() + this.m20() * this.m32() * this.m03() + this.m30() * this.m02() * this.m23() - this.m00() * this.m32() * this.m23() - this.m20() * this.m02() * this.m33() + this.m00() * this.m22() * this.m33() ) / det,
                        ( this.m30() * this.m12() * this.m03() - this.m10() * this.m32() * this.m03() - this.m30() * this.m02() * this.m13() + this.m00() * this.m32() * this.m13() + this.m10() * this.m02() * this.m33() - this.m00() * this.m12() * this.m33() ) / det,
                        ( -this.m20() * this.m12() * this.m03() + this.m10() * this.m22() * this.m03() + this.m20() * this.m02() * this.m13() - this.m00() * this.m22() * this.m13() - this.m10() * this.m02() * this.m23() + this.m00() * this.m12() * this.m23() ) / det,
                        ( -this.m30() * this.m21() * this.m13() + this.m20() * this.m31() * this.m13() + this.m30() * this.m11() * this.m23() - this.m10() * this.m31() * this.m23() - this.m20() * this.m11() * this.m33() + this.m10() * this.m21() * this.m33() ) / det,
                        ( this.m30() * this.m21() * this.m03() - this.m20() * this.m31() * this.m03() - this.m30() * this.m01() * this.m23() + this.m00() * this.m31() * this.m23() + this.m20() * this.m01() * this.m33() - this.m00() * this.m21() * this.m33() ) / det,
                        ( -this.m30() * this.m11() * this.m03() + this.m10() * this.m31() * this.m03() + this.m30() * this.m01() * this.m13() - this.m00() * this.m31() * this.m13() - this.m10() * this.m01() * this.m33() + this.m00() * this.m11() * this.m33() ) / det,
                        ( this.m20() * this.m11() * this.m03() - this.m10() * this.m21() * this.m03() - this.m20() * this.m01() * this.m13() + this.m00() * this.m21() * this.m13() + this.m10() * this.m01() * this.m23() - this.m00() * this.m11() * this.m23() ) / det,
                        ( this.m30() * this.m21() * this.m12() - this.m20() * this.m31() * this.m12() - this.m30() * this.m11() * this.m22() + this.m10() * this.m31() * this.m22() + this.m20() * this.m11() * this.m32() - this.m10() * this.m21() * this.m32() ) / det,
                        ( -this.m30() * this.m21() * this.m02() + this.m20() * this.m31() * this.m02() + this.m30() * this.m01() * this.m22() - this.m00() * this.m31() * this.m22() - this.m20() * this.m01() * this.m32() + this.m00() * this.m21() * this.m32() ) / det,
                        ( this.m30() * this.m11() * this.m02() - this.m10() * this.m31() * this.m02() - this.m30() * this.m01() * this.m12() + this.m00() * this.m31() * this.m12() + this.m10() * this.m01() * this.m32() - this.m00() * this.m11() * this.m32() ) / det,
                        ( -this.m20() * this.m11() * this.m02() + this.m10() * this.m21() * this.m02() + this.m20() * this.m01() * this.m12() - this.m00() * this.m21() * this.m12() - this.m10() * this.m01() * this.m22() + this.m00() * this.m11() * this.m22() ) / det
                    );
                  }
                  else {
                    throw new Error( 'Matrix could not be inverted, determinant === 0' );
                  }
                  break; // because JSHint totally can't tell that this can't be reached
                default:
                  throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );
              }
            },
        
            timesMatrix: function( m ) {
              // I * M === M * I === I (the identity)
              if ( this.type === Types.IDENTITY || m.type === Types.IDENTITY ) {
                return this.type === Types.IDENTITY ? m : this;
              }
        
              if ( this.type === m.type ) {
                // currently two matrices of the same type will result in the same result type
                if ( this.type === Types.TRANSLATION_3D ) {
                  // faster combination of translations
                  return new Matrix4(
                    1, 0, 0, this.m03() + m.m02(),
                    0, 1, 0, this.m13() + m.m12(),
                    0, 0, 1, this.m23() + m.m23(),
                    0, 0, 0, 1, Types.TRANSLATION_3D );
                }
                else if ( this.type === Types.SCALING ) {
                  // faster combination of scaling
                  return new Matrix4(
                      this.m00() * m.m00(), 0, 0, 0,
                    0, this.m11() * m.m11(), 0, 0,
                    0, 0, this.m22() * m.m22(), 0,
                    0, 0, 0, 1, Types.SCALING );
                }
              }
        
              if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {
                // currently two matrices that are anything but "other" are technically affine, and the result will be affine
        
                // affine case
                return new Matrix4(
                    this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),
                    this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),
                    this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),
                    this.m00() * m.m03() + this.m01() * m.m13() + this.m02() * m.m23() + this.m03(),
                    this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),
                    this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),
                    this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),
                    this.m10() * m.m03() + this.m11() * m.m13() + this.m12() * m.m23() + this.m13(),
                    this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),
                    this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),
                    this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22(),
                    this.m20() * m.m03() + this.m21() * m.m13() + this.m22() * m.m23() + this.m23(),
                  0, 0, 0, 1, Types.AFFINE );
              }
        
              // general case
              return new Matrix4(
                  this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20() + this.m03() * m.m30(),
                  this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21() + this.m03() * m.m31(),
                  this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22() + this.m03() * m.m32(),
                  this.m00() * m.m03() + this.m01() * m.m13() + this.m02() * m.m23() + this.m03() * m.m33(),
                  this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20() + this.m13() * m.m30(),
                  this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21() + this.m13() * m.m31(),
                  this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22() + this.m13() * m.m32(),
                  this.m10() * m.m03() + this.m11() * m.m13() + this.m12() * m.m23() + this.m13() * m.m33(),
                  this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20() + this.m23() * m.m30(),
                  this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21() + this.m23() * m.m31(),
                  this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() + this.m23() * m.m32(),
                  this.m20() * m.m03() + this.m21() * m.m13() + this.m22() * m.m23() + this.m23() * m.m33(),
                  this.m30() * m.m00() + this.m31() * m.m10() + this.m32() * m.m20() + this.m33() * m.m30(),
                  this.m30() * m.m01() + this.m31() * m.m11() + this.m32() * m.m21() + this.m33() * m.m31(),
                  this.m30() * m.m02() + this.m31() * m.m12() + this.m32() * m.m22() + this.m33() * m.m32(),
                  this.m30() * m.m03() + this.m31() * m.m13() + this.m32() * m.m23() + this.m33() * m.m33() );
            },
        
            timesVector4: function( v ) {
              var x = this.m00() * v.x + this.m01() * v.y + this.m02() * v.z + this.m03() * v.w;
              var y = this.m10() * v.x + this.m11() * v.y + this.m12() * v.z + this.m13() * v.w;
              var z = this.m20() * v.x + this.m21() * v.y + this.m22() * v.z + this.m23() * v.w;
              var w = this.m30() * v.x + this.m31() * v.y + this.m32() * v.z + this.m33() * v.w;
              return new dot.Vector4( x, y, z, w );
            },
        
            timesVector3: function( v ) {
              return this.timesVector4( v.toVector4() ).toVector3();
            },
        
            timesTransposeVector4: function( v ) {
              var x = this.m00() * v.x + this.m10() * v.y + this.m20() * v.z + this.m30() * v.w;
              var y = this.m01() * v.x + this.m11() * v.y + this.m21() * v.z + this.m31() * v.w;
              var z = this.m02() * v.x + this.m12() * v.y + this.m22() * v.z + this.m32() * v.w;
              var w = this.m03() * v.x + this.m13() * v.y + this.m23() * v.z + this.m33() * v.w;
              return new dot.Vector4( x, y, z, w );
            },
        
            timesTransposeVector3: function( v ) {
              return this.timesTransposeVector4( v.toVector4() ).toVector3();
            },
        
            timesRelativeVector3: function( v ) {
              var x = this.m00() * v.x + this.m10() * v.y + this.m20() * v.z;
              var y = this.m01() * v.y + this.m11() * v.y + this.m21() * v.z;
              var z = this.m02() * v.z + this.m12() * v.y + this.m22() * v.z;
              return new dot.Vector3( x, y, z );
            },
        
            getDeterminant: function() {
              return this.m03() * this.m12() * this.m21() * this.m30() -
                     this.m02() * this.m13() * this.m21() * this.m30() -
                     this.m03() * this.m11() * this.m22() * this.m30() +
                     this.m01() * this.m13() * this.m22() * this.m30() +
                     this.m02() * this.m11() * this.m23() * this.m30() -
                     this.m01() * this.m12() * this.m23() * this.m30() -
                     this.m03() * this.m12() * this.m20() * this.m31() +
                     this.m02() * this.m13() * this.m20() * this.m31() +
                     this.m03() * this.m10() * this.m22() * this.m31() -
                     this.m00() * this.m13() * this.m22() * this.m31() -
                     this.m02() * this.m10() * this.m23() * this.m31() +
                     this.m00() * this.m12() * this.m23() * this.m31() +
                     this.m03() * this.m11() * this.m20() * this.m32() -
                     this.m01() * this.m13() * this.m20() * this.m32() -
                     this.m03() * this.m10() * this.m21() * this.m32() +
                     this.m00() * this.m13() * this.m21() * this.m32() +
                     this.m01() * this.m10() * this.m23() * this.m32() -
                     this.m00() * this.m11() * this.m23() * this.m32() -
                     this.m02() * this.m11() * this.m20() * this.m33() +
                     this.m01() * this.m12() * this.m20() * this.m33() +
                     this.m02() * this.m10() * this.m21() * this.m33() -
                     this.m00() * this.m12() * this.m21() * this.m33() -
                     this.m01() * this.m10() * this.m22() * this.m33() +
                     this.m00() * this.m11() * this.m22() * this.m33();
            },
            get determinant() { return this.getDeterminant(); },
        
            toString: function() {
              return this.m00() + " " + this.m01() + " " + this.m02() + " " + this.m03() + "\n" +
                     this.m10() + " " + this.m11() + " " + this.m12() + " " + this.m13() + "\n" +
                     this.m20() + " " + this.m21() + " " + this.m22() + " " + this.m23() + "\n" +
                     this.m30() + " " + this.m31() + " " + this.m32() + " " + this.m33();
            },
        
            makeImmutable: function() {
              this.rowMajor = function() {
                throw new Error( "Cannot modify immutable matrix" );
              };
            }
          };
        
          // create an immutable
          Matrix4.IDENTITY = new Matrix4();
          Matrix4.IDENTITY.makeImmutable();
        
          return Matrix4;
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * 3-dimensional Matrix
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'DOT/Matrix3',['require','DOT/dot','PHET_CORE/Poolable','DOT/Vector2','DOT/Vector3','DOT/Matrix4'],function( require ) {
          
        
          var dot = require( 'DOT/dot' );
          var Poolable = require( 'PHET_CORE/Poolable' );
        
          var FastArray = dot.FastArray;
        
          require( 'DOT/Vector2' );
          require( 'DOT/Vector3' );
          require( 'DOT/Matrix4' );
        
          var identityFastArray = new FastArray( 9 );
          identityFastArray[0] = 1;
          identityFastArray[4] = 1;
          identityFastArray[8] = 1;
        
          var createIdentityArray = FastArray === Array ?
                                    function() {
                                      return [1, 0, 0, 0, 1, 0, 0, 0, 1];
                                    } :
                                    function() {
                                      return new FastArray( identityFastArray );
                                    };
        
          //Create an identity matrix
          dot.Matrix3 = function Matrix3( argumentsShouldNotExist ) {
        
            //Make sure no clients are expecting to create a matrix with non-identity values
            assert && assert( !argumentsShouldNotExist, 'Matrix3 constructor should not be called with any arguments.  Use Matrix3.createFromPool()/Matrix3.identity()/etc.' );
        
            // entries stored in column-major format
            this.entries = createIdentityArray();
        
        //    this.rowMajor( v00 === undefined ? 1 : v00, v01 || 0, v02 || 0,
        //        v10 || 0, v11 === undefined ? 1 : v11, v12 || 0,
        //        v20 || 0, v21 || 0, v22 === undefined ? 1 : v22,
        //      type );
        
            phetAllocation && phetAllocation( 'Matrix3' );
            this.type = Types.IDENTITY;
          };
          var Matrix3 = dot.Matrix3;
        
          Matrix3.Types = {
            // NOTE: if an inverted matrix of a type is not that type, change inverted()!
            // NOTE: if two matrices with identical types are multiplied, the result should have the same type. if not, changed timesMatrix()!
            // NOTE: on adding a type, exaustively check all type usage
            OTHER: 0, // default
            IDENTITY: 1,
            TRANSLATION_2D: 2,
            SCALING: 3,
            AFFINE: 4
        
            // TODO: possibly add rotations
          };
        
          var Types = Matrix3.Types;
        
          Matrix3.identity = function() { return Matrix3.dirtyFromPool().setToIdentity(); };
          Matrix3.translation = function( x, y ) { return Matrix3.dirtyFromPool().setToTranslation( x, y ); };
          Matrix3.translationFromVector = function( v ) { return Matrix3.translation( v.x, v.y ); };
          Matrix3.scaling = function( x, y ) { return Matrix3.dirtyFromPool().setToScale( x, y ); };
          Matrix3.scale = Matrix3.scaling;
          Matrix3.affine = function( m00, m10, m01, m11, m02, m12 ) { return Matrix3.dirtyFromPool().setToAffine( m00, m01, m02, m10, m11, m12 ); };
          Matrix3.rowMajor = function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) { return Matrix3.dirtyFromPool().rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ); };
        
          // axis is a normalized Vector3, angle in radians.
          Matrix3.rotationAxisAngle = function( axis, angle ) { return Matrix3.dirtyFromPool().setToRotationAxisAngle( axis, angle ); };
        
          Matrix3.rotationX = function( angle ) { return Matrix3.dirtyFromPool().setToRotationX( angle ); };
          Matrix3.rotationY = function( angle ) { return Matrix3.dirtyFromPool().setToRotationY( angle ); };
          Matrix3.rotationZ = function( angle ) { return Matrix3.dirtyFromPool().setToRotationZ( angle ); };
        
          // standard 2d rotation
          Matrix3.rotation2 = Matrix3.rotationZ;
        
          Matrix3.rotationAround = function( angle, x, y ) {
            return Matrix3.translation( x, y ).timesMatrix( Matrix3.rotation2( angle ) ).timesMatrix( Matrix3.translation( -x, -y ) );
          };
        
          Matrix3.rotationAroundPoint = function( angle, point ) {
            return Matrix3.rotationAround( angle, point.x, point.y );
          };
        
          Matrix3.fromSVGMatrix = function( svgMatrix ) { return Matrix3.dirtyFromPool().setToSVGMatrix( svgMatrix ); };
        
          // a rotation matrix that rotates A to B, by rotating about the axis A.cross( B ) -- Shortest path. ideally should be unit vectors
          Matrix3.rotateAToB = function( a, b ) { return Matrix3.dirtyFromPool().setRotationAToB( a, b ); };
        
          Matrix3.prototype = {
            constructor: Matrix3,
        
            /*---------------------------------------------------------------------------*
            * "Properties"
            *----------------------------------------------------------------------------*/
        
            // convenience getters. inline usages of these when performance is critical? TODO: test performance of inlining these, with / without closure compiler
            m00: function() { return this.entries[0]; },
            m01: function() { return this.entries[3]; },
            m02: function() { return this.entries[6]; },
            m10: function() { return this.entries[1]; },
            m11: function() { return this.entries[4]; },
            m12: function() { return this.entries[7]; },
            m20: function() { return this.entries[2]; },
            m21: function() { return this.entries[5]; },
            m22: function() { return this.entries[8]; },
        
            isIdentity: function() {
              return this.type === Types.IDENTITY || this.equals( Matrix3.IDENTITY );
            },
        
            isAffine: function() {
              return this.type === Types.AFFINE || ( this.m20() === 0 && this.m21() === 0 && this.m22() === 1 );
            },
        
            // if it's an affine matrix where the components of transforms are independent
            // i.e. constructed from arbitrary component scaling and translation.
            isAligned: function() {
              // non-diagonal non-translation entries should all be zero.
              return this.isAffine() && this.m01() === 0 && this.m10() === 0;
            },
        
            // if it's an affine matrix where the components of transforms are independent, but may be switched (unlike isAligned)
            // i.e. the 2x2 rotational sub-matrix is of one of the two forms:
            // A 0  or  0  A
            // 0 B      B  0
            // This means that moving a transformed point by (x,0) or (0,y) will result in a motion along one of the axes.
            isAxisAligned: function() {
              return this.isAffine() && ( ( this.m01() === 0 && this.m10() === 0 ) || ( this.m00() === 0 && this.m11() === 0 ) );
            },
        
            isFinite: function() {
              return isFinite( this.m00() ) &&
                     isFinite( this.m01() ) &&
                     isFinite( this.m02() ) &&
                     isFinite( this.m10() ) &&
                     isFinite( this.m11() ) &&
                     isFinite( this.m12() ) &&
                     isFinite( this.m20() ) &&
                     isFinite( this.m21() ) &&
                     isFinite( this.m22() );
            },
        
            getDeterminant: function() {
              return this.m00() * this.m11() * this.m22() + this.m01() * this.m12() * this.m20() + this.m02() * this.m10() * this.m21() - this.m02() * this.m11() * this.m20() - this.m01() * this.m10() * this.m22() - this.m00() * this.m12() * this.m21();
            },
            get determinant() { return this.getDeterminant(); },
        
            // the 2D translation, assuming multiplication with a homogeneous vector
            getTranslation: function() {
              return new dot.Vector2( this.m02(), this.m12() );
            },
            get translation() { return this.getTranslation(); },
        
            // returns a vector that is equivalent to ( T(1,0).magnitude(), T(0,1).magnitude() ) where T is a relative transform
            getScaleVector: function() {
              return new dot.Vector2(
                Math.sqrt( this.m00() * this.m00() + this.m10() * this.m10() ),
                Math.sqrt( this.m01() * this.m01() + this.m11() * this.m11() ) );
            },
            get scaleVector() { return this.getScaleVector(); },
        
            // angle in radians for the 2d rotation from this matrix, between pi, -pi
            getRotation: function() {
              var transformedVector = this.timesVector2( dot.Vector2.X_UNIT ).minus( this.timesVector2( dot.Vector2.ZERO ) );
              return Math.atan2( transformedVector.y, transformedVector.x );
            },
            get rotation() { return this.getRotation(); },
        
            toMatrix4: function() {
              return new dot.Matrix4(
                this.m00(), this.m01(), this.m02(), 0,
                this.m10(), this.m11(), this.m12(), 0,
                this.m20(), this.m21(), this.m22(), 0,
                0, 0, 0, 1 );
            },
        
            toString: function() {
              return this.m00() + ' ' + this.m01() + ' ' + this.m02() + '\n' +
                     this.m10() + ' ' + this.m11() + ' ' + this.m12() + '\n' +
                     this.m20() + ' ' + this.m21() + ' ' + this.m22();
            },
        
            toSVGMatrix: function() {
              var result = document.createElementNS( 'http://www.w3.org/2000/svg', 'svg' ).createSVGMatrix();
        
              // top two rows
              result.a = this.m00();
              result.b = this.m10();
              result.c = this.m01();
              result.d = this.m11();
              result.e = this.m02();
              result.f = this.m12();
        
              return result;
            },
        
            getCSSTransform: function() {
              // See http://www.w3.org/TR/css3-transforms/, particularly Section 13 that discusses the SVG compatibility
        
              // we need to prevent the numbers from being in an exponential toString form, since the CSS transform does not support that
              // 20 is the largest guaranteed number of digits according to https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed
        
              // the inner part of a CSS3 transform, but remember to add the browser-specific parts!
              // NOTE: the toFixed calls are inlined for performance reasons
              return 'matrix(' + this.entries[0].toFixed( 20 ) + ',' + this.entries[1].toFixed( 20 ) + ',' + this.entries[3].toFixed( 20 ) + ',' + this.entries[4].toFixed( 20 ) + ',' + this.entries[6].toFixed( 20 ) + ',' + this.entries[7].toFixed( 20 ) + ')';
            },
            get cssTransform() { return this.getCSSTransform(); },
        
            getSVGTransform: function() {
              // SVG transform presentation attribute. See http://www.w3.org/TR/SVG/coords.html#TransformAttribute
        
              // we need to prevent the numbers from being in an exponential toString form, since the CSS transform does not support that
              function svgNumber( number ) {
                // largest guaranteed number of digits according to https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed
                return number.toFixed( 20 );
              }
        
              switch( this.type ) {
                case Types.IDENTITY:
                  return '';
                case Types.TRANSLATION_2D:
                  return 'translate(' + svgNumber( this.entries[6] ) + ',' + svgNumber( this.entries[7] ) + ')';
                case Types.SCALING:
                  return 'scale(' + svgNumber( this.entries[0] ) + ( this.entries[0] === this.entries[4] ? '' : ',' + svgNumber( this.entries[4] ) ) + ')';
                default:
                  return 'matrix(' + svgNumber( this.entries[0] ) + ',' + svgNumber( this.entries[1] ) + ',' + svgNumber( this.entries[3] ) + ',' + svgNumber( this.entries[4] ) + ',' + svgNumber( this.entries[6] ) + ',' + svgNumber( this.entries[7] ) + ')';
              }
            },
            get svgTransform() { return this.getSVGTransform(); },
        
            // returns a parameter object suitable for use with jQuery's .css()
            getCSSTransformStyles: function() {
              var transformCSS = this.getCSSTransform();
        
              // notes on triggering hardware acceleration: http://creativejs.com/2011/12/day-2-gpu-accelerate-your-dom-elements/
              return {
                // force iOS hardware acceleration
                '-webkit-perspective': 1000,
                '-webkit-backface-visibility': 'hidden',
        
                '-webkit-transform': transformCSS + ' translateZ(0)', // trigger hardware acceleration if possible
                '-moz-transform': transformCSS + ' translateZ(0)', // trigger hardware acceleration if possible
                '-ms-transform': transformCSS,
                '-o-transform': transformCSS,
                'transform': transformCSS,
                'transform-origin': 'top left', // at the origin of the component. consider 0px 0px instead. Critical, since otherwise this defaults to 50% 50%!!! see https://developer.mozilla.org/en-US/docs/CSS/transform-origin
                '-ms-transform-origin': 'top left' // TODO: do we need other platform-specific transform-origin styles?
              };
            },
            get cssTransformStyles() { return this.getCSSTransformStyles(); },
        
            // exact equality
            equals: function( m ) {
              return this.m00() === m.m00() && this.m01() === m.m01() && this.m02() === m.m02() &&
                     this.m10() === m.m10() && this.m11() === m.m11() && this.m12() === m.m12() &&
                     this.m20() === m.m20() && this.m21() === m.m21() && this.m22() === m.m22();
            },
        
            // equality within a margin of error
            equalsEpsilon: function( m, epsilon ) {
              return Math.abs( this.m00() - m.m00() ) < epsilon && Math.abs( this.m01() - m.m01() ) < epsilon && Math.abs( this.m02() - m.m02() ) < epsilon &&
                     Math.abs( this.m10() - m.m10() ) < epsilon && Math.abs( this.m11() - m.m11() ) < epsilon && Math.abs( this.m12() - m.m12() ) < epsilon &&
                     Math.abs( this.m20() - m.m20() ) < epsilon && Math.abs( this.m21() - m.m21() ) < epsilon && Math.abs( this.m22() - m.m22() ) < epsilon;
            },
        
            /*---------------------------------------------------------------------------*
            * Immutable operations (returns a new matrix)
            *----------------------------------------------------------------------------*/
        
            copy: function() {
              return Matrix3.createFromPool(
                this.m00(), this.m01(), this.m02(),
                this.m10(), this.m11(), this.m12(),
                this.m20(), this.m21(), this.m22(),
                this.type
              );
            },
        
            plus: function( m ) {
              return Matrix3.createFromPool(
                  this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(),
                  this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(),
                  this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22()
              );
            },
        
            minus: function( m ) {
              return Matrix3.createFromPool(
                  this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(),
                  this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(),
                  this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22()
              );
            },
        
            transposed: function() {
              return Matrix3.createFromPool(
                this.m00(), this.m10(), this.m20(),
                this.m01(), this.m11(), this.m21(),
                this.m02(), this.m12(), this.m22(), ( this.type === Types.IDENTITY || this.type === Types.SCALING ) ? this.type : undefined
              );
            },
        
            negated: function() {
              return Matrix3.createFromPool(
                -this.m00(), -this.m01(), -this.m02(),
                -this.m10(), -this.m11(), -this.m12(),
                -this.m20(), -this.m21(), -this.m22()
              );
            },
        
            inverted: function() {
              var det;
        
              switch( this.type ) {
                case Types.IDENTITY:
                  return this;
                case Types.TRANSLATION_2D:
                  return Matrix3.createFromPool(
                    1, 0, -this.m02(),
                    0, 1, -this.m12(),
                    0, 0, 1, Types.TRANSLATION_2D );
                case Types.SCALING:
                  return Matrix3.createFromPool(
                      1 / this.m00(), 0, 0,
                    0, 1 / this.m11(), 0,
                    0, 0, 1 / this.m22(), Types.SCALING );
                case Types.AFFINE:
                  det = this.getDeterminant();
                  if ( det !== 0 ) {
                    return Matrix3.createFromPool(
                        ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,
                        ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,
                        ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,
                        ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,
                        ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,
                        ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,
                      0, 0, 1, Types.AFFINE
                    );
                  }
                  else {
                    throw new Error( 'Matrix could not be inverted, determinant === 0' );
                  }
                  break; // because JSHint totally can't tell that this can't be reached
                case Types.OTHER:
                  det = this.getDeterminant();
                  if ( det !== 0 ) {
                    return Matrix3.createFromPool(
                        ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,
                        ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,
                        ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,
                        ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,
                        ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,
                        ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,
                        ( -this.m11() * this.m20() + this.m10() * this.m21() ) / det,
                        ( this.m01() * this.m20() - this.m00() * this.m21() ) / det,
                        ( -this.m01() * this.m10() + this.m00() * this.m11() ) / det,
                      Types.OTHER
                    );
                  }
                  else {
                    throw new Error( 'Matrix could not be inverted, determinant === 0' );
                  }
                  break; // because JSHint totally can't tell that this can't be reached
                default:
                  throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );
              }
            },
        
            timesMatrix: function( m ) {
              // I * M === M * I === M (the identity)
              if ( this.type === Types.IDENTITY || m.type === Types.IDENTITY ) {
                return this.type === Types.IDENTITY ? m : this;
              }
        
              if ( this.type === m.type ) {
                // currently two matrices of the same type will result in the same result type
                if ( this.type === Types.TRANSLATION_2D ) {
                  // faster combination of translations
                  return Matrix3.createFromPool(
                    1, 0, this.m02() + m.m02(),
                    0, 1, this.m12() + m.m12(),
                    0, 0, 1, Types.TRANSLATION_2D );
                }
                else if ( this.type === Types.SCALING ) {
                  // faster combination of scaling
                  return Matrix3.createFromPool(
                      this.m00() * m.m00(), 0, 0,
                    0, this.m11() * m.m11(), 0,
                    0, 0, 1, Types.SCALING );
                }
              }
        
              if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {
                // currently two matrices that are anything but "other" are technically affine, and the result will be affine
        
                // affine case
                return Matrix3.createFromPool(
                    this.m00() * m.m00() + this.m01() * m.m10(),
                    this.m00() * m.m01() + this.m01() * m.m11(),
                    this.m00() * m.m02() + this.m01() * m.m12() + this.m02(),
                    this.m10() * m.m00() + this.m11() * m.m10(),
                    this.m10() * m.m01() + this.m11() * m.m11(),
                    this.m10() * m.m02() + this.m11() * m.m12() + this.m12(),
                  0, 0, 1, Types.AFFINE );
              }
        
              // general case
              return Matrix3.createFromPool(
                  this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),
                  this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),
                  this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),
                  this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),
                  this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),
                  this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),
                  this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),
                  this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),
                  this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() );
            },
        
            /*---------------------------------------------------------------------------*
            * Immutable operations (returns new form of a parameter)
            *----------------------------------------------------------------------------*/
        
            timesVector2: function( v ) {
              var x = this.m00() * v.x + this.m01() * v.y + this.m02();
              var y = this.m10() * v.x + this.m11() * v.y + this.m12();
              return new dot.Vector2( x, y );
            },
        
            timesVector3: function( v ) {
              var x = this.m00() * v.x + this.m01() * v.y + this.m02() * v.z;
              var y = this.m10() * v.x + this.m11() * v.y + this.m12() * v.z;
              var z = this.m20() * v.x + this.m21() * v.y + this.m22() * v.z;
              return new dot.Vector3( x, y, z );
            },
        
            timesTransposeVector2: function( v ) {
              var x = this.m00() * v.x + this.m10() * v.y;
              var y = this.m01() * v.x + this.m11() * v.y;
              return new dot.Vector2( x, y );
            },
        
            // TODO: this operation seems to not work for transformDelta2, should be vetted
            timesRelativeVector2: function( v ) {
              var x = this.m00() * v.x + this.m01() * v.y;
              var y = this.m10() * v.y + this.m11() * v.y;
              return new dot.Vector2( x, y );
            },
        
            /*---------------------------------------------------------------------------*
            * Mutable operations (changes this matrix)
            *----------------------------------------------------------------------------*/
        
            // every mutable method goes through rowMajor
            rowMajor: function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {
              this.entries[0] = v00;
              this.entries[1] = v10;
              this.entries[2] = v20;
              this.entries[3] = v01;
              this.entries[4] = v11;
              this.entries[5] = v21;
              this.entries[6] = v02;
              this.entries[7] = v12;
              this.entries[8] = v22;
        
              // TODO: consider performance of the affine check here
              this.type = type === undefined ? ( ( v20 === 0 && v21 === 0 && v22 === 1 ) ? Types.AFFINE : Types.OTHER ) : type;
              return this;
            },
        
            set: function( matrix ) {
              return this.rowMajor(
                matrix.m00(), matrix.m01(), matrix.m02(),
                matrix.m10(), matrix.m11(), matrix.m12(),
                matrix.m20(), matrix.m21(), matrix.m22(),
                matrix.type );
            },
        
            makeImmutable: function() {
              this.rowMajor = function() {
                throw new Error( 'Cannot modify immutable matrix' );
              };
              return this;
            },
        
            columnMajor: function( v00, v10, v20, v01, v11, v21, v02, v12, v22, type ) {
              return this.rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type );
            },
        
            add: function( m ) {
              return this.rowMajor(
                  this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(),
                  this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(),
                  this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22()
              );
            },
        
            subtract: function( m ) {
              return this.rowMajor(
                  this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(),
                  this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(),
                  this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22()
              );
            },
        
            transpose: function() {
              return this.rowMajor(
                this.m00(), this.m10(), this.m20(),
                this.m01(), this.m11(), this.m21(),
                this.m02(), this.m12(), this.m22(),
                ( this.type === Types.IDENTITY || this.type === Types.SCALING ) ? this.type : undefined
              );
            },
        
            negate: function() {
              return this.rowMajor(
                -this.m00(), -this.m01(), -this.m02(),
                -this.m10(), -this.m11(), -this.m12(),
                -this.m20(), -this.m21(), -this.m22()
              );
            },
        
            invert: function() {
              var det;
        
              switch( this.type ) {
                case Types.IDENTITY:
                  return this;
                case Types.TRANSLATION_2D:
                  return this.rowMajor(
                    1, 0, -this.m02(),
                    0, 1, -this.m12(),
                    0, 0, 1, Types.TRANSLATION_2D );
                case Types.SCALING:
                  return this.rowMajor(
                      1 / this.m00(), 0, 0,
                    0, 1 / this.m11(), 0,
                    0, 0, 1 / this.m22(), Types.SCALING );
                case Types.AFFINE:
                  det = this.getDeterminant();
                  if ( det !== 0 ) {
                    return this.rowMajor(
                        ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,
                        ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,
                        ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,
                        ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,
                        ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,
                        ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,
                      0, 0, 1, Types.AFFINE
                    );
                  }
                  else {
                    throw new Error( 'Matrix could not be inverted, determinant === 0' );
                  }
                  break; // because JSHint totally can't tell that this can't be reached
                case Types.OTHER:
                  det = this.getDeterminant();
                  if ( det !== 0 ) {
                    return this.rowMajor(
                        ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,
                        ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,
                        ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,
                        ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,
                        ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,
                        ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,
                        ( -this.m11() * this.m20() + this.m10() * this.m21() ) / det,
                        ( this.m01() * this.m20() - this.m00() * this.m21() ) / det,
                        ( -this.m01() * this.m10() + this.m00() * this.m11() ) / det,
                      Types.OTHER
                    );
                  }
                  else {
                    throw new Error( 'Matrix could not be inverted, determinant === 0' );
                  }
                  break; // because JSHint totally can't tell that this can't be reached
                default:
                  throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );
              }
            },
        
            multiplyMatrix: function( m ) {
              // M * I === M (the identity)
              if ( m.type === Types.IDENTITY ) {
                // no change needed
                return this;
              }
        
              // I * M === M (the identity)
              if ( this.type === Types.IDENTITY ) {
                // copy the other matrix to us
                return this.set( m );
              }
        
              if ( this.type === m.type ) {
                // currently two matrices of the same type will result in the same result type
                if ( this.type === Types.TRANSLATION_2D ) {
                  // faster combination of translations
                  return this.rowMajor(
                    1, 0, this.m02() + m.m02(),
                    0, 1, this.m12() + m.m12(),
                    0, 0, 1, Types.TRANSLATION_2D );
                }
                else if ( this.type === Types.SCALING ) {
                  // faster combination of scaling
                  return this.rowMajor(
                      this.m00() * m.m00(), 0, 0,
                    0, this.m11() * m.m11(), 0,
                    0, 0, 1, Types.SCALING );
                }
              }
        
              if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {
                // currently two matrices that are anything but "other" are technically affine, and the result will be affine
        
                // affine case
                return this.rowMajor(
                    this.m00() * m.m00() + this.m01() * m.m10(),
                    this.m00() * m.m01() + this.m01() * m.m11(),
                    this.m00() * m.m02() + this.m01() * m.m12() + this.m02(),
                    this.m10() * m.m00() + this.m11() * m.m10(),
                    this.m10() * m.m01() + this.m11() * m.m11(),
                    this.m10() * m.m02() + this.m11() * m.m12() + this.m12(),
                  0, 0, 1, Types.AFFINE );
              }
        
              // general case
              return this.rowMajor(
                  this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),
                  this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),
                  this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),
                  this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),
                  this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),
                  this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),
                  this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),
                  this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),
                  this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() );
            },
        
            setToIdentity: function() {
              return this.rowMajor(
                1, 0, 0,
                0, 1, 0,
                0, 0, 1,
                Types.IDENTITY );
            },
        
            setToTranslation: function( x, y ) {
              return this.rowMajor(
                1, 0, x,
                0, 1, y,
                0, 0, 1,
                Types.TRANSLATION_2D );
            },
        
            setToScale: function( x, y ) {
              // allow using one parameter to scale everything
              y = y === undefined ? x : y;
        
              return this.rowMajor(
                x, 0, 0,
                0, y, 0,
                0, 0, 1,
                Types.SCALING );
            },
        
            // row major
            setToAffine: function( m00, m01, m02, m10, m11, m12 ) {
              return this.rowMajor( m00, m01, m02, m10, m11, m12, 0, 0, 1, Types.AFFINE );
            },
        
            // axis is a normalized Vector3, angle in radians.
            setToRotationAxisAngle: function( axis, angle ) {
              var c = Math.cos( angle );
              var s = Math.sin( angle );
              var C = 1 - c;
        
              return this.rowMajor(
                  axis.x * axis.x * C + c, axis.x * axis.y * C - axis.z * s, axis.x * axis.z * C + axis.y * s,
                  axis.y * axis.x * C + axis.z * s, axis.y * axis.y * C + c, axis.y * axis.z * C - axis.x * s,
                  axis.z * axis.x * C - axis.y * s, axis.z * axis.y * C + axis.x * s, axis.z * axis.z * C + c,
                Types.OTHER );
            },
        
            setToRotationX: function( angle ) {
              var c = Math.cos( angle );
              var s = Math.sin( angle );
        
              return this.rowMajor(
                1, 0, 0,
                0, c, -s,
                0, s, c,
                Types.OTHER );
            },
        
            setToRotationY: function( angle ) {
              var c = Math.cos( angle );
              var s = Math.sin( angle );
        
              return this.rowMajor(
                c, 0, s,
                0, 1, 0,
                -s, 0, c,
                Types.OTHER );
            },
        
            setToRotationZ: function( angle ) {
              var c = Math.cos( angle );
              var s = Math.sin( angle );
        
              return this.rowMajor(
                c, -s, 0,
                s, c, 0,
                0, 0, 1,
                Types.AFFINE );
            },
        
            setToSVGMatrix: function( svgMatrix ) {
              return this.rowMajor(
                svgMatrix.a, svgMatrix.c, svgMatrix.e,
                svgMatrix.b, svgMatrix.d, svgMatrix.f,
                0, 0, 1,
                Types.AFFINE );
            },
        
            // a rotation matrix that rotates A to B (Vector3 instances), by rotating about the axis A.cross( B ) -- Shortest path. ideally should be unit vectors
            setRotationAToB: function( a, b ) {
              // see http://graphics.cs.brown.edu/~jfh/papers/Moller-EBA-1999/paper.pdf for information on this implementation
              var start = a;
              var end = b;
        
              var epsilon = 0.0001;
        
              var e, h, f;
        
              var v = start.cross( end );
              e = start.dot( end );
              f = ( e < 0 ) ? -e : e;
        
              // if "from" and "to" vectors are nearly parallel
              if ( f > 1.0 - epsilon ) {
                var c1, c2, c3;
        
                var x = new dot.Vector3(
                  ( start.x > 0.0 ) ? start.x : -start.x,
                  ( start.y > 0.0 ) ? start.y : -start.y,
                  ( start.z > 0.0 ) ? start.z : -start.z
                );
        
                if ( x.x < x.y ) {
                  if ( x.x < x.z ) {
                    x = dot.Vector3.X_UNIT;
                  }
                  else {
                    x = dot.Vector3.Z_UNIT;
                  }
                }
                else {
                  if ( x.y < x.z ) {
                    x = dot.Vector3.Y_UNIT;
                  }
                  else {
                    x = dot.Vector3.Z_UNIT;
                  }
                }
        
                var u = x.minus( start );
                v = x.minus( end );
        
                c1 = 2.0 / u.dot( u );
                c2 = 2.0 / v.dot( v );
                c3 = c1 * c2 * u.dot( v );
        
                return this.rowMajor(
                    -c1 * u.x * u.x - c2 * v.x * v.x + c3 * v.x * u.x + 1,
                    -c1 * u.x * u.y - c2 * v.x * v.y + c3 * v.x * u.y,
                    -c1 * u.x * u.z - c2 * v.x * v.z + c3 * v.x * u.z,
                    -c1 * u.y * u.x - c2 * v.y * v.x + c3 * v.y * u.x,
                    -c1 * u.y * u.y - c2 * v.y * v.y + c3 * v.y * u.y + 1,
                    -c1 * u.y * u.z - c2 * v.y * v.z + c3 * v.y * u.z,
                    -c1 * u.z * u.x - c2 * v.z * v.x + c3 * v.z * u.x,
                    -c1 * u.z * u.y - c2 * v.z * v.y + c3 * v.z * u.y,
                    -c1 * u.z * u.z - c2 * v.z * v.z + c3 * v.z * u.z + 1
                );
              }
              else {
                // the most common case, unless "start"="end", or "start"=-"end"
                var hvx, hvz, hvxy, hvxz, hvyz;
                h = 1.0 / ( 1.0 + e );
                hvx = h * v.x;
                hvz = h * v.z;
                hvxy = hvx * v.y;
                hvxz = hvx * v.z;
                hvyz = hvz * v.y;
        
                return this.rowMajor(
                    e + hvx * v.x, hvxy - v.z, hvxz + v.y,
                    hvxy + v.z, e + h * v.y * v.y, hvyz - v.x,
                    hvxz - v.y, hvyz + v.x, e + hvz * v.z
                );
              }
            },
        
            /*---------------------------------------------------------------------------*
            * Mutable operations (changes the parameter)
            *----------------------------------------------------------------------------*/
        
            multiplyVector2: function( v ) {
              return v.setXY(
                  this.m00() * v.x + this.m01() * v.y + this.m02(),
                  this.m10() * v.x + this.m11() * v.y + this.m12() );
            },
        
            multiplyVector3: function( v ) {
              return v.setXYZ(
                  this.m00() * v.x + this.m01() * v.y + this.m02() * v.z,
                  this.m10() * v.x + this.m11() * v.y + this.m12() * v.z,
                  this.m20() * v.x + this.m21() * v.y + this.m22() * v.z );
            },
        
            multiplyTransposeVector2: function( v ) {
              return v.setXY(
                  this.m00() * v.x + this.m10() * v.y,
                  this.m01() * v.x + this.m11() * v.y );
            },
        
            multiplyRelativeVector2: function( v ) {
              return v.setXY(
                  this.m00() * v.x + this.m01() * v.y,
                  this.m10() * v.y + this.m11() * v.y );
            },
        
            // sets the transform of a Canvas 2D rendering context to the affine part of this matrix
            canvasSetTransform: function( context ) {
              context.setTransform(
                // inlined array entries
                this.entries[0],
                this.entries[1],
                this.entries[3],
                this.entries[4],
                this.entries[6],
                this.entries[7]
              );
            },
        
            // appends the affine part of this matrix to the Canvas 2D rendering context
            canvasAppendTransform: function( context ) {
              if ( this.type !== Types.IDENTITY ) {
                context.transform(
                  // inlined array entries
                  this.entries[0],
                  this.entries[1],
                  this.entries[3],
                  this.entries[4],
                  this.entries[6],
                  this.entries[7]
                );
              }
            }
          };
        
          /* jshint -W064 */
          Poolable( Matrix3, {
        
            //The default factory creates an identity matrix
            defaultFactory: function() { return new Matrix3(); },
        
            constructorDuplicateFactory: function( pool ) {
              return function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {
                var instance = pool.length ? pool.pop() : new Matrix3();
                return instance.rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type );
              };
            }
          } );
        
          // create an immutable
          Matrix3.IDENTITY = Matrix3.identity();
          Matrix3.IDENTITY.makeImmutable();
        
          Matrix3.X_REFLECTION = Matrix3.createFromPool( -1, 0, 0,
            0, 1, 0,
            0, 0, 1,
            Types.AFFINE );
          Matrix3.X_REFLECTION.makeImmutable();
        
          Matrix3.Y_REFLECTION = Matrix3.createFromPool( 1, 0, 0,
            0, -1, 0,
            0, 0, 1,
            Types.AFFINE );
          Matrix3.Y_REFLECTION.makeImmutable();
        
          //Shortcut for translation times a matrix (without allocating a translation matrix), see scenery#119
          Matrix3.translationTimesMatrix = function( x, y, m ) {
            var type;
            if ( m.type === Types.IDENTITY || m.type === Types.TRANSLATION_2D ) {
              return Matrix3.createFromPool(
                1, 0, m.m02() + x,
                0, 1, m.m12() + y,
                0, 0, 1,
                Types.TRANSLATION_2D );
            }
            else if ( m.type === Types.OTHER ) {
              type = Types.OTHER;
            }
            else {
              type = Types.AFFINE;
            }
            return Matrix3.createFromPool( m.m00(), m.m01(), m.m02() + x,
              m.m10(), m.m11(), m.m12() + y,
              m.m20(), m.m21(), m.m22(),
              type );
          };
        
          Matrix3.printer = {
            print: function( matrix ) {
              console.log( matrix.toString() );
            }
          };
        
          return Matrix3;
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * 2-dimensional ray
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'DOT/Ray2',['require','DOT/dot'],function( require ) {
          
        
          var dot = require( 'DOT/dot' );
        
          dot.Ray2 = function Ray2( pos, dir ) {
            this.pos = pos;
            this.dir = dir;
        
            assert && assert( Math.abs( dir.magnitude() - 1 ) < 0.01 );
        
            phetAllocation && phetAllocation( 'Ray2' );
          };
          var Ray2 = dot.Ray2;
        
          Ray2.prototype = {
            constructor: Ray2,
        
            shifted: function( distance ) {
              return new Ray2( this.pointAtDistance( distance ), this.dir );
            },
        
            pointAtDistance: function( distance ) {
              return this.pos.plus( this.dir.timesScalar( distance ) );
            },
        
            toString: function() {
              return this.pos.toString() + " => " + this.dir.toString();
            }
          };
        
          return Ray2;
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Forward and inverse transforms with 3x3 matrices
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'DOT/Transform3',['require','DOT/dot','DOT/Matrix3','DOT/Vector2','DOT/Ray2'],function( require ) {
          
        
          var dot = require( 'DOT/dot' );
        
          require( 'DOT/Matrix3' );
          require( 'DOT/Vector2' );
          require( 'DOT/Ray2' );
        
          // takes a 4x4 matrix
          dot.Transform3 = function Transform3( matrix ) {
            this.listeners = [];
        
            // using immutable version for now. change it to the mutable identity copy if we need mutable operations on the matrices
            this.setMatrix( matrix === undefined ? dot.Matrix3.IDENTITY : matrix );
        
            phetAllocation && phetAllocation( 'Transform3' );
          };
          var Transform3 = dot.Transform3;
        
          Transform3.prototype = {
            constructor: Transform3,
        
            /*---------------------------------------------------------------------------*
            * mutators
            *----------------------------------------------------------------------------*/
        
            setMatrix: function( matrix ) {
              // TODO: performance: don't notify or handle instances where the matrix is detected to be the identity matrix?
              assert && assert( matrix instanceof dot.Matrix3 );
        
              assert && assert( matrix.isFinite(), 'Matrix was suspicious' );
        
              //Temporary solution: if the programmer tried to set the top, bottom, etc of a node without defined bounds, do a no-op
              //In the future, this should be replaced with the assertion above, once we have tested that everything is working properly
              if ( !matrix.isFinite() ) {
                return;
              }
        
              var oldMatrix = this.matrix;
              var length = this.listeners.length;
              var i;
        
              // notify listeners before the change
              for ( i = 0; i < length; i++ ) {
                this.listeners[i].before( matrix, oldMatrix );
              }
        
              this.matrix = matrix;
        
              // compute these lazily
              this.inverse = null;
              this.matrixTransposed = null;
              this.inverseTransposed = null;
        
              // notify listeners after the change
              for ( i = 0; i < length; i++ ) {
                this.listeners[i].after( matrix, oldMatrix );
              }
            },
        
            prepend: function( matrix ) {
              this.setMatrix( matrix.timesMatrix( this.matrix ) );
            },
        
            //Simpler case of prepending a translation without having to allocate a matrix for it, see scenery#119
            prependTranslation: function( x, y ) {
              this.setMatrix( dot.Matrix3.translationTimesMatrix( x, y, this.matrix ) );
            },
        
            append: function( matrix ) {
              this.setMatrix( this.matrix.timesMatrix( matrix ) );
            },
        
            prependTransform: function( transform ) {
              this.prepend( transform.matrix );
            },
        
            appendTransform: function( transform ) {
              this.append( transform.matrix );
            },
        
            applyToCanvasContext: function( context ) {
              context.setTransform( this.matrix.m00(), this.matrix.m10(), this.matrix.m01(), this.matrix.m11(), this.matrix.m02(), this.matrix.m12() );
            },
        
            /*---------------------------------------------------------------------------*
            * getters
            *----------------------------------------------------------------------------*/
        
            // uses the same matrices, for use cases where the matrices are considered immutable
            copy: function() {
              var transform = new Transform3( this.matrix );
              transform.inverse = this.inverse;
              transform.matrixTransposed = this.matrixTransposed;
              transform.inverseTransposed = this.inverseTransposed;
            },
        
            // copies matrices, for use cases where the matrices are considered mutable
            deepCopy: function() {
              var transform = new Transform3( this.matrix.copy() );
              transform.inverse = this.inverse ? this.inverse.copy() : null;
              transform.matrixTransposed = this.matrixTransposed ? this.matrixTransposed.copy() : null;
              transform.inverseTransposed = this.inverseTransposed ? this.inverseTransposed.copy() : null;
            },
        
            getMatrix: function() {
              return this.matrix;
            },
        
            getInverse: function() {
              if ( this.inverse === null ) {
                this.inverse = this.matrix.inverted();
              }
              return this.inverse;
            },
        
            getMatrixTransposed: function() {
              if ( this.matrixTransposed === null ) {
                this.matrixTransposed = this.matrix.transposed();
              }
              return this.matrixTransposed;
            },
        
            getInverseTransposed: function() {
              if ( this.inverseTransposed === null ) {
                this.inverseTransposed = this.getInverse().transposed();
              }
              return this.inverseTransposed;
            },
        
            isIdentity: function() {
              return this.matrix.type === dot.Matrix3.Types.IDENTITY;
            },
        
            isFinite: function() {
              return this.matrix.isFinite();
            },
        
            /*---------------------------------------------------------------------------*
             * forward transforms (for Vector2 or scalar)
             *----------------------------------------------------------------------------*/
        
            // transform a position (includes translation)
            transformPosition2: function( vec2 ) {
              return this.matrix.timesVector2( vec2 );
            },
        
            // transform a vector (exclude translation)
            transformDelta2: function( vec2 ) {
              var m = this.getMatrix();
              // m . vec2 - m . Vector2.ZERO
              return new dot.Vector2( m.m00() * vec2.x + m.m01() * vec2.y, m.m10() * vec2.x + m.m11() * vec2.y );
            },
        
            // transform a normal vector (different than a normal vector)
            transformNormal2: function( vec2 ) {
              return this.getInverse().timesTransposeVector2( vec2 );
            },
        
            transformX: function( x ) {
              var m = this.getMatrix();
              // TODO: ensure assertions are stripped out
              assert && assert( !m.m01(), 'Transforming an X value with a rotation/shear is ill-defined' );
              return m.m00() * x + m.m02();
            },
        
            transformY: function( y ) {
              var m = this.getMatrix();
              assert && assert( !m.m10(), 'Transforming a Y value with a rotation/shear is ill-defined' );
              return m.m11() * y + m.m12();
            },
        
            transformDeltaX: function( x ) {
              var m = this.getMatrix();
              assert && assert( !m.m01(), 'Transforming an X value with a rotation/shear is ill-defined' );
              // same as this.transformDelta2( new dot.Vector2( x, 0 ) ).x;
              return m.m00() * x;
            },
        
            transformDeltaY: function( y ) {
              var m = this.getMatrix();
              assert && assert( !m.m10(), 'Transforming a Y value with a rotation/shear is ill-defined' );
              // same as this.transformDelta2( new dot.Vector2( 0, y ) ).y;
              return m.m11() * y;
            },
        
            transformBounds2: function( bounds2 ) {
              return bounds2.transformed( this.matrix );
            },
        
            transformShape: function( shape ) {
              return shape.transformed( this.matrix );
            },
        
            transformRay2: function( ray ) {
              return new dot.Ray2( this.transformPosition2( ray.pos ), this.transformDelta2( ray.dir ).normalized() );
            },
        
            /*---------------------------------------------------------------------------*
             * inverse transforms (for Vector2 or scalar)
             *----------------------------------------------------------------------------*/
        
            inversePosition2: function( vec2 ) {
              return this.getInverse().timesVector2( vec2 );
            },
        
            inverseDelta2: function( vec2 ) {
              var m = this.getInverse();
              // m . vec2 - m . Vector2.ZERO
              return new dot.Vector2( m.m00() * vec2.x + m.m01() * vec2.y, m.m10() * vec2.x + m.m11() * vec2.y );
            },
        
            inverseNormal2: function( vec2 ) {
              return this.matrix.timesTransposeVector2( vec2 );
            },
        
            inverseX: function( x ) {
              var m = this.getInverse();
              assert && assert( !m.m01(), 'Inverting an X value with a rotation/shear is ill-defined' );
              return m.m00() * x + m.m02();
            },
        
            inverseY: function( y ) {
              var m = this.getInverse();
              assert && assert( !m.m10(), 'Inverting a Y value with a rotation/shear is ill-defined' );
              return m.m11() * y + m.m12();
            },
        
            inverseDeltaX: function( x ) {
              var m = this.getInverse();
              assert && assert( !m.m01(), 'Inverting an X value with a rotation/shear is ill-defined' );
              // same as this.inverseDelta2( new dot.Vector2( x, 0 ) ).x;
              return m.m00() * x;
            },
        
            inverseDeltaY: function( y ) {
              var m = this.getInverse();
              assert && assert( !m.m10(), 'Inverting a Y value with a rotation/shear is ill-defined' );
              // same as this.inverseDelta2( new dot.Vector2( 0, y ) ).y;
              return m.m11() * y;
            },
        
            inverseBounds2: function( bounds2 ) {
              return bounds2.transformed( this.getInverse() );
            },
        
            inverseShape: function( shape ) {
              return shape.transformed( this.getInverse() );
            },
        
            inverseRay2: function( ray ) {
              return new dot.Ray2( this.inversePosition2( ray.pos ), this.inverseDelta2( ray.dir ).normalized() );
            },
        
            /*---------------------------------------------------------------------------*
            * listeners
            *----------------------------------------------------------------------------*/
        
            // note: listener.before( matrix, oldMatrix ) will be called before the change, listener.after( matrix, oldMatrix ) will be called after
            addTransformListener: function( listener ) {
              assert && assert( !_.contains( this.listeners, listener ) );
              this.listeners.push( listener );
            },
        
            // useful for making sure the listener is triggered first
            prependTransformListener: function( listener ) {
              assert && assert( !_.contains( this.listeners, listener ) );
              this.listeners.unshift( listener );
            },
        
            removeTransformListener: function( listener ) {
              assert && assert( _.contains( this.listeners, listener ) );
              this.listeners.splice( _.indexOf( this.listeners, listener ), 1 );
            }
          };
        
          return Transform3;
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * The main 'kite' namespace object for the exported (non-Require.js) API. Used internally
         * since it prevents Require.js issues with circular dependencies.
         *
         * The returned kite object namespace may be incomplete if not all modules are listed as
         * dependencies. Please use the 'main' module for that purpose if all of Kite is desired.
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'KITE/kite',['require','ASSERT/assert','ASSERT/assert','PHET_CORE/phetAllocation'],function( require ) {
          
        
          window.assert = window.assert || require( 'ASSERT/assert' )( 'basic' );
          window.assertSlow = window.assertSlow || require( 'ASSERT/assert' )( 'slow', true );
        
          // object allocation tracking
          window.phetAllocation = require( 'PHET_CORE/phetAllocation' );
        
          var kite = {};
        
          // will be filled in by other modules
          return kite;
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * A segment represents a specific curve with a start and end.
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'KITE/segments/Segment',['require','KITE/kite','DOT/Util','DOT/Bounds2'],function( require ) {
          
        
          var kite = require( 'KITE/kite' );
        
          var DotUtil = require( 'DOT/Util' );
          var Bounds2 = require( 'DOT/Bounds2' );
        
          /*
           * Will contain (for segments):
           * properties (backed by ES5 getters, created usually lazily):
           * start        - start point of this segment
           * end          - end point of this segment
           * startTangent - the tangent vector (normalized) to the segment at the start, pointing in the direction of motion (from start to end)
           * endTangent   - the tangent vector (normalized) to the segment at the end, pointing in the direction of motion (from start to end)
           * bounds       - the bounding box for the segment
           *
           * methods:
           * positionAt( t )          - returns the position parametrically, with 0 <= t <= 1. this does NOT guarantee a constant magnitude tangent... don't feel like adding elliptical functions yet!
           * tangentAt( t )           - returns the non-normalized tangent (dx/dt, dy/dt) parametrically, with 0 <= t <= 1.
           * curvatureAt( t )         - returns the signed curvature (positive for visual clockwise - mathematical counterclockwise)
           * subdivided( t )          - returns an array with 2 sub-segments, split at the parametric t value.
           * getSVGPathFragment()     - returns a string containing the SVG path. assumes that the start point is already provided, so anything that calls this needs to put the M calls first
           * strokeLeft( lineWidth )  - returns an array of segments that will draw an offset curve on the logical left side
           * strokeRight( lineWidth ) - returns an array of segments that will draw an offset curve on the logical right side
           * intersectsBounds         - whether this segment intersects the specified bounding box (not just the segment's bounding box, but the actual segment)
           * windingIntersection      - returns the winding number for intersection with a ray
           * getInteriorExtremaTs     - returns a list of t values where dx/dt or dy/dt is 0 where 0 < t < 1. subdividing on these will result in monotonic segments
           *
           * writeToContext( context ) - draws the segment to the 2D Canvas context, assuming the context's current location is already at the start point
           * transformed( matrix )     - returns a new segment that represents this segment after transformation by the matrix
           */
          kite.Segment = function Segment() {}; // no common construction for now
          var Segment = kite.Segment;
        
          var identityFunction = function identityFunction( x ) { return x; };
        
          Segment.prototype = {
            constructor: Segment,
        
            // TODO: override everywhere so this isn't necessary (it's not particularly efficient!)
            getBoundsWithTransform: function( matrix ) {
              var transformedSegment = this.transformed( matrix );
              return transformedSegment.getBounds();
            },
        
            // tList should be a list of sorted t values from 0 <= t <= 1
            subdivisions: function( tList ) {
              // this could be solved by recursion, but we don't plan on the JS engine doing tail-call optimization
              var right = this;
              var result = [];
              for ( var i = 0; i < tList.length; i++ ) {
                // assume binary subdivision
                var t = tList[i];
                var arr = right.subdivided( t );
                assert && assert( arr.length === 2 );
                result.push( arr[0] );
                right = arr[1];
        
                // scale up the remaining t values
                for ( var j = i + 1; j < tList.length; j++ ) {
                  tList[j] = DotUtil.linear( t, 1, 0, 1, tList[j] );
                }
              }
              result.push( right );
              return result;
            },
        
            // return an array of segments from breaking this segment into monotone pieces
            subdividedIntoMonotone: function() {
              return this.subdivisions( this.getInteriorExtremaTs() );
            },
        
            /*
             * toPiecewiseLinearSegments( options ), with the following options provided:
             * - minLevels:                       how many levels to force subdivisions
             * - maxLevels:                       prevent subdivision past this level
             * - distanceEpsilon (optional null): controls level of subdivision by attempting to ensure a maximum (squared) deviation from the curve
             * - curveEpsilon (optional null):    controls level of subdivision by attempting to ensure a maximum curvature change between segments
             * - pointMap (optional):             function( Vector2 ) : Vector2, represents a (usually non-linear) transformation applied
             * - methodName (optional):           if the method name is found on the segment, it is called with the expected signature function( options ) : Array[Segment]
             *                                    instead of using our brute-force logic
             */
            toPiecewiseLinearSegments: function( options, minLevels, maxLevels, segments, start, end ) {
              // for the first call, initialize min/max levels from our options
              minLevels = minLevels === undefined ? options.minLevels : minLevels;
              maxLevels = maxLevels === undefined ? options.maxLevels : maxLevels;
              segments = segments || [];
              var pointMap = options.pointMap || identityFunction;
        
              // points mapped by the (possibly-nonlinear) pointMap.
              start = start || pointMap( this.start );
              end = end || pointMap( this.end );
              var middle = pointMap( this.positionAt( 0.5 ) );
        
              assert && assert( minLevels <= maxLevels );
              assert && assert( options.distanceEpsilon === null || typeof options.distanceEpsilon === 'number' );
              assert && assert( options.curveEpsilon === null || typeof options.curveEpsilon === 'number' );
              assert && assert( !pointMap || typeof pointMap === 'function' );
        
              // i.e. we will have finished = maxLevels === 0 || ( minLevels <= 0 && epsilonConstraints ), just didn't want to one-line it
              var finished = maxLevels === 0; // bail out once we reach our maximum number of subdivision levels
              if ( !finished && minLevels <= 0 ) { // force subdivision if minLevels hasn't been reached
                // flatness criterion: A=start, B=end, C=midpoint, d0=distance from AB, d1=||B-A||, subdivide if d0/d1 > sqrt(epsilon)
                finished = ( options.curveEpsilon === null || ( DotUtil.distToSegmentSquared( middle, start, end ) / start.distanceSquared( end ) < options.curveEpsilon ) ) &&
                  // deviation criterion
                           ( options.distanceEpsilon === null || ( DotUtil.distToSegmentSquared( middle, start, end ) < options.distanceEpsilon ) );
              }
        
              if ( finished ) {
                segments.push( new Segment.Line( start, end ) );
              }
              else {
                var subdividedSegments = this.subdivided( 0.5 );
                subdividedSegments[0].toPiecewiseLinearSegments( options, minLevels - 1, maxLevels - 1, segments, start, middle );
                subdividedSegments[1].toPiecewiseLinearSegments( options, minLevels - 1, maxLevels - 1, segments, middle, end );
              }
              return segments;
            }
          };
        
          // list of { segment: ..., t: ..., closestPoint: ..., distanceSquared: ... } (since there can be duplicates), threshold is used for subdivision,
          // where it will exit if all of the segments are shorter than the threshold
          // TODO: solve segments to determine this analytically!
          Segment.closestToPoint = function( segments, point, threshold ) {
            var thresholdSquared = threshold * threshold;
            var items = [];
            var bestList = [];
            var bestDistanceSquared = Number.POSITIVE_INFINITY;
            var thresholdOk = false;
        
            _.each( segments, function( segment ) {
              // if we have an explicit computation for this segment, use it
              if ( segment.explicitClosestToPoint ) {
                var infos = segment.explicitClosestToPoint( point );
                _.each( infos, function( info ) {
                  if ( info.distanceSquared < bestDistanceSquared ) {
                    bestList = [info];
                    bestDistanceSquared = info.distanceSquared;
                  }
                  else if ( info.distanceSquared === bestDistanceSquared ) {
                    bestList.push( info );
                  }
                } );
              }
              else {
                // otherwise, we will split based on monotonicity, so we can subdivide
                // separate, so we can map the subdivided segments
                var ts = [0].concat( segment.getInteriorExtremaTs() ).concat( [1] );
                for ( var i = 0; i < ts.length - 1; i++ ) {
                  var ta = ts[i];
                  var tb = ts[i + 1];
                  var pa = segment.positionAt( ta );
                  var pb = segment.positionAt( tb );
                  var bounds = Bounds2.point( pa ).addPoint( pb );
                  var minDistanceSquared = bounds.minimumDistanceToPointSquared( point );
                  if ( minDistanceSquared <= bestDistanceSquared ) {
                    var maxDistanceSquared = bounds.maximumDistanceToPointSquared( point );
                    if ( maxDistanceSquared < bestDistanceSquared ) {
                      bestDistanceSquared = maxDistanceSquared;
                      bestList = []; // clear it
                    }
                    items.push( {
                      ta: ta,
                      tb: tb,
                      pa: pa,
                      pb: pb,
                      segment: segment,
                      bounds: bounds,
                      min: minDistanceSquared,
                      max: maxDistanceSquared
                    } );
                  }
                }
              }
            } );
        
            while ( items.length && !thresholdOk ) {
              var curItems = items;
              items = [];
        
              // whether all of the segments processed are shorter than the threshold
              thresholdOk = true;
        
              _.each( curItems, function( item ) {
                if ( item.minDistanceSquared > bestDistanceSquared ) {
                  return; // drop this item
                }
                if ( thresholdOk && item.pa.distanceSquared( item.pb ) > thresholdSquared ) {
                  thresholdOk = false;
                }
                var tmid = ( item.ta + item.tb ) / 2;
                var pmid = item.segment.positionAt( tmid );
                var boundsA = Bounds2.point( item.pa ).addPoint( pmid );
                var boundsB = Bounds2.point( item.pb ).addPoint( pmid );
                var minA = boundsA.minimumDistanceToPointSquared( point );
                var minB = boundsB.minimumDistanceToPointSquared( point );
                if ( minA <= bestDistanceSquared ) {
                  var maxA = boundsA.maximumDistanceToPointSquared( point );
                  if ( maxA < bestDistanceSquared ) {
                    bestDistanceSquared = maxA;
                    bestList = []; // clear it
                  }
                  items.push( {
                    ta: item.ta,
                    tb: tmid,
                    pa: item.pa,
                    pb: pmid,
                    segment: item.segment,
                    bounds: boundsA,
                    min: minA,
                    max: maxA
                  } );
                }
                if ( minB <= bestDistanceSquared ) {
                  var maxB = boundsB.maximumDistanceToPointSquared( point );
                  if ( maxB < bestDistanceSquared ) {
                    bestDistanceSquared = maxB;
                    bestList = []; // clear it
                  }
                  items.push( {
                    ta: tmid,
                    tb: item.tb,
                    pa: pmid,
                    pb: item.pb,
                    segment: item.segment,
                    bounds: boundsB,
                    min: minB,
                    max: maxB
                  } );
                }
              } );
            }
        
            // if there are any closest regions, they are within the threshold, so we will add them all
            _.each( items, function( item ) {
              var t = ( item.ta + item.tb ) / 2;
              var closestPoint = item.segment.positionAt( t );
              bestList.push( {
                segment: item.segment,
                t: t,
                closestPoint: closestPoint,
                distanceSquared: point.distanceSquared( closestPoint )
              } );
            } );
        
            return bestList;
          };
        
          return Segment;
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Linear segment
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'KITE/segments/Line',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Vector2','DOT/Util','KITE/segments/Segment'],function( require ) {
          
        
          var inherit = require( 'PHET_CORE/inherit' );
          var Bounds2 = require( 'DOT/Bounds2' );
          var Vector2 = require( 'DOT/Vector2' );
          var Util = require( 'DOT/Util' );
        
          var Segment = require( 'KITE/segments/Segment' );
        
          var scratchVector2 = new Vector2();
        
          Segment.Line = function Line( start, end ) {
            this._start = start;
            this._end = end;
        
            // TODO: performance test removal of these undefined declarations
            this._tangent = undefined;
            this._bounds = undefined;
          };
          inherit( Segment, Segment.Line, {
        
            getStart: function() {
              return this._start;
            },
            get start() { return this._start; },
        
            getEnd: function() {
              return this._end;
            },
            get end() { return this._end; },
        
            getStartTangent: function() {
              if ( this._tangent === undefined ) {
                // TODO: allocation reduction
                this._tangent = this._end.minus( this._start ).normalized();
              }
              return this._tangent;
            },
            get startTangent() { return this.getStartTangent(); },
        
            getEndTangent: function() {
              return this.getStartTangent();
            },
            get endTangent() { return this.getEndTangent(); },
        
            getBounds: function() {
              // TODO: allocation reduction
              if ( this._bounds === undefined ) {
                this._bounds = Bounds2.NOTHING.copy().addPoint( this._start ).addPoint( this._end );
              }
              return this._bounds;
            },
            get bounds() { return this.getBounds(); },
        
            getBoundsWithTransform: function( matrix ) {
              // uses mutable calls
              var bounds = Bounds2.NOTHING.copy();
              bounds.addPoint( matrix.multiplyVector2( scratchVector2.set( this._start ) ) );
              bounds.addPoint( matrix.multiplyVector2( scratchVector2.set( this._end ) ) );
              return bounds;
            },
        
            getNondegenerateSegments: function() {
              // if it is degenerate (0-length), just ignore it
              if ( this._start.equals( this._end ) ) {
                return [];
              }
              else {
                return [this];
              }
            },
        
            positionAt: function( t ) {
              return this._start.plus( this._end.minus( this._start ).times( t ) );
            },
        
            tangentAt: function( t ) {
              // tangent always the same, just use the start tanget
              return this.getStartTangent();
            },
        
            curvatureAt: function( t ) {
              return 0; // no curvature on a straight line segment
            },
        
            getSVGPathFragment: function() {
              return 'L ' + this._end.x + ' ' + this._end.y;
            },
        
            strokeLeft: function( lineWidth ) {
              var offset = this.getEndTangent().perpendicular().negated().times( lineWidth / 2 );
              return [new Segment.Line( this._start.plus( offset ), this._end.plus( offset ) )];
            },
        
            strokeRight: function( lineWidth ) {
              var offset = this.getStartTangent().perpendicular().times( lineWidth / 2 );
              return [new Segment.Line( this._end.plus( offset ), this._start.plus( offset ) )];
            },
        
            // lines are already monotone
            getInteriorExtremaTs: function() { return []; },
        
            subdivided: function( t ) {
              var pt = this.positionAt( t );
              return [
                new Segment.Line( this._start, pt ),
                new Segment.Line( pt, this._end )
              ];
            },
        
            intersectsBounds: function( bounds ) {
              throw new Error( 'Segment.Line.intersectsBounds unimplemented' ); // TODO: implement
            },
        
            intersection: function( ray ) {
              // We solve for the parametric line-line intersection, and then ensure the parameters are within both
              // the line segment and forwards from the ray.
        
              var result = [];
        
              var start = this._start;
              var end = this._end;
        
              var diff = end.minus( start );
        
              if ( diff.magnitudeSquared() === 0 ) {
                return result;
              }
        
              var denom = ray.dir.y * diff.x - ray.dir.x * diff.y;
        
              // If denominator is 0, the lines are parallel or coincident
              if ( denom === 0 ) {
                return result;
              }
        
              // linear parameter where start (0) to end (1)
              var t = ( ray.dir.x * ( start.y - ray.pos.y ) - ray.dir.y * ( start.x - ray.pos.x ) ) / denom;
        
              // check that the intersection point is between the line segment's endpoints
              if ( t < 0 || t >= 1 ) {
                return result;
              }
        
              // linear parameter where ray.pos (0) to ray.pos+ray.dir (1)
              var s = ( diff.x * ( start.y - ray.pos.y ) - diff.y * ( start.x - ray.pos.x ) ) / denom;
        
              // bail if it is behind our ray
              if ( s < 0.000001 ) {
                return result;
              }
        
              // return the proper winding direction depending on what way our line intersection is "pointed"
              var perp = diff.perpendicular();
              result.push( {
                distance: s,
                point: start.plus( diff.times( t ) ),
                normal: perp.dot( ray.dir ) > 0 ? perp.negated() : perp,
                wind: ray.dir.perpendicular().dot( diff ) < 0 ? 1 : -1,
                segment: this
              } );
              return result;
            },
        
            // returns the resultant winding number of this ray intersecting this segment.
            windingIntersection: function( ray ) {
              var hits = this.intersection( ray );
              if ( hits.length ) {
                return hits[0].wind;
              }
              else {
                return 0;
              }
            },
        
            // assumes the current position is at start
            writeToContext: function( context ) {
              context.lineTo( this._end.x, this._end.y );
            },
        
            transformed: function( matrix ) {
              return new Segment.Line( matrix.timesVector2( this._start ), matrix.timesVector2( this._end ) );
            },
        
            explicitClosestToPoint: function( point ) {
              var diff = this._end.minus( this._start );
              var t = point.minus( this._start ).dot( diff ) / diff.magnitudeSquared();
              t = Util.clamp( t, 0, 1 );
              var closestPoint = this.positionAt( t );
              return [
                {
                  segment: this,
                  t: t,
                  closestPoint: closestPoint,
                  distanceSquared: point.distanceSquared( closestPoint )
                }
              ];
            },
        
            // given the current curve parameterized by t, will return a curve parameterized by x where t = a * x + b
            reparameterized: function( a, b ) {
              return new Segment.Line( this.positionAt( b ), this.positionAt( a + b ) );
            },
        
            polarToCartesian: function( options ) {
              if ( this._start.x === this._end.x ) {
                // angle is the same, we are still a line segment!
                return [new Segment.Line( Vector2.createPolar( this._start.y, this._start.x ), Vector2.createPolar( this._end.y, this._end.x ) )];
              }
              else if ( this._start.y === this._end.y ) {
                // we have a constant radius, so we are a circular arc
                return [new Segment.Arc( Vector2.ZERO, this._start.y, this._start.x, this._end.x, this._start.x > this._end.x )];
              }
              else {
                return this.toPiecewiseLinearSegments( options );
              }
            }
          } );
        
          return Segment.Line;
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Arc segment
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'KITE/segments/Arc',['require','PHET_CORE/inherit','DOT/Vector2','DOT/Bounds2','DOT/Util','KITE/segments/Segment'],function( require ) {
          
        
          var inherit = require( 'PHET_CORE/inherit' );
          var Vector2 = require( 'DOT/Vector2' );
          var Bounds2 = require( 'DOT/Bounds2' );
          var DotUtil = require( 'DOT/Util' );
        
          var Segment = require( 'KITE/segments/Segment' );
        
          Segment.Arc = function Arc( center, radius, startAngle, endAngle, anticlockwise ) {
            if ( radius < 0 ) {
              // support this case since we might actually need to handle it inside of strokes?
              radius = -radius;
              startAngle += Math.PI;
              endAngle += Math.PI;
            }
        
            this._center = center;
            this._radius = radius;
            this._startAngle = startAngle;
            this._endAngle = endAngle;
            this._anticlockwise = anticlockwise;
        
            // TODO: performance test removal of these undefined declarations
            this._start = undefined;
            this._end = undefined;
            this._startTangent = undefined;
            this._endTangent = undefined;
            this._actualEndAngle = undefined;
            this._isFullPerimeter = undefined;
            this._angleDifference = undefined;
        
            // constraints
            assert && assert( !( ( !anticlockwise && endAngle - startAngle <= -Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle <= -Math.PI * 2 ) ), 'Not handling arcs with start/end angles that show differences in-between browser handling' );
            assert && assert( !( ( !anticlockwise && endAngle - startAngle > Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle > Math.PI * 2 ) ), 'Not handling arcs with start/end angles that show differences in-between browser handling' );
          };
          inherit( Segment, Segment.Arc, {
        
            getCenter: function() {
              return this._center;
            },
            get center() { return this.getCenter(); },
        
            getRadius: function() {
              return this._radius;
            },
            get radius() { return this.getRadius(); },
        
            getStartAngle: function() {
              return this._startAngle;
            },
            get startAngle() { return this.getStartAngle(); },
        
            getEndAngle: function() {
              return this._endAngle;
            },
            get endAngle() { return this.getEndAngle(); },
        
            getAnticlockwise: function() {
              return this._anticlockwise;
            },
            get anticlockwise() { return this.getAnticlockwise(); },
        
            getStart: function() {
              if ( this._start === undefined ) {
                this._start = this.positionAtAngle( this._startAngle );
              }
              return this._start;
            },
            get start() { return this.getStart(); },
        
            getEnd: function() {
              if ( this._end === undefined ) {
                this._end = this.positionAtAngle( this._endAngle );
              }
              return this._end;
            },
            get end() { return this.getEnd(); },
        
            getStartTangent: function() {
              if ( this._startTangent === undefined ) {
                this._startTangent = this.tangentAtAngle( this._startAngle );
              }
              return this._startTangent;
            },
            get startTangent() { return this.getStartTangent(); },
        
            getEndTangent: function() {
              if ( this._endTangent === undefined ) {
                this._endTangent = this.tangentAtAngle( this._endAngle );
              }
              return this._endTangent;
            },
            get endTangent() { return this.getEndTangent(); },
        
            getActualEndAngle: function() {
              if ( this._actualEndAngle === undefined ) {
                // compute an actual end angle so that we can smoothly go from this._startAngle to this._actualEndAngle
                if ( this._anticlockwise ) {
                  // angle is 'decreasing'
                  // -2pi <= end - start < 2pi
                  if ( this._startAngle > this._endAngle ) {
                    this._actualEndAngle = this._endAngle;
                  }
                  else if ( this._startAngle < this._endAngle ) {
                    this._actualEndAngle = this._endAngle - 2 * Math.PI;
                  }
                  else {
                    // equal
                    this._actualEndAngle = this._startAngle;
                  }
                }
                else {
                  // angle is 'increasing'
                  // -2pi < end - start <= 2pi
                  if ( this._startAngle < this._endAngle ) {
                    this._actualEndAngle = this._endAngle;
                  }
                  else if ( this._startAngle > this._endAngle ) {
                    this._actualEndAngle = this._endAngle + Math.PI * 2;
                  }
                  else {
                    // equal
                    this._actualEndAngle = this._startAngle;
                  }
                }
              }
              return this._actualEndAngle;
            },
            get actualEndAngle() { return this.getActualEndAngle(); },
        
            getIsFullPerimeter: function() {
              if ( this._isFullPerimeter === undefined ) {
                this._isFullPerimeter = ( !this._anticlockwise && this._endAngle - this._startAngle >= Math.PI * 2 ) || ( this._anticlockwise && this._startAngle - this._endAngle >= Math.PI * 2 );
              }
              return this._isFullPerimeter;
            },
            get isFullPerimeter() { return this.getIsFullPerimeter(); },
        
            getAngleDifference: function() {
              if ( this._angleDifference === undefined ) {
                // compute an angle difference that represents how "much" of the circle our arc covers
                this._angleDifference = this._anticlockwise ? this._startAngle - this._endAngle : this._endAngle - this._startAngle;
                if ( this._angleDifference < 0 ) {
                  this._angleDifference += Math.PI * 2;
                }
                assert && assert( this._angleDifference >= 0 ); // now it should always be zero or positive
              }
              return this._angleDifference;
            },
            get angleDifference() { return this.getAngleDifference(); },
        
            getBounds: function() {
              if ( this._bounds === undefined ) {
                // acceleration for intersection
                this._bounds = Bounds2.NOTHING.copy().withPoint( this.getStart() )
                  .withPoint( this.getEnd() );
        
                // if the angles are different, check extrema points
                if ( this._startAngle !== this._endAngle ) {
                  // check all of the extrema points
                  this.includeBoundsAtAngle( 0 );
                  this.includeBoundsAtAngle( Math.PI / 2 );
                  this.includeBoundsAtAngle( Math.PI );
                  this.includeBoundsAtAngle( 3 * Math.PI / 2 );
                }
              }
              return this._bounds;
            },
            get bounds() { return this.getBounds(); },
        
            getNondegenerateSegments: function() {
              if ( this._radius <= 0 || this._startAngle === this._endAngle ) {
                return [];
              }
              else {
                return [this]; // basically, Arcs aren't really degenerate that easily
              }
            },
        
            includeBoundsAtAngle: function( angle ) {
              if ( this.containsAngle( angle ) ) {
                // the boundary point is in the arc
                this._bounds = this._bounds.withPoint( this._center.plus( Vector2.createPolar( this._radius, angle ) ) );
              }
            },
        
            // maps a contained angle to between [startAngle,actualEndAngle), even if the end angle is lower.
            mapAngle: function( angle ) {
              // consider an assert that we contain that angle?
              return ( this._startAngle > this.getActualEndAngle() ) ?
                     DotUtil.moduloBetweenUp( angle, this._startAngle - 2 * Math.PI, this._startAngle ) :
                     DotUtil.moduloBetweenDown( angle, this._startAngle, this._startAngle + 2 * Math.PI );
            },
        
            tAtAngle: function( angle ) {
              return ( this.mapAngle( angle ) - this._startAngle ) / ( this.getActualEndAngle() - this._startAngle );
            },
        
            angleAt: function( t ) {
              return this._startAngle + ( this.getActualEndAngle() - this._startAngle ) * t;
            },
        
            positionAt: function( t ) {
              return this.positionAtAngle( this.angleAt( t ) );
            },
        
            tangentAt: function( t ) {
              return this.tangentAtAngle( this.angleAt( t ) );
            },
        
            curvatureAt: function( t ) {
              return ( this._anticlockwise ? -1 : 1 ) / this._radius;
            },
        
            positionAtAngle: function( angle ) {
              return this._center.plus( Vector2.createPolar( this._radius, angle ) );
            },
        
            tangentAtAngle: function( angle ) {
              var normal = Vector2.createPolar( 1, angle );
        
              return this._anticlockwise ? normal.perpendicular() : normal.perpendicular().negated();
            },
        
            // TODO: refactor? shared with Segment.EllipticalArc (use this improved version)
            containsAngle: function( angle ) {
              // transform the angle into the appropriate coordinate form
              // TODO: check anticlockwise version!
              var normalizedAngle = this._anticlockwise ? angle - this._endAngle : angle - this._startAngle;
        
              // get the angle between 0 and 2pi
              var positiveMinAngle = DotUtil.moduloBetweenDown( normalizedAngle, 0, Math.PI * 2 );
        
              return positiveMinAngle <= this.angleDifference;
            },
        
            getSVGPathFragment: function() {
              // see http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands for more info
              // rx ry x-axis-rotation large-arc-flag sweep-flag x y
        
              var epsilon = 0.01; // allow some leeway to render things as 'almost circles'
              var sweepFlag = this._anticlockwise ? '0' : '1';
              var largeArcFlag;
              if ( this.angleDifference < Math.PI * 2 - epsilon ) {
                largeArcFlag = this.angleDifference < Math.PI ? '0' : '1';
                return 'A ' + this._radius + ' ' + this._radius + ' 0 ' + largeArcFlag + ' ' + sweepFlag + ' ' + this.end.x + ' ' + this.end.y;
              }
              else {
                // circle (or almost-circle) case needs to be handled differently
                // since SVG will not be able to draw (or know how to draw) the correct circle if we just have a start and end, we need to split it into two circular arcs
        
                // get the angle that is between and opposite of both of the points
                var splitOppositeAngle = ( this._startAngle + this._endAngle ) / 2; // this _should_ work for the modular case?
                var splitPoint = this._center.plus( Vector2.createPolar( this._radius, splitOppositeAngle ) );
        
                largeArcFlag = '0'; // since we split it in 2, it's always the small arc
        
                var firstArc = 'A ' + this._radius + ' ' + this._radius + ' 0 ' + largeArcFlag + ' ' + sweepFlag + ' ' + splitPoint.x + ' ' + splitPoint.y;
                var secondArc = 'A ' + this._radius + ' ' + this._radius + ' 0 ' + largeArcFlag + ' ' + sweepFlag + ' ' + this.end.x + ' ' + this.end.y;
        
                return firstArc + ' ' + secondArc;
              }
            },
        
            strokeLeft: function( lineWidth ) {
              return [new Segment.Arc( this._center, this._radius + ( this._anticlockwise ? 1 : -1 ) * lineWidth / 2, this._startAngle, this._endAngle, this._anticlockwise )];
            },
        
            strokeRight: function( lineWidth ) {
              return [new Segment.Arc( this._center, this._radius + ( this._anticlockwise ? -1 : 1 ) * lineWidth / 2, this._endAngle, this._startAngle, !this._anticlockwise )];
            },
        
            // not including 0 and 1
            getInteriorExtremaTs: function() {
              var that = this;
              var result = [];
              _.each( [ 0, Math.PI / 2, Math.PI, 3 * Math.PI / 2 ], function( angle ) {
                if ( that.containsAngle( angle ) ) {
                  var t = that.tAtAngle( angle );
                  var epsilon = 0.0000000001; // TODO: general kite epsilon?
                  if ( t > epsilon && t < 1 - epsilon ) {
                    result.push( t );
                  }
                }
              } );
              return result.sort(); // modifies original, which is OK
            },
        
            subdivided: function( t ) {
              // TODO: verify that we don't need to switch anticlockwise here, or subtract 2pi off any angles
              var angle0 = this.angleAt( 0 );
              var angleT = this.angleAt( t );
              var angle1 = this.angleAt( 1 );
              return [
                new Segment.Arc( this._center, this._radius, angle0, angleT, this._anticlockwise ),
                new Segment.Arc( this._center, this._radius, angleT, angle1, this._anticlockwise )
              ];
            },
        
            intersectsBounds: function( bounds ) {
              throw new Error( 'Segment.intersectsBounds unimplemented!' );
            },
        
            intersection: function( ray ) {
              var result = []; // hits in order
        
              // left here, if in the future we want to better-handle boundary points
              var epsilon = 0;
        
              // Run a general circle-intersection routine, then we can test the angles later.
              // Solves for the two solutions t such that ray.pos + ray.dir * t is on the circle.
              // Then we check whether the angle at each possible hit point is in our arc.
              var centerToRay = ray.pos.minus( this._center );
              var tmp = ray.dir.dot( centerToRay );
              var centerToRayDistSq = centerToRay.magnitudeSquared();
              var discriminant = 4 * tmp * tmp - 4 * ( centerToRayDistSq - this._radius * this._radius );
              if ( discriminant < epsilon ) {
                // ray misses circle entirely
                return result;
              }
              var base = ray.dir.dot( this._center ) - ray.dir.dot( ray.pos );
              var sqt = Math.sqrt( discriminant ) / 2;
              var ta = base - sqt;
              var tb = base + sqt;
        
              if ( tb < epsilon ) {
                // circle is behind ray
                return result;
              }
        
              var pointB = ray.pointAtDistance( tb );
              var normalB = pointB.minus( this._center ).normalized();
        
              if ( ta < epsilon ) {
                // we are inside the circle, so only one intersection is possible
                if ( this.containsAngle( normalB.angle() ) ) {
                  result.push( {
                    distance: tb,
                    point: pointB,
                    normal: normalB.negated(), // normal is towards the ray
                    wind: this._anticlockwise ? -1 : 1 // since we are inside, wind this way
                  } );
                }
              }
              else {
                // two possible hits (outside circle)
                var pointA = ray.pointAtDistance( ta );
                var normalA = pointA.minus( this._center ).normalized();
        
                if ( this.containsAngle( normalA.angle() ) ) {
                  result.push( {
                    distance: ta,
                    point: pointA,
                    normal: normalA,
                    wind: this._anticlockwise ? 1 : -1 // hit from outside
                  } );
                }
                if ( this.containsAngle( normalB.angle() ) ) {
                  result.push( {
                    distance: tb,
                    point: pointB,
                    normal: normalB.negated(),
                    wind: this._anticlockwise ? -1 : 1 // this is the far hit, which winds the opposite way
                  } );
                }
              }
        
              return result;
            },
        
            // returns the resultant winding number of this ray intersecting this segment.
            windingIntersection: function( ray ) {
              var wind = 0;
              var hits = this.intersection( ray );
              _.each( hits, function( hit ) {
                wind += hit.wind;
              } );
              return wind;
            },
        
            writeToContext: function( context ) {
              context.arc( this._center.x, this._center.y, this._radius, this._startAngle, this._endAngle, this._anticlockwise );
            },
        
            // TODO: test various transform types, especially rotations, scaling, shears, etc.
            transformed: function( matrix ) {
              // so we can handle reflections in the transform, we do the general case handling for start/end angles
              var startAngle = matrix.timesVector2( Vector2.createPolar( 1, this._startAngle ) ).minus( matrix.timesVector2( Vector2.ZERO ) ).angle();
              var endAngle = matrix.timesVector2( Vector2.createPolar( 1, this._endAngle ) ).minus( matrix.timesVector2( Vector2.ZERO ) ).angle();
        
              // reverse the 'clockwiseness' if our transform includes a reflection
              var anticlockwise = matrix.getDeterminant() >= 0 ? this._anticlockwise : !this._anticlockwise;
        
              if ( Math.abs( this._endAngle - this._startAngle ) === Math.PI * 2 ) {
                endAngle = anticlockwise ? startAngle - Math.PI * 2 : startAngle + Math.PI * 2;
              }
        
              var scaleVector = matrix.getScaleVector();
              if ( scaleVector.x !== scaleVector.y ) {
                var radiusX = scaleVector.x * this._radius;
                var radiusY = scaleVector.y * this._radius;
                return new Segment.EllipticalArc( matrix.timesVector2( this._center ), radiusX, radiusY, 0, startAngle, endAngle, anticlockwise );
              }
              else {
                var radius = scaleVector.x * this._radius;
                return new Segment.Arc( matrix.timesVector2( this._center ), radius, startAngle, endAngle, anticlockwise );
              }
            }
          } );
        
          return Segment.Arc;
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * A Canvas-style stateful (mutable) subpath, which tracks segments in addition to the points.
         *
         * See http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#concept-path
         * for the path / subpath Canvas concept.
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'KITE/util/Subpath',['require','DOT/Bounds2','DOT/Util','KITE/kite','KITE/segments/Line','KITE/segments/Arc'],function( require ) {
          
        
          var Bounds2 = require( 'DOT/Bounds2' );
          var lineLineIntersection = require( 'DOT/Util' ).lineLineIntersection;
        
          var kite = require( 'KITE/kite' );
        
          require( 'KITE/segments/Line' );
          require( 'KITE/segments/Arc' );
        
          // all arguments optional (they are for the copy() method)
          kite.Subpath = function Subpath( segments, points, closed ) {
            this.segments = segments || [];
        
            // recombine points if necessary, based off of start points of segments + the end point of the last segment
            this.points = points || ( ( segments && segments.length ) ? _.map( segments, function( segment ) { return segment.start; } ).concat( segments[segments.length - 1].end ) : [] );
            this.closed = !!closed;
        
            // cached stroked shape (so hit testing can be done quickly on stroked shapes)
            this._strokedSubpaths = null;
            this._strokedSubpathsComputed = false;
            this._strokedStyles = null;
        
            var bounds = this.bounds = Bounds2.NOTHING.copy();
            _.each( this.segments, function( segment ) {
              bounds.includeBounds( segment.bounds );
            } );
          };
          var Subpath = kite.Subpath;
          Subpath.prototype = {
            copy: function() {
              return new Subpath( this.segments.slice( 0 ), this.points.slice( 0 ), this.closed );
            },
        
            invalidate: function() {
              this._strokedSubpathsComputed = false;
            },
        
            addPoint: function( point ) {
              this.points.push( point );
        
              return this; // allow chaining
            },
        
            addSegmentDirectly: function( segment ) {
              assert && assert( segment.start.isFinite(), 'Segment start is infinite' );
              assert && assert( segment.end.isFinite(), 'Segment end is infinite' );
              assert && assert( segment.startTangent.isFinite(), 'Segment startTangent is infinite' );
              assert && assert( segment.endTangent.isFinite(), 'Segment endTangent is infinite' );
              assert && assert( segment.bounds.isEmpty() || segment.bounds.isFinite(), 'Segment bounds is infinite and non-empty' );
              this.segments.push( segment );
              this.invalidate();
        
              this.bounds.includeBounds( segment.getBounds() );
        
              return this; // allow chaining
            },
        
            addSegment: function( segment ) {
              var subpath = this;
              _.each( segment.getNondegenerateSegments(), function( segment ) {
                subpath.addSegmentDirectly( segment );
              } );
        
              return this; // allow chaining
            },
        
            // Adds a line segment from the start to end (if non-zero length) and marks the subpath as closed.
            // NOTE: normally you just want to mark the subpath as closed, and not generate the closing segment this way?
            addClosingSegment: function() {
              if ( this.hasClosingSegment() ) {
                var closingSegment = this.getClosingSegment();
                this.addSegmentDirectly( closingSegment );
                this.addPoint( this.getFirstPoint() );
                this.closed = true;
              }
            },
        
            // TODO: consider always adding a closing segment into our segments list for easier processing!! see addClosingSegment()
            close: function() {
              this.closed = true;
            },
        
            getLength: function() {
              return this.points.length;
            },
        
            getFirstPoint: function() {
              return _.first( this.points );
            },
        
            getLastPoint: function() {
              return _.last( this.points );
            },
        
            getFirstSegment: function() {
              return _.first( this.segments );
            },
        
            getLastSegment: function() {
              return _.last( this.segments );
            },
        
            isDrawable: function() {
              return this.segments.length > 0;
            },
        
            isClosed: function() {
              return this.closed;
            },
        
            hasClosingSegment: function() {
              return !this.getFirstPoint().equalsEpsilon( this.getLastPoint(), 0.000000001 );
            },
        
            getClosingSegment: function() {
              assert && assert( this.hasClosingSegment(), 'Implicit closing segment unnecessary on a fully closed path' );
              return new kite.Segment.Line( this.getLastPoint(), this.getFirstPoint() );
            },
        
            writeToContext: function( context ) {
              if ( this.isDrawable() ) {
                var startPoint = this.getFirstSegment().start;
                context.moveTo( startPoint.x, startPoint.y ); // the segments assume the current context position is at their start
        
                var len = this.segments.length;
                for ( var i = 0; i < len; i++ ) {
                  this.segments[i].writeToContext( context );
                }
        
                if ( this.closed ) {
                  context.closePath();
                }
              }
            },
        
            // see Segment.toPiecewiseLinearSegments for documentation
            toPiecewiseLinear: function( options ) {
              assert && assert( !options.pointMap, 'For use with pointMap, please use nonlinearTransformed' );
              return new Subpath( _.flatten( _.map( this.segments, function( segment ) {
                return segment.toPiecewiseLinearSegments( options );
              } ) ), null, this.closed );
            },
        
            transformed: function( matrix ) {
              return new Subpath(
                _.map( this.segments, function( segment ) { return segment.transformed( matrix ); } ),
                _.map( this.points, function( point ) { return matrix.timesVector2( point ); } ),
                this.closed
              );
            },
        
            // see Segment.toPiecewiseLinearSegments for documentation
            nonlinearTransformed: function( options ) {
              // specify an actual closing segment, so it can be mapped properly by any non-linear transforms
              // TODO: always create and add the closing segments when the subpath is closed!!!
              if ( this.closed && this.hasClosingSegment() ) {
                this.addClosingSegment();
              }
        
              return new Subpath( _.flatten( _.map( this.segments, function( segment ) {
                // check for this segment's support for the specific transform or discretization being applied
                if ( options.methodName && segment[options.methodName] ) {
                  return segment[options.methodName]( options );
                }
                else {
                  return segment.toPiecewiseLinearSegments( options );
                }
              } ) ), null, this.closed );
            },
        
            getBoundsWithTransform: function( matrix ) {
              var bounds = Bounds2.NOTHING.copy();
              var numSegments = this.segments.length;
              for ( var i = 0; i < numSegments; i++ ) {
                bounds.includeBounds( this.segments[i].getBoundsWithTransform( matrix ) );
              }
              return bounds;
            },
        
            // returns an array of subpaths (one if open, two if closed) that represent a stroked copy of this subpath.
            stroked: function( lineStyles ) {
              // non-drawable subpaths convert to empty subpaths
              if ( !this.isDrawable() ) {
                return [];
              }
        
              if ( lineStyles === undefined ) {
                lineStyles = new kite.LineStyles();
              }
        
              // return a cached version if possible
              if ( this._strokedSubpathsComputed && this._strokedStyles.equals( lineStyles ) ) {
                return this._strokedSubpaths;
              }
        
              var lineWidth = lineStyles.lineWidth;
        
              // joins two segments together on the logical "left" side, at 'center' (where they meet), and normalized tangent vectors in the direction of the stroking
              // to join on the "right" side, switch the tangent order and negate them
              function join( center, fromTangent, toTangent ) {
                // where our join path starts and ends
                var fromPoint = center.plus( fromTangent.perpendicular().negated().times( lineWidth / 2 ) );
                var toPoint = center.plus( toTangent.perpendicular().negated().times( lineWidth / 2 ) );
        
                var bevel = ( fromPoint.equals( toPoint ) ? [] : [new kite.Segment.Line( fromPoint, toPoint )] );
        
                // only insert a join on the non-acute-angle side
                if ( fromTangent.perpendicular().dot( toTangent ) > 0 ) {
                  switch( lineStyles.lineJoin ) {
                    case 'round':
                      var fromAngle = fromTangent.angle() + Math.PI / 2;
                      var toAngle = toTangent.angle() + Math.PI / 2;
                      return [new kite.Segment.Arc( center, lineWidth / 2, fromAngle, toAngle, true )];
                    case 'miter':
                      var theta = fromTangent.angleBetween( toTangent.negated() );
                      if ( 1 / Math.sin( theta / 2 ) <= lineStyles.miterLimit && theta < Math.PI - 0.00001 ) {
                        // draw the miter
                        var miterPoint = lineLineIntersection( fromPoint, fromPoint.plus( fromTangent ), toPoint, toPoint.plus( toTangent ) );
                        return [
                          new kite.Segment.Line( fromPoint, miterPoint ),
                          new kite.Segment.Line( miterPoint, toPoint )
                        ];
                      }
                      else {
                        // angle too steep, use bevel instead. same as below, but copied for linter
                        return bevel;
                      }
                      break;
                    case 'bevel':
                      return bevel;
                  }
                }
                else {
                  // no join necessary here since we have the acute angle. just simple lineTo for now so that the next segment starts from the right place
                  // TODO: can we prevent self-intersection here?
                  return bevel;
                }
              }
        
              // draws the necessary line cap from the endpoint 'center' in the direction of the tangent
              function cap( center, tangent ) {
                var fromPoint = center.plus( tangent.perpendicular().times( -lineWidth / 2 ) );
                var toPoint = center.plus( tangent.perpendicular().times( lineWidth / 2 ) );
        
                switch( lineStyles.lineCap ) {
                  case 'butt':
                    return [new kite.Segment.Line( fromPoint, toPoint )];
                  case 'round':
                    var tangentAngle = tangent.angle();
                    return [new kite.Segment.Arc( center, lineWidth / 2, tangentAngle + Math.PI / 2, tangentAngle - Math.PI / 2, true )];
                  case 'square':
                    var toLeft = tangent.perpendicular().negated().times( lineWidth / 2 );
                    var toRight = tangent.perpendicular().times( lineWidth / 2 );
                    var toFront = tangent.times( lineWidth / 2 );
        
                    var left = center.plus( toLeft ).plus( toFront );
                    var right = center.plus( toRight ).plus( toFront );
                    return [
                      new kite.Segment.Line( fromPoint, left ),
                      new kite.Segment.Line( left, right ),
                      new kite.Segment.Line( right, toPoint )
                    ];
                }
              }
        
              var i;
              var leftSegments = [];
              var rightSegments = [];
              var firstSegment = this.getFirstSegment();
              var lastSegment = this.getLastSegment();
        
              function addLeftSegments( segments ) {
                leftSegments = leftSegments.concat( segments );
              }
        
              function addRightSegments( segments ) {
                rightSegments = rightSegments.concat( segments );
              }
        
              // we don't need to insert an implicit closing segment if the start and end points are the same
              var alreadyClosed = lastSegment.end.equals( firstSegment.start );
              // if there is an implicit closing segment
              var closingSegment = alreadyClosed ? null : new kite.Segment.Line( this.segments[this.segments.length - 1].end, this.segments[0].start );
        
              // stroke the logical "left" side of our path
              for ( i = 0; i < this.segments.length; i++ ) {
                if ( i > 0 ) {
                  addLeftSegments( join( this.segments[i].start, this.segments[i - 1].endTangent, this.segments[i].startTangent, true ) );
                }
                addLeftSegments( this.segments[i].strokeLeft( lineWidth ) );
              }
        
              // stroke the logical "right" side of our path
              for ( i = this.segments.length - 1; i >= 0; i-- ) {
                if ( i < this.segments.length - 1 ) {
                  addRightSegments( join( this.segments[i].end, this.segments[i + 1].startTangent.negated(), this.segments[i].endTangent.negated(), false ) );
                }
                addRightSegments( this.segments[i].strokeRight( lineWidth ) );
              }
        
              var subpaths;
              if ( this.closed ) {
                if ( alreadyClosed ) {
                  // add the joins between the start and end
                  addLeftSegments( join( lastSegment.end, lastSegment.endTangent, firstSegment.startTangent ) );
                  addRightSegments( join( lastSegment.end, firstSegment.startTangent.negated(), lastSegment.endTangent.negated() ) );
                }
                else {
                  // logical "left" stroke on the implicit closing segment
                  addLeftSegments( join( closingSegment.start, lastSegment.endTangent, closingSegment.startTangent ) );
                  addLeftSegments( closingSegment.strokeLeft( lineWidth ) );
                  addLeftSegments( join( closingSegment.end, closingSegment.endTangent, firstSegment.startTangent ) );
        
                  // logical "right" stroke on the implicit closing segment
                  addRightSegments( join( closingSegment.end, firstSegment.startTangent.negated(), closingSegment.endTangent.negated() ) );
                  addRightSegments( closingSegment.strokeRight( lineWidth ) );
                  addRightSegments( join( closingSegment.start, closingSegment.startTangent.negated(), lastSegment.endTangent.negated() ) );
                }
                subpaths = [
                  new Subpath( leftSegments, null, true ),
                  new Subpath( rightSegments, null, true )
                ];
              }
              else {
                subpaths = [
                  new Subpath( leftSegments
                      .concat( cap( lastSegment.end, lastSegment.endTangent ) )
                      .concat( rightSegments )
                      .concat( cap( firstSegment.start, firstSegment.startTangent.negated() ) ),
                    null, true )
                ];
              }
        
              this._strokedSubpaths = subpaths;
              this._strokedSubpathsComputed = true;
              this._strokedStyles = new kite.LineStyles( lineStyles ); // shallow copy, since we consider linestyles to be mutable
        
              return subpaths;
            }
          };
        
          return kite.Subpath;
        } );
        
        // generated from svgPath.pegjs, with added kite namespace and require.js compatibility
        
        define( 'KITE/parser/svgPath',['require','KITE/kite'],function( require ) {
        
          var kite = require( 'KITE/kite' );
        
          /*
           * Generated by PEG.js 0.7.0.
           *
           * http://pegjs.majda.cz/
           */
        
          function quote( s ) {
            /*
             * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
             * string literal except for the closing quote character, backslash,
             * carriage return, line separator, paragraph separator, and line feed.
             * Any character may appear in the form of an escape sequence.
             *
             * For portability, we also escape escape all control and non-ASCII
             * characters. Note that "\0" and "\v" escape sequences are not used
             * because JSHint does not like the first and IE the second.
             */
            return '"' + s
              .replace( /\\/g, '\\\\' )  // backslash
              .replace( /"/g, '\\"' )    // closing quote character
              .replace( /\x08/g, '\\b' ) // backspace
              .replace( /\t/g, '\\t' )   // horizontal tab
              .replace( /\n/g, '\\n' )   // line feed
              .replace( /\f/g, '\\f' )   // form feed
              .replace( /\r/g, '\\r' )   // carriage return
              .replace( /[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape )
              + '"';
          }
        
          kite.svgPath = {
            /*
             * Parses the input with a generated parser. If the parsing is successfull,
             * returns a value explicitly or implicitly specified by the grammar from
             * which the parser was generated (see |PEG.buildParser|). If the parsing is
             * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
             */
            parse: function( input, startRule ) {
              var parseFunctions = {
                "svgPath": parse_svgPath,
                "movetoDrawtoCommandGroups": parse_movetoDrawtoCommandGroups,
                "movetoDrawtoCommandGroup": parse_movetoDrawtoCommandGroup,
                "drawtoCommands": parse_drawtoCommands,
                "drawtoCommand": parse_drawtoCommand,
                "moveto": parse_moveto,
                "movetoArgumentSequence": parse_movetoArgumentSequence,
                "closepath": parse_closepath,
                "lineto": parse_lineto,
                "linetoArgumentSequence": parse_linetoArgumentSequence,
                "horizontalLineto": parse_horizontalLineto,
                "horizontalLinetoArgumentSequence": parse_horizontalLinetoArgumentSequence,
                "verticalLineto": parse_verticalLineto,
                "verticalLinetoArgumentSequence": parse_verticalLinetoArgumentSequence,
                "curveto": parse_curveto,
                "curvetoArgumentSequence": parse_curvetoArgumentSequence,
                "curvetoArgument": parse_curvetoArgument,
                "smoothCurveto": parse_smoothCurveto,
                "smoothCurvetoArgumentSequence": parse_smoothCurvetoArgumentSequence,
                "smoothCurvetoArgument": parse_smoothCurvetoArgument,
                "quadraticBezierCurveto": parse_quadraticBezierCurveto,
                "quadraticBezierCurvetoArgumentSequence": parse_quadraticBezierCurvetoArgumentSequence,
                "quadraticBezierCurvetoArgument": parse_quadraticBezierCurvetoArgument,
                "smoothQuadraticBezierCurveto": parse_smoothQuadraticBezierCurveto,
                "smoothQuadraticBezierCurvetoArgumentSequence": parse_smoothQuadraticBezierCurvetoArgumentSequence,
                "ellipticalArc": parse_ellipticalArc,
                "ellipticalArcArgumentSequence": parse_ellipticalArcArgumentSequence,
                "ellipticalArcArgument": parse_ellipticalArcArgument,
                "coordinatePair": parse_coordinatePair,
                "nonnegativeNumber": parse_nonnegativeNumber,
                "number": parse_number,
                "flag": parse_flag,
                "commaWsp": parse_commaWsp,
                "comma": parse_comma,
                "floatingPointConstant": parse_floatingPointConstant,
                "fractionalConstant": parse_fractionalConstant,
                "exponent": parse_exponent,
                "sign": parse_sign,
                "digitSequence": parse_digitSequence,
                "digit": parse_digit,
                "wsp": parse_wsp
              };
        
              if ( startRule !== undefined ) {
                if ( parseFunctions[startRule] === undefined ) {
                  throw new Error( "Invalid rule name: " + quote( startRule ) + "." );
                }
              }
              else {
                startRule = "svgPath";
              }
        
              var pos = 0;
              var reportFailures = 0;
              var rightmostFailuresPos = 0;
              var rightmostFailuresExpected = [];
        
              function padLeft( input, padding, length ) {
                var result = input;
        
                var padLength = length - input.length;
                for ( var i = 0; i < padLength; i++ ) {
                  result = padding + result;
                }
        
                return result;
              }
        
              function escape( ch ) {
                var charCode = ch.charCodeAt( 0 );
                var escapeChar;
                var length;
        
                if ( charCode <= 0xFF ) {
                  escapeChar = 'x';
                  length = 2;
                }
                else {
                  escapeChar = 'u';
                  length = 4;
                }
        
                return '\\' + escapeChar + padLeft( charCode.toString( 16 ).toUpperCase(), '0', length );
              }
        
              function matchFailed( failure ) {
                if ( pos < rightmostFailuresPos ) {
                  return;
                }
        
                if ( pos > rightmostFailuresPos ) {
                  rightmostFailuresPos = pos;
                  rightmostFailuresExpected = [];
                }
        
                rightmostFailuresExpected.push( failure );
              }
        
              function parse_svgPath() {
                var result0, result1, result2, result3;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = [];
                result1 = parse_wsp();
                while ( result1 !== null ) {
                  result0.push( result1 );
                  result1 = parse_wsp();
                }
                if ( result0 !== null ) {
                  result1 = parse_movetoDrawtoCommandGroups();
                  result1 = result1 !== null ? result1 : "";
                  if ( result1 !== null ) {
                    result2 = [];
                    result3 = parse_wsp();
                    while ( result3 !== null ) {
                      result2.push( result3 );
                      result3 = parse_wsp();
                    }
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, path ) { return path ? path : []; })( pos0, result0[1] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                return result0;
              }
        
              function parse_movetoDrawtoCommandGroups() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_movetoDrawtoCommandGroup();
                if ( result0 !== null ) {
                  result1 = [];
                  result2 = parse_wsp();
                  while ( result2 !== null ) {
                    result1.push( result2 );
                    result2 = parse_wsp();
                  }
                  if ( result1 !== null ) {
                    result2 = parse_movetoDrawtoCommandGroups();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, a, b ) { return a.concat( b ); })( pos0, result0[0], result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  result0 = parse_movetoDrawtoCommandGroup();
                  if ( result0 !== null ) {
                    result0 = (function( offset, a ) { return a; })( pos0, result0 );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_movetoDrawtoCommandGroup() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_moveto();
                if ( result0 !== null ) {
                  result1 = [];
                  result2 = parse_wsp();
                  while ( result2 !== null ) {
                    result1.push( result2 );
                    result2 = parse_wsp();
                  }
                  if ( result1 !== null ) {
                    result2 = parse_drawtoCommands();
                    result2 = result2 !== null ? result2 : "";
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, m, c ) { return c.length ? m.concat( c ) : m; })( pos0, result0[0], result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                return result0;
              }
        
              function parse_drawtoCommands() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_drawtoCommand();
                if ( result0 !== null ) {
                  result1 = [];
                  result2 = parse_wsp();
                  while ( result2 !== null ) {
                    result1.push( result2 );
                    result2 = parse_wsp();
                  }
                  if ( result1 !== null ) {
                    result2 = parse_drawtoCommands();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, cmd, cmds ) { return cmd.concat( cmds ); })( pos0, result0[0], result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  result0 = parse_drawtoCommand();
                  if ( result0 !== null ) {
                    result0 = (function( offset, cmd ) { return cmd; })( pos0, result0 );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_drawtoCommand() {
                var result0;
        
                result0 = parse_closepath();
                if ( result0 === null ) {
                  result0 = parse_lineto();
                  if ( result0 === null ) {
                    result0 = parse_horizontalLineto();
                    if ( result0 === null ) {
                      result0 = parse_verticalLineto();
                      if ( result0 === null ) {
                        result0 = parse_curveto();
                        if ( result0 === null ) {
                          result0 = parse_smoothCurveto();
                          if ( result0 === null ) {
                            result0 = parse_quadraticBezierCurveto();
                            if ( result0 === null ) {
                              result0 = parse_smoothQuadraticBezierCurveto();
                              if ( result0 === null ) {
                                result0 = parse_ellipticalArc();
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                return result0;
              }
        
              function parse_moveto() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                if ( input.charCodeAt( pos ) === 77 ) {
                  result0 = "M";
                  pos++;
                }
                else {
                  result0 = null;
                  if ( reportFailures === 0 ) {
                    matchFailed( "\"M\"" );
                  }
                }
                if ( result0 !== null ) {
                  result1 = [];
                  result2 = parse_wsp();
                  while ( result2 !== null ) {
                    result1.push( result2 );
                    result2 = parse_wsp();
                  }
                  if ( result1 !== null ) {
                    result2 = parse_movetoArgumentSequence();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, args ) { return createMoveTo( args, false ); })( pos0, result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  pos1 = pos;
                  if ( input.charCodeAt( pos ) === 109 ) {
                    result0 = "m";
                    pos++;
                  }
                  else {
                    result0 = null;
                    if ( reportFailures === 0 ) {
                      matchFailed( "\"m\"" );
                    }
                  }
                  if ( result0 !== null ) {
                    result1 = [];
                    result2 = parse_wsp();
                    while ( result2 !== null ) {
                      result1.push( result2 );
                      result2 = parse_wsp();
                    }
                    if ( result1 !== null ) {
                      result2 = parse_movetoArgumentSequence();
                      if ( result2 !== null ) {
                        result0 = [result0, result1, result2];
                      }
                      else {
                        result0 = null;
                        pos = pos1;
                      }
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                  if ( result0 !== null ) {
                    result0 = (function( offset, args ) { return createMoveTo( args, true ); })( pos0, result0[2] );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_movetoArgumentSequence() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_coordinatePair();
                if ( result0 !== null ) {
                  result1 = parse_commaWsp();
                  result1 = result1 !== null ? result1 : "";
                  if ( result1 !== null ) {
                    result2 = parse_linetoArgumentSequence();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, pair, list ) { return [pair].concat( list ); })( pos0, result0[0], result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  result0 = parse_coordinatePair();
                  if ( result0 !== null ) {
                    result0 = (function( offset, pair ) { return [pair]; })( pos0, result0 );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_closepath() {
                var result0;
                var pos0;
        
                pos0 = pos;
                if ( input.charCodeAt( pos ) === 90 ) {
                  result0 = "Z";
                  pos++;
                }
                else {
                  result0 = null;
                  if ( reportFailures === 0 ) {
                    matchFailed( "\"Z\"" );
                  }
                }
                if ( result0 === null ) {
                  if ( input.charCodeAt( pos ) === 122 ) {
                    result0 = "z";
                    pos++;
                  }
                  else {
                    result0 = null;
                    if ( reportFailures === 0 ) {
                      matchFailed( "\"z\"" );
                    }
                  }
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, command ) { return { cmd: 'close' }; })( pos0, result0 );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                return result0;
              }
        
              function parse_lineto() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                if ( input.charCodeAt( pos ) === 76 ) {
                  result0 = "L";
                  pos++;
                }
                else {
                  result0 = null;
                  if ( reportFailures === 0 ) {
                    matchFailed( "\"L\"" );
                  }
                }
                if ( result0 !== null ) {
                  result1 = [];
                  result2 = parse_wsp();
                  while ( result2 !== null ) {
                    result1.push( result2 );
                    result2 = parse_wsp();
                  }
                  if ( result1 !== null ) {
                    result2 = parse_linetoArgumentSequence();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, args ) { return args.map( function( arg ) { return { cmd: 'lineTo', args: [ arg.x, arg.y ] }; } ); })( pos0, result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  pos1 = pos;
                  if ( input.charCodeAt( pos ) === 108 ) {
                    result0 = "l";
                    pos++;
                  }
                  else {
                    result0 = null;
                    if ( reportFailures === 0 ) {
                      matchFailed( "\"l\"" );
                    }
                  }
                  if ( result0 !== null ) {
                    result1 = [];
                    result2 = parse_wsp();
                    while ( result2 !== null ) {
                      result1.push( result2 );
                      result2 = parse_wsp();
                    }
                    if ( result1 !== null ) {
                      result2 = parse_linetoArgumentSequence();
                      if ( result2 !== null ) {
                        result0 = [result0, result1, result2];
                      }
                      else {
                        result0 = null;
                        pos = pos1;
                      }
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                  if ( result0 !== null ) {
                    result0 = (function( offset, args ) { return args.map( function( arg ) { return { cmd: 'lineToRelative', args: [ arg.x, arg.y ] }; } ); })( pos0, result0[2] );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_linetoArgumentSequence() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_coordinatePair();
                if ( result0 !== null ) {
                  result1 = parse_commaWsp();
                  result1 = result1 !== null ? result1 : "";
                  if ( result1 !== null ) {
                    result2 = parse_linetoArgumentSequence();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, a, b ) { return [a].concat( b ); })( pos0, result0[0], result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  result0 = parse_coordinatePair();
                  if ( result0 !== null ) {
                    result0 = (function( offset, a ) { return [a]; })( pos0, result0 );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_horizontalLineto() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                if ( input.charCodeAt( pos ) === 72 ) {
                  result0 = "H";
                  pos++;
                }
                else {
                  result0 = null;
                  if ( reportFailures === 0 ) {
                    matchFailed( "\"H\"" );
                  }
                }
                if ( result0 !== null ) {
                  result1 = [];
                  result2 = parse_wsp();
                  while ( result2 !== null ) {
                    result1.push( result2 );
                    result2 = parse_wsp();
                  }
                  if ( result1 !== null ) {
                    result2 = parse_horizontalLinetoArgumentSequence();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, args ) { return args.map( function( arg ) { return { cmd: 'horizontalLineTo', args: [ arg ] } } ); })( pos0, result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  pos1 = pos;
                  if ( input.charCodeAt( pos ) === 104 ) {
                    result0 = "h";
                    pos++;
                  }
                  else {
                    result0 = null;
                    if ( reportFailures === 0 ) {
                      matchFailed( "\"h\"" );
                    }
                  }
                  if ( result0 !== null ) {
                    result1 = [];
                    result2 = parse_wsp();
                    while ( result2 !== null ) {
                      result1.push( result2 );
                      result2 = parse_wsp();
                    }
                    if ( result1 !== null ) {
                      result2 = parse_horizontalLinetoArgumentSequence();
                      if ( result2 !== null ) {
                        result0 = [result0, result1, result2];
                      }
                      else {
                        result0 = null;
                        pos = pos1;
                      }
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                  if ( result0 !== null ) {
                    result0 = (function( offset, args ) { return args.map( function( arg ) { return { cmd: 'horizontalLineToRelative', args: [ arg ] } } ); })( pos0, result0[2] );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_horizontalLinetoArgumentSequence() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_number();
                if ( result0 !== null ) {
                  result1 = parse_commaWsp();
                  result1 = result1 !== null ? result1 : "";
                  if ( result1 !== null ) {
                    result2 = parse_horizontalLinetoArgumentSequence();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, a, b ) { return [a].concat( b ); })( pos0, result0[0], result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  result0 = parse_number();
                  if ( result0 !== null ) {
                    result0 = (function( offset, a ) { return [a]; })( pos0, result0 );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_verticalLineto() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                if ( input.charCodeAt( pos ) === 86 ) {
                  result0 = "V";
                  pos++;
                }
                else {
                  result0 = null;
                  if ( reportFailures === 0 ) {
                    matchFailed( "\"V\"" );
                  }
                }
                if ( result0 !== null ) {
                  result1 = [];
                  result2 = parse_wsp();
                  while ( result2 !== null ) {
                    result1.push( result2 );
                    result2 = parse_wsp();
                  }
                  if ( result1 !== null ) {
                    result2 = parse_verticalLinetoArgumentSequence();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, args ) { return args.map( function( arg ) { return { cmd: 'verticalLineTo', args: [ arg ] } } ); })( pos0, result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  pos1 = pos;
                  if ( input.charCodeAt( pos ) === 118 ) {
                    result0 = "v";
                    pos++;
                  }
                  else {
                    result0 = null;
                    if ( reportFailures === 0 ) {
                      matchFailed( "\"v\"" );
                    }
                  }
                  if ( result0 !== null ) {
                    result1 = [];
                    result2 = parse_wsp();
                    while ( result2 !== null ) {
                      result1.push( result2 );
                      result2 = parse_wsp();
                    }
                    if ( result1 !== null ) {
                      result2 = parse_verticalLinetoArgumentSequence();
                      if ( result2 !== null ) {
                        result0 = [result0, result1, result2];
                      }
                      else {
                        result0 = null;
                        pos = pos1;
                      }
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                  if ( result0 !== null ) {
                    result0 = (function( offset, args ) { return args.map( function( arg ) { return { cmd: 'verticalLineToRelative', args: [ arg ] } } ); })( pos0, result0[2] );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_verticalLinetoArgumentSequence() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_number();
                if ( result0 !== null ) {
                  result1 = parse_commaWsp();
                  result1 = result1 !== null ? result1 : "";
                  if ( result1 !== null ) {
                    result2 = parse_verticalLinetoArgumentSequence();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, a, b ) { return [a].concat( b ); })( pos0, result0[0], result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  result0 = parse_number();
                  if ( result0 !== null ) {
                    result0 = (function( offset, a ) { return [a]; })( pos0, result0 );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_curveto() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                if ( input.charCodeAt( pos ) === 67 ) {
                  result0 = "C";
                  pos++;
                }
                else {
                  result0 = null;
                  if ( reportFailures === 0 ) {
                    matchFailed( "\"C\"" );
                  }
                }
                if ( result0 !== null ) {
                  result1 = [];
                  result2 = parse_wsp();
                  while ( result2 !== null ) {
                    result1.push( result2 );
                    result2 = parse_wsp();
                  }
                  if ( result1 !== null ) {
                    result2 = parse_curvetoArgumentSequence();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, args ) { return args.map( function( arg ) { return { cmd: 'cubicCurveTo', args: arg } } ); })( pos0, result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  pos1 = pos;
                  if ( input.charCodeAt( pos ) === 99 ) {
                    result0 = "c";
                    pos++;
                  }
                  else {
                    result0 = null;
                    if ( reportFailures === 0 ) {
                      matchFailed( "\"c\"" );
                    }
                  }
                  if ( result0 !== null ) {
                    result1 = [];
                    result2 = parse_wsp();
                    while ( result2 !== null ) {
                      result1.push( result2 );
                      result2 = parse_wsp();
                    }
                    if ( result1 !== null ) {
                      result2 = parse_curvetoArgumentSequence();
                      if ( result2 !== null ) {
                        result0 = [result0, result1, result2];
                      }
                      else {
                        result0 = null;
                        pos = pos1;
                      }
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                  if ( result0 !== null ) {
                    result0 = (function( offset, args ) { return args.map( function( arg ) { return { cmd: 'cubicCurveToRelative', args: arg } } ); })( pos0, result0[2] );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_curvetoArgumentSequence() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_curvetoArgument();
                if ( result0 !== null ) {
                  result1 = parse_commaWsp();
                  result1 = result1 !== null ? result1 : "";
                  if ( result1 !== null ) {
                    result2 = parse_curvetoArgumentSequence();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, a, list ) { return [a].concat( list ); })( pos0, result0[0], result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  result0 = parse_curvetoArgument();
                  if ( result0 !== null ) {
                    result0 = (function( offset, a ) { return [a]; })( pos0, result0 );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_curvetoArgument() {
                var result0, result1, result2, result3, result4;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_coordinatePair();
                if ( result0 !== null ) {
                  result1 = parse_commaWsp();
                  result1 = result1 !== null ? result1 : "";
                  if ( result1 !== null ) {
                    result2 = parse_coordinatePair();
                    if ( result2 !== null ) {
                      result3 = parse_commaWsp();
                      result3 = result3 !== null ? result3 : "";
                      if ( result3 !== null ) {
                        result4 = parse_coordinatePair();
                        if ( result4 !== null ) {
                          result0 = [result0, result1, result2, result3, result4];
                        }
                        else {
                          result0 = null;
                          pos = pos1;
                        }
                      }
                      else {
                        result0 = null;
                        pos = pos1;
                      }
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, a, b, c ) { return [ a.x, a.y, b.x, b.y, c.x, c.y ]; })( pos0, result0[0], result0[2], result0[4] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                return result0;
              }
        
              function parse_smoothCurveto() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                if ( input.charCodeAt( pos ) === 83 ) {
                  result0 = "S";
                  pos++;
                }
                else {
                  result0 = null;
                  if ( reportFailures === 0 ) {
                    matchFailed( "\"S\"" );
                  }
                }
                if ( result0 !== null ) {
                  result1 = [];
                  result2 = parse_wsp();
                  while ( result2 !== null ) {
                    result1.push( result2 );
                    result2 = parse_wsp();
                  }
                  if ( result1 !== null ) {
                    result2 = parse_smoothCurvetoArgumentSequence();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, args ) { return args.map( function( arg ) { return { cmd: 'smoothCubicCurveTo', args: arg } } ); })( pos0, result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  pos1 = pos;
                  if ( input.charCodeAt( pos ) === 115 ) {
                    result0 = "s";
                    pos++;
                  }
                  else {
                    result0 = null;
                    if ( reportFailures === 0 ) {
                      matchFailed( "\"s\"" );
                    }
                  }
                  if ( result0 !== null ) {
                    result1 = [];
                    result2 = parse_wsp();
                    while ( result2 !== null ) {
                      result1.push( result2 );
                      result2 = parse_wsp();
                    }
                    if ( result1 !== null ) {
                      result2 = parse_smoothCurvetoArgumentSequence();
                      if ( result2 !== null ) {
                        result0 = [result0, result1, result2];
                      }
                      else {
                        result0 = null;
                        pos = pos1;
                      }
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                  if ( result0 !== null ) {
                    result0 = (function( offset, args ) { return args.map( function( arg ) { return { cmd: 'smoothCubicCurveToRelative', args: arg } } ); })( pos0, result0[2] );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_smoothCurvetoArgumentSequence() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_smoothCurvetoArgument();
                if ( result0 !== null ) {
                  result1 = parse_commaWsp();
                  result1 = result1 !== null ? result1 : "";
                  if ( result1 !== null ) {
                    result2 = parse_smoothCurvetoArgumentSequence();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, a, list ) { return [a].concat( list ); })( pos0, result0[0], result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  result0 = parse_smoothCurvetoArgument();
                  if ( result0 !== null ) {
                    result0 = (function( offset, a ) { return [a]; })( pos0, result0 );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_smoothCurvetoArgument() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_coordinatePair();
                if ( result0 !== null ) {
                  result1 = parse_commaWsp();
                  result1 = result1 !== null ? result1 : "";
                  if ( result1 !== null ) {
                    result2 = parse_coordinatePair();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, a, b ) { return [ a.x, a.y, b.x, b.y ]; })( pos0, result0[0], result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                return result0;
              }
        
              function parse_quadraticBezierCurveto() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                if ( input.charCodeAt( pos ) === 81 ) {
                  result0 = "Q";
                  pos++;
                }
                else {
                  result0 = null;
                  if ( reportFailures === 0 ) {
                    matchFailed( "\"Q\"" );
                  }
                }
                if ( result0 !== null ) {
                  result1 = [];
                  result2 = parse_wsp();
                  while ( result2 !== null ) {
                    result1.push( result2 );
                    result2 = parse_wsp();
                  }
                  if ( result1 !== null ) {
                    result2 = parse_quadraticBezierCurvetoArgumentSequence();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, args ) { return args.map( function( arg ) { return { cmd: 'quadraticCurveTo', args: arg } } ); })( pos0, result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  pos1 = pos;
                  if ( input.charCodeAt( pos ) === 113 ) {
                    result0 = "q";
                    pos++;
                  }
                  else {
                    result0 = null;
                    if ( reportFailures === 0 ) {
                      matchFailed( "\"q\"" );
                    }
                  }
                  if ( result0 !== null ) {
                    result1 = [];
                    result2 = parse_wsp();
                    while ( result2 !== null ) {
                      result1.push( result2 );
                      result2 = parse_wsp();
                    }
                    if ( result1 !== null ) {
                      result2 = parse_quadraticBezierCurvetoArgumentSequence();
                      if ( result2 !== null ) {
                        result0 = [result0, result1, result2];
                      }
                      else {
                        result0 = null;
                        pos = pos1;
                      }
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                  if ( result0 !== null ) {
                    result0 = (function( offset, args ) { return args.map( function( arg ) { return { cmd: 'quadraticCurveToRelative', args: arg } } ); })( pos0, result0[2] );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_quadraticBezierCurvetoArgumentSequence() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_quadraticBezierCurvetoArgument();
                if ( result0 !== null ) {
                  result1 = parse_commaWsp();
                  result1 = result1 !== null ? result1 : "";
                  if ( result1 !== null ) {
                    result2 = parse_quadraticBezierCurvetoArgumentSequence();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, a, list ) { return [a].concat( list ); })( pos0, result0[0], result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  result0 = parse_quadraticBezierCurvetoArgument();
                  if ( result0 !== null ) {
                    result0 = (function( offset, a ) { return [a]; })( pos0, result0 );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_quadraticBezierCurvetoArgument() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_coordinatePair();
                if ( result0 !== null ) {
                  result1 = parse_commaWsp();
                  result1 = result1 !== null ? result1 : "";
                  if ( result1 !== null ) {
                    result2 = parse_coordinatePair();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, a, b ) { return [ a.x, a.y, b.x, b.y ]; })( pos0, result0[0], result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                return result0;
              }
        
              function parse_smoothQuadraticBezierCurveto() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                if ( input.charCodeAt( pos ) === 84 ) {
                  result0 = "T";
                  pos++;
                }
                else {
                  result0 = null;
                  if ( reportFailures === 0 ) {
                    matchFailed( "\"T\"" );
                  }
                }
                if ( result0 !== null ) {
                  result1 = [];
                  result2 = parse_wsp();
                  while ( result2 !== null ) {
                    result1.push( result2 );
                    result2 = parse_wsp();
                  }
                  if ( result1 !== null ) {
                    result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, args ) { return args.map( function( arg ) { return { cmd: 'smoothQuadraticCurveTo', args: [ arg.x, arg.y ] } } ); })( pos0, result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  pos1 = pos;
                  if ( input.charCodeAt( pos ) === 116 ) {
                    result0 = "t";
                    pos++;
                  }
                  else {
                    result0 = null;
                    if ( reportFailures === 0 ) {
                      matchFailed( "\"t\"" );
                    }
                  }
                  if ( result0 !== null ) {
                    result1 = [];
                    result2 = parse_wsp();
                    while ( result2 !== null ) {
                      result1.push( result2 );
                      result2 = parse_wsp();
                    }
                    if ( result1 !== null ) {
                      result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();
                      if ( result2 !== null ) {
                        result0 = [result0, result1, result2];
                      }
                      else {
                        result0 = null;
                        pos = pos1;
                      }
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                  if ( result0 !== null ) {
                    result0 = (function( offset, args ) { return args.map( function( arg ) { return { cmd: 'smoothQuadraticCurveToRelative', args: [ arg.x, arg.y ] } } ); })( pos0, result0[2] );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_smoothQuadraticBezierCurvetoArgumentSequence() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_coordinatePair();
                if ( result0 !== null ) {
                  result1 = parse_commaWsp();
                  result1 = result1 !== null ? result1 : "";
                  if ( result1 !== null ) {
                    result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, a, list ) { return [a].concat( list ); })( pos0, result0[0], result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  result0 = parse_coordinatePair();
                  if ( result0 !== null ) {
                    result0 = (function( offset, a ) { return [a]; })( pos0, result0 );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_ellipticalArc() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                if ( input.charCodeAt( pos ) === 65 ) {
                  result0 = "A";
                  pos++;
                }
                else {
                  result0 = null;
                  if ( reportFailures === 0 ) {
                    matchFailed( "\"A\"" );
                  }
                }
                if ( result0 !== null ) {
                  result1 = [];
                  result2 = parse_wsp();
                  while ( result2 !== null ) {
                    result1.push( result2 );
                    result2 = parse_wsp();
                  }
                  if ( result1 !== null ) {
                    result2 = parse_ellipticalArcArgumentSequence();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, args ) { return args.map( function( arg ) { return { cmd: 'ellipticalArcTo', args: arg } } ); })( pos0, result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  pos1 = pos;
                  if ( input.charCodeAt( pos ) === 97 ) {
                    result0 = "a";
                    pos++;
                  }
                  else {
                    result0 = null;
                    if ( reportFailures === 0 ) {
                      matchFailed( "\"a\"" );
                    }
                  }
                  if ( result0 !== null ) {
                    result1 = [];
                    result2 = parse_wsp();
                    while ( result2 !== null ) {
                      result1.push( result2 );
                      result2 = parse_wsp();
                    }
                    if ( result1 !== null ) {
                      result2 = parse_ellipticalArcArgumentSequence();
                      if ( result2 !== null ) {
                        result0 = [result0, result1, result2];
                      }
                      else {
                        result0 = null;
                        pos = pos1;
                      }
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                  if ( result0 !== null ) {
                    result0 = (function( offset, args ) { return args.map( function( arg ) { return { cmd: 'ellipticalArcToRelative', args: arg } } ); })( pos0, result0[2] );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_ellipticalArcArgumentSequence() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_ellipticalArcArgument();
                if ( result0 !== null ) {
                  result1 = parse_commaWsp();
                  result1 = result1 !== null ? result1 : "";
                  if ( result1 !== null ) {
                    result2 = parse_ellipticalArcArgumentSequence();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, a, list ) { return [a].concat( list ); })( pos0, result0[0], result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  result0 = parse_ellipticalArcArgument();
                  if ( result0 !== null ) {
                    result0 = (function( offset, a ) { return [a]; })( pos0, result0 );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_ellipticalArcArgument() {
                var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_nonnegativeNumber();
                if ( result0 !== null ) {
                  result1 = parse_commaWsp();
                  result1 = result1 !== null ? result1 : "";
                  if ( result1 !== null ) {
                    result2 = parse_nonnegativeNumber();
                    if ( result2 !== null ) {
                      result3 = parse_commaWsp();
                      result3 = result3 !== null ? result3 : "";
                      if ( result3 !== null ) {
                        result4 = parse_number();
                        if ( result4 !== null ) {
                          result5 = parse_commaWsp();
                          if ( result5 !== null ) {
                            result6 = parse_flag();
                            if ( result6 !== null ) {
                              result7 = parse_commaWsp();
                              result7 = result7 !== null ? result7 : "";
                              if ( result7 !== null ) {
                                result8 = parse_flag();
                                if ( result8 !== null ) {
                                  result9 = parse_commaWsp();
                                  result9 = result9 !== null ? result9 : "";
                                  if ( result9 !== null ) {
                                    result10 = parse_coordinatePair();
                                    if ( result10 !== null ) {
                                      result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10];
                                    }
                                    else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  }
                                  else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                }
                                else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              }
                              else {
                                result0 = null;
                                pos = pos1;
                              }
                            }
                            else {
                              result0 = null;
                              pos = pos1;
                            }
                          }
                          else {
                            result0 = null;
                            pos = pos1;
                          }
                        }
                        else {
                          result0 = null;
                          pos = pos1;
                        }
                      }
                      else {
                        result0 = null;
                        pos = pos1;
                      }
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, rx, ry, rot, largeArc, sweep, to ) { return [ rx, ry, rot, largeArc, sweep, to.x, to.y ] })( pos0, result0[0], result0[2], result0[4], result0[6], result0[8], result0[10] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                return result0;
              }
        
              function parse_coordinatePair() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_number();
                if ( result0 !== null ) {
                  result1 = parse_commaWsp();
                  result1 = result1 !== null ? result1 : "";
                  if ( result1 !== null ) {
                    result2 = parse_number();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, a, b ) { return { x: a, y: b }; })( pos0, result0[0], result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                return result0;
              }
        
              function parse_nonnegativeNumber() {
                var result0;
                var pos0;
        
                pos0 = pos;
                result0 = parse_floatingPointConstant();
                if ( result0 !== null ) {
                  result0 = (function( offset, number ) { return parseFloat( number, 10 ); })( pos0, result0 );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  result0 = parse_digitSequence();
                  if ( result0 !== null ) {
                    result0 = (function( offset, number ) { return parseInt( number, 10 ); })( pos0, result0 );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_number() {
                var result0, result1;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_sign();
                result0 = result0 !== null ? result0 : "";
                if ( result0 !== null ) {
                  result1 = parse_floatingPointConstant();
                  if ( result1 !== null ) {
                    result0 = [result0, result1];
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, sign, number ) { return parseFloat( sign + number, 10 ); })( pos0, result0[0], result0[1] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  pos1 = pos;
                  result0 = parse_sign();
                  result0 = result0 !== null ? result0 : "";
                  if ( result0 !== null ) {
                    result1 = parse_digitSequence();
                    if ( result1 !== null ) {
                      result0 = [result0, result1];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                  if ( result0 !== null ) {
                    result0 = (function( offset, sign, number ) { return parseInt( sign + number, 10 ); })( pos0, result0[0], result0[1] );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_flag() {
                var result0;
                var pos0;
        
                pos0 = pos;
                if ( input.charCodeAt( pos ) === 48 ) {
                  result0 = "0";
                  pos++;
                }
                else {
                  result0 = null;
                  if ( reportFailures === 0 ) {
                    matchFailed( "\"0\"" );
                  }
                }
                if ( result0 !== null ) {
                  result0 = (function( offset ) { return false; })( pos0 );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  if ( input.charCodeAt( pos ) === 49 ) {
                    result0 = "1";
                    pos++;
                  }
                  else {
                    result0 = null;
                    if ( reportFailures === 0 ) {
                      matchFailed( "\"1\"" );
                    }
                  }
                  if ( result0 !== null ) {
                    result0 = (function( offset ) { return true; })( pos0 );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_commaWsp() {
                var result0, result1, result2, result3;
                var pos0;
        
                pos0 = pos;
                result1 = parse_wsp();
                if ( result1 !== null ) {
                  result0 = [];
                  while ( result1 !== null ) {
                    result0.push( result1 );
                    result1 = parse_wsp();
                  }
                }
                else {
                  result0 = null;
                }
                if ( result0 !== null ) {
                  result1 = parse_comma();
                  result1 = result1 !== null ? result1 : "";
                  if ( result1 !== null ) {
                    result2 = [];
                    result3 = parse_wsp();
                    while ( result3 !== null ) {
                      result2.push( result3 );
                      result3 = parse_wsp();
                    }
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos0;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos0;
                  }
                }
                else {
                  result0 = null;
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  result0 = parse_comma();
                  if ( result0 !== null ) {
                    result1 = [];
                    result2 = parse_wsp();
                    while ( result2 !== null ) {
                      result1.push( result2 );
                      result2 = parse_wsp();
                    }
                    if ( result1 !== null ) {
                      result0 = [result0, result1];
                    }
                    else {
                      result0 = null;
                      pos = pos0;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_comma() {
                var result0;
        
                if ( input.charCodeAt( pos ) === 44 ) {
                  result0 = ",";
                  pos++;
                }
                else {
                  result0 = null;
                  if ( reportFailures === 0 ) {
                    matchFailed( "\",\"" );
                  }
                }
                return result0;
              }
        
              function parse_floatingPointConstant() {
                var result0, result1;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_fractionalConstant();
                if ( result0 !== null ) {
                  result1 = parse_exponent();
                  result1 = result1 !== null ? result1 : "";
                  if ( result1 !== null ) {
                    result0 = [result0, result1];
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, a, b ) { return a + b; })( pos0, result0[0], result0[1] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  pos1 = pos;
                  result0 = parse_digitSequence();
                  if ( result0 !== null ) {
                    result1 = parse_exponent();
                    if ( result1 !== null ) {
                      result0 = [result0, result1];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                  if ( result0 !== null ) {
                    result0 = (function( offset, a, b ) { return a + b; })( pos0, result0[0], result0[1] );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_fractionalConstant() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_digitSequence();
                result0 = result0 !== null ? result0 : "";
                if ( result0 !== null ) {
                  if ( input.charCodeAt( pos ) === 46 ) {
                    result1 = ".";
                    pos++;
                  }
                  else {
                    result1 = null;
                    if ( reportFailures === 0 ) {
                      matchFailed( "\".\"" );
                    }
                  }
                  if ( result1 !== null ) {
                    result2 = parse_digitSequence();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, a, b ) { return a + '.' + b; })( pos0, result0[0], result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  pos0 = pos;
                  pos1 = pos;
                  result0 = parse_digitSequence();
                  if ( result0 !== null ) {
                    if ( input.charCodeAt( pos ) === 46 ) {
                      result1 = ".";
                      pos++;
                    }
                    else {
                      result1 = null;
                      if ( reportFailures === 0 ) {
                        matchFailed( "\".\"" );
                      }
                    }
                    if ( result1 !== null ) {
                      result0 = [result0, result1];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                  if ( result0 !== null ) {
                    result0 = (function( offset, a ) { return a })( pos0, result0[0] );
                  }
                  if ( result0 === null ) {
                    pos = pos0;
                  }
                }
                return result0;
              }
        
              function parse_exponent() {
                var result0, result1, result2;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                if ( input.charCodeAt( pos ) === 101 ) {
                  result0 = "e";
                  pos++;
                }
                else {
                  result0 = null;
                  if ( reportFailures === 0 ) {
                    matchFailed( "\"e\"" );
                  }
                }
                if ( result0 === null ) {
                  if ( input.charCodeAt( pos ) === 69 ) {
                    result0 = "E";
                    pos++;
                  }
                  else {
                    result0 = null;
                    if ( reportFailures === 0 ) {
                      matchFailed( "\"E\"" );
                    }
                  }
                }
                if ( result0 !== null ) {
                  result1 = parse_sign();
                  result1 = result1 !== null ? result1 : "";
                  if ( result1 !== null ) {
                    result2 = parse_digitSequence();
                    if ( result2 !== null ) {
                      result0 = [result0, result1, result2];
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, a, b, c ) { return a + b + c; })( pos0, result0[0], result0[1], result0[2] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                return result0;
              }
        
              function parse_sign() {
                var result0;
        
                if ( input.charCodeAt( pos ) === 43 ) {
                  result0 = "+";
                  pos++;
                }
                else {
                  result0 = null;
                  if ( reportFailures === 0 ) {
                    matchFailed( "\"+\"" );
                  }
                }
                if ( result0 === null ) {
                  if ( input.charCodeAt( pos ) === 45 ) {
                    result0 = "-";
                    pos++;
                  }
                  else {
                    result0 = null;
                    if ( reportFailures === 0 ) {
                      matchFailed( "\"-\"" );
                    }
                  }
                }
                return result0;
              }
        
              function parse_digitSequence() {
                var result0, result1;
                var pos0, pos1;
        
                pos0 = pos;
                pos1 = pos;
                result0 = parse_digit();
                if ( result0 !== null ) {
                  result1 = parse_digitSequence();
                  if ( result1 !== null ) {
                    result0 = [result0, result1];
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
                if ( result0 !== null ) {
                  result0 = (function( offset, a, b ) { return a + b; })( pos0, result0[0], result0[1] );
                }
                if ( result0 === null ) {
                  pos = pos0;
                }
                if ( result0 === null ) {
                  result0 = parse_digit();
                }
                return result0;
              }
        
              function parse_digit() {
                var result0;
        
                if ( /^[0-9]/.test( input.charAt( pos ) ) ) {
                  result0 = input.charAt( pos );
                  pos++;
                }
                else {
                  result0 = null;
                  if ( reportFailures === 0 ) {
                    matchFailed( "[0-9]" );
                  }
                }
                return result0;
              }
        
              function parse_wsp() {
                var result0;
        
                if ( input.charCodeAt( pos ) === 32 ) {
                  result0 = " ";
                  pos++;
                }
                else {
                  result0 = null;
                  if ( reportFailures === 0 ) {
                    matchFailed( "\" \"" );
                  }
                }
                if ( result0 === null ) {
                  if ( input.charCodeAt( pos ) === 9 ) {
                    result0 = "\t";
                    pos++;
                  }
                  else {
                    result0 = null;
                    if ( reportFailures === 0 ) {
                      matchFailed( "\"\\t\"" );
                    }
                  }
                  if ( result0 === null ) {
                    if ( input.charCodeAt( pos ) === 13 ) {
                      result0 = "\r";
                      pos++;
                    }
                    else {
                      result0 = null;
                      if ( reportFailures === 0 ) {
                        matchFailed( "\"\\r\"" );
                      }
                    }
                    if ( result0 === null ) {
                      if ( input.charCodeAt( pos ) === 10 ) {
                        result0 = "\n";
                        pos++;
                      }
                      else {
                        result0 = null;
                        if ( reportFailures === 0 ) {
                          matchFailed( "\"\\n\"" );
                        }
                      }
                    }
                  }
                }
                return result0;
              }
        
        
              function cleanupExpected( expected ) {
                expected.sort();
        
                var lastExpected = null;
                var cleanExpected = [];
                for ( var i = 0; i < expected.length; i++ ) {
                  if ( expected[i] !== lastExpected ) {
                    cleanExpected.push( expected[i] );
                    lastExpected = expected[i];
                  }
                }
                return cleanExpected;
              }
        
              function computeErrorPosition() {
                /*
                 * The first idea was to use |String.split| to break the input up to the
                 * error position along newlines and derive the line and column from
                 * there. However IE's |split| implementation is so broken that it was
                 * enough to prevent it.
                 */
        
                var line = 1;
                var column = 1;
                var seenCR = false;
        
                for ( var i = 0; i < Math.max( pos, rightmostFailuresPos ); i++ ) {
                  var ch = input.charAt( i );
                  if ( ch === "\n" ) {
                    if ( !seenCR ) { line++; }
                    column = 1;
                    seenCR = false;
                  }
                  else if ( ch === "\r" || ch === "\u2028" || ch === "\u2029" ) {
                    line++;
                    column = 1;
                    seenCR = true;
                  }
                  else {
                    column++;
                    seenCR = false;
                  }
                }
        
                return { line: line, column: column };
              }
        
        
              function createMoveTo( args, isRelative ) {
                var result = [
                  {
                    cmd: isRelative ? 'moveToRelative' : 'moveTo',
                    args: [ args[0].x, args[0].y ]
                  }
                ];
        
                // any other coordinate pairs are implicit lineTos
                if ( args.length > 1 ) {
                  for ( var i = 1; i < args.length; i++ ) {
                    result.push( {
                      cmd: isRelative ? 'lineToRelative' : 'lineTo',
                      args: [ args[i].x, args[i].y ]
                    } );
                  }
                }
                return result;
              }
        
        
              var result = parseFunctions[startRule]();
        
              /*
               * The parser is now in one of the following three states:
               *
               * 1. The parser successfully parsed the whole input.
               *
               *    - |result !== null|
               *    - |pos === input.length|
               *    - |rightmostFailuresExpected| may or may not contain something
               *
               * 2. The parser successfully parsed only a part of the input.
               *
               *    - |result !== null|
               *    - |pos < input.length|
               *    - |rightmostFailuresExpected| may or may not contain something
               *
               * 3. The parser did not successfully parse any part of the input.
               *
               *   - |result === null|
               *   - |pos === 0|
               *   - |rightmostFailuresExpected| contains at least one failure
               *
               * All code following this comment (including called functions) must
               * handle these states.
               */
              if ( result === null || pos !== input.length ) {
                var offset = Math.max( pos, rightmostFailuresPos );
                var found = offset < input.length ? input.charAt( offset ) : null;
                var errorPosition = computeErrorPosition();
        
                throw new this.SyntaxError(
                  cleanupExpected( rightmostFailuresExpected ),
                  found,
                  offset,
                  errorPosition.line,
                  errorPosition.column
                );
              }
        
              return result;
            },
        
            /* Returns the parser source code. */
            toSource: function() { return this._source; }
          };
          var result = kite.svgPath;
        
          /* Thrown when a parser encounters a syntax error. */
        
          result.SyntaxError = function( expected, found, offset, line, column ) {
            function buildMessage( expected, found ) {
              var expectedHumanized, foundHumanized;
        
              switch( expected.length ) {
                case 0:
                  expectedHumanized = "end of input";
                  break;
                case 1:
                  expectedHumanized = expected[0];
                  break;
                default:
                  expectedHumanized = expected.slice( 0, expected.length - 1 ).join( ", " )
                                        + " or "
                    + expected[expected.length - 1];
              }
        
              foundHumanized = found ? quote( found ) : "end of input";
        
              return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
            }
        
            this.name = "SyntaxError";
            this.expected = expected;
            this.found = found;
            this.message = buildMessage( expected, found );
            this.offset = offset;
            this.line = line;
            this.column = column;
          };
        
          result.SyntaxError.prototype = Error.prototype;
        
          return result;
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Styles needed to determine a stroked line shape.
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'KITE/util/LineStyles',['require','KITE/kite'],function( require ) {
          
        
          var kite = require( 'KITE/kite' );
        
          kite.LineStyles = function( args ) {
            if ( args === undefined ) {
              args = {};
            }
            this.lineWidth = args.lineWidth !== undefined ? args.lineWidth : 1;
            this.lineCap = args.lineCap !== undefined ? args.lineCap : 'butt'; // butt, round, square
            this.lineJoin = args.lineJoin !== undefined ? args.lineJoin : 'miter'; // miter, round, bevel
            this.lineDash = args.lineDash ? args.lineDash : []; // [] is default, otherwise an array of numbers
            this.lineDashOffset = args.lineDashOffset !== undefined ? args.lineDashOffset : 0; // 0 default, any number
            this.miterLimit = args.miterLimit !== undefined ? args.miterLimit : 10; // see https://svgwg.org/svg2-draft/painting.html for miterLimit computations
        
            assert && assert( Array.isArray( this.lineDash ) );
          };
          var LineStyles = kite.LineStyles;
          LineStyles.prototype = {
            constructor: LineStyles,
        
            equals: function( other ) {
              var typical = this.lineWidth === other.lineWidth &&
                            this.lineCap === other.lineCap &&
                            this.lineJoin === other.lineJoin &&
                            this.miterLimit === other.miterLimit &&
                            this.lineDashOffset === other.lineDashOffset;
              if ( !typical ) {
                return false;
              }
        
              if ( this.lineDash.length === other.lineDash.length ) {
                for ( var i = 0; i < this.lineDash.length; i++ ) {
                  if ( this.lineDash[i] !== other.lineDash[i] ) {
                    return false;
                  }
                }
              }
              else {
                // line dashes must be different
                return false;
              }
        
              return true;
            }
          };
        
          return kite.LineStyles;
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Quadratic Bezier segment
         *
         * Good reference: http://cagd.cs.byu.edu/~557/text/ch2.pdf
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'KITE/segments/Quadratic',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Matrix3','DOT/Util','DOT/Util','KITE/segments/Segment'],function( require ) {
          
        
          var inherit = require( 'PHET_CORE/inherit' );
          var Bounds2 = require( 'DOT/Bounds2' );
          var Matrix3 = require( 'DOT/Matrix3' );
          var solveQuadraticRootsReal = require( 'DOT/Util' ).solveQuadraticRootsReal;
          var arePointsCollinear = require( 'DOT/Util' ).arePointsCollinear;
        
          var Segment = require( 'KITE/segments/Segment' );
        
          Segment.Quadratic = function Quadratic( start, control, end ) {
            this._start = start;
            this._control = control;
            this._end = end;
        
            // TODO: performance test removal of these undefined declarations
            this._startTangent = undefined;
            this._endTangent = undefined;
            this._tCriticalX = undefined; // replaced with null if not in range
            this._tCriticalY = undefined; // replaced with null if not in range
            this._bounds = undefined;
          };
          inherit( Segment, Segment.Quadratic, {
        
            degree: 2,
        
            getStart: function() {
              return this._start;
            },
            get start() { return this._start; },
        
            getControl: function() {
              return this._control;
            },
            get control() { return this._control; },
        
            getEnd: function() {
              return this._end;
            },
            get end() { return this._end; },
        
            getStartTangent: function() {
              if ( this._startTangent === undefined ) {
                var controlIsStart = this._start.equals( this._control );
                // TODO: allocation reduction
                this._startTangent = controlIsStart ?
                                     this._end.minus( this._start ).normalized() :
                                     this._control.minus( this._start ).normalized();
              }
              return this._startTangent;
            },
            get startTangent() { return this.getStartTangent(); },
        
            getEndTangent: function() {
              if ( this._endTangent === undefined ) {
                var controlIsEnd = this._end.equals( this._control );
                // TODO: allocation reduction
                this._endTangent = controlIsEnd ?
                                   this._end.minus( this._start ).normalized() :
                                   this._end.minus( this._control ).normalized();
              }
              return this._endTangent;
            },
            get endTangent() { return this.getEndTangent(); },
        
            getTCriticalX: function() {
              // compute x where the derivative is 0 (used for bounds and other things)
              if ( this._tCriticalX === undefined ) {
                this._tCriticalX = Segment.Quadratic.extremaT( this._start.x, this._control.x, this._end.x );
              }
              return this._tCriticalX;
            },
            get tCriticalX() { return this.getTCriticalX(); },
        
            getTCriticalY: function() {
              // compute y where the derivative is 0 (used for bounds and other things)
              if ( this._tCriticalY === undefined ) {
                this._tCriticalY = Segment.Quadratic.extremaT( this._start.y, this._control.y, this._end.y );
              }
              return this._tCriticalY;
            },
            get tCriticalY() { return this.getTCriticalY(); },
        
            getNondegenerateSegments: function() {
              var start = this._start;
              var control = this._control;
              var end = this._end;
        
              var startIsEnd = start.equals( end );
              var startIsControl = start.equals( control );
              var endIsControl = start.equals( control );
        
              if ( startIsEnd && startIsControl ) {
                // all same points
                return [];
              }
              else if ( startIsEnd ) {
                // this is a special collinear case, we basically line out to the farthest point and back
                var halfPoint = this.positionAt( 0.5 );
                return [
                  new Segment.Line( start, halfPoint ),
                  new Segment.Line( halfPoint, end )
                ];
              }
              else if ( arePointsCollinear( start, control, end ) ) {
                // if they are collinear, we can reduce to start->control and control->end, or if control is between, just one line segment
                // also, start !== end (handled earlier)
                if ( startIsControl || endIsControl ) {
                  // just a line segment!
                  return [new Segment.Line( start, end )]; // no extra nondegenerate check since start !== end
                }
                // now control point must be unique. we check to see if our rendered path will be outside of the start->end line segment
                var delta = end.minus( start );
                var p1d = control.minus( start ).dot( delta.normalized ) / delta.magnitude();
                var t = Segment.Quadratic.extremaT( 0, p1d, 1 );
                if ( t !== null && t > 0 && t < 1 ) {
                  // we have a local max inside the range, indicating that our extrema point is outside of start->end
                  // we'll line to and from it
                  var pt = this.positionAt( t );
                  return _.flatten( [
                    new Segment.Line( start, pt ).getNondegenerateSegments(),
                    new Segment.Line( pt, end ).getNondegenerateSegments()
                  ] );
                }
                else {
                  // just provide a line segment, our rendered path doesn't go outside of this
                  return [new Segment.Line( start, end )]; // no extra nondegenerate check since start !== end
                }
              }
              else {
                return [this];
              }
            },
        
            getBounds: function() {
              // calculate our temporary guaranteed lower bounds based on the end points
              if ( this._bounds === undefined ) {
                this._bounds = new Bounds2( Math.min( this._start.x, this._end.x ), Math.min( this._start.y, this._end.y ), Math.max( this._start.x, this._end.x ), Math.max( this._start.y, this._end.y ) );
        
                // compute x and y where the derivative is 0, so we can include this in the bounds
                var tCriticalX = this.getTCriticalX();
                var tCriticalY = this.getTCriticalY();
        
                if ( tCriticalX !== null && tCriticalX > 0 && tCriticalX < 1 ) {
                  this._bounds = this._bounds.withPoint( this.positionAt( tCriticalX ) );
                }
                if ( tCriticalY !== null && tCriticalY > 0 && tCriticalY < 1 ) {
                  this._bounds = this._bounds.withPoint( this.positionAt( tCriticalY ) );
                }
              }
              return this._bounds;
            },
            get bounds() { return this.getBounds(); },
        
            // can be described from t=[0,1] as: (1-t)^2 start + 2(1-t)t control + t^2 end
            positionAt: function( t ) {
              var mt = 1 - t;
              // TODO: allocation reduction
              return this._start.times( mt * mt ).plus( this._control.times( 2 * mt * t ) ).plus( this._end.times( t * t ) );
            },
        
            // derivative: 2(1-t)( control - start ) + 2t( end - control )
            tangentAt: function( t ) {
              // TODO: allocation reduction
              return this._control.minus( this._start ).times( 2 * ( 1 - t ) ).plus( this._end.minus( this._control ).times( 2 * t ) );
            },
        
            curvatureAt: function( t ) {
              // see http://cagd.cs.byu.edu/~557/text/ch2.pdf p31
              // TODO: remove code duplication with Cubic
              var epsilon = 0.0000001;
              if ( Math.abs( t - 0.5 ) > 0.5 - epsilon ) {
                var isZero = t < 0.5;
                var p0 = isZero ? this._start : this._end;
                var p1 = this._control;
                var p2 = isZero ? this._end : this._start;
                var d10 = p1.minus( p0 );
                var a = d10.magnitude();
                var h = ( isZero ? -1 : 1 ) * d10.perpendicular().normalized().dot( p2.minus( p1 ) );
                return ( h * ( this.degree - 1 ) ) / ( this.degree * a * a );
              }
              else {
                return this.subdivided( t, true )[0].curvatureAt( 1 );
              }
            },
        
            // see http://www.visgraf.impa.br/sibgrapi96/trabs/pdf/a14.pdf
            // and http://math.stackexchange.com/questions/12186/arc-length-of-bezier-curves for curvature / arc length
        
            offsetTo: function( r, reverse ) {
              // TODO: implement more accurate method at http://www.antigrain.com/research/adaptive_bezier/index.html
              // TODO: or more recently (and relevantly): http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf
              var curves = [this];
        
              // subdivide this curve
              var depth = 5; // generates 2^depth curves
              for ( var i = 0; i < depth; i++ ) {
                curves = _.flatten( _.map( curves, function( curve ) {
                  return curve.subdivided( 0.5, true );
                } ) );
              }
        
              var offsetCurves = _.map( curves, function( curve ) { return curve.approximateOffset( r ); } );
        
              if ( reverse ) {
                offsetCurves.reverse();
                offsetCurves = _.map( offsetCurves, function( curve ) { return curve.reversed( true ); } );
              }
        
              return offsetCurves;
            },
        
            subdivided: function( t ) {
              // de Casteljau method
              var leftMid = this._start.blend( this._control, t );
              var rightMid = this._control.blend( this._end, t );
              var mid = leftMid.blend( rightMid, t );
              return [
                new Segment.Quadratic( this._start, leftMid, mid ),
                new Segment.Quadratic( mid, rightMid, this._end )
              ];
            },
        
            // elevation of this quadratic Bezier curve to a cubic Bezier curve
            degreeElevated: function() {
              // TODO: allocation reduction
              return new Segment.Cubic(
                this._start,
                this._start.plus( this._control.timesScalar( 2 ) ).dividedScalar( 3 ),
                this._end.plus( this._control.timesScalar( 2 ) ).dividedScalar( 3 ),
                this._end
              );
            },
        
            reversed: function() {
              return new Segment.Quadratic( this._end, this._control, this._start );
            },
        
            approximateOffset: function( r ) {
              return new Segment.Quadratic(
                this._start.plus( ( this._start.equals( this._control ) ? this._end.minus( this._start ) : this._control.minus( this._start ) ).perpendicular().normalized().times( r ) ),
                this._control.plus( this._end.minus( this._start ).perpendicular().normalized().times( r ) ),
                this._end.plus( ( this._end.equals( this._control ) ? this._end.minus( this._start ) : this._end.minus( this._control ) ).perpendicular().normalized().times( r ) )
              );
            },
        
            getSVGPathFragment: function() {
              return 'Q ' + this._control.x + ' ' + this._control.y + ' ' + this._end.x + ' ' + this._end.y;
            },
        
            strokeLeft: function( lineWidth ) {
              return this.offsetTo( -lineWidth / 2, false );
            },
        
            strokeRight: function( lineWidth ) {
              return this.offsetTo( lineWidth / 2, true );
            },
        
            getInteriorExtremaTs: function() {
              // TODO: we assume here we are reduce, so that a criticalX doesn't equal a criticalY?
              var result = [];
              var epsilon = 0.0000000001; // TODO: general kite epsilon?
              if ( this.tCriticalX !== undefined && this.tCriticalX > epsilon && this.tCriticalX < 1 - epsilon ) {
                result.push( this.tCriticalX );
              }
              if ( this.tCriticalY !== undefined && this.tCriticalY > epsilon && this.tCriticalY < 1 - epsilon ) {
                result.push( this.tCriticalY );
              }
              return result.sort();
            },
        
            intersectsBounds: function( bounds ) {
              throw new Error( 'Segment.Quadratic.intersectsBounds unimplemented' ); // TODO: implement
            },
        
            // returns the resultant winding number of this ray intersecting this segment.
            intersection: function( ray ) {
              var self = this;
              var result = [];
        
              // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections
              var inverseMatrix = Matrix3.rotation2( -ray.dir.angle() ).timesMatrix( Matrix3.translation( -ray.pos.x, -ray.pos.y ) );
        
              var p0 = inverseMatrix.timesVector2( this._start );
              var p1 = inverseMatrix.timesVector2( this._control );
              var p2 = inverseMatrix.timesVector2( this._end );
        
              //(1-t)^2 start + 2(1-t)t control + t^2 end
              var a = p0.y - 2 * p1.y + p2.y;
              var b = -2 * p0.y + 2 * p1.y;
              var c = p0.y;
        
              var ts = solveQuadraticRootsReal( a, b, c );
        
              _.each( ts, function( t ) {
                if ( t >= 0 && t <= 1 ) {
                  var hitPoint = self.positionAt( t );
                  var unitTangent = self.tangentAt( t ).normalized();
                  var perp = unitTangent.perpendicular();
                  var toHit = hitPoint.minus( ray.pos );
        
                  // make sure it's not behind the ray
                  if ( toHit.dot( ray.dir ) > 0 ) {
                    result.push( {
                      distance: toHit.magnitude(),
                      point: hitPoint,
                      normal: perp.dot( ray.dir ) > 0 ? perp.negated() : perp,
                      wind: ray.dir.perpendicular().dot( unitTangent ) < 0 ? 1 : -1
                    } );
                  }
                }
              } );
              return result;
            },
        
            windingIntersection: function( ray ) {
              var wind = 0;
              var hits = this.intersection( ray );
              _.each( hits, function( hit ) {
                wind += hit.wind;
              } );
              return wind;
            },
        
            // assumes the current position is at start
            writeToContext: function( context ) {
              context.quadraticCurveTo( this._control.x, this._control.y, this._end.x, this._end.y );
            },
        
            transformed: function( matrix ) {
              return new Segment.Quadratic( matrix.timesVector2( this._start ), matrix.timesVector2( this._control ), matrix.timesVector2( this._end ) );
            },
        
            // given the current curve parameterized by t, will return a curve parameterized by x where t = a * x + b
            reparameterized: function( a, b ) {
              // to the polynomial pt^2 + qt + r:
              var p = this._start.plus( this._end.plus( this._control.timesScalar( -2 ) ) );
              var q = this._control.minus( this._start ).timesScalar( 2 );
              var r = this._start;
        
              // to the polynomial alpha*x^2 + beta*x + gamma:
              var alpha = p.timesScalar( a * a );
              var beta = p.timesScalar( a * b ).timesScalar( 2 ).plus( q.timesScalar( a ) );
              var gamma = p.timesScalar( b * b ).plus( q.timesScalar( b ) ).plus( r );
        
              // back to the form start,control,end
              return new Segment.Quadratic( gamma, beta.timesScalar( 0.5 ).plus( gamma ), alpha.plus( beta ).plus( gamma ) );
            }
          } );
        
          // one-dimensional solution to extrema
          Segment.Quadratic.extremaT = function( start, control, end ) {
            // compute t where the derivative is 0 (used for bounds and other things)
            var divisorX = 2 * ( end - 2 * control + start );
            if ( divisorX !== 0 ) {
              return -2 * ( control - start ) / divisorX;
            }
            else {
              return null;
            }
          };
        
          return Segment.Quadratic;
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Cubic Bezier segment.
         *
         * See http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf for info
         *
         * Good reference: http://cagd.cs.byu.edu/~557/text/ch2.pdf
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'KITE/segments/Cubic',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Vector2','DOT/Matrix3','DOT/Util','DOT/Util','DOT/Util','KITE/segments/Segment','KITE/segments/Quadratic'],function( require ) {
          
        
          var inherit = require( 'PHET_CORE/inherit' );
          var Bounds2 = require( 'DOT/Bounds2' );
          var Vector2 = require( 'DOT/Vector2' );
          var Matrix3 = require( 'DOT/Matrix3' );
          var solveQuadraticRootsReal = require( 'DOT/Util' ).solveQuadraticRootsReal;
          var solveCubicRootsReal = require( 'DOT/Util' ).solveCubicRootsReal;
          var arePointsCollinear = require( 'DOT/Util' ).arePointsCollinear;
        
          var Segment = require( 'KITE/segments/Segment' );
          require( 'KITE/segments/Quadratic' );
        
          Segment.Cubic = function Cubic( start, control1, control2, end ) {
            this._start = start;
            this._control1 = control1;
            this._control2 = control2;
            this._end = end;
        
            // TODO: performance test removal of these undefined declarations
            this._startTangent = undefined;
            this._endTangent = undefined;
            this._r = undefined;
            this._s = undefined;
        
            this._tCusp = undefined;
            this._tDeterminant = undefined;
            this._tInflection1 = undefined;
            this._tInflection2 = undefined;
            this._startQuadratic = undefined;
            this._endQuadratic = undefined;
        
            this._xExtremaT = undefined;
            this._yExtremaT = undefined;
        
            this._bounds = undefined;
          };
          inherit( Segment, Segment.Cubic, {
        
            degree: 3,
        
            getStart: function() {
              return this._start;
            },
            get start() { return this._start; },
        
            getControl1: function() {
              return this._control1;
            },
            get control1() { return this._control1; },
        
            getControl2: function() {
              return this._control2;
            },
            get control2() { return this._control2; },
        
            getEnd: function() {
              return this._end;
            },
            get end() { return this._end; },
        
            getStartTangent: function() {
              if ( this._startTangent === undefined ) {
                this._startTangent = this.tangentAt( 0 ).normalized();
              }
              return this._startTangent;
            },
            get startTangent() { return this.getStartTangent(); },
        
            getEndTangent: function() {
              if ( this._endTangent === undefined ) {
                this._endTangent = this.tangentAt( 1 ).normalized();
              }
              return this._endTangent;
            },
            get endTangent() { return this.getEndTangent(); },
        
            getR: function() {
              // from http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf
              if ( this._r === undefined ) {
                this._r = this._control1.minus( this._start ).normalized();
              }
              return this._r;
            },
            get r() { return this.getR(); },
        
            getS: function() {
              // from http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf
              if ( this._s === undefined ) {
                this._s = this.getR().perpendicular();
              }
              return this._s;
            },
            get s() { return this.getS(); },
        
            getTCusp: function() {
              if ( this._tCusp === undefined ) {
                this.computeCuspInfo();
              }
              assert && assert( this._tCusp !== undefined );
              return this._tCusp;
            },
            get tCusp() { return this.getTCusp(); },
        
            getTDeterminant: function() {
              if ( this._tDeterminant === undefined ) {
                this.computeCuspInfo();
              }
              assert && assert( this._tDeterminant !== undefined );
              return this._tDeterminant;
            },
            get tDeterminant() { return this.getTDeterminant(); },
        
            getTInflection1: function() {
              if ( this._tInflection1 === undefined ) {
                this.computeCuspInfo();
              }
              assert && assert( this._tInflection1 !== undefined );
              return this._tInflection1;
            },
            get tInflection1() { return this.getTInflection1(); },
        
            getTInflection2: function() {
              if ( this._tInflection2 === undefined ) {
                this.computeCuspInfo();
              }
              assert && assert( this._tInflection2 !== undefined );
              return this._tInflection2;
            },
            get tInflection2() { return this.getTInflection2(); },
        
            getStartQuadratic: function() {
              if ( this._startQuadratic === undefined ) {
                this.computeCuspSegments();
              }
              assert && assert( this._startQuadratic !== undefined );
              return this._startQuadratic;
            },
            get startQuadratic() { return this.getStartQuadratic(); },
        
            getEndQuadratic: function() {
              if ( this._endQuadratic === undefined ) {
                this.computeCuspSegments();
              }
              assert && assert( this._endQuadratic !== undefined );
              return this._endQuadratic;
            },
            get endQuadratic() { return this.getEndQuadratic(); },
        
            getXExtremaT: function() {
              if ( this._xExtremaT === undefined ) {
                this._xExtremaT = Segment.Cubic.extremaT( this._start.x, this._control1.x, this._control2.x, this._end.x );
              }
              return this._xExtremaT;
            },
            get xExtremaT() { return this.getXExtremaT(); },
        
            getYExtremaT: function() {
              if ( this._yExtremaT === undefined ) {
                this._yExtremaT = Segment.Cubic.extremaT( this._start.y, this._control1.y, this._control2.y, this._end.y );
              }
              return this._yExtremaT;
            },
            get yExtremaT() { return this.getYExtremaT(); },
        
            getBounds: function() {
              if ( this._bounds === undefined ) {
                this._bounds = Bounds2.NOTHING;
                this._bounds = this._bounds.withPoint( this._start );
                this._bounds = this._bounds.withPoint( this._end );
        
                var cubic = this;
                _.each( this.getXExtremaT(), function( t ) {
                  if ( t >= 0 && t <= 1 ) {
                    cubic._bounds = cubic._bounds.withPoint( cubic.positionAt( t ) );
                  }
                } );
                _.each( this.getYExtremaT(), function( t ) {
                  if ( t >= 0 && t <= 1 ) {
                    cubic._bounds = cubic._bounds.withPoint( cubic.positionAt( t ) );
                  }
                } );
        
                if ( this.hasCusp() ) {
                  this._bounds = this._bounds.withPoint( this.positionAt( this.getTCusp() ) );
                }
              }
              return this._bounds;
            },
            get bounds() { return this.getBounds(); },
        
            // t value for the cusp, and the related determinant and inflection points
            computeCuspInfo: function() {
              // from http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf
              // TODO: allocation reduction
              var a = this._start.times( -1 ).plus( this._control1.times( 3 ) ).plus( this._control2.times( -3 ) ).plus( this._end );
              var b = this._start.times( 3 ).plus( this._control1.times( -6 ) ).plus( this._control2.times( 3 ) );
              var c = this._start.times( -3 ).plus( this._control1.times( 3 ) );
        
              var aPerp = a.perpendicular();
              var bPerp = b.perpendicular();
              var aPerpDotB = aPerp.dot( b );
        
              this._tCusp = -0.5 * ( aPerp.dot( c ) / aPerpDotB );
              this._tDeterminant = this._tCusp * this._tCusp - ( 1 / 3 ) * ( bPerp.dot( c ) / aPerpDotB );
              if ( this._tDeterminant >= 0 ) {
                var sqrtDet = Math.sqrt( this._tDeterminant );
                this._tInflection1 = this._tCusp - sqrtDet;
                this._tInflection2 = this._tCusp + sqrtDet;
              }
              else {
                this._tInflection1 = null;
                this._tInflection2 = null;
              }
            },
        
            // the cusp allows us to split into 2 quadratic Bezier curves
            computeCuspSegments: function() {
              if ( this.hasCusp() ) {
                // if there is a cusp, we'll split at the cusp into two quadratic bezier curves.
                // see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.94.8088&rep=rep1&type=pdf (Singularities of rational Bezier curves - J Monterde, 2001)
                var subdividedAtCusp = this.subdivided( this.getTCusp );
                this._startQuadratic = new Segment.Quadratic( subdividedAtCusp[0].start, subdividedAtCusp[0].control1, subdividedAtCusp[0].end, false );
                this._endQuadratic = new Segment.Quadratic( subdividedAtCusp[1].start, subdividedAtCusp[1].control2, subdividedAtCusp[1].end, false );
              }
              else {
                this._startQuadratic = null;
                this._endQuadratic = null;
              }
            },
        
            getNondegenerateSegments: function() {
              var start = this._start;
              var control1 = this._control1;
              var control2 = this._control2;
              var end = this._end;
        
              var reduced = this.degreeReduced( 1e-9 );
        
              if ( start.equals( end ) && start.equals( control1 ) && start.equals( control2 ) ) {
                // degenerate point
                return [];
              }
              else if ( this.hasCusp() ) {
                return _.flatten( [
                  this._startQuadratic.getNondegenerateSegments(),
                  this._endQuadratic.getNondegenerateSegments()
                ] );
              }
              else if ( reduced ) {
                // if we can reduce to a quadratic Bezier, always do this (and make sure it is non-degenerate)
                return reduced.getNondegenerateSegments();
              }
              else if ( arePointsCollinear( start, control1, end ) && arePointsCollinear( start, control2, end ) ) {
                throw new Error( 'TODO, use extrema T funcs' );
              }
              else {
                return [this];
              }
            },
        
            hasCusp: function() {
              var tCusp = this.getTCusp();
        
              var epsilon = 1e-7; // TODO: make this available to change?
              return this.tangentAt( tCusp ).magnitude() < epsilon && tCusp >= 0 && tCusp <= 1;
            },
        
            // position: (1 - t)^3*start + 3*(1 - t)^2*t*control1 + 3*(1 - t) t^2*control2 + t^3*end
            positionAt: function( t ) {
              var mt = 1 - t;
              return this._start.times( mt * mt * mt ).plus( this._control1.times( 3 * mt * mt * t ) ).plus( this._control2.times( 3 * mt * t * t ) ).plus( this._end.times( t * t * t ) );
            },
        
            // derivative: -3 p0 (1 - t)^2 + 3 p1 (1 - t)^2 - 6 p1 (1 - t) t + 6 p2 (1 - t) t - 3 p2 t^2 + 3 p3 t^2
            tangentAt: function( t ) {
              var mt = 1 - t;
              return this._start.times( -3 * mt * mt ).plus( this._control1.times( 3 * mt * mt - 6 * mt * t ) ).plus( this._control2.times( 6 * mt * t - 3 * t * t ) ).plus( this._end.times( 3 * t * t ) );
            },
        
            curvatureAt: function( t ) {
              // see http://cagd.cs.byu.edu/~557/text/ch2.pdf p31
              // TODO: remove code duplication with Quadratic
              var epsilon = 0.0000001;
              if ( Math.abs( t - 0.5 ) > 0.5 - epsilon ) {
                var isZero = t < 0.5;
                var p0 = isZero ? this._start : this._end;
                var p1 = isZero ? this._control1 : this._control2;
                var p2 = isZero ? this._control2 : this._control1;
                var d10 = p1.minus( p0 );
                var a = d10.magnitude();
                var h = ( isZero ? -1 : 1 ) * d10.perpendicular().normalized().dot( p2.minus( p1 ) );
                return ( h * ( this.degree - 1 ) ) / ( this.degree * a * a );
              }
              else {
                return this.subdivided( t )[0].curvatureAt( 1 );
              }
            },
        
            toRS: function( point ) {
              var firstVector = point.minus( this._start );
              return new Vector2( firstVector.dot( this.getR() ), firstVector.dot( this.getS() ) );
            },
        
            subdivided: function( t ) {
              // de Casteljau method
              // TODO: add a 'bisect' or 'between' method for vectors?
              var left = this._start.blend( this._control1, t );
              var right = this._control2.blend( this._end, t );
              var middle = this._control1.blend( this._control2, t );
              var leftMid = left.blend( middle, t );
              var rightMid = middle.blend( right, t );
              var mid = leftMid.blend( rightMid, t );
              return [
                new Segment.Cubic( this._start, left, leftMid, mid ),
                new Segment.Cubic( mid, rightMid, right, this._end )
              ];
            },
        
            offsetTo: function( r, reverse ) {
              // TODO: implement more accurate method at http://www.antigrain.com/research/adaptive_bezier/index.html
              // TODO: or more recently (and relevantly): http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf
        
              // how many segments to create (possibly make this more adaptive?)
              var quantity = 32;
        
              var points = [];
              var result = [];
              for ( var i = 0; i < quantity; i++ ) {
                var t = i / ( quantity - 1 );
                if ( reverse ) {
                  t = 1 - t;
                }
        
                points.push( this.positionAt( t ).plus( this.tangentAt( t ).perpendicular().normalized().times( r ) ) );
                if ( i > 0 ) {
                  result.push( new Segment.Line( points[i - 1], points[i] ) );
                }
              }
        
              return result;
            },
        
            getSVGPathFragment: function() {
              return 'C ' + this._control1.x + ' ' + this._control1.y + ' ' + this._control2.x + ' ' + this._control2.y + ' ' + this._end.x + ' ' + this._end.y;
            },
        
            strokeLeft: function( lineWidth ) {
              return this.offsetTo( -lineWidth / 2, false );
            },
        
            strokeRight: function( lineWidth ) {
              return this.offsetTo( lineWidth / 2, true );
            },
        
            getInteriorExtremaTs: function() {
              var ts = this.getXExtremaT().concat( this.getYExtremaT() );
              var result = [];
              _.each( ts, function( t ) {
                var epsilon = 0.0000000001; // TODO: general kite epsilon?
                if ( t > epsilon && t < 1 - epsilon ) {
                  // don't add duplicate t values
                  if ( _.every( result, function( otherT ) { return Math.abs( t - otherT ) > epsilon; } ) ) {
                    result.push( t );
                  }
                }
              } );
              return result.sort();
            },
        
            intersectsBounds: function( bounds ) {
              throw new Error( 'Segment.Cubic.intersectsBounds unimplemented' ); // TODO: implement
            },
        
            // returns the resultant winding number of this ray intersecting this segment.
            intersection: function( ray ) {
              var self = this;
              var result = [];
        
              // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections
              var inverseMatrix = Matrix3.rotation2( -ray.dir.angle() ).timesMatrix( Matrix3.translation( -ray.pos.x, -ray.pos.y ) );
        
              var p0 = inverseMatrix.timesVector2( this._start );
              var p1 = inverseMatrix.timesVector2( this._control1 );
              var p2 = inverseMatrix.timesVector2( this._control2 );
              var p3 = inverseMatrix.timesVector2( this._end );
        
              // polynomial form of cubic: start + (3 control1 - 3 start) t + (-6 control1 + 3 control2 + 3 start) t^2 + (3 control1 - 3 control2 + end - start) t^3
              var a = -p0.y + 3 * p1.y - 3 * p2.y + p3.y;
              var b = 3 * p0.y - 6 * p1.y + 3 * p2.y;
              var c = -3 * p0.y + 3 * p1.y;
              var d = p0.y;
        
              var ts = solveCubicRootsReal( a, b, c, d );
        
              _.each( ts, function( t ) {
                if ( t >= 0 && t <= 1 ) {
                  var hitPoint = self.positionAt( t );
                  var unitTangent = self.tangentAt( t ).normalized();
                  var perp = unitTangent.perpendicular();
                  var toHit = hitPoint.minus( ray.pos );
        
                  // make sure it's not behind the ray
                  if ( toHit.dot( ray.dir ) > 0 ) {
                    result.push( {
                      distance: toHit.magnitude(),
                      point: hitPoint,
                      normal: perp.dot( ray.dir ) > 0 ? perp.negated() : perp,
                      wind: ray.dir.perpendicular().dot( unitTangent ) < 0 ? 1 : -1
                    } );
                  }
                }
              } );
              return result;
            },
        
            windingIntersection: function( ray ) {
              var wind = 0;
              var hits = this.intersection( ray );
              _.each( hits, function( hit ) {
                wind += hit.wind;
              } );
              return wind;
            },
        
            // assumes the current position is at start
            writeToContext: function( context ) {
              context.bezierCurveTo( this._control1.x, this._control1.y, this._control2.x, this._control2.y, this._end.x, this._end.y );
            },
        
            transformed: function( matrix ) {
              return new Segment.Cubic( matrix.timesVector2( this._start ), matrix.timesVector2( this._control1 ), matrix.timesVector2( this._control2 ), matrix.timesVector2( this._end ) );
            },
        
            // returns a degree-reduced quadratic Bezier if possible, otherwise it returns null
            degreeReduced: function( epsilon ) {
              epsilon = epsilon || 0; // if not provided, use an exact version
              // TODO: allocation reduction
              // TODO: performance: don't divide both by 2 here, combine it later!!
              var controlA = this._control1.timesScalar( 3 ).minus( this._start ).dividedScalar( 2 );
              var controlB = this._control2.timesScalar( 3 ).minus( this._end ).dividedScalar( 2 );
              if ( controlA.minus( controlB ).magnitude() <= epsilon ) {
                return new Segment.Quadratic(
                  this._start,
                  controlA.average( controlB ), // average the control points for stability. they should be almost identical
                  this._end
                );
              }
              else {
                // the two options for control points are too far away, this curve isn't easily reducible.
                return null;
              }
            }
        
            // returns the resultant winding number of this ray intersecting this segment.
            // windingIntersection: function( ray ) {
            //   // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections
            //   var inverseMatrix = Matrix3.rotation2( -ray.dir.angle() );
            //   assert && assert( inverseMatrix.timesVector2( ray.dir ).x > 0.99 ); // verify that we transform the unit vector to the x-unit
        
            //   var y0 = inverseMatrix.timesVector2( this._start ).y;
            //   var y1 = inverseMatrix.timesVector2( this._control1 ).y;
            //   var y2 = inverseMatrix.timesVector2( this._control2 ).y;
            //   var y3 = inverseMatrix.timesVector2( this._end ).y;
        
            //   // polynomial form of cubic: start + (3 control1 - 3 start) t + (-6 control1 + 3 control2 + 3 start) t^2 + (3 control1 - 3 control2 + end - start) t^3
            //   var a = -y0 + 3 * y1 - 3 * y2 + y3;
            //   var b = 3 * y0 - 6 * y1 + 3 * y2;
            //   var c = -3 * y0 + 3 * y1;
            //   var d = y0;
        
            //   // solve cubic roots
            //   var ts = solveCubicRootsReal( a, b, c, d );
        
            //   var result = 0;
        
            //   // for each hit
            //   _.each( ts, function( t ) {
            //     if ( t >= 0 && t <= 1 ) {
            //       result += ray.dir.perpendicular().dot( this.tangentAt( t ) ) < 0 ? 1 : -1;
            //     }
            //   } );
        
            //   return result;
            // }
          } );
        
          // finds what t values the cubic extrema are at (if any). This is just the 1-dimensional case, used for multiple purposes
          Segment.Cubic.extremaT = function( v0, v1, v2, v3 ) {
            // coefficients of derivative
            var a = -3 * v0 + 9 * v1 - 9 * v2 + 3 * v3;
            var b = 6 * v0 - 12 * v1 + 6 * v2;
            var c = -3 * v0 + 3 * v1;
        
            return solveQuadraticRootsReal( a, b, c );
          };
        
          return Segment.Cubic;
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Elliptical arc segment
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'KITE/segments/EllipticalArc',['require','PHET_CORE/inherit','DOT/Vector2','DOT/Bounds2','DOT/Matrix3','DOT/Transform3','DOT/Util','DOT/Util','KITE/segments/Segment','KITE/util/Subpath'],function( require ) {
          
        
          var inherit = require( 'PHET_CORE/inherit' );
          var Vector2 = require( 'DOT/Vector2' );
          var Bounds2 = require( 'DOT/Bounds2' );
          var Matrix3 = require( 'DOT/Matrix3' );
          var Transform3 = require( 'DOT/Transform3' );
          var toDegrees = require( 'DOT/Util' ).toDegrees;
          var DotUtil = require( 'DOT/Util' );
        
          var Segment = require( 'KITE/segments/Segment' );
          require( 'KITE/util/Subpath' );
        
          // TODO: notes at http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes
          // Canvas notes at http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-ellipse
          Segment.EllipticalArc = function EllipticalArc( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {
            if ( radiusX < 0 ) {
              // support this case since we might actually need to handle it inside of strokes?
              radiusX = -radiusX;
              startAngle = Math.PI - startAngle;
              endAngle = Math.PI - endAngle;
              anticlockwise = !anticlockwise;
            }
            if ( radiusY < 0 ) {
              // support this case since we might actually need to handle it inside of strokes?
              radiusY = -radiusY;
              startAngle = -startAngle;
              endAngle = -endAngle;
              anticlockwise = !anticlockwise;
            }
            if ( radiusX < radiusY ) {
              // swap radiusX and radiusY internally for consistent Canvas / SVG output
              rotation += Math.PI / 2;
              startAngle -= Math.PI / 2;
              endAngle -= Math.PI / 2;
        
              // swap radiusX and radiusY
              var tmpR = radiusX;
              radiusX = radiusY;
              radiusY = tmpR;
            }
        
            this._center = center;
            this._radiusX = radiusX;
            this._radiusY = radiusY;
            this._rotation = rotation;
            this._startAngle = startAngle;
            this._endAngle = endAngle;
            this._anticlockwise = anticlockwise;
        
            // TODO: performance test removal of these undefined declarations
            this._unitTransform = undefined;
            this._start = undefined;
            this._end = undefined;
            this._startTangent = undefined;
            this._endTangent = undefined;
            this._actualEndAngle = undefined;
            this._isFullPerimeter = undefined;
            this._angleDifference = undefined;
            this._unitArcSegment = undefined;
        
            if ( radiusX < radiusY ) {
              // TODO: check this
              throw new Error( 'Not verified to work if radiusX < radiusY' );
            }
        
            // constraints shared with Segment.Arc
            assert && assert( !( ( !anticlockwise && endAngle - startAngle <= -Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle <= -Math.PI * 2 ) ), 'Not handling elliptical arcs with start/end angles that show differences in-between browser handling' );
            assert && assert( !( ( !anticlockwise && endAngle - startAngle > Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle > Math.PI * 2 ) ), 'Not handling elliptical arcs with start/end angles that show differences in-between browser handling' );
          };
          inherit( Segment, Segment.EllipticalArc, {
        
            getCenter: function() {
              return this._center;
            },
            get center() { return this.getCenter(); },
        
            getRadiusX: function() {
              return this._radiusX;
            },
            get radiusX() { return this.getRadiusX(); },
        
            getRadiusY: function() {
              return this._radiusY;
            },
            get radiusY() { return this.getRadiusY(); },
        
            getRotation: function() {
              return this._rotation;
            },
            get rotation() { return this.getRotation(); },
        
            getStartAngle: function() {
              return this._startAngle;
            },
            get startAngle() { return this.getStartAngle(); },
        
            getEndAngle: function() {
              return this._endAngle;
            },
            get endAngle() { return this.getEndAngle(); },
        
            getAnticlockwise: function() {
              return this._anticlockwise;
            },
            get anticlockwise() { return this.getAnticlockwise(); },
        
            getUnitTransform: function() {
              if ( this._unitTransform === undefined ) {
                this._unitTransform = Segment.EllipticalArc.computeUnitTransform( this._center, this._radiusX, this._radiusY, this._rotation );
              }
              return this._unitTransform;
            },
            get unitTransform() { return this.getUnitTransform(); },
        
            getStart: function() {
              if ( this._start === undefined ) {
                this._start = this.positionAtAngle( this._startAngle );
              }
              return this._start;
            },
            get start() { return this.getStart(); },
        
            getEnd: function() {
              if ( this._end === undefined ) {
                this._end = this.positionAtAngle( this._endAngle );
              }
              return this._end;
            },
            get end() { return this.getEnd(); },
        
            getStartTangent: function() {
              if ( this._startTangent === undefined ) {
                this._startTangent = this.tangentAtAngle( this._startAngle );
              }
              return this._startTangent;
            },
            get startTangent() { return this.getStartTangent(); },
        
            getEndTangent: function() {
              if ( this._endTangent === undefined ) {
                this._endTangent = this.tangentAtAngle( this._endAngle );
              }
              return this._endTangent;
            },
            get endTangent() { return this.getEndTangent(); },
        
            getActualEndAngle: function() {
              if ( this._actualEndAngle === undefined ) {
                // compute an actual end angle so that we can smoothly go from this._startAngle to this._actualEndAngle
                if ( this._anticlockwise ) {
                  // angle is 'decreasing'
                  // -2pi <= end - start < 2pi
                  if ( this._startAngle > this._endAngle ) {
                    this._actualEndAngle = this._endAngle;
                  }
                  else if ( this._startAngle < this._endAngle ) {
                    this._actualEndAngle = this._endAngle - 2 * Math.PI;
                  }
                  else {
                    // equal
                    this._actualEndAngle = this._startAngle;
                  }
                }
                else {
                  // angle is 'increasing'
                  // -2pi < end - start <= 2pi
                  if ( this._startAngle < this._endAngle ) {
                    this._actualEndAngle = this._endAngle;
                  }
                  else if ( this._startAngle > this._endAngle ) {
                    this._actualEndAngle = this._endAngle + Math.PI * 2;
                  }
                  else {
                    // equal
                    this._actualEndAngle = this._startAngle;
                  }
                }
              }
              return this._actualEndAngle;
            },
            get actualEndAngle() { return this.getActualEndAngle(); },
        
            getIsFullPerimeter: function() {
              if ( this._isFullPerimeter === undefined ) {
                this._isFullPerimeter = ( !this._anticlockwise && this._endAngle - this._startAngle >= Math.PI * 2 ) || ( this._anticlockwise && this._startAngle - this._endAngle >= Math.PI * 2 );
              }
              return this._isFullPerimeter;
            },
            get isFullPerimeter() { return this.getIsFullPerimeter(); },
        
            getAngleDifference: function() {
              if ( this._angleDifference === undefined ) {
                // compute an angle difference that represents how "much" of the circle our arc covers
                this._angleDifference = this._anticlockwise ? this._startAngle - this._endAngle : this._endAngle - this._startAngle;
                if ( this._angleDifference < 0 ) {
                  this._angleDifference += Math.PI * 2;
                }
                assert && assert( this._angleDifference >= 0 ); // now it should always be zero or positive
              }
              return this._angleDifference;
            },
            get angleDifference() { return this.getAngleDifference(); },
        
            // a unit arg segment that we can map to our ellipse. useful for hit testing and such.
            getUnitArcSegment: function() {
              if ( this._unitArcSegment === undefined ) {
                this._unitArcSegment = new Segment.Arc( Vector2.ZERO, 1, this._startAngle, this._endAngle, this._anticlockwise );
              }
              return this._unitArcSegment;
            },
        
            // temporary shims
            getBounds: function() {
              if ( this._bounds === undefined ) {
                this._bounds = Bounds2.NOTHING.withPoint( this.getStart() )
                  .withPoint( this.getEnd() );
        
                // if the angles are different, check extrema points
                if ( this._startAngle !== this._endAngle ) {
                  // solve the mapping from the unit circle, find locations where a coordinate of the gradient is zero.
                  // we find one extrema point for both x and y, since the other two are just rotated by pi from them.
                  var xAngle = Math.atan( -( this._radiusY / this._radiusX ) * Math.tan( this._rotation ) );
                  var yAngle = Math.atan( ( this._radiusY / this._radiusX ) / Math.tan( this._rotation ) );
        
                  // check all of the extrema points
                  this.possibleExtremaAngles = [
                    xAngle,
                      xAngle + Math.PI,
                    yAngle,
                      yAngle + Math.PI
                  ];
        
                  _.each( this.possibleExtremaAngles, this.includeBoundsAtAngle.bind( this ) );
                }
              }
              return this._bounds;
            },
            get bounds() { return this.getBounds(); },
        
            getNondegenerateSegments: function() {
              if ( this._radiusX <= 0 || this._radiusY <= 0 || this._startAngle === this._endAngle ) {
                return [];
              }
              else if ( this._radiusX === this._radiusY ) {
                // reduce to an Arc
                var startAngle = this._startAngle - this._rotation;
                var endAngle = this._endAngle - this._rotation;
        
                // preserve full circles
                if ( Math.abs( this._endAngle - this._startAngle ) === Math.PI * 2 ) {
                  endAngle = this._anticlockwise ? startAngle - Math.PI * 2 : startAngle + Math.PI * 2;
                }
                return [new Segment.Arc( this._center, this._radiusX, startAngle, endAngle, this._anticlockwise )];
              }
              else {
                return [this];
              }
            },
        
            includeBoundsAtAngle: function( angle ) {
              if ( this.containsAngle( angle ) ) {
                // the boundary point is in the arc
                this._bounds = this._bounds.withPoint( this.positionAtAngle( angle ) );
              }
            },
        
            // maps a contained angle to between [startAngle,actualEndAngle), even if the end angle is lower.
            mapAngle: function( angle ) {
              // consider an assert that we contain that angle?
              return ( this._startAngle > this.getActualEndAngle() ) ?
                     DotUtil.moduloBetweenUp( angle, this._startAngle - 2 * Math.PI, this._startAngle ) :
                     DotUtil.moduloBetweenDown( angle, this._startAngle, this._startAngle + 2 * Math.PI );
            },
        
            tAtAngle: function( angle ) {
              return ( this.mapAngle( angle ) - this._startAngle ) / ( this.getActualEndAngle() - this._startAngle );
            },
        
            angleAt: function( t ) {
              return this._startAngle + ( this.getActualEndAngle() - this._startAngle ) * t;
            },
        
            positionAt: function( t ) {
              return this.positionAtAngle( this.angleAt( t ) );
            },
        
            tangentAt: function( t ) {
              return this.tangentAtAngle( this.angleAt( t ) );
            },
        
            curvatureAt: function( t ) {
              // see http://mathworld.wolfram.com/Ellipse.html (59)
              var angle = this.angleAt( t );
              var aq = this._radiusX * Math.sin( angle );
              var bq = this._radiusY * Math.cos( angle );
              var denominator = Math.pow( bq * bq + aq * aq, 3 / 2 );
              return ( this._anticlockwise ? -1 : 1 ) * this._radiusX * this._radiusY / denominator;
            },
        
            positionAtAngle: function( angle ) {
              return this.getUnitTransform().transformPosition2( Vector2.createPolar( 1, angle ) );
            },
        
            tangentAtAngle: function( angle ) {
              var normal = this.getUnitTransform().transformNormal2( Vector2.createPolar( 1, angle ) );
        
              return this._anticlockwise ? normal.perpendicular() : normal.perpendicular().negated();
            },
        
            // TODO: refactor? exact same as Segment.Arc
            containsAngle: function( angle ) {
              // transform the angle into the appropriate coordinate form
              // TODO: check anticlockwise version!
              var normalizedAngle = this._anticlockwise ? angle - this._endAngle : angle - this._startAngle;
        
              // get the angle between 0 and 2pi
              var positiveMinAngle = normalizedAngle % ( Math.PI * 2 );
              // check this because modular arithmetic with negative numbers reveal a negative number
              if ( positiveMinAngle < 0 ) {
                positiveMinAngle += Math.PI * 2;
              }
        
              return positiveMinAngle <= this.getAngleDifference();
            },
        
            // discretizes the elliptical arc and returns an offset curve as a list of lineTos
            offsetTo: function( r, reverse ) {
              // how many segments to create (possibly make this more adaptive?)
              var quantity = 32;
        
              var points = [];
              var result = [];
              for ( var i = 0; i < quantity; i++ ) {
                var ratio = i / ( quantity - 1 );
                if ( reverse ) {
                  ratio = 1 - ratio;
                }
                var angle = this.angleAt( ratio );
        
                points.push( this.positionAtAngle( angle ).plus( this.tangentAtAngle( angle ).perpendicular().normalized().times( r ) ) );
                if ( i > 0 ) {
                  result.push( new Segment.Line( points[i - 1], points[i] ) );
                }
              }
        
              return result;
            },
        
            getSVGPathFragment: function() {
              // see http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands for more info
              // rx ry x-axis-rotation large-arc-flag sweep-flag x y
              var epsilon = 0.01; // allow some leeway to render things as 'almost circles'
              var sweepFlag = this._anticlockwise ? '0' : '1';
              var largeArcFlag;
              var degreesRotation = toDegrees( this._rotation ); // bleh, degrees?
              if ( this.getAngleDifference() < Math.PI * 2 - epsilon ) {
                largeArcFlag = this.getAngleDifference() < Math.PI ? '0' : '1';
                return 'A ' + this._radiusX + ' ' + this._radiusY + ' ' + degreesRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + this.getEnd().x + ' ' + this.getEnd().y;
              }
              else {
                // ellipse (or almost-ellipse) case needs to be handled differently
                // since SVG will not be able to draw (or know how to draw) the correct circle if we just have a start and end, we need to split it into two circular arcs
        
                // get the angle that is between and opposite of both of the points
                var splitOppositeAngle = ( this._startAngle + this._endAngle ) / 2; // this _should_ work for the modular case?
                var splitPoint = this.positionAtAngle( splitOppositeAngle );
        
                largeArcFlag = '0'; // since we split it in 2, it's always the small arc
        
                var firstArc = 'A ' + this._radiusX + ' ' + this._radiusY + ' ' + degreesRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + splitPoint.x + ' ' + splitPoint.y;
                var secondArc = 'A ' + this._radiusX + ' ' + this._radiusY + ' ' + degreesRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + this.getEnd().x + ' ' + this.getEnd().y;
        
                return firstArc + ' ' + secondArc;
              }
            },
        
            strokeLeft: function( lineWidth ) {
              return this.offsetTo( -lineWidth / 2, false );
            },
        
            strokeRight: function( lineWidth ) {
              return this.offsetTo( lineWidth / 2, true );
            },
        
            // not including 0 and 1
            getInteriorExtremaTs: function() {
              var that = this;
              var result = [];
              _.each( this.possibleExtremaAngles, function( angle ) {
                if ( that.containsAngle( angle ) ) {
                  var t = that.tAtAngle( angle );
                  var epsilon = 0.0000000001; // TODO: general kite epsilon?
                  if ( t > epsilon && t < 1 - epsilon ) {
                    result.push( t );
                  }
                }
              } );
              return result.sort(); // modifies original, which is OK
            },
        
            subdivided: function( t ) {
              // TODO: verify that we don't need to switch anticlockwise here, or subtract 2pi off any angles
              var angle0 = this.angleAt( 0 );
              var angleT = this.angleAt( t );
              var angle1 = this.angleAt( 1 );
              return [
                new Segment.EllipticalArc( this._center, this._radiusX, this._radiusY, this._rotation, angle0, angleT, this._anticlockwise ),
                new Segment.EllipticalArc( this._center, this._radiusX, this._radiusY, this._rotation, angleT, angle1, this._anticlockwise )
              ];
            },
        
            intersectsBounds: function( bounds ) {
              throw new Error( 'Segment.EllipticalArc.intersectsBounds unimplemented' );
            },
        
            intersection: function( ray ) {
              // be lazy. transform it into the space of a non-elliptical arc.
              var unitTransform = this.getUnitTransform();
              var rayInUnitCircleSpace = unitTransform.inverseRay2( ray );
              var hits = this.getUnitArcSegment().intersection( rayInUnitCircleSpace );
        
              return _.map( hits, function( hit ) {
                var transformedPoint = unitTransform.transformPosition2( hit.point );
                return {
                  distance: ray.pos.distance( transformedPoint ),
                  point: transformedPoint,
                  normal: unitTransform.inverseNormal2( hit.normal ),
                  wind: hit.wind
                };
              } );
            },
        
            // returns the resultant winding number of this ray intersecting this segment.
            windingIntersection: function( ray ) {
              // be lazy. transform it into the space of a non-elliptical arc.
              var rayInUnitCircleSpace = this.getUnitTransform().inverseRay2( ray );
              return this.getUnitArcSegment().windingIntersection( rayInUnitCircleSpace );
            },
        
            // assumes the current position is at start
            writeToContext: function( context ) {
              if ( context.ellipse ) {
                context.ellipse( this._center.x, this._center.y, this._radiusX, this._radiusY, this._rotation, this._startAngle, this._endAngle, this._anticlockwise );
              }
              else {
                // fake the ellipse call by using transforms
                this.getUnitTransform().getMatrix().canvasAppendTransform( context );
                context.arc( 0, 0, 1, this._startAngle, this._endAngle, this._anticlockwise );
                this.getUnitTransform().getInverse().canvasAppendTransform( context );
              }
            },
        
            transformed: function( matrix ) {
              var transformedSemiMajorAxis = matrix.timesVector2( Vector2.createPolar( this._radiusX, this._rotation ) ).minus( matrix.timesVector2( Vector2.ZERO ) );
              var transformedSemiMinorAxis = matrix.timesVector2( Vector2.createPolar( this._radiusY, this._rotation + Math.PI / 2 ) ).minus( matrix.timesVector2( Vector2.ZERO ) );
              var rotation = transformedSemiMajorAxis.angle();
              var radiusX = transformedSemiMajorAxis.magnitude();
              var radiusY = transformedSemiMinorAxis.magnitude();
        
              var reflected = matrix.getDeterminant() < 0;
        
              // reverse the 'clockwiseness' if our transform includes a reflection
              // TODO: check reflections. swapping angle signs should fix clockwiseness
              var anticlockwise = reflected ? !this._anticlockwise : this._anticlockwise;
              var startAngle = reflected ? -this._startAngle : this._startAngle;
              var endAngle = reflected ? -this._endAngle : this._endAngle;
        
              if ( Math.abs( this._endAngle - this._startAngle ) === Math.PI * 2 ) {
                endAngle = anticlockwise ? startAngle - Math.PI * 2 : startAngle + Math.PI * 2;
              }
        
              return new Segment.EllipticalArc( matrix.timesVector2( this._center ), radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );
            }
          } );
        
          // adapted from http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes
          // transforms the unit circle onto our ellipse
          Segment.EllipticalArc.computeUnitTransform = function( center, radiusX, radiusY, rotation ) {
            return new Transform3( Matrix3.translation( center.x, center.y ) // TODO: convert to Matrix3.translation( this._center) when available
              .timesMatrix( Matrix3.rotation2( rotation ) )
              .timesMatrix( Matrix3.scaling( radiusX, radiusY ) ) );
          };
        
          return Segment.EllipticalArc;
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Shape handling
         *
         * Shapes are internally made up of Subpaths, which contain a series of segments, and are optionally closed.
         * Familiarity with how Canvas handles subpaths is helpful for understanding this code.
         *
         * Canvas spec: http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html
         * SVG spec: http://www.w3.org/TR/SVG/expanded-toc.html
         *           http://www.w3.org/TR/SVG/paths.html#PathData (for paths)
         * Notes for elliptical arcs: http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes
         * Notes for painting strokes: https://svgwg.org/svg2-draft/painting.html
         *
         * TODO: add nonzero / evenodd support when browsers support it
         * TODO: docs
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'KITE/Shape',['require','KITE/kite','DOT/Vector2','DOT/Bounds2','DOT/Ray2','KITE/util/Subpath','KITE/parser/svgPath','KITE/util/LineStyles','KITE/segments/Arc','KITE/segments/Cubic','KITE/segments/EllipticalArc','KITE/segments/Line','KITE/segments/Quadratic'],function( require ) {
          
        
          var kite = require( 'KITE/kite' );
        
          // TODO: clean up imports
          var Vector2 = require( 'DOT/Vector2' );
          var Bounds2 = require( 'DOT/Bounds2' );
          var Ray2 = require( 'DOT/Ray2' );
        
          var Subpath = require( 'KITE/util/Subpath' );
        
          var svgPath = require( 'KITE/parser/svgPath' );
          require( 'KITE/util/LineStyles' );
          require( 'KITE/segments/Arc' );
          require( 'KITE/segments/Cubic' );
          require( 'KITE/segments/EllipticalArc' );
          require( 'KITE/segments/Line' );
          require( 'KITE/segments/Quadratic' );
        
          // for brevity
          function p( x, y ) { return new Vector2( x, y ); }
        
          function v( x, y ) { return new Vector2( x, y ); } // TODO: use this version in general, it makes more sense and is easier to type
        
          // a normalized vector for non-zero winding checks
          // var weirdDir = p( Math.PI, 22 / 7 );
        
          // all arguments optional, they are for the copy() method. if used, ensure that 'bounds' is consistent with 'subpaths'
          kite.Shape = function Shape( subpaths, bounds ) {
            // lower-level piecewise mathematical description using segments, also individually immutable
            this.subpaths = ( typeof subpaths === 'object' ) ? subpaths : [];
            assert && assert( this.subpaths.length === 0 || this.subpaths[0].constructor.name !== 'Array' );
        
            // computed bounds for all pieces added so far
            this.bounds = ( bounds || Bounds2.NOTHING ).copy();
        
            var that = this;
            if ( subpaths && typeof subpaths !== 'object' ) {
              assert && assert( typeof subpaths === 'string', 'if subpaths is not an object, it must be a string' );
              // parse the SVG path
              _.each( svgPath.parse( subpaths ), function( item ) {
                assert && assert( Shape.prototype[item.cmd] !== undefined, 'method ' + item.cmd + ' from parsed SVG does not exist' );
                that[item.cmd].apply( that, item.args );
              } );
            }
        
            phetAllocation && phetAllocation( 'Shape' );
          };
          var Shape = kite.Shape;
        
          Shape.prototype = {
            constructor: Shape,
        
            moveTo: function( x, y ) { return this.moveToPoint( v( x, y ) ); },
            moveToRelative: function( x, y ) { return this.moveToPointRelative( v( x, y ) ); },
            moveToPointRelative: function( point ) { return this.moveToPoint( this.getRelativePoint().plus( point ) ); },
            moveToPoint: function( point ) {
              return this.addSubpath( new kite.Subpath().addPoint( point ) );
            },
        
            lineTo: function( x, y ) { return this.lineToPoint( v( x, y ) ); },
            lineToRelative: function( x, y ) { return this.lineToPointRelative( v( x, y ) ); },
            lineToPointRelative: function( point ) { return this.lineToPoint( this.getRelativePoint().plus( point ) ); },
            lineToPoint: function( point ) {
              // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-lineto
              if ( this.hasSubpaths() ) {
                var start = this.getLastSubpath().getLastPoint();
                var end = point;
                var line = new kite.Segment.Line( start, end );
                this.getLastSubpath().addPoint( end );
                this.addSegmentAndBounds( line );
                assert && assert( !isNaN( this.bounds.getX() ) );
              }
              else {
                this.ensure( point );
              }
        
              return this;
            },
        
            horizontalLineTo: function( x ) { return this.lineTo( x, this.getRelativePoint().y ); },
            horizontalLineToRelative: function( x ) { return this.lineToRelative( x, 0 ); },
        
            verticalLineTo: function( y ) { return this.lineTo( this.getRelativePoint().x, y ); },
            verticalLineToRelative: function( y ) { return this.lineToRelative( 0, y ); },
        
            quadraticCurveTo: function( cpx, cpy, x, y ) { return this.quadraticCurveToPoint( v( cpx, cpy ), v( x, y ) ); },
            quadraticCurveToRelative: function( cpx, cpy, x, y ) { return this.quadraticCurveToPointRelative( v( cpx, cpy ), v( x, y ) ); },
            quadraticCurveToPointRelative: function( controlPoint, point ) {
              var relativePoint = this.getRelativePoint();
              return this.quadraticCurveToPoint( relativePoint.plus( controlPoint ), relativePoint.plus( point ) );
            },
            // TODO: consider a rename to put 'smooth' farther back?
            smoothQuadraticCurveTo: function( x, y ) { return this.quadraticCurveToPoint( this.getSmoothQuadraticControlPoint(), v( x, y ) ); },
            smoothQuadraticCurveToRelative: function( x, y ) { return this.quadraticCurveToPoint( this.getSmoothQuadraticControlPoint(), v( x, y ).plus( this.getRelativePoint() ) ); },
            quadraticCurveToPoint: function( controlPoint, point ) {
              var shape = this;
        
              // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto
              this.ensure( controlPoint );
              var start = this.getLastSubpath().getLastPoint();
              var quadratic = new kite.Segment.Quadratic( start, controlPoint, point );
              this.getLastSubpath().addPoint( point );
              var nondegenerateSegments = quadratic.getNondegenerateSegments();
              _.each( nondegenerateSegments, function( segment ) {
                // TODO: optimization
                shape.addSegmentAndBounds( segment );
              } );
              return this;
            },
        
            cubicCurveTo: function( cp1x, cp1y, cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( v( cp1x, cp1y ), v( cp2x, cp2y ), v( x, y ) ); },
            cubicCurveToRelative: function( cp1x, cp1y, cp2x, cp2y, x, y ) { return this.cubicCurveToPointRelative( v( cp1x, cp1y ), v( cp2x, cp2y ), v( x, y ) ); },
            cubicCurveToPointRelative: function( control1, control2, point ) {
              var relativePoint = this.getRelativePoint();
              return this.cubicCurveToPoint( relativePoint.plus( control1 ), relativePoint.plus( control2 ), relativePoint.plus( point ) );
            },
            smoothCubicCurveTo: function( cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( this.getSmoothCubicControlPoint(), v( cp2x, cp2y ), v( x, y ) ); },
            smoothCubicCurveToRelative: function( cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( this.getSmoothCubicControlPoint(), v( cp2x, cp2y ).plus( this.getRelativePoint() ), v( x, y ).plus( this.getRelativePoint() ) ); },
            cubicCurveToPoint: function( control1, control2, point ) {
              var shape = this;
              // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto
              this.ensure( control1 );
              var start = this.getLastSubpath().getLastPoint();
              var cubic = new kite.Segment.Cubic( start, control1, control2, point );
        
              var nondegenerateSegments = cubic.getNondegenerateSegments();
              _.each( nondegenerateSegments, function( segment ) {
                shape.addSegmentAndBounds( segment );
              } );
              this.getLastSubpath().addPoint( point );
        
              return this;
            },
        
            arc: function( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) { return this.arcPoint( v( centerX, centerY ), radius, startAngle, endAngle, anticlockwise ); },
            arcPoint: function( center, radius, startAngle, endAngle, anticlockwise ) {
              // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc
        
              var arc = new kite.Segment.Arc( center, radius, startAngle, endAngle, anticlockwise );
        
              // we are assuming that the normal conditions were already met (or exceptioned out) so that these actually work with canvas
              var startPoint = arc.getStart();
              var endPoint = arc.getEnd();
        
              // if there is already a point on the subpath, and it is different than our starting point, draw a line between them
              if ( this.hasSubpaths() && this.getLastSubpath().getLength() > 0 && !startPoint.equals( this.getLastSubpath().getLastPoint(), 0 ) ) {
                this.addSegmentAndBounds( new kite.Segment.Line( this.getLastSubpath().getLastPoint(), startPoint ) );
              }
        
              if ( !this.hasSubpaths() ) {
                this.addSubpath( new kite.Subpath() );
              }
        
              // technically the Canvas spec says to add the start point, so we do this even though it is probably completely unnecessary (there is no conditional)
              this.getLastSubpath().addPoint( startPoint );
              this.getLastSubpath().addPoint( endPoint );
        
              this.addSegmentAndBounds( arc );
        
              return this;
            },
        
            ellipticalArc: function( centerX, centerY, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) { return this.ellipticalArcPoint( v( centerX, centerY ), radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ); },
            ellipticalArcPoint: function( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {
              // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc
        
              var ellipticalArc = new kite.Segment.EllipticalArc( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );
        
              // we are assuming that the normal conditions were already met (or exceptioned out) so that these actually work with canvas
              var startPoint = ellipticalArc.start;
              var endPoint = ellipticalArc.end;
        
              // if there is already a point on the subpath, and it is different than our starting point, draw a line between them
              if ( this.hasSubpaths() && this.getLastSubpath().getLength() > 0 && !startPoint.equals( this.getLastSubpath().getLastPoint(), 0 ) ) {
                this.addSegmentAndBounds( new kite.Segment.Line( this.getLastSubpath().getLastPoint(), startPoint ) );
              }
        
              if ( !this.hasSubpaths() ) {
                this.addSubpath( new kite.Subpath() );
              }
        
              // technically the Canvas spec says to add the start point, so we do this even though it is probably completely unnecessary (there is no conditional)
              this.getLastSubpath().addPoint( startPoint );
              this.getLastSubpath().addPoint( endPoint );
        
              this.addSegmentAndBounds( ellipticalArc );
        
              return this;
            },
        
            close: function() {
              if ( this.hasSubpaths() ) {
                var previousPath = this.getLastSubpath();
                var nextPath = new kite.Subpath();
        
                previousPath.close();
                this.addSubpath( nextPath );
                nextPath.addPoint( previousPath.getFirstPoint() );
              }
              return this;
            },
        
            // matches SVG's elliptical arc from http://www.w3.org/TR/SVG/paths.html
            ellipticalArcToRelative: function( radiusX, radiusY, rotation, largeArc, sweep, x, y ) {
              var relativePoint = this.getRelativePoint();
              return this.ellipticalArcTo( radiusX, radiusY, rotation, largeArc, sweep, x + relativePoint.x, y + relativePoint.y );
            },
            ellipticalArcTo: function( radiusX, radiusY, rotation, largeArc, sweep, x, y ) {
              throw new Error( 'ellipticalArcTo unimplemented' );
            },
        
            /*
             * Draws a circle using the arc() call with the following parameters:
             * circle( center, radius ) // center is a Vector2
             * circle( centerX, centerY, radius )
             */
            circle: function( centerX, centerY, radius ) {
              if ( typeof centerX === 'object' ) {
                // circle( center, radius )
                var center = centerX;
                radius = centerY;
                return this.arcPoint( center, radius, 0, Math.PI * 2, false );
              }
              else {
                // circle( centerX, centerY, radius )
                return this.arcPoint( p( centerX, centerY ), radius, 0, Math.PI * 2, false );
              }
            },
        
            /*
             * Draws an ellipse using the ellipticalArc() call with the following parameters:
             * ellipse( center, radiusX, radiusY, rotation ) // center is a Vector2
             * ellipse( centerX, centerY, radiusX, radiusY, rotation )
             *
             * The rotation is about the centerX, centerY.
             */
            ellipse: function( centerX, centerY, radiusX, radiusY, rotation ) {
              // TODO: separate into ellipse() and ellipsePoint()?
              // TODO: Ellipse/EllipticalArc has a mess of parameters. Consider parameter object, or double-check parameter handling
              if ( typeof centerX === 'object' ) {
                // ellipse( center, radiusX, radiusY, rotation )
                var center = centerX;
                rotation = radiusY;
                radiusY = radiusX;
                radiusX = centerY;
                return this.ellipticalArcPoint( center, radiusX, radiusY, rotation || 0, 0, Math.PI * 2, false );
              }
              else {
                // ellipse( centerX, centerY, radiusX, radiusY, rotation )
                return this.ellipticalArcPoint( v( centerX, centerY ), radiusX, radiusY, rotation || 0, 0, Math.PI * 2, false );
              }
            },
        
            rect: function( x, y, width, height ) {
              var subpath = new kite.Subpath();
              this.addSubpath( subpath );
              subpath.addPoint( v( x, y ) );
              subpath.addPoint( v( x + width, y ) );
              subpath.addPoint( v( x + width, y + height ) );
              subpath.addPoint( v( x, y + height ) );
              this.addSegmentAndBounds( new kite.Segment.Line( subpath.points[0], subpath.points[1] ) );
              this.addSegmentAndBounds( new kite.Segment.Line( subpath.points[1], subpath.points[2] ) );
              this.addSegmentAndBounds( new kite.Segment.Line( subpath.points[2], subpath.points[3] ) );
              subpath.close();
              this.addSubpath( new kite.Subpath() );
              this.getLastSubpath().addPoint( v( x, y ) );
              assert && assert( !isNaN( this.bounds.getX() ) );
        
              return this;
            },
        
            //Create a round rectangle. All arguments are number.
            roundRect: function( x, y, width, height, arcw, arch ) {
              var lowX = x + arcw;
              var highX = x + width - arcw;
              var lowY = y + arch;
              var highY = y + height - arch;
              // if ( true ) {
              if ( arcw === arch ) {
                // we can use circular arcs, which have well defined stroked offsets
                this
                  .arc( highX, lowY, arcw, -Math.PI / 2, 0, false )
                  .arc( highX, highY, arcw, 0, Math.PI / 2, false )
                  .arc( lowX, highY, arcw, Math.PI / 2, Math.PI, false )
                  .arc( lowX, lowY, arcw, Math.PI, Math.PI * 3 / 2, false )
                  .close();
              }
              else {
                // we have to resort to elliptical arcs
                this
                  .ellipticalArc( highX, lowY, arcw, arch, 0, -Math.PI / 2, 0, false )
                  .ellipticalArc( highX, highY, arcw, arch, 0, 0, Math.PI / 2, false )
                  .ellipticalArc( lowX, highY, arcw, arch, 0, Math.PI / 2, Math.PI, false )
                  .ellipticalArc( lowX, lowY, arcw, arch, 0, Math.PI, Math.PI * 3 / 2, false )
                  .close();
              }
              return this;
            },
        
            polygon: function( vertices ) {
              var length = vertices.length;
              if ( length > 0 ) {
                this.moveToPoint( vertices[0] );
                for ( var i = 1; i < length; i++ ) {
                  this.lineToPoint( vertices[i] );
                }
              }
              return this.close();
            },
        
            copy: function() {
              // copy each individual subpath, so future modifications to either Shape doesn't affect the other one
              return new Shape( _.map( this.subpaths, function( subpath ) { return subpath.copy(); } ), this.bounds );
            },
        
            // write out this shape's path to a canvas 2d context. does NOT include the beginPath()!
            writeToContext: function( context ) {
              var len = this.subpaths.length;
              for ( var i = 0; i < len; i++ ) {
                this.subpaths[i].writeToContext( context );
              }
            },
        
            // returns something like "M150 0 L75 200 L225 200 Z" for a triangle
            getSVGPath: function() {
              var subpathStrings = [];
              var len = this.subpaths.length;
              for ( var i = 0; i < len; i++ ) {
                var subpath = this.subpaths[i];
                if ( subpath.isDrawable() ) {
                  // since the commands after this are relative to the previous 'point', we need to specify a move to the initial point
                  var startPoint = subpath.getFirstSegment().start;
                  assert && assert( startPoint.equals( subpath.getFirstPoint(), 0.00001 ) ); // sanity check
                  var string = 'M ' + startPoint.x + ' ' + startPoint.y + ' ';
        
                  string += _.map( subpath.segments, function( segment ) { return segment.getSVGPathFragment(); } ).join( ' ' );
        
                  if ( subpath.isClosed() ) {
                    string += ' Z';
                  }
                  subpathStrings.push( string );
                }
              }
              return subpathStrings.join( ' ' );
            },
        
            // return a new Shape that is transformed by the associated matrix
            transformed: function( matrix ) {
              // TODO: allocation reduction
              var subpaths = _.map( this.subpaths, function( subpath ) { return subpath.transformed( matrix ); } );
              var bounds = _.reduce( subpaths, function( bounds, subpath ) { return bounds.union( subpath.bounds ); }, Bounds2.NOTHING );
              return new Shape( subpaths, bounds );
            },
        
            /*
             * Provided options (see Segment.nonlinearTransformed)
             * - minLevels:                       how many levels to force subdivisions
             * - maxLevels:                       prevent subdivision past this level
             * - distanceEpsilon (optional null): controls level of subdivision by attempting to ensure a maximum (squared) deviation from the curve. smaller => more subdivision
             * - curveEpsilon (optional null):    controls level of subdivision by attempting to ensure a maximum curvature change between segments. smaller => more subdivision
             * -   OR includeCurvature:           {Boolean}, whether to include a default curveEpsilon (usually off by default)
             * - pointMap (optional):             function( Vector2 ) : Vector2, represents a (usually non-linear) transformation applied
             * - methodName (optional):           if the method name is found on the segment, it is called with the expected signature function( options ) : Array[Segment]
             *                                    instead of using our brute-force logic. Supports optimizations for custom non-linear transforms (like polar coordinates)
             */
            nonlinearTransformed: function( options ) {
              // defaults
              options = _.extend( {
                minLevels: 0,
                maxLevels: 7,
                distanceEpsilon: 0.16, // NOTE: this will change when the Shape is scaled, since this is a threshold for the square of a distance value
                curveEpsilon: ( options && options.includeCurvature ) ? 0.002 : null
              }, options );
        
              // TODO: allocation reduction
              var subpaths = _.map( this.subpaths, function( subpath ) { return subpath.nonlinearTransformed( options ); } );
              var bounds = _.reduce( subpaths, function( bounds, subpath ) { return bounds.union( subpath.bounds ); }, Bounds2.NOTHING );
              return new Shape( subpaths, bounds );
            },
        
            /*
             * Maps points by treating their x coordinate as polar angle, and y coordinate as polar magnitude.
             * See http://en.wikipedia.org/wiki/Polar_coordinate_system
             *
             * Please see Shape.nonlinearTransformed for more documentation on adaptive discretization options (minLevels, maxLevels, distanceEpsilon, curveEpsilon)
             *
             * Example: A line from (0,10) to (pi,10) will be transformed to a circular arc from (10,0) to (-10,0) passing through (0,10).
             */
            polarToCartesian: function( options ) {
              return this.nonlinearTransformed( _.extend( {
                pointMap: function( p ) {
                  return Vector2.createPolar( p.y, p.x );
                  // return new Vector2( p.y * Math.cos( p.x ), p.y * Math.sin( p.x ) );
                },
                methodName: 'polarToCartesian' // this will be called on Segments if it exists to do more optimized conversion (see Line)
              }, options ) );
            },
        
            /*
             * Converts each segment into lines, using an adaptive (midpoint distance subdivision) method.
             *
             * NOTE: uses nonlinearTransformed method internally, but since we don't provide a pointMap or methodName, it won't create anything but line segments.
             * See nonlinearTransformed for documentation of options
             */
            toPiecewiseLinear: function( options ) {
              assert && assert( !options.pointMap, 'No pointMap for toPiecewiseLinear allowed, since it could create non-linear segments' );
              assert && assert( !options.methodName, 'No methodName for toPiecewiseLinear allowed, since it could create non-linear segments' );
              return this.nonlinearTransformed( options );
            },
        
            // returns the bounds. if lineStyles exists, include the stroke in the bounds
            // TODO: consider renaming to getBounds()? (yes, definitely rename)
            computeBounds: function( lineStyles ) {
              if ( lineStyles ) {
                return this.bounds.union( this.getStrokedShape( lineStyles ).bounds );
              }
              else {
                return this.bounds;
              }
            },
        
            getBoundsWithTransform: function( matrix, lineStyles ) {
              // if we don't need to handle rotation/shear, don't use the extra effort!
              if ( matrix.isAxisAligned() ) {
                return this.computeBounds( lineStyles );
              }
        
              var bounds = Bounds2.NOTHING.copy();
        
              var numSubpaths = this.subpaths.length;
              for ( var i = 0; i < numSubpaths; i++ ) {
                var subpath = this.subpaths[i];
                bounds.includeBounds( subpath.getBoundsWithTransform( matrix ) );
              }
        
              if ( lineStyles ) {
                bounds.includeBounds( this.getStrokedShape( lineStyles ).getBoundsWithTransform( matrix ) );
              }
        
              return bounds;
            },
        
            containsPoint: function( point ) {
              // we pick a ray, and determine the winding number over that ray. if the number of segments crossing it CCW == number of segments crossing it CW, then the point is contained in the shape
              var ray = new Ray2( point, Vector2.X_UNIT );
        
              return this.windingIntersection( ray ) !== 0;
            },
        
            intersection: function( ray ) {
              var hits = [];
              var numSubpaths = this.subpaths.length;
              for ( var i = 0; i < numSubpaths; i++ ) {
                var subpath = this.subpaths[i];
        
                if ( subpath.isDrawable() ) {
                  var numSegments = subpath.segments.length;
                  for ( var k = 0; k < numSegments; k++ ) {
                    var segment = subpath.segments[k];
                    hits = hits.concat( segment.intersection( ray ) );
                  }
        
                  if ( subpath.hasClosingSegment() ) {
                    hits = hits.concat( subpath.getClosingSegment().intersection( ray ) );
                  }
                }
              }
              return _.sortBy( hits, function( hit ) { return hit.distance; } );
            },
        
            windingIntersection: function( ray ) {
              var wind = 0;
        
              var numSubpaths = this.subpaths.length;
              for ( var i = 0; i < numSubpaths; i++ ) {
                var subpath = this.subpaths[i];
        
                if ( subpath.isDrawable() ) {
                  var numSegments = subpath.segments.length;
                  for ( var k = 0; k < numSegments; k++ ) {
                    wind += subpath.segments[k].windingIntersection( ray );
                  }
        
                  // handle the implicit closing line segment
                  if ( subpath.hasClosingSegment() ) {
                    wind += subpath.getClosingSegment().windingIntersection( ray );
                  }
                }
              }
        
              return wind;
            },
        
            intersectsBounds: function( bounds ) {
              var numSubpaths = this.subpaths.length;
              for ( var i = 0; i < numSubpaths; i++ ) {
                var subpath = this.subpaths[i];
        
                if ( subpath.isDrawable() ) {
                  var numSegments = subpath.segments.length;
                  for ( var k = 0; k < numSegments; k++ ) {
                    if ( subpath.segments[k].intersectsBounds( bounds ) ) {
                      return true;
                    }
                  }
        
                  // handle the implicit closing line segment
                  if ( subpath.hasClosingSegment() ) {
                    if ( subpath.getClosingSegment().intersectsBounds( bounds ) ) {
                      return true;
                    }
                  }
                }
              }
              return false;
            },
        
            // returns a new Shape that is an outline of the stroked path of this current Shape. currently not intended to be nested (doesn't do intersection computations yet)
            // TODO: rename stroked( lineStyles )
            getStrokedShape: function( lineStyles ) {
              var subpaths = [];
              var bounds = Bounds2.NOTHING.copy();
              var subLen = this.subpaths.length;
              for ( var i = 0; i < subLen; i++ ) {
                var subpath = this.subpaths[i];
                var strokedSubpath = subpath.stroked( lineStyles );
                subpaths = subpaths.concat( strokedSubpath );
              }
              subLen = subpaths.length;
              for ( i = 0; i < subLen; i++ ) {
                bounds.includeBounds( subpaths[i].bounds );
              }
              return new Shape( subpaths, bounds );
            },
        
            toString: function() {
              // TODO: consider a more verbose but safer way?
              return 'new kite.Shape( \'' + this.getSVGPath() + '\' )';
            },
        
            /*---------------------------------------------------------------------------*
            * Internal subpath computations
            *----------------------------------------------------------------------------*/
        
            addSegmentAndBounds: function( segment ) {
              this.getLastSubpath().addSegment( segment );
              this.bounds = this.bounds.includeBounds( this.getLastSubpath().bounds );
            },
        
            ensure: function( point ) {
              if ( !this.hasSubpaths() ) {
                this.addSubpath( new Subpath() );
                this.getLastSubpath().addPoint( point );
              }
            },
        
            addSubpath: function( subpath ) {
              this.subpaths.push( subpath );
        
              return this; // allow chaining
            },
        
            hasSubpaths: function() {
              return this.subpaths.length > 0;
            },
        
            getLastSubpath: function() {
              return _.last( this.subpaths );
            },
        
            // gets the last point in the last subpath, or null if it doesn't exist
            getLastPoint: function() {
              return this.hasSubpaths() ? this.getLastSubpath().getLastPoint() : null;
            },
        
            getLastSegment: function() {
              if ( !this.hasSubpaths() ) { return null; }
        
              var subpath = this.getLastSubpath();
              if ( !subpath.isDrawable() ) { return null; }
        
              return subpath.getLastSegment();
            },
        
            // returns the point to be used for smooth quadratic segments
            getSmoothQuadraticControlPoint: function() {
              var lastPoint = this.getLastPoint();
        
              var segment = this.getLastSegment();
              if ( !segment || !( segment instanceof kite.Segment.Quadratic ) ) { return lastPoint; }
        
              return lastPoint.plus( lastPoint.minus( segment.control ) );
            },
        
            // returns the point to be used for smooth cubic segments
            getSmoothCubicControlPoint: function() {
              var lastPoint = this.getLastPoint();
        
              var segment = this.getLastSegment();
              if ( !segment || !( segment instanceof kite.Segment.Cubic ) ) { return lastPoint; }
        
              return lastPoint.plus( lastPoint.minus( segment.control2 ) );
            },
        
            getRelativePoint: function() {
              var lastPoint = this.getLastPoint();
              return lastPoint ? lastPoint : Vector2.ZERO;
            }
          };
        
          /*---------------------------------------------------------------------------*
          * Shape shortcuts
          *----------------------------------------------------------------------------*/
        
          Shape.rectangle = function( x, y, width, height ) {
            return new Shape().rect( x, y, width, height );
          };
          Shape.rect = Shape.rectangle;
        
          // Create a round rectangle {Shape}, with {Number} arguments. Uses circular or elliptical arcs if given.
          Shape.roundRect = function( x, y, width, height, arcw, arch ) {
            return new Shape().roundRect( x, y, width, height, arcw, arch );
          };
          Shape.roundRectangle = Shape.roundRect;
        
          Shape.polygon = function( vertices ) {
            return new Shape().polygon( vertices );
          };
        
          Shape.bounds = function( bounds ) {
            return new Shape().rect( bounds.minX, bounds.minY, bounds.maxX - bounds.minX, bounds.maxY - bounds.minY );
          };
        
          //Create a line segment, using either (x1,y1,x2,y2) or ({x1,y1},{x2,y2}) arguments
          Shape.lineSegment = function( a, b, c, d ) {
            // TODO: add type assertions?
            if ( typeof a === 'number' ) {
              return new Shape().moveTo( a, b ).lineTo( c, d );
            }
            else {
              return new Shape().moveToPoint( a ).lineToPoint( b );
            }
          };
        
          Shape.regularPolygon = function( sides, radius ) {
            var shape = new Shape();
            _.each( _.range( sides ), function( k ) {
              var point = Vector2.createPolar( radius, 2 * Math.PI * k / sides );
              ( k === 0 ) ? shape.moveToPoint( point ) : shape.lineToPoint( point );
            } );
            return shape.close();
          };
        
          // supports both circle( centerX, centerY, radius ), circle( center, radius ), and circle( radius ) with the center default to 0,0
          Shape.circle = function( centerX, centerY, radius ) {
            if ( centerY === undefined ) {
              // circle( radius ), center = 0,0
              return new Shape().circle( 0, 0, centerX );
            }
            return new Shape().circle( centerX, centerY, radius ).close();
          };
        
          /*
           * Supports ellipse( centerX, centerY, radiusX, radiusY, rotation ), ellipse( center, radiusX, radiusY, rotation ), and ellipse( radiusX, radiusY, rotation )
           * with the center default to 0,0 and rotation of 0.  The rotation is about the centerX, centerY.
           */
          Shape.ellipse = function( centerX, centerY, radiusX, radiusY, rotation ) {
            // TODO: Ellipse/EllipticalArc has a mess of parameters. Consider parameter object, or double-check parameter handling
            if ( radiusY === undefined ) {
              // ellipse( radiusX, radiusY ), center = 0,0
              return new Shape().ellipse( 0, 0, centerX, centerY, radiusX );
            }
            return new Shape().ellipse( centerX, centerY, radiusX, radiusY, rotation ).close();
          };
        
          // supports both arc( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) and arc( center, radius, startAngle, endAngle, anticlockwise )
          Shape.arc = function( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) {
            return new Shape().arc( centerX, centerY, radius, startAngle, endAngle, anticlockwise );
          };
        
          return Shape;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Mix-in for Node's event handling, with experimental performance enhancements
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/util/FixedNodeEvents',['require','SCENERY/scenery'],function( require ) {
          
        
          var scenery = require( 'SCENERY/scenery' );
        
          var eventNames = [
            'selfBounds',
            'childBounds',
            'bounds',
            'resize',
            'boundsAccuracy'
          ];
        
          scenery.FixedNodeEvents = function FixedNodeEvents( type ) {
            var proto = type.prototype;
        
            // this should be called in the constructor to initialize
            proto.initializeNodeEvents = function() {
              this._events = {};
        
              var node = this;
        
              // TODO: performance: consider delaying this? Could affect memory usage?
              var len = eventNames.length;
              for ( var i = 0; i < len; i++ ) {
                node._events[eventNames[i]] = [];
              }
            };
        
            /**
             * @param {String}   type     The type of event, like 'resize' or 'bounds'
             * @param {Function} listener Callback, called with arguments that depend on the event type
             */
            proto.addEventListener = function( type, listener ) {
              assert && assert( type !== undefined && listener !== undefined,
                'Both a type and listener are required for addEventListener' );
        
              // most commonly a bug, maybe there will be a good use case? can always work around by wrapping with a new function each time
              assert && assert( _.indexOf( this._events[type], listener ),
                'Event listener was already there for addEventListener with type ' + type );
        
              this._events[type].push( listener );
        
              // allow chaining
              return this;
            };
        
            /**
             * Check to see whether this Node contains the specified listener
             * @param {string} type type of listener
             * @param {function} listener the listener instance
             * @returns {boolean} true if the listener is already registered with this Node
             */
            proto.containsEventListener = function( type, listener ) {
              return _.indexOf( this._events[type], listener ) >= 0;
            };
        
            /**
             * @param {String}   type     The type of event, like 'resize' or 'bounds'
             * @param {Function} listener The callback to remove.
             */
            proto.removeEventListener = function( type, listener ) {
              assert && assert( type !== undefined && listener !== undefined,
                'Both a type and listener are required for removeEventListener' );
        
              // ensure the listener is in our list
              assert && assert( _.indexOf( this._events[type], listener ) !== -1,
                'Listener did not exist for type ' + type );
        
              this._events[type].splice( _.indexOf( this._events[type], listener ), 1 );
        
              // allow chaining
              return this;
            };
        
            /*
             * Fires an event to all event listeners attached to this node. It does not bubble down to
             * all ancestors with trails, like dispatchEvent does. Use fireEvent when you only want an event
             * that is relevant for a specific node, and ancestors don't need to be notified.
             */
            proto.fireEvent = function( type, args ) {
              assert && assert( _.contains( eventNames, type ),
                'unknown event type: ' + type );
        
              var events = this._events[type];
              var len = events.length;
              if ( len ) { // TODO: consider removing branch? is this even helpful?
                var copy = events.slice( 0 ); // defensive copy, in case listeners are added or removed as a side effect of a listener being called
                for ( var i = 0; i < len; i++ ) {
                  copy[i]( args );
                }
              }
            };
          };
          var FixedNodeEvents = scenery.FixedNodeEvents;
        
          return FixedNodeEvents;
        } );
        
        
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * A node for the Scenery scene graph. Supports general directed acyclic graphics (DAGs).
         * Handles multiple layers with assorted types (Canvas 2D, SVG, DOM, WebGL, etc.).
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/nodes/Node',['require','DOT/Bounds2','DOT/Transform3','DOT/Matrix3','DOT/Vector2','DOT/Util','KITE/Shape','SCENERY/scenery','SCENERY/util/FixedNodeEvents'],function( require ) {
          
          
          var Bounds2 = require( 'DOT/Bounds2' );
          var Transform3 = require( 'DOT/Transform3' );
          var Matrix3 = require( 'DOT/Matrix3' );
          var Vector2 = require( 'DOT/Vector2' );
          var clamp = require( 'DOT/Util' ).clamp;
          
          var Shape = require( 'KITE/Shape' );
          
          var scenery = require( 'SCENERY/scenery' );
          var NodeEvents = require( 'SCENERY/util/FixedNodeEvents' ); // uncapitalized, because of JSHint (TODO: find the flag)
          // require( 'SCENERY/layers/Renderer' ); // commented out so Require.js doesn't balk at the circular dependency
          
          // TODO: FIXME: Why do I have to comment out this dependency?
          // require( 'SCENERY/util/Trail' );
          // require( 'SCENERY/util/TrailPointer' );
          
          var globalIdCounter = 1;
          
          /*
           * Available keys for use in the options parameter object for a vanilla Node (not inherited), in the order they are executed in:
           *
           * children:         A list of children to add (in order)
           * cursor:           Will display the specified CSS cursor when the mouse is over this Node or one of its descendents. The Scene needs to have input listeners attached with an initialize method first.
           * visible:          If false, this node (and its children) will not be displayed (or get input events)
           * pickable:         If false, this node (and its children) will not get input events
           * translation:      Sets the translation of the node to either the specified dot.Vector2 value, or the x,y values from an object (e.g. translation: { x: 1, y: 2 } )
           * x:                Sets the x-translation of the node
           * y:                Sets the y-translation of the node
           * rotation:         Sets the rotation of the node in radians
           * scale:            Sets the scale of the node. Supports either a number (same x-y scale), or a dot.Vector2 / object with ob.x and ob.y to set the scale for each axis independently
           * left:             Sets the x-translation so that the left (min X) of the bounding box (in the parent coordinate frame) is at the specified value
           * right:            Sets the x-translation so that the right (max X) of the bounding box (in the parent coordinate frame) is at the specified value
           * top:              Sets the y-translation so that the top (min Y) of the bounding box (in the parent coordinate frame) is at the specified value
           * bottom:           Sets the y-translation so that the bottom (min Y) of the bounding box (in the parent coordinate frame) is at the specified value
           * centerX:          Sets the x-translation so that the horizontal center of the bounding box (in the parent coordinate frame) is at the specified value
           * centerY:          Sets the y-translation so that the vertical center of the bounding box (in the parent coordinate frame) is at the specified value
           * renderer:         Forces Scenery to use the specific renderer (canvas/svg) to display this node (and if possible, children). Accepts both strings (e.g. 'canvas', 'svg', etc.) or actual Renderer objects (e.g. Renderer.Canvas, Renderer.SVG, etc.)
           * rendererOptions:  Parameter object that is passed to the created layer, and can affect how the layering process works.
           * layerSplit:       Forces a split between layers before and after this node (and its children) have been rendered. Useful for performance with Canvas-based renderers.
           * mouseArea:        Shape (in local coordinate frame) that overrides the 'hit area' for mouse input.
           * touchArea:        Shape (in local coordinate frame) that overrides the 'hit area' for touch input.
           * clipArea:         Shape (in local coordinate frame) that causes any graphics outside of the shape to be invisible (for the node and any children).
           */
          scenery.Node = function Node( options ) {
            var self = this;
            
            // assign a unique ID to this node (allows trails to get a unique list of IDs)
            this._id = globalIdCounter++;
            
            // all of the Instances tracking this Node (across multiple layers and scenes)
            this._instances = [];
            
            // Whether this node (and its children) will be visible when the scene is updated. Visible nodes by default will not be pickable either
            this._visible = true;
            
            // Opacity from 0 to 1
            this._opacity = 1;
            
            // Whether this node (and its subtree) will allow hit-testing (and thus user interaction). Notably:
            // pickable: null  - default. Node is only pickable if it (or an ancestor/descendant) has either an input listener or pickable: true set
            // pickable: false - Node (and subtree) is pickable, just like if there is an input listener
            // pickable: true  - Node is unpickable (only has an effect when underneath a node with an input listener / pickable: true set)
            this._pickable = null;
            
            // This node and all children will be clipped by this shape (in addition to any other clipping shapes).
            // The shape should be in the local coordinate frame
            this._clipArea = null;
            
            // areas for hit intersection. if set on a Node, no descendants can handle events
            this._mouseArea = null; // {Shape|Bounds2} for mouse position          in the local coordinate frame
            this._touchArea = null; // {Shape|Bounds2} for touch and pen position  in the local coordinate frame
            
            // the CSS cursor to be displayed over this node. null should be the default (inherit) value
            this._cursor = null;
            
            this._children = []; // ordered
            this._parents = []; // unordered
            
            this._peers = []; // array of peer factories: { element: ..., options: ... }, where element can be an element or a string
            this._liveRegions = []; // array of live region instances
        
            // whether we will do more accurate (and tight) bounds computations for rotations or shears
            this._transformBounds = false;
            
            /*
             * Set up the transform reference. we add a listener so that the transform itself can be modified directly
             * by reference, or node.transform = <transform> / node.setTransform() can be used to change the transform reference.
             * Both should trigger the necessary event notifications for Scenery to keep track internally.
             */
            this._transform = new Transform3();
            this._transformListener = {
              // TODO: performance handling so we don't need to do two recursions!
              before: function() { self.beforeTransformChange(); },
              after: function() { self.afterTransformChange(); }
            };
            this._transform.addTransformListener( this._transformListener );
            
            this._inputListeners = []; // for user input handling (mouse/touch)
            this.initializeNodeEvents(); // for internal events like paint invalidation, layer invalidation, etc.
            
            // bounds handling
            this._bounds = Bounds2.NOTHING;      // for this node and its children, in "parent" coordinates
            this._selfBounds = Bounds2.NOTHING;  // just for this node, in "local" coordinates
            this._childBounds = Bounds2.NOTHING; // just for children, in "local" coordinates
            this._localBounds = null; // just used for an override currently, will be replaced in Scenery ohtwo
            this._boundsDirty = true;
            this._selfBoundsDirty = this.isPainted();
            this._childBoundsDirty = true;
            
            // Similar to bounds, but includes any mouse/touch areas respectively. They are validated separately (immediately after normal bounds validation),
            // and are only non-null if there are mouseAreas/touchAreas in this node or any descendants. null indicates that the normal bounds can be treated
            // as the mouse/touch bounds, and hit pruning can use those instead. These are needed because mouse/touch areas (and thus pruning bounds) can be
            // larger than the actual bounds (display bounds, _bounds above)
            this._mouseBounds = null;
            this._mouseBoundsDirty = true;
            this._touchBounds = null;
            this._touchBoundsDirty = true;
            
            // dirty region handling
            this._paintDirty = false;        // whether the self paint is dirty (just this node, none of its children)
            this._subtreePaintDirty = false; // whether the subtree paint is dirty (this node and its children, usually after a transform)
            this._childPaintDirty = false;   // whether the child paint is dirty (excluding self paint, just used for finding _paintDirty, _selfPaintDirty)
            
            // what type of renderer should be forced for this node.
            this._renderer = null;
            this._rendererOptions = null; // options that will determine the layer type
            this._rendererLayerType = null; // cached layer type that is used by the LayerStrategy
            
            // whether layers should be split before and after this node
            this._layerSplit = false;
            
            // the subtree pickable count is #pickable:true + #inputListeners, since we can prune subtrees with a pickable count of 0
            this._subtreePickableCount = 0;
            
            this._rendererBitmask = scenery.bitmaskNodeDefault;
            this._subtreeRendererBitmask = scenery.bitmaskNodeDefault; // value not important initially, since it is dirty
            // this._subtreeRendererBitmaskDirty = true; // TODO: include dirty flag!
            
            if ( options ) {
              this.mutate( options );
            }
            
            phetAllocation && phetAllocation( 'Node' );
          };
          var Node = scenery.Node;
          
          Node.prototype = {
            constructor: Node,
            
            insertChild: function( index, node ) {
              assert && assert( node !== null && node !== undefined, 'insertChild cannot insert a null/undefined child' );
              assert && assert( !_.contains( this._children, node ), 'Parent already contains child' );
              assert && assert( node !== this, 'Cannot add self as a child' );
              
              // needs to be early to prevent re-entrant children modifications
              this.changePickableCount( node._subtreePickableCount );
              
              node._parents.push( this );
              this._children.splice( index, 0, node );
              
              node.invalidateBounds();
              this._boundsDirty = true; // like calling this.invalidateBounds(), but we already marked all ancestors with dirty child bounds
              
              this.markForInsertion( node, index );
              this.notifyStitch( false );
              
              node.invalidateSubtreePaint();
            },
            
            addChild: function( node ) {
              this.insertChild( this._children.length, node );
            },
            
            removeChild: function( node ) {
              assert && assert( node );
              assert && assert( this.isChild( node ) );
              
              var indexOfChild = _.indexOf( this._children, node );
              
              this.removeChildWithIndex( node, indexOfChild );
            },
            
            removeChildAt: function( index ) {
              assert && assert( index >= 0 );
              assert && assert( index < this._children.length );
              
              var node = this._children[index];
              
              this.removeChildWithIndex( node, index );
            },
            
            // meant for internal use
            removeChildWithIndex: function( node, indexOfChild ) {
              assert && assert( node );
              assert && assert( this.isChild( node ) );
              assert && assert( this._children[indexOfChild] === node );
              
              // needs to be early to prevent re-entrant children modifications
              this.changePickableCount( -node._subtreePickableCount );
              
              node.markOldPaint( false );
              
              var indexOfParent = _.indexOf( node._parents, this );
              
              this.markForRemoval( node, indexOfChild );
              
              node._parents.splice( indexOfParent, 1 );
              this._children.splice( indexOfChild, 1 );
              
              this.invalidateBounds();
              this._childBoundsDirty = true; // force recomputation of child bounds after removing a child
              
              this.notifyStitch( false );
            },
            
            removeAllChildren: function() {
              this.setChildren( [] );
            },
            
            // TODO: efficiency by batching calls?
            setChildren: function( children ) {
              if ( this._children !== children ) {
                // remove all children in a way where we don't have to copy the child array for safety
                while ( this._children.length ) {
                  this.removeChild( this._children[this._children.length-1] );
                }
                
                var len = children.length;
                for ( var i = 0; i < len; i++ ) {
                  this.addChild( children[i] );
                }
              }
            },
            
            getChildren: function() {
              // TODO: ensure we are not triggering this in Scenery code when not necessary!
              return this._children.slice( 0 ); // create a defensive copy
            },
            
            getChildrenCount: function() {
              return this._children.length;
            },
            
            getParents: function() {
              return this._parents.slice( 0 ); // create a defensive copy
            },
            
            // returns a single parent if it exists, otherwise null (no parents), or an assertion failure (multiple parents)
            getParent: function() {
              assert && assert( this._parents.length <= 1, 'Cannot call getParent on a node with multiple parents' );
              return this._parents.length ? this._parents[0] : null;
            },
            
            getChildAt: function( index ) {
              return this._children[index];
            },
            
            indexOfParent: function( parent ) {
              return _.indexOf( this._parents, parent );
            },
            
            indexOfChild: function( child ) {
              return _.indexOf( this._children, child );
            },
            
            moveToFront: function() {
              var self = this;
              _.each( this._parents.slice( 0 ), function( parent ) {
                parent.moveChildToFront( self );
              } );
            },
            
            moveChildToFront: function( child ) {
              if ( this.indexOfChild( child ) !== this._children.length - 1 ) {
                this.removeChild( child );
                this.addChild( child );
              }
            },
            
            moveToBack: function() {
              var self = this;
              _.each( this._parents.slice( 0 ), function( parent ) {
                parent.moveChildToBack( self );
              } );
            },
            
            moveChildToBack: function( child ) {
              if ( this.indexOfChild( child ) !== 0 ) {
                this.removeChild( child );
                this.insertChild( 0, child );
              }
            },
            
            // remove this node from its parents
            detach: function() {
              var that = this;
              _.each( this._parents.slice( 0 ), function( parent ) {
                parent.removeChild( that );
              } );
            },
            
            // propagate the pickable count change down to our ancestors
            changePickableCount: function( n ) {
              this._subtreePickableCount += n;
              assert && assert( this._subtreePickableCount >= 0, 'subtree pickable count should be guaranteed to be >= 0' );
              var len = this._parents.length;
              for ( var i = 0; i < len; i++ ) {
                this._parents[i].changePickableCount( n );
              }
            },
            
            // currently, there is no way to remove peers. if a string is passed as the element pattern, it will be turned into an element
            addPeer: function( element, options ) {
              assert && assert( !this.instances.length, 'Cannot call addPeer after a node has instances (yet)' );
              
              this._peers.push( { element: element, options: options } );
            },
        
            /**               
             * @param property any object that has es5 getter for 'value' es5 setter for value, and 
             */
            addLiveRegion: function( property, options ) {
              this._liveRegions.push( {property: property, options: options} );
            },
            
            // should be overridden to modify (increase ONLY if Canvas is involved) the node's bounds. Return the expanded bounds.
            overrideBounds: function( computedBounds ) {
              return computedBounds;
            },
            
            // ensure that cached bounds stored on this node (and all children) are accurate
            validateBounds: function() {
              var that = this;
              var i;
              
              if ( this._selfBoundsDirty ) {
                // note: this should only be triggered if the bounds were actually changed, since we have a guard in place at invalidateSelf()
                this._selfBoundsDirty = false;
                
                // TODO: consider changing to parameter object (that may be a problem for the GC overhead)
                this.fireEvent( 'selfBounds', this._selfBounds );
              }
              
              // validate bounds of children if necessary
              if ( this._childBoundsDirty ) {
                
                // have each child validate their own bounds
                i = this._children.length;
                while ( i-- ) {
                  this._children[i].validateBounds();
                }
                
                var oldChildBounds = this._childBounds;
                
                // and recompute our _childBounds
                this._childBounds = Bounds2.NOTHING.copy();
                
                i = this._children.length;
                while ( i-- ) {
                  this._childBounds.includeBounds( this._children[i]._bounds );
                }
                
                // run this before firing the event
                this._childBoundsDirty = false;
                
                if ( !this._childBounds.equals( oldChildBounds ) ) {
                  // TODO: consider changing to parameter object (that may be a problem for the GC overhead)
                  this.fireEvent( 'childBounds', this._childBounds );
                }
              }
              
              // TODO: layout here?
              
              if ( this._boundsDirty ) {
                // run this before firing the event
                this._boundsDirty = false;
                
                var oldBounds = this._bounds;
        
                var newBounds;
        
                if ( this._localBounds ) {
                  // ignore clipArea for local bounds override
                  newBounds = this.localToParentBounds( this._localBounds );
                } else if ( this._transformBounds && !this._transform.getMatrix().isAxisAligned() ) {
                  // we will be mutating this matrix and bounds
                  var matrix = this._transform.getMatrix().copy();
                  newBounds = Bounds2.NOTHING.copy();
        
                  this.includeTransformedSubtreeBounds( matrix, newBounds );
        
                  if ( this.hasClipArea() ) {
                    newBounds = newBounds.intersection( this._clipArea.getBoundsWithTransform( matrix ) );
                  }
                } else {
                  // converts local to parent bounds. mutable methods used to minimize number of created bounds instances (we create one so we don't change references to the old one)
                  var localBounds = this._selfBounds.copy().includeBounds( this._childBounds );
        
                  if ( this.hasClipArea() ) {
                    // localBounds clipping in the local coordinate frame
                    localBounds = localBounds.intersection( this._clipArea.bounds );
                  }
        
                  // mutable here, since we copied localBounds above
                  newBounds = this.transformBoundsFromLocalToParent( localBounds );
                }
        
                newBounds = this.overrideBounds( newBounds ); // allow expansion of the bounds area
                var changed = !newBounds.equals( oldBounds );
                
                if ( changed ) {
                  this._bounds = newBounds;
                  
                  i = this._parents.length;
                  while ( i-- ) {
                    this._parents[i].invalidateBounds();
                  }
                  
                  // TODO: consider changing to parameter object (that may be a problem for the GC overhead)
                  this.fireEvent( 'bounds', this._bounds );
                }
              }
              
              // if there were side-effects, run the validation again until we are clean
              if ( this._selfBoundsDirty || this._childBoundsDirty || this._boundsDirty ) {
                // TODO: if there are side-effects in listeners, this could overflow the stack. we should report an error instead of locking up
                this.validateBounds();
              }
              
              // double-check that all of our bounds handling has been accurate
              if ( assertSlow ) {
                // new scope for safety
                (function(){
                  var epsilon = 0.000001;
                  
                  var childBounds = Bounds2.NOTHING.copy();
                  _.each( that.children, function( child ) { childBounds.includeBounds( child._bounds ); } );
                  
                  var fullBounds = that.localToParentBounds( that._selfBounds ).union( that.localToParentBounds( childBounds ) );
                  
                  if ( that.hasClipArea() ) {
                    fullBounds = fullBounds.intersection( that.getClipArea().bounds );
                  }
                  
                  assertSlow && assertSlow( that._childBounds.equalsEpsilon( childBounds, epsilon ), 'Child bounds mismatch after validateBounds: ' +
                                                                                                            that._childBounds.toString() + ', expected: ' + childBounds.toString() );
                  assertSlow && assertSlow( that._transformBounds || that._bounds.equalsEpsilon( fullBounds, epsilon ) ||
                                                            that._bounds.equalsEpsilon( that.overrideBounds( fullBounds ), epsilon ),
                                                            'Bounds mismatch after validateBounds: ' + that._bounds.toString() + ', expected: ' + fullBounds.toString() );
                })();
              }
            },
        
            // @private: for transformed bounds computation. mutates both arguments
            includeTransformedSubtreeBounds: function( matrix, bounds ) {
              if ( !this._selfBounds.isEmpty() ) {
                bounds.includeBounds( this.getTransformedSelfBounds( matrix ) );
              }
        
              var numChildren = this._children.length;
              for ( var i = 0; i < numChildren; i++ ) {
                var child = this._children[i];
        
                matrix.multiplyMatrix( child._transform.getMatrix() );
                child.includeTransformedSubtreeBounds( matrix, bounds );
                matrix.multiplyMatrix( child._transform.getInverse() );
              }
        
              return bounds;
            },
            
            validateMouseBounds: function() {
              var that = this;
              
              assert && assert( !this._selfBoundsDirty && !this._childBoundsDirty && !this._boundsDirty, 'Bounds must be validated before calling validateMouseBounds' );
              
              if ( this._mouseBoundsDirty ) {
                var hasMouseAreas = false;
                
                // --- mouseBounds in local coordinates for now, transformed later
                this._mouseBounds = this._selfBounds.copy(); // start with the self bounds, then add from there
                
                // union of all children's mouse bounds (if they exist)
                var i = this._children.length;
                while ( i-- ) {
                  var child = this._children[i];
                  child.validateMouseBounds();
                  if ( child._mouseBounds ) {
                    hasMouseAreas = true;
                    that._mouseBounds.includeBounds( child._mouseBounds );
                  }
                }
                
                // do this before the transformation to the parent coordinate frame
                if ( this._mouseArea ) {
                  hasMouseAreas = true;
                  this._mouseBounds.includeBounds( this._mouseArea.isBounds ? this._mouseArea : this._mouseArea.bounds );
                }
                
                if ( this.hasClipArea() ) {
                  // exclude areas outside of the clipping area's bounds (for efficiency)
                  this._mouseBounds = this._mouseBounds.intersection( this._clipArea.bounds );
                }
                
                if ( hasMouseAreas ) {
                  // --- mouseBounds put into parent coordinates here
                  // transform it to the parent coordinate frame\
                  this.transformBoundsFromLocalToParent( this._mouseBounds );
                  
                  // and include the normal bounds, so that we don't have to 
                  this._mouseBounds.includeBounds( this._bounds );
                } else {
                  this._mouseBounds = null; // no mouse areas under this node
                }
                
                this._mouseBoundsDirty = false;
              }
            },
            
            validateTouchBounds: function() {
              var that = this;
              
              assert && assert( !this._selfBoundsDirty && !this._childBoundsDirty && !this._boundsDirty, 'Bounds must be validated before calling validateTouchBounds' );
              
              if ( this._touchBoundsDirty ) {
                var hasTouchAreas = false;
                
                // --- touchBounds in local coordinates for now, transformed later
                this._touchBounds = this._selfBounds.copy(); // start with the self bounds, then add from there
                
                // union of all children's touch bounds (if they exist)
                var i = this._children.length;
                while ( i-- ) {
                  var child = this._children[i];
                  child.validateTouchBounds();
                  if ( child._touchBounds ) {
                    hasTouchAreas = true;
                    that._touchBounds.includeBounds( child._touchBounds );
                  }
                }
                
                // do this before the transformation to the parent coordinate frame
                if ( this._touchArea ) {
                  hasTouchAreas = true;
                  this._touchBounds.includeBounds( this._touchArea.isBounds ? this._touchArea : this._touchArea.bounds );
                }
                
                if ( this.hasClipArea() ) {
                  // exclude areas outside of the clipping area's bounds (for efficiency)
                  this._touchBounds = this._touchBounds.intersection( this._clipArea.bounds );
                }
                
                if ( hasTouchAreas ) {
                  // --- touchBounds put into parent coordinates here
                  // transform it to the parent coordinate frame
                  this.transformBoundsFromLocalToParent( this._touchBounds );
                  
                  // and include the normal bounds, so that we don't have to 
                  this._touchBounds.includeBounds( this._bounds );
                } else {
                  this._touchBounds = null; // no touch areas under this node
                }
                
                this._touchBoundsDirty = false;
              }
            },
            
            validatePaint: function() {
              if ( this._paintDirty ) {
                assert && assert( this.isPainted(), 'Only painted nodes can have self dirty paint' );
                if ( !this._subtreePaintDirty ) {
                  // if the subtree is clean, just notify the self (only will hit one layer, instead of possibly multiple ones)
                  this.notifyDirtySelfPaint();
                }
                this._paintDirty = false;
              }
              
              if ( this._subtreePaintDirty ) {
                this.notifyDirtySubtreePaint();
                this._subtreePaintDirty = false;
              }
              
              // clear flags and recurse
              if ( this._childPaintDirty ) {
                this._childPaintDirty = false;
                
                var children = this._children;
                var length = children.length;
                for ( var i = 0; i < length; i++ ) {
                  children[i].validatePaint();
                }
              }
            },
            
            // mark the bounds of this node as invalid, so it is recomputed before it is accessed again
            invalidateBounds: function() {
              this._boundsDirty = true;
              this._mouseBoundsDirty = true;
              this._touchBoundsDirty = true;
              
              // and set flags for all ancestors
              var i = this._parents.length;
              while ( i-- ) {
                this._parents[i].invalidateChildBounds();
              }
            },
            
            // recursively tag all ancestors with _childBoundsDirty
            invalidateChildBounds: function() {
              // don't bother updating if we've already been tagged
              if ( !this._childBoundsDirty ) {
                this._childBoundsDirty = true;
                this._mouseBoundsDirty = true;
                this._touchBoundsDirty = true;
                var i = this._parents.length;
                while ( i-- ) {
                  this._parents[i].invalidateChildBounds();
                }
              }
            },
            
            // mark the paint of this node as invalid, so its new region will be painted
            invalidatePaint: function() {
              assert && assert( this.isPainted(), 'Can only call invalidatePaint on a painted node' );
              this._paintDirty = true;
              
              // and set flags for all ancestors
              var i = this._parents.length;
              while ( i-- ) {
                this._parents[i].invalidateChildPaint();
              }
            },
            
            invalidateSubtreePaint: function() {
              this._subtreePaintDirty = true;
              
              // and set flags for all ancestors
              var i = this._parents.length;
              while ( i-- ) {
                this._parents[i].invalidateChildPaint();
              }
            },
            
            // recursively tag all ancestors with _childPaintDirty
            invalidateChildPaint: function() {
              // don't bother updating if we've already been tagged
              if ( !this._childPaintDirty ) {
                this._childPaintDirty = true;
                var i = this._parents.length;
                while ( i-- ) {
                  this._parents[i].invalidateChildPaint();
                }
              }
            },
            
            // called to notify that self rendering will display different paint, with possibly different bounds
            invalidateSelf: function( newBounds ) {
              assert && assert( newBounds.isEmpty() || newBounds.isFinite() , "Bounds must be empty or finite in invalidateSelf");
              
              // mark the old region to be repainted, regardless of whether the actual bounds change
              this.notifyBeforeSelfChange();
              
              // if these bounds are different than current self bounds
              if ( !this._selfBounds.equals( newBounds ) ) {
                // set repaint flags
                this._selfBoundsDirty = true;
                this.invalidateBounds();
                
                // record the new bounds
                this._selfBounds = newBounds;
              }
              
              this.invalidatePaint();
            },
            
            markOldSelfPaint: function() {
              this.notifyBeforeSelfChange();
            },
            
            // should be called whenever something triggers changes for how this node is layered
            markLayerRefreshNeeded: function() {
              this.markForLayerRefresh();
              this.notifyStitch( true );
            },
            
            // marks the last-rendered bounds of this node and optionally all of its descendants as needing a repaint
            markOldPaint: function( justSelf ) {
              // TODO: rearchitecture
              if ( justSelf ) {
                this.notifyBeforeSelfChange();
              } else {
                this.notifyBeforeSubtreeChange();
              }
            },
            
            isChild: function( potentialChild ) {
              assert && assert( potentialChild && ( potentialChild instanceof Node ), 'isChild needs to be called with a Node' );
              var ourChild = _.contains( this._children, potentialChild );
              var itsParent = _.contains( potentialChild._parents, this );
              assert && assert( ourChild === itsParent );
              return ourChild;
            },
            
            // the bounds for self content in "local" coordinates.
            getSelfBounds: function() {
              return this._selfBounds;
            },
            
            // returns a bounding box that should contain all self content in the local coordinate frame (our normal self bounds aren't guaranteed this for Text, etc.)
            getSafeSelfBounds: function() {
              // override this to provide different behavior
              return this._selfBounds;
            },
        
            getTransformedSelfBounds: function( matrix ) {
              // our inaccurate variety, assuming it's a rectangle
              return this._selfBounds.transformed( matrix );
            },
            
            getChildBounds: function() {
              this.validateBounds();
              return this._childBounds;
            },
            
            // local coordinate frame bounds
            getLocalBounds: function() {
              if ( this._localBounds ) {
                return this._localBounds;
              }
              var localBounds = this.getSelfBounds().union( this.getChildBounds() );
              if ( this.hasClipArea() ) {
                // localBounds clipping in the local coordinate frame
                localBounds = localBounds.intersection( this._clipArea.bounds );
              }
              return localBounds;
            },
            
            // {Bounds2 | null} to override the localBounds. Once this is called, it will always be used for localBounds until this is called again.
            // To revert to having Scenery compute the localBounds, set this to null.
            setLocalBounds: function( localBounds ) {
              assert && assert( localBounds === null || localBounds instanceof Bounds2, 'localBounds override should be set to either null or a Bounds2' );
              
              if ( localBounds === null ) {
                this._localBounds = null;
                this.invalidateBounds();
              } else {
                var changed = localBounds !== this._localBounds || !this._localBounds;
                
                if ( changed ) {
                  this._localBounds = localBounds;
                  
                  this.invalidateBounds();
                }
              }
              
              return this; // allow chaining
            },
            
            // the bounds for content in render(), in "parent" coordinates
            getBounds: function() {
              this.validateBounds();
              return this._bounds;
            },
            
            // like getBounds() in the "parent" coordinate frame, but includes only visible nodes
            getVisibleBounds: function() {
              // defensive copy, since we use mutable modifications below
              var bounds = this._selfBounds.copy();
              
              var i = this._children.length;
              while ( i-- ) {
                var child = this._children[i];
                if ( child.isVisible() ) {
                  bounds.includeBounds( child.getVisibleBounds() );
                }
              }
              
              assert && assert( bounds.isFinite() || bounds.isEmpty(), 'Visible bounds should not be infinite' );
              return this.localToParentBounds( bounds );
            },
            
            trailUnderPointer: function( pointer ) {
              var options = {};
              if ( pointer.isMouse ) { options.isMouse = true; }
              if ( pointer.isTouch ) { options.isTouch = true; }
              if ( pointer.isPen ) { options.isPen = true; }
              
              return this.trailUnderPoint( pointer.point, options );
            },
            
            /*
             * Return a trail to the top node (if any, otherwise null) whose self-rendered area contains the
             * point (in parent coordinates).
             *
             * If options.pruneInvisible is false, invisible nodes will be allowed in the trail.
             * If options.pruneUnpickable is false, unpickable nodes will be allowed in the trail.
             *
             * When calling, don't pass the recursive flag. It signals that the point passed can be mutated
             */
            trailUnderPoint: function( point, options, recursive, hasListener ) {
              assert && assert( point, 'trailUnderPointer requires a point' );
              
              if ( options === undefined ) { options = {}; }
              
              var pruneInvisible = ( options.pruneInvisible === undefined ) ? true : options.pruneInvisible;
              var pruneUnpickable = ( options.pruneUnpickable === undefined ) ? true : options.pruneUnpickable;
              
              hasListener = hasListener || this._inputListeners.length > 0 || this._pickable === true;
              
              if ( pruneInvisible && !this.isVisible() ) {
                return null;
              }
              
              // if pickable: false, skip it
              // if pickable: undefined and our pickable count indicates there are no input listeners / pickable: true in our subtree, skip it
              if ( pruneUnpickable && ( this._pickable === false || ( this._pickable !== true && !hasListener && this._subtreePickableCount === 0 ) ) ) {
                return null;
              }
              
              // update bounds for pruning
              this.validateBounds();
              if ( options.isMouse ) { this.validateMouseBounds(); }
              if ( options.isTouch ) { this.validateTouchBounds(); }
              
              var hasHitAreas = options && ( ( options.isMouse && this._mouseBounds ) || ( options.isTouch && this._touchBounds ) || options.isPen );
              
              // bail quickly if this doesn't hit our computed bounds
              if ( hasHitAreas ? (
                    // if we have hit areas, prune based on the respective hit bounds (mouseBounds/touchBounds)
                    ( options.isMouse && !this._mouseBounds.containsPoint( point ) ) ||
                    ( options.isTouch && !this._touchBounds.containsPoint( point ) )
                    // otherwise, prune based on the normal bounds
                  ) : !this._bounds.containsPoint( point ) ) {
                return null; // not in our bounds, so this point can't possibly be contained
              }
              
              // temporary result variable, since it's easier to do this way to free the computed point
              var result = null;
              
              // point in the local coordinate frame. computed after the main bounds check, so we can bail out there efficiently
              var localPoint = this._transform.getInverse().multiplyVector2( Vector2.createFromPool( point.x, point.y ) );
              // var localPoint = this.parentToLocalPoint( point );
              
              // if our point is outside of the local-coordinate clipping area, we shouldn't return a hit
              if ( this.hasClipArea() && !this._clipArea.containsPoint( localPoint ) ) {
                return null;
              }
              
              // check children first, since they are rendered later
              if ( this._children.length > 0 && ( hasHitAreas || this._childBounds.containsPoint( localPoint ) ) ) {
                
                // manual iteration here so we can return directly, and so we can iterate backwards (last node is in front)
                for ( var i = this._children.length - 1; i >= 0; i-- ) {
                  var child = this._children[i];
                  
                  var childHit = child.trailUnderPoint( localPoint, options, true, hasListener );
                  
                  // the child will have the point in its parent's coordinate frame (i.e. this node's frame)
                  if ( childHit ) {
                    childHit.addAncestor( this, i );
                    localPoint.freeToPool();
                    return childHit;
                  }
                }
              }
        
              // tests for mouse and touch hit areas before testing containsPointSelf
              if ( hasHitAreas ) {
                if ( options.isMouse && this._mouseArea ) {
                  // NOTE: both Bounds2 and Shape have containsPoint! We use both here!
                  result = this._mouseArea.containsPoint( localPoint ) ? new scenery.Trail( this ) : null;
                  localPoint.freeToPool();
                  return result;
                }
                if ( ( options.isTouch || options.isPen ) && this._touchArea ) {
                  // NOTE: both Bounds2 and Shape have containsPoint! We use both here!
                  result = this._touchArea.containsPoint( localPoint ) ? new scenery.Trail( this ) : null;
                  localPoint.freeToPool();
                  return result;
                }
              }
              
              // didn't hit our children, so check ourself as a last resort
              if ( hasHitAreas || this._selfBounds.containsPoint( localPoint ) ) {
                if ( this.containsPointSelf( localPoint ) ) {
                  localPoint.freeToPool();
                  return new scenery.Trail( this );
                }
              }
              
              // signal no hit
              localPoint.freeToPool();
              return null;
            },
            
            // checking for whether a point (in parent coordinates) is contained in this sub-tree
            containsPoint: function( point ) {
              return this.trailUnderPoint( point ) !== null;
            },
            
            // override for computation of whether a point is inside the self content
            // point is considered to be in the local coordinate frame
            containsPointSelf: function( point ) {
              // if self bounds are not null default to checking self bounds
              return this._selfBounds.containsPoint( point );
            },
            
            // whether this node's self intersects the specified bounds, in the local coordinate frame
            intersectsBoundsSelf: function( bounds ) {
              // if self bounds are not null, child should override this
              return this._selfBounds.intersectsBounds( bounds );
            },
            
            isPainted: function() {
              return false;
            },
            
            hasParent: function() {
              return this._parents.length !== 0;
            },
            
            hasChildren: function() {
              return this._children.length > 0;
            },
            
            walkDepthFirst: function( callback ) {
              callback( this );
              var length = this._children.length;
              for ( var i = 0; i < length; i++ ) {
                this._children[i].walkDepthFirst( callback );
              }
            },
            
            getChildrenWithinBounds: function( bounds ) {
              var result = [];
              var length = this._children.length;
              for ( var i = 0; i < length; i++ ) {
                var child = this._children[i];
                if ( !child._bounds.intersection( bounds ).isEmpty() ) {
                  result.push( child );
                }
              }
              return result;
            },
            
            // TODO: set this up with a mix-in for a generic notifier?
            addInputListener: function( listener ) {
              // don't allow listeners to be added multiple times
              if ( _.indexOf( this._inputListeners, listener ) === -1 ) {
                this._inputListeners.push( listener );
                this.changePickableCount( 1 );
              }
              return this;
            },
            
            removeInputListener: function( listener ) {
              // ensure the listener is in our list
              assert && assert( _.indexOf( this._inputListeners, listener ) !== -1 );
              
              this._inputListeners.splice( _.indexOf( this._inputListeners, listener ), 1 );
              this.changePickableCount( -1 );
              return this;
            },
            
            getInputListeners: function() {
              return this._inputListeners.slice( 0 ); // defensive copy
            },
            
            /*
             * Dispatches an event across all possible Trails ending in this node.
             *
             * For example, if the scene has two children A and B, and both of those nodes have X as a child,
             * dispatching an event on X will fire the event with the following trails:
             * on X     with trail [ X ]
             * on A     with trail [ A, X ]
             * on scene with trail [ scene, A, X ]
             * on B     with trail [ B, X ]
             * on scene with trail [ scene, B, X ]
             *
             * This allows you to add a listener on any node to get notifications for all of the trails that the
             * event is relevant for (e.g. marks dirty paint region for both places X was on the scene).
             */
            dispatchEvent: function( type, args ) {
              sceneryEventLog && sceneryEventLog( this.constructor.name + '.dispatchEvent ' + type );
              var trail = new scenery.Trail();
              trail.setMutable(); // don't allow this trail to be set as immutable for storage
              args.trail = trail; // this reference shouldn't be changed be listeners (or errors will occur)
              
              // store a branching flag, since if we don't branch at all, we don't have to walk our trail back down.
              var branches = false;
              
              function recursiveEventDispatch( node ) {
                trail.addAncestor( node );
                
                node.fireEvent( type, args );
                
                var parents = node._parents;
                var length = parents.length;
                
                // make sure to set the branch flag here before iterating (don't move it)
                branches = branches || length > 1;
                
                for ( var i = 0; i < length; i++ ) {
                  recursiveEventDispatch( parents[i] );
                }
                
                // if there were no branches, we will not fire another listener once we have reached here
                if ( branches ) {
                  trail.removeAncestor();
                }
              }
              
              recursiveEventDispatch( this );
            },
            
            // TODO: consider renaming to translateBy to match scaleBy
            translate: function( x, y, prependInstead ) {
              if ( typeof x === 'number' ) {
                // translate( x, y, prependInstead )
                if ( !x && !y ) { return; } // bail out if both are zero
                if ( prependInstead ) {
                  this.prependTranslation( x, y );
                } else {
                  this.appendMatrix( Matrix3.translation( x, y ) );
                }
              } else {
                // translate( vector, prependInstead )
                var vector = x;
                if ( !vector.x && !vector.y ) { return; } // bail out if both are zero
                this.translate( vector.x, vector.y, y ); // forward to full version
              }
            },
            
            // scale( s ) is also supported, which will scale both dimensions by the same amount. renamed from 'scale' to satisfy the setter/getter
            scale: function( x, y, prependInstead ) {
              if ( typeof x === 'number' ) {
                if ( y === undefined ) {
                  // scale( scale )
                  if ( x === 1 ) { return; } // bail out if we are scaling by 1 (identity)
                  this.appendMatrix( Matrix3.scaling( x, x ) );
                } else {
                  // scale( x, y, prependInstead )
                  if ( x === 1 && y === 1 ) { return; } // bail out if we are scaling by 1 (identity)
                  if ( prependInstead ) {
                    this.prependMatrix( Matrix3.scaling( x, y ) );
                  } else {
                    this.appendMatrix( Matrix3.scaling( x, y ) );
                  }
                }
              } else {
                // scale( vector, prependInstead ) or scale( { x: x, y: y }, prependInstead )
                var vector = x;
                this.scale( vector.x, vector.y, y ); // forward to full version
              }
            },
            
            // TODO: consider naming to rotateBy to match scaleBy (due to scale property / method name conflict)
            rotate: function( angle, prependInstead ) {
              if ( angle % ( 2 * Math.PI ) === 0 ) { return; } // bail out if our angle is effectively 0
              if ( prependInstead ) {
                this.prependMatrix( Matrix3.rotation2( angle ) );
              } else {
                this.appendMatrix( Matrix3.rotation2( angle ) );
              }
            },
            
            // point should be in the parent coordinate frame
            // TODO: determine whether this should use the appendMatrix method
            rotateAround: function( point, angle ) {
              var matrix = Matrix3.translation( -point.x, -point.y );
              matrix = Matrix3.rotation2( angle ).timesMatrix( matrix );
              matrix = Matrix3.translation( point.x, point.y ).timesMatrix( matrix );
              this.prependMatrix( matrix );
            },
            
            getX: function() {
              return this._transform.getMatrix().m02();
            },
            
            setX: function( x ) {
              assert && assert( typeof x === 'number' );
              
              this.translate( x - this.getX(), 0, true );
              return this;
            },
            
            getY: function() {
              return this._transform.getMatrix().m12();
            },
            
            setY: function( y ) {
              assert && assert( typeof y === 'number' );
              
              this.translate( 0, y - this.getY(), true );
              return this;
            },
            
            // returns a vector with an entry for each axis, e.g. (5,2) for an Affine-style matrix with rows ((5,0,0),(0,2,0),(0,0,1))
            getScaleVector: function() {
              return this._transform.getMatrix().getScaleVector();
            },
            
            // supports setScaleMagnitude( 5 ) for both dimensions, setScaleMagnitude( 5, 3 ) for each dimension separately, or setScaleMagnitude( new Vector2( x, y ) )
            setScaleMagnitude: function( a, b ) {
              var currentScale = this.getScaleVector();
              
              if ( typeof a === 'number' ) {
                if ( b === undefined ) {
                  // to map setScaleMagnitude( scale ) => setScaleMagnitude( scale, scale )
                  b = a;
                }
                // setScaleMagnitude( x, y )
                this.appendMatrix( Matrix3.scaling( a / currentScale.x, b / currentScale.y ) );
              } else {
                // setScaleMagnitude( vector ), where we set the x-scale to vector.x and y-scale to vector.y
                this.appendMatrix( Matrix3.scaling( a.x / currentScale.x, a.y / currentScale.y ) );
              }
              return this;
            },
            
            getRotation: function() {
              return this._transform.getMatrix().getRotation();
            },
            
            setRotation: function( rotation ) {
              assert && assert( typeof rotation === 'number' );
              
              this.appendMatrix( Matrix3.rotation2( rotation - this.getRotation() ) );
              return this;
            },
            
            // supports setTranslation( x, y ) or setTranslation( new Vector2( x, y ) ) .. or technically setTranslation( { x: x, y: y } )
            setTranslation: function( a, b ) {
              var m = this._transform.getMatrix();
              var tx = m.m02();
              var ty = m.m12();
        
              var dx, dy;
              
              if ( typeof a === 'number' ) {
                dx = a - tx;
                dy = b - ty;
              } else {
                dx = a.x - tx;
                dy = a.y - ty;
              }
              
              this.translate( dx, dy, true );
              
              return this;
            },
            
            getTranslation: function() {
              var matrix = this._transform.getMatrix();
              return new Vector2( matrix.m02(), matrix.m12() );
            },
            
            // append a transformation matrix to our local transform
            appendMatrix: function( matrix ) {
              this._transform.append( matrix );
            },
            
            // prepend a transformation matrix to our local transform
            prependMatrix: function( matrix ) {
              this._transform.prepend( matrix );
            },
        
            // prepend an x,y translation to our local transform without allocating a matrix for it, see #119
            prependTranslation: function( x,y ) {
              this._transform.prependTranslation( x, y );
            },
            
            setMatrix: function( matrix ) {
              this._transform.setMatrix( matrix );
            },
            
            getMatrix: function() {
              return this._transform.getMatrix();
            },
            
            // change the actual transform reference (not just the actual transform)
            setTransform: function( transform ) {
              assert && assert( transform.isFinite(), 'Transform should not have infinite/NaN values' );
              
              if ( this._transform !== transform ) {
                // since our referenced transform doesn't change, we need to trigger the before/after ourselves
                this.beforeTransformChange();
                
                // swap the transform and move the listener to the new one
                this._transform.removeTransformListener( this._transformListener ); // don't leak memory!
                this._transform = transform;
                this._transform.prependTransformListener( this._transformListener );
                
                this.afterTransformChange();
              }
            },
            
            getTransform: function() {
              // for now, return an actual copy. we can consider listening to changes in the future
              return this._transform;
            },
            
            resetTransform: function() {
              this.setMatrix( Matrix3.IDENTITY );
            },
            
            // called before our transform is changed
            beforeTransformChange: function() {
              // mark our old bounds as dirty, so that any dirty region repainting will include not just our new position, but also our old position
              this.notifyBeforeSubtreeChange();
            },
            
            // called after our transform is changed
            afterTransformChange: function() {
              assert && assert( this.transform.matrix.isFinite() );
              this.notifyTransformChange();
              
              this.invalidateBounds();
              this.invalidateSubtreePaint();
            },
            
            // the left bound of this node, in the parent coordinate frame
            getLeft: function() {
              return this.getBounds().minX;
            },
            
            // shifts this node horizontally so that its left bound (in the parent coordinate frame) is 'left'
            setLeft: function( left ) {
              assert && assert( typeof left === 'number' );
              
              this.translate( left - this.getLeft(), 0, true );
              return this; // allow chaining
            },
            
            // the right bound of this node, in the parent coordinate frame
            getRight: function() {
              return this.getBounds().maxX;
            },
            
            // shifts this node horizontally so that its right bound (in the parent coordinate frame) is 'right'
            setRight: function( right ) {
              assert && assert( typeof right === 'number' );
              
              this.translate( right - this.getRight(), 0, true );
              return this; // allow chaining
            },
            
            getCenter: function() {
              return this.getBounds().getCenter();
            },
            
            setCenter: function( center ) {
              assert && assert( center instanceof Vector2 );
              
              this.translate( center.minus( this.getCenter() ), true );
              return this;
            },
            
            getCenterX: function() {
              return this.getBounds().getCenterX();
            },
            
            setCenterX: function( x ) {
              assert && assert( typeof x === 'number' );
              
              this.translate( x - this.getCenterX(), 0, true );
              return this; // allow chaining
            },
            
            getCenterY: function() {
              return this.getBounds().getCenterY();
            },
            
            setCenterY: function( y ) {
              assert && assert( typeof y === 'number' );
              
              this.translate( 0, y - this.getCenterY(), true );
              return this; // allow chaining
            },
            
            // the top bound of this node, in the parent coordinate frame
            getTop: function() {
              return this.getBounds().minY;
            },
            
            // shifts this node vertically so that its top bound (in the parent coordinate frame) is 'top'
            setTop: function( top ) {
              assert && assert( typeof top === 'number' );
              
              this.translate( 0, top - this.getTop(), true );
              return this; // allow chaining
            },
            
            // the bottom bound of this node, in the parent coordinate frame
            getBottom: function() {
              return this.getBounds().maxY;
            },
            
            // shifts this node vertically so that its bottom bound (in the parent coordinate frame) is 'bottom'
            setBottom: function( bottom ) {
              assert && assert( typeof bottom === 'number' );
              
              this.translate( 0, bottom - this.getBottom(), true );
              return this; // allow chaining
            },
            
            getLeftTop: function() {
              return this.getBounds().getLeftTop();
            },
            
            setLeftTop: function( leftTop ) {
              assert && assert( leftTop instanceof Vector2 );
              
              this.translate( leftTop.minus( this.getLeftTop() ), true );
            },
            
            getCenterTop: function() {
              return this.getBounds().getCenterTop();
            },
            
            setCenterTop: function( centerTop ) {
              assert && assert( centerTop instanceof Vector2 );
              
              this.translate( centerTop.minus( this.getCenterTop() ), true );
            },
            
            getRightTop: function() {
              return this.getBounds().getRightTop();
            },
            
            setRightTop: function( rightTop ) {
              assert && assert( rightTop instanceof Vector2 );
              
              this.translate( rightTop.minus( this.getRightTop() ), true );
            },
            
            getLeftCenter: function() {
              return this.getBounds().getLeftCenter();
            },
            
            setLeftCenter: function( leftCenter ) {
              assert && assert( leftCenter instanceof Vector2 );
              
              this.translate( leftCenter.minus( this.getLeftCenter() ), true );
            },
            
            getRightCenter: function() {
              return this.getBounds().getRightCenter();
            },
            
            setRightCenter: function( rightCenter ) {
              assert && assert( rightCenter instanceof Vector2 );
              
              this.translate( rightCenter.minus( this.getRightCenter() ), true );
            },
            
            getLeftBottom: function() {
              return this.getBounds().getLeftBottom();
            },
            
            setLeftBottom: function( leftBottom ) {
              assert && assert( leftBottom instanceof Vector2 );
              
              this.translate( leftBottom.minus( this.getLeftBottom() ), true );
            },
            
            getCenterBottom: function() {
              return this.getBounds().getCenterBottom();
            },
            
            setCenterBottom: function( centerBottom ) {
              assert && assert( centerBottom instanceof Vector2 );
              
              this.translate( centerBottom.minus( this.getCenterBottom() ), true );
            },
            
            getRightBottom: function() {
              return this.getBounds().getRightBottom();
            },
            
            setRightBottom: function( rightBottom ) {
              assert && assert( rightBottom instanceof Vector2 );
              
              this.translate( rightBottom.minus( this.getRightBottom() ), true );
            },
            
            getWidth: function() {
              return this.getBounds().getWidth();
            },
            
            getHeight: function() {
              return this.getBounds().getHeight();
            },
            
            getId: function() {
              return this._id;
            },
            
            isVisible: function() {
              return this._visible;
            },
            
            setVisible: function( visible ) {
              assert && assert( typeof visible === 'boolean' );
              
              if ( visible !== this._visible ) {
                if ( this._visible ) {
                  this.notifyBeforeSubtreeChange();
                }
                
                this._visible = visible;
                
                this.notifyVisibilityChange();
              }
              return this;
            },
            
            getOpacity: function() {
              return this._opacity;
            },
            
            setOpacity: function( opacity ) {
              assert && assert( typeof opacity === 'number' );
              
              var clampedOpacity = clamp( opacity, 0, 1 );
              if ( clampedOpacity !== this._opacity ) {
                this.notifyBeforeSubtreeChange();
                
                this._opacity = clampedOpacity;
                
                this.notifyOpacityChange();
              }
            },
            
            isPickable: function() {
              return this._pickable;
            },
            
            setPickable: function( pickable ) {
              assert && assert( pickable === null || typeof pickable === 'boolean' );
              
              if ( this._pickable !== pickable ) {
                var n = this._pickable === true ? -1 : 0;
                
                // no paint or invalidation changes for now, since this is only handled for the mouse
                this._pickable = pickable;
                n += this._pickable === true ? 1 : 0;
                
                if ( n ) {
                  this.changePickableCount( n );
                }
                
                // TODO: invalidate the cursor somehow? #150
              }
            },
            
            setCursor: function( cursor ) {
              assert && assert( typeof cursor === 'string' || cursor === null );
              
              // TODO: consider a mapping of types to set reasonable defaults
              /*
              auto default none inherit help pointer progress wait crosshair text vertical-text alias copy move no-drop not-allowed
              e-resize n-resize w-resize s-resize nw-resize ne-resize se-resize sw-resize ew-resize ns-resize nesw-resize nwse-resize
              context-menu cell col-resize row-resize all-scroll url( ... ) --> does it support data URLs?
               */
              
              // allow the 'auto' cursor type to let the ancestors or scene pick the cursor type
              this._cursor = cursor === "auto" ? null : cursor;
            },
            
            getCursor: function() {
              return this._cursor;
            },
            
            setMouseArea: function( area ) {
              assert && assert( area === null || area instanceof Shape || area instanceof Bounds2, 'mouseArea needs to be a kite.Shape, dot.Bounds2, or null' );
              
              if ( this._mouseArea !== area ) {
                this._mouseArea = area; // TODO: could change what is under the mouse, invalidate!
                
                this.invalidateBounds();
              }
            },
            
            getMouseArea: function() {
              return this._mouseArea;
            },
            
            setTouchArea: function( area ) {
              assert && assert( area === null || area instanceof Shape || area instanceof Bounds2, 'touchArea needs to be a kite.Shape, dot.Bounds2, or null' );
              
              if ( this._touchArea !== area ) {
                this._touchArea = area; // TODO: could change what is under the touch, invalidate!
                
                this.invalidateBounds();
              }
            },
            
            getTouchArea: function() {
              return this._touchArea;
            },
            
            setClipArea: function( shape ) {
              assert && assert( shape === null || shape instanceof Shape, 'clipArea needs to be a kite.Shape, or null' );
              
              if ( this._clipArea !== shape ) {
                this.notifyBeforeSubtreeChange();
                
                this._clipArea = shape;
                
                this.notifyClipChange();
                
                this.invalidateBounds();
              }
            },
            
            getClipArea: function() {
              return this._clipArea;
            },
            
            hasClipArea: function() {
              return this._clipArea !== null;
            },
        
            setTransformBounds: function( transformBounds ) {
              assert && assert( typeof transformBounds === 'boolean', 'transformBounds should be boolean' );
        
              if ( this._transformBounds !== transformBounds ) {
                this._transformBounds = transformBounds;
        
                this.invalidateBounds();
              }
            },
        
            // getter for whether we will transform bounds with rotations and shears when computing bounds
            getTransformBounds: function() {
              return this._transformBounds;
            },
            
            updateLayerType: function() {
              if ( this._renderer && this._rendererOptions ) {
                // TODO: factor this check out! Make RendererOptions its own class?
                // TODO: FIXME: support undoing this!
                // ensure that if we are passing a CSS transform, we pass this node as the baseNode
                if ( this._rendererOptions.cssTransform || this._rendererOptions.cssTranslation || this._rendererOptions.cssRotation || this._rendererOptions.cssScale ) {
                  this._rendererOptions.baseNode = this;
                } else if ( this._rendererOptions.hasOwnProperty( 'baseNode' ) ) {
                  delete this._rendererOptions.baseNode; // don't override, let the scene pass in the scene
                }
                // if we set renderer and rendererOptions, only then do we want to trigger a specific layer type
                this._rendererLayerType = this._renderer.createLayerType( this._rendererOptions );
              } else {
                this._rendererLayerType = null; // nothing signaled, since we want to support multiple layer types (including if we specify a renderer)
              }
            },
            
            getRendererLayerType: function() {
              return this._rendererLayerType;
            },
            
            hasRendererLayerType: function() {
              return !!this._rendererLayerType;
            },
            
            supportsCanvas: function() {
              return ( this._rendererBitmask & scenery.bitmaskSupportsCanvas ) !== 0;
            },
            
            supportsSVG: function() {
              return ( this._rendererBitmask & scenery.bitmaskSupportsSVG ) !== 0;
            },
            
            supportsDOM: function() {
              return ( this._rendererBitmask & scenery.bitmaskSupportsDOM ) !== 0;
            },
            
            supportsWebGL: function() {
              return ( this._rendererBitmask & scenery.bitmaskSupportsWebGL ) !== 0;
            },
            
            supportsRenderer: function( renderer ) {
              return ( this._rendererBitmask & renderer.bitmask ) !== 0;
            },
            
            // return a supported renderer (fallback case, not called often)
            pickARenderer: function() {
              if ( this.supportsCanvas() ) {
                return scenery.Renderer.Canvas;
              } else if ( this.supportsSVG() ) {
                return scenery.Renderer.SVG;
              } else if ( this.supportsDOM() ) {
                return scenery.Renderer.DOM;
              }
              // oi!
            },
            
            setRendererBitmask: function( bitmask ) {
              if ( bitmask !== this._rendererBitmask ) {
                this._rendererBitmask = bitmask;
                this.markLayerRefreshNeeded();
              }
            },
            
            // meant to be overridden
            invalidateSupportedRenderers: function() {
              
            },
            
            setRenderer: function( renderer ) {
              var newRenderer;
              if ( typeof renderer === 'string' ) {
                assert && assert( scenery.Renderer[renderer], 'unknown renderer in setRenderer: ' + renderer );
                newRenderer = scenery.Renderer[renderer];
              } else if ( renderer instanceof scenery.Renderer ) {
                newRenderer = renderer;
              } else if ( !renderer ) {
                newRenderer = null;
              } else {
                throw new Error( 'unrecognized type of renderer: ' + renderer );
              }
              if ( newRenderer !== this._renderer ) {
                assert && assert( !this.isPainted() || !newRenderer || this.supportsRenderer( newRenderer ), 'renderer ' + newRenderer + ' not supported by ' + this.constructor.name );
                this._renderer = newRenderer;
                
                this.updateLayerType();
                this.markLayerRefreshNeeded();
              }
            },
            
            getRenderer: function() {
              return this._renderer;
            },
            
            hasRenderer: function() {
              return !!this._renderer;
            },
            
            setRendererOptions: function( options ) {
              // TODO: consider checking options based on the specified 'renderer'?
              this._rendererOptions = options;
              
              this.updateLayerType();
              this.markLayerRefreshNeeded();
            },
            
            getRendererOptions: function() {
              return this._rendererOptions;
            },
            
            hasRendererOptions: function() {
              return !!this._rendererOptions;
            },
            
            setLayerSplit: function( split ) {
              assert && assert( typeof split === 'boolean' );
              
              if ( split !== this._layerSplit ) {
                this._layerSplit = split;
                this.markLayerRefreshNeeded();
              }
            },
            
            isLayerSplit: function() {
              return this._layerSplit;
            },
            
            // returns a unique trail (if it exists) where each node in the ancestor chain has 0 or 1 parents
            getUniqueTrail: function() {
              var trail = new scenery.Trail();
              var node = this;
              
              while ( node ) {
                trail.addAncestor( node );
                assert && assert( node._parents.length <= 1 );
                node = node._parents[0]; // should be undefined if there aren't any parents
              }
              
              return trail;
            },
            
            // all nodes in the connected component, returned in an arbitrary order
            getConnectedNodes: function() {
              var result = [];
              var fresh = this._children.concat( this._parents ).concat( this );
              while ( fresh.length ) {
                var node = fresh.pop();
                if ( !_.contains( result, node ) ) {
                  result.push( node );
                  fresh = fresh.concat( node._children, node._parents );
                }
              }
              return result;
            },
            
            getTopologicallySortedNodes: function() {
              // see http://en.wikipedia.org/wiki/Topological_sorting
              var edges = {};
              var s = [];
              var l = [];
              var n;
              _.each( this.getConnectedNodes(), function( node ) {
                edges[node.id] = {};
                _.each( node.children, function( m ) {
                  edges[node.id][m.id] = true;
                } );
                if ( !node.parents.length ) {
                  s.push( node );
                }
              } );
              function handleChild( m ) {
                delete edges[n.id][m.id];
                if ( _.every( edges, function( children ) { return !children[m.id]; } ) ) {
                  // there are no more edges to m
                  s.push( m );
                }
              }
              
              while ( s.length ) {
                n = s.pop();
                l.push( n );
                
                _.each( n.children, handleChild );
              }
              
              // ensure that there are no edges left, since then it would contain a circular reference
              assert && assert( _.every( edges, function( children ) {
                return _.every( children, function( final ) { return false; } );
              } ), 'circular reference check' );
              
              return l;
            },
            
            // verify that this.addChild( child ) it wouldn't cause circular references
            canAddChild: function( child ) {
              if ( this === child || _.contains( this.children, child ) ) {
                return false;
              }
              
              // see http://en.wikipedia.org/wiki/Topological_sorting
              // TODO: remove duplication with above handling?
              var edges = {};
              var s = [];
              var l = [];
              var n;
              _.each( this.getConnectedNodes().concat( child.getConnectedNodes() ), function( node ) {
                edges[node.id] = {};
                _.each( node.children, function( m ) {
                  edges[node.id][m.id] = true;
                } );
                if ( !node.parents.length && node !== child ) {
                  s.push( node );
                }
              } );
              edges[this.id][child.id] = true; // add in our 'new' edge
              function handleChild( m ) {
                delete edges[n.id][m.id];
                if ( _.every( edges, function( children ) { return !children[m.id]; } ) ) {
                  // there are no more edges to m
                  s.push( m );
                }
              }
              
              while ( s.length ) {
                n = s.pop();
                l.push( n );
                
                _.each( n.children, handleChild );
                
                // handle our new edge
                if ( n === this ) {
                  handleChild( child );
                }
              }
              
              // ensure that there are no edges left, since then it would contain a circular reference
              return _.every( edges, function( children ) {
                return _.every( children, function( final ) { return false; } );
              } );
            },
            
            debugText: function() {
              var startPointer = new scenery.TrailPointer( new scenery.Trail( this ), true );
              var endPointer = new scenery.TrailPointer( new scenery.Trail( this ), false );
              
              var depth = 0;
              
              startPointer.depthFirstUntil( endPointer, function( pointer ) {
                if ( pointer.isBefore ) {
                  // hackish way of multiplying a string
                  var padding = new Array( depth * 2 ).join( ' ' );
                  console.log( padding + pointer.trail.lastNode().getId() + ' ' + pointer.trail.toString() );
                }
                depth += pointer.isBefore ? 1 : -1;
              }, false );
            },
            
            /*
             * Renders this node to a canvas. If toCanvas( callback ) is used, the canvas will contain the node's
             * entire bounds.
             *
             * callback( canvas, x, y ) is called, where x and y offsets are computed if not specified.
             */
            toCanvas: function( callback, x, y, width, height ) {
              var self = this;
              
              var padding = 2; // padding used if x and y are not set
              
              // for now, we add an unpleasant hack around Text and safe bounds in general. We don't want to add another Bounds2 object per Node for now.
              var bounds = this.getBounds().union( this.localToParentBounds( this.getSafeSelfBounds() ) );
              
              x = x !== undefined ? x : Math.ceil( padding - bounds.minX );
              y = y !== undefined ? y : Math.ceil( padding - bounds.minY );
              width = width !== undefined ? width : Math.ceil( bounds.getWidth() + 2 * padding );
              height = height !== undefined ? height : Math.ceil( bounds.getHeight() + 2 * padding );
              
              var canvas = document.createElement( 'canvas' );
              canvas.width = width;
              canvas.height = height;
              var context = canvas.getContext( '2d' );
              
              var $div = $( document.createElement( 'div' ) );
              $div.width( width ).height( height );
              var scene = new scenery.Scene( $div );
              
              scene.addChild( self );
              scene.x = x;
              scene.y = y;
              scene.updateScene();
              
              scene.renderToCanvas( canvas, context, function() {
                callback( canvas, x, y );
                
                // let us be garbage collected
                scene.removeChild( self );
              } );
            },
            
            // gives a data URI, with the same parameter handling as Node.toCanvas()
            toDataURL: function( callback, x, y, width, height ) {
              this.toCanvas( function( canvas, x, y ) {
                // this x and y shadow the outside parameters, and will be different if the outside parameters are undefined
                callback( canvas.toDataURL(), x, y );
              }, x, y, width, height );
            },
            
            // gives an HTMLImageElement with the same parameter handling as Node.toCanvas(). guaranteed to be asynchronous
            toImage: function( callback, x, y, width, height ) {
              this.toDataURL( function( url, x, y ) {
                // this x and y shadow the outside parameters, and will be different if the outside parameters are undefined
                var img = document.createElement( 'img' );
                img.onload = function() {
                  callback( img, x, y );
                  try {
                    delete img.onload;
                  } catch ( e ) {} // fails on Safari 5.1
                };
                img.src = url;
              }, x, y, width, height );
            },
            
            // will call callback( node )
            toImageNodeAsynchronous: function( callback, x, y, width, height ) {
              this.toImage( function( image, x, y ) {
                callback( new scenery.Node( { children: [
                  new scenery.Image( image, { x: -x, y: -y } )
                ] } ) );
              }, x, y, width, height );
            },
            
            // fully synchronous, but returns a node that can only be rendered in Canvas
            toCanvasNodeSynchronous: function( x, y, width, height ) {
              var result;
              this.toCanvas( function( canvas, x, y ) {
                result = new scenery.Node( { children: [
                  new scenery.Image( canvas, { x: -x, y: -y } )
                ] } );
              }, x, y, width, height );
              assert && assert( result, 'toCanvasNodeSynchronous requires that the node can be rendered only using Canvas' );
              return result;
            },
            
            // synchronous, but Image will not have the correct bounds immediately (that will be asynchronous)
            toDataURLNodeSynchronous: function( x, y, width, height ) {
              var result;
              this.toDataURL( function( dataURL, x, y ) {
                result = new scenery.Node( { children: [
                  new scenery.Image( dataURL, { x: -x, y: -y } )
                ] } );
              }, x, y, width, height );
              assert && assert( result, 'toDataURLNodeSynchronous requires that the node can be rendered only using Canvas' );
              return result;
            },
            
            /*---------------------------------------------------------------------------*
            * Instance handling
            *----------------------------------------------------------------------------*/
            
            getInstances: function() {
              return this._instances;
            },
            
            addInstance: function( instance ) {
              assert && assert( instance.getNode() === this, 'Must be an instance of this Node' );
              assert && assert( !_.find( this._instances, function( other ) { return instance.equals( other ); } ), 'Cannot add duplicates of an instance to a Node' );
              this._instances.push( instance );
              if ( this._instances.length === 1 ) {
                this.firstInstanceAdded();
              }
            },
            
            firstInstanceAdded: function() {
              // no-op, meant to be overridden in the prototype chain
            },
            
            // returns undefined if there is no instance.
            getInstanceFromTrail: function( trail ) {
              var result;
              var len = this._instances.length;
              if ( len === 1 ) {
                // don't bother with checking the trail, but assertion should assure that it's what we're looking for
                result = this._instances[0];
              } else {
                var i = len;
                while ( i-- ) {
                  if ( this._instances[i].trail.equals( trail ) ) {
                    result = this._instances[i];
                    break;
                  }
                }
                // leave it as undefined if we don't find one
              }
              assert && assert( result, 'Could not find an instance for the trail ' + trail.toString() );
              assert && assert( result.trail.equals( trail ), 'Instance has an incorrect Trail' );
              return result;
            },
            
            removeInstance: function( instance ) {
              var index = _.indexOf( this._instances, instance ); // actual instance equality (NOT capitalized, normal meaning)
              assert && assert( index !== -1, 'Cannot remove an Instance from a Node if it was not there' );
              this._instances.splice( index, 1 );
              if ( this._instances.length === 0 ) {
                this.lastInstanceRemoved();
              }
            },
            
            lastInstanceRemoved: function() {
              // no-op, meant to be overridden in the prototype chain
            },
            
            notifyVisibilityChange: function() {
              var i = this._instances.length;
              while ( i-- ) {
                this._instances[i].notifyVisibilityChange();
              }
            },
            
            notifyOpacityChange: function() {
              var i = this._instances.length;
              while ( i-- ) {
                this._instances[i].notifyOpacityChange();
              }
            },
            
            notifyClipChange: function() {
              var i = this._instances.length;
              while ( i-- ) {
                this._instances[i].notifyClipChange();
              }
            },
            
            notifyBeforeSelfChange: function() {
              var i = this._instances.length;
              while ( i-- ) {
                this._instances[i].notifyBeforeSelfChange();
              }
            },
            
            notifyBeforeSubtreeChange: function() {
              var i = this._instances.length;
              while ( i-- ) {
                this._instances[i].notifyBeforeSubtreeChange();
              }
            },
            
            notifyDirtySelfPaint: function() {
              var i = this._instances.length;
              while ( i-- ) {
                this._instances[i].notifyDirtySelfPaint();
              }
            },
            
            notifyDirtySubtreePaint: function() {
              var i = this._instances.length;
              while ( i-- ) {
                this._instances[i].notifyDirtySubtreePaint();
              }
            },
            
            notifyTransformChange: function() {
              var i = this._instances.length;
              while ( i-- ) {
                this._instances[i].notifyTransformChange();
              }
            },
            
            notifyBoundsAccuracyChange: function() {
              var i = this._instances.length;
              while ( i-- ) {
                this._instances[i].notifyBoundsAccuracyChange();
              }
            },
            
            notifyStitch: function( match ) {
              var i = this._instances.length;
              while ( i-- ) {
                this._instances[i].notifyStitch( match );
              }
            },
            
            markForLayerRefresh: function() {
              var i = this._instances.length;
              while ( i-- ) {
                this._instances[i].markForLayerRefresh();
              }
            },
            
            markForInsertion: function( child, index ) {
              var i = this._instances.length;
              while ( i-- ) {
                this._instances[i].markForInsertion( child, index );
              }
            },
            
            markForRemoval: function( child, index ) {
              var i = this._instances.length;
              while ( i-- ) {
                this._instances[i].markForRemoval( child, index );
              }
            },
            
            /*---------------------------------------------------------------------------*
            * Coordinate transform methods
            *----------------------------------------------------------------------------*/
            
            // apply this node's transform to the point
            localToParentPoint: function( point ) {
              return this._transform.transformPosition2( point );
            },
            
            // apply this node's transform to the bounds
            localToParentBounds: function( bounds ) {
              return this._transform.transformBounds2( bounds );
            },
            
            // apply the inverse of this node's transform to the point
            parentToLocalPoint: function( point ) {
              return this._transform.inversePosition2( point );
            },
            
            // apply the inverse of this node's transform to the bounds
            parentToLocalBounds: function( bounds ) {
              return this._transform.inverseBounds2( bounds );
            },
            
            // mutable optimized form of localToParentBounds
            transformBoundsFromLocalToParent: function( bounds ) {
              return bounds.transform( this._transform.getMatrix() );
            },
            
            // mutable optimized form of parentToLocalBounds
            transformBoundsFromParentToLocal: function( bounds ) {
              return bounds.transform( this._transform.getInverse() );
            },
            
            // returns the matrix (fresh copy) that transforms points from the local coordinate frame into the global coordinate frame
            getLocalToGlobalMatrix: function() {
              var node = this;
              
              // we need to apply the transformations in the reverse order, so we temporarily store them
              var matrices = [];
              
              // concatenation like this has been faster than getting a unique trail, getting its transform, and applying it
              while ( node ) {
                matrices.push( node._transform.getMatrix() );
                assert && assert( node._parents[1] === undefined, 'getLocalToGlobalMatrix unable to work for DAG' );
                node = node._parents[0];
              }
        
              var matrix = Matrix3.identity(); // will be modified in place
              
              // iterate from the back forwards (from the root node to here)
              for ( var i = matrices.length - 1; i >=0; i-- ) {
                matrix.multiplyMatrix( matrices[i] );
              }
              
              // NOTE: always return a fresh copy, getGlobalToLocalMatrix depends on it to minimize instance usage!
              return matrix;
            },
            
            // equivalent to getUniqueTrail().getTransform(), but faster.
            getUniqueTransform: function() {
              return new Transform3( this.getLocalToGlobalMatrix() );
            },
            
            // returns the matrix (fresh copy) that transforms points in the global coordinate frame into the local coordinate frame
            getGlobalToLocalMatrix: function() {
              return this.getLocalToGlobalMatrix().invert();
            },
            
            // apply this node's transform (and then all of its parents' transforms) to the point
            localToGlobalPoint: function( point ) {
              var node = this;
              var resultPoint = point.copy();
              while ( node ) {
                // in-place multiplication
                node._transform.getMatrix().multiplyVector2( resultPoint );
                assert && assert( node._parents[1] === undefined, 'localToGlobalPoint unable to work for DAG' );
                node = node._parents[0];
              }
              return resultPoint;
            },
            
            globalToLocalPoint: function( point ) {
              var node = this;
              // TODO: performance: test whether it is faster to get a total transform and then invert (won't compute individual inverses)
              
              // we need to apply the transformations in the reverse order, so we temporarily store them
              var transforms = [];
              while ( node ) {
                transforms.push( node._transform );
                assert && assert( node._parents[1] === undefined, 'globalToLocalPoint unable to work for DAG' );
                node = node._parents[0];
              }
              
              // iterate from the back forwards (from the root node to here)
              var resultPoint = point.copy();
              for ( var i = transforms.length - 1; i >=0; i-- ) {
                // in-place multiplication
                transforms[i].getInverse().multiplyVector2( resultPoint );
              }
              return resultPoint;
            },
            
            // apply this node's transform (and then all of its parents' transforms) to the bounds
            localToGlobalBounds: function( bounds ) {
              // apply the bounds transform only once, so we can minimize the expansion encountered from multiple rotations
              // it also seems to be a bit faster this way
              return bounds.transformed( this.getLocalToGlobalMatrix() );
            },
            
            globalToLocalBounds: function( bounds ) {
              // apply the bounds transform only once, so we can minimize the expansion encountered from multiple rotations
              return bounds.transformed( this.getGlobalToLocalMatrix() );
            },
            
            // like localToGlobalPoint, but without applying this node's transform
            parentToGlobalPoint: function( point ) {
              assert && assert( this.parents.length <= 1, 'parentToGlobalPoint unable to work for DAG' );
              return this.parents.length ? this.parents[0].localToGlobalPoint( point ) : point;
            },
            
            // like localToGlobalBounds, but without applying this node's transform
            parentToGlobalBounds: function( bounds ) {
              assert && assert( this.parents.length <= 1, 'parentToGlobalBounds unable to work for DAG' );
              return this.parents.length ? this.parents[0].localToGlobalBounds( bounds ) : bounds;
            },
            
            globalToParentPoint: function( point ) {
              assert && assert( this.parents.length <= 1, 'globalToParentPoint unable to work for DAG' );
              return this.parents.length ? this.parents[0].globalToLocalPoint( point ) : point;
            },
            
            globalToParentBounds: function( bounds ) {
              assert && assert( this.parents.length <= 1, 'globalToParentBounds unable to work for DAG' );
              return this.parents.length ? this.parents[0].globalToLocalBounds( bounds ) : bounds;
            },
            
            // get the Bounds2 of this node in the global coordinate frame.  Does not work for DAG.
            getGlobalBounds: function() {
              assert && assert( this.parents.length <= 1, 'globalBounds unable to work for DAG' );
              return this.parentToGlobalBounds( this.getBounds() );
            },
            
            // get the Bounds2 of any other node by converting to the global coordinate frame.  Does not work for DAG.
            boundsOf: function( node ) {
              return this.globalToLocalBounds( node.getGlobalBounds() );
            },
            
            // get the Bounds2 of this node in the coordinate frame of the parameter node. Does not work for DAG cases.
            boundsTo: function( node ) {
              return node.globalToLocalBounds( this.getGlobalBounds() );
            },
            
            /*---------------------------------------------------------------------------*
            * ES5 get/set
            *----------------------------------------------------------------------------*/
            
            set layerSplit( value ) { this.setLayerSplit( value ); },
            get layerSplit() { return this.isLayerSplit(); },
            
            set renderer( value ) { this.setRenderer( value ); },
            get renderer() { return this.getRenderer(); },
            
            set rendererOptions( value ) { this.setRendererOptions( value ); },
            get rendererOptions() { return this.getRendererOptions(); },
            
            set cursor( value ) { this.setCursor( value ); },
            get cursor() { return this.getCursor(); },
            
            set mouseArea( value ) { this.setMouseArea( value ); },
            get mouseArea() { return this.getMouseArea(); },
            
            set touchArea( value ) { this.setTouchArea( value ); },
            get touchArea() { return this.getTouchArea(); },
            
            set clipArea( value ) { this.setClipArea( value ); },
            get clipArea() { return this.getClipArea(); },
        
            set transformBounds( value ) { this.setTransformBounds( value ); },
            get transformBounds() { return this.getTransformBounds(); },
            
            set visible( value ) { this.setVisible( value ); },
            get visible() { return this.isVisible(); },
            
            set opacity( value ) { this.setOpacity( value ); },
            get opacity() { return this.getOpacity(); },
            
            set pickable( value ) { this.setPickable( value ); },
            get pickable() { return this.isPickable(); },
            
            set transform( value ) { this.setTransform( value ); },
            get transform() { return this.getTransform(); },
            
            set matrix( value ) { this.setMatrix( value ); },
            get matrix() { return this.getMatrix(); },
            
            set translation( value ) { this.setTranslation( value ); },
            get translation() { return this.getTranslation(); },
            
            set rotation( value ) { this.setRotation( value ); },
            get rotation() { return this.getRotation(); },
            
            set x( value ) { this.setX( value ); },
            get x() { return this.getX(); },
            
            set y( value ) { this.setY( value ); },
            get y() { return this.getY(); },
            
            set left( value ) { this.setLeft( value ); },
            get left() { return this.getLeft(); },
            
            set right( value ) { this.setRight( value ); },
            get right() { return this.getRight(); },
            
            set top( value ) { this.setTop( value ); },
            get top() { return this.getTop(); },
            
            set bottom( value ) { this.setBottom( value ); },
            get bottom() { return this.getBottom(); },
            
            set center( value ) { this.setCenter( value ); },
            get center() { return this.getCenter(); },
            
            set centerX( value ) { this.setCenterX( value ); },
            get centerX() { return this.getCenterX(); },
            
            set centerY( value ) { this.setCenterY( value ); },
            get centerY() { return this.getCenterY(); },
            
            set leftTop( value ) { this.setLeftTop( value ); },
            get leftTop() { return this.getLeftTop(); },
            set centerTop( value ) { this.setCenterTop( value ); },
            get centerTop() { return this.getCenterTop(); },
            set rightTop( value ) { this.setRightTop( value ); },
            get rightTop() { return this.getRightTop(); },
            set leftCenter( value ) { this.setLeftCenter( value ); },
            get leftCenter() { return this.getLeftCenter(); },
            set rightCenter( value ) { this.setRightCenter( value ); },
            get rightCenter() { return this.getRightCenter(); },
            set leftBottom( value ) { this.setLeftBottom( value ); },
            get leftBottom() { return this.getLeftBottom(); },
            set centerBottom( value ) { this.setCenterBottom( value ); },
            get centerBottom() { return this.getCenterBottom(); },
            set rightBottom( value ) { this.setRightBottom( value ); },
            get rightBottom() { return this.getRightBottom(); },
            
            set children( value ) { this.setChildren( value ); },
            get children() { return this.getChildren(); },
            
            get parents() { return this.getParents(); },
            
            get width() { return this.getWidth(); },
            get height() { return this.getHeight(); },
            get bounds() { return this.getBounds(); },
            get selfBounds() { return this.getSelfBounds(); },
            get childBounds() { return this.getChildBounds(); },
            get localBounds() { return this.getLocalBounds(); },
            set localBounds( value ) { return this.setLocalBounds( value ); },
            get globalBounds() { return this.getGlobalBounds(); },
            get visibleBounds() { return this.getVisibleBounds(); },
            get id() { return this.getId(); },
            get instances() { return this.getInstances(); },
            
            mutate: function( options ) {
              if ( !options ) {
                return this;
              }
              
              var node = this;
              
              _.each( this._mutatorKeys, function( key ) {
                if ( options[key] !== undefined ) {
                  var descriptor = Object.getOwnPropertyDescriptor( Node.prototype, key );
                  
                  // if the key refers to a function that is not ES5 writable, it will execute that function with the single argument
                  if ( descriptor && typeof descriptor.value === 'function' ) {
                    node[key]( options[key] );
                  } else {
                    node[key] = options[key];
                  }
                }
              } );
              
              return this; // allow chaining
            },
            
            toString: function( spaces, includeChildren ) {
              spaces = spaces || '';
              var props = this.getPropString( spaces + '  ', includeChildren === undefined ? true : includeChildren );
              return spaces + this.getBasicConstructor( props ? ( '\n' + props + '\n' + spaces ) : '' );
            },
            
            getBasicConstructor: function( propLines ) {
              return 'new scenery.Node( {' + propLines + '} )';
            },
            
            getPropString: function( spaces, includeChildren ) {
        
              var result = '';
              function addProp( key, value, nowrap ) {
                if ( result ) {
                  result += ',\n';
                }
                if ( !nowrap && typeof value === 'string' ) {
                  result += spaces + key + ': \'' + value + '\'';
                } else {
                  result += spaces + key + ': ' + value;
                }
              }
              
              if ( this._children.length && includeChildren ) {
                var childString = '';
                _.each( this._children, function( child ) {
                  if ( childString ) {
                    childString += ',\n';
                  }
                  childString += child.toString( spaces + '  ' );
                } );
                addProp( 'children', '[\n' + childString + '\n' + spaces + ']', true );
              }
              
              // direct copy props
              if ( this.cursor ) { addProp( 'cursor', this.cursor ); }
              if ( !this.visible ) { addProp( 'visible', this.visible ); }
              if ( this.pickable !== null ) { addProp( 'pickable', this.pickable ); }
              if ( this.opacity !== 1 ) { addProp( 'opacity', this.opacity ); }
              
              if ( !this.transform.isIdentity() ) {
                var m = this.transform.getMatrix();
                addProp( 'matrix', 'dot.Matrix3.createFromPool( ' + m.m00() + ', ' + m.m01() + ', ' + m.m02() + ', ' +
                                                         m.m10() + ', ' + m.m11() + ', ' + m.m12() + ', ' +
                                                         m.m20() + ', ' + m.m21() + ', ' + m.m22() + ' )', true );
              }
              
              if ( this.renderer ) {
                addProp( 'renderer', this.renderer.name );
                if ( this.rendererOptions ) {
                  // addProp( 'rendererOptions', JSON.stringify( this.rendererOptions ), true );
                }
              }
              
              if ( this._layerSplit ) {
                addProp( 'layerSplit', true );
              }
              
              return result;
            }
          };
          
          /*
           * This is an array of property (setter) names for Node.mutate(), which are also used when creating nodes with parameter objects.
           *
           * E.g. new scenery.Node( { x: 5, rotation: 20 } ) will create a Path, and apply setters in the order below (node.x = 5; node.rotation = 20)
           *
           * The order below is important! Don't change this without knowing the implications.
           * NOTE: translation-based mutators come before rotation/scale, since typically we think of their operations occuring "after" the rotation / scaling
           * NOTE: left/right/top/bottom/centerX/centerY are at the end, since they rely potentially on rotation / scaling changes of bounds that may happen beforehand
           * TODO: using more than one of {translation,x,left,right,centerX} or {translation,y,top,bottom,centerY} should be considered an error
           * TODO: move fill / stroke setting to mixins
           */
          Node.prototype._mutatorKeys = [ 'children', 'cursor', 'visible', 'pickable', 'opacity', 'matrix', 'translation', 'x', 'y', 'rotation', 'scale',
                                          'leftTop', 'centerTop', 'rightTop', 'leftCenter', 'center', 'rightCenter', 'leftBottom', 'centerBottom', 'rightBottom',
                                          'left', 'right', 'top', 'bottom', 'centerX', 'centerY', 'renderer', 'rendererOptions',
                                          'layerSplit', 'mouseArea', 'touchArea', 'clipArea', 'transformBounds' ];
          
          // mix-in the events for Node
          /* jshint -W064 */
          NodeEvents( Node );
          
          return Node;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * A description of layer settings and the ability to create a layer with those settings.
         * Used internally for the layer building process.
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/layers/LayerType',['require','SCENERY/scenery'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          
          scenery.LayerType = function LayerType( Constructor, name, bitmask, renderer, args ) {
            this.Constructor = Constructor;
            this.name = name;
            this.bitmask = bitmask;
            this.renderer = renderer;
            this.args = args;
          };
          var LayerType = scenery.LayerType;
          
          LayerType.prototype = {
            constructor: LayerType,
            
            supportsRenderer: function( renderer ) {
              // NOTE: if this is changed off of instance equality, update supportsNode below
              return this.renderer === renderer;
            },
            
            supportsBitmask: function( bitmask ) {
              return ( this.bitmask & bitmask ) !== 0;
            },
            
            supportsNode: function( node ) {
              // for now, only check the renderer that we are interested in
              return node.supportsRenderer( this.renderer );
            },
            
            createLayer: function( args ) {
              var Constructor = this.Constructor;
              return new Constructor( _.extend( {}, args, this.args ) ); // allow overriding certain arguments if necessary by the LayerType
            }
          };
          
          return LayerType;
        } );
        
        
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Represents a trail (path in the graph) from a 'root' node down to a descendant node.
         * In a DAG, or with different views, there can be more than one trail up from a node,
         * even to the same root node!
         *
         * It has an array of nodes, in order from the 'root' down to the last node,
         * a length, and an array of indices such that node_i.children[index_i] === node_{i+1}.
         *
         * The indices can sometimes become stale when nodes are added and removed, so Trails
         * can have their indices updated with reindex(). It's designed to be as fast as possible
         * on Trails that are already indexed accurately.
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/util/Trail',['require','DOT/Matrix3','DOT/Transform3','SCENERY/scenery','SCENERY/nodes/Node'],function( require ) {
          
        
          var Matrix3 = require( 'DOT/Matrix3' );
          var Transform3 = require( 'DOT/Transform3' );
        
          var scenery = require( 'SCENERY/scenery' );
        
          require( 'SCENERY/nodes/Node' );
          // require( 'SCENERY/util/TrailPointer' );
        
          scenery.Trail = function Trail( nodes ) {
            /*
             * Controls the immutability of the trail.
             * If set to true, add/remove descendant/ancestor should fail if assertions are enabled
             * Use setImmutable() or setMutable() to signal a specific type of protection, so it cannot be changed later
             */
            if ( assert ) {
              // only do this if assertions are enabled, otherwise we won't access it at all
              this.immutable = undefined;
            }
        
            if ( nodes instanceof Trail ) {
              // copy constructor (takes advantage of already built index information)
              var otherTrail = nodes;
        
              this.nodes = otherTrail.nodes.slice( 0 );
              this.length = otherTrail.length;
              this.uniqueId = otherTrail.uniqueId;
              this.indices = otherTrail.indices.slice( 0 );
              return;
            }
        
            this.nodes = [];
            this.length = 0;
            this.uniqueId = '';
        
            // indices[x] stores the index of nodes[x] in nodes[x-1]'s children
            this.indices = [];
        
            var trail = this;
            if ( nodes ) {
              if ( nodes instanceof scenery.Node ) {
                var node = nodes;
        
                // add just a single node in
                trail.addDescendant( node );
              }
              else {
                // process it as an array
                var len = nodes.length;
                for ( var i = 0; i < len; i++ ) {
                  trail.addDescendant( nodes[i] );
                }
              }
            }
        
            phetAllocation && phetAllocation( 'Trail' );
          };
          var Trail = scenery.Trail;
        
          Trail.prototype = {
            constructor: Trail,
        
            copy: function() {
              return new Trail( this );
            },
        
            // convenience function to determine whether this trail will render something
            isPainted: function() {
              return this.lastNode().isPainted();
            },
        
            // this trail is visible only if all nodes on it are marked as visible
            isVisible: function() {
              var i = this.nodes.length;
              while ( i-- ) {
                if ( !this.nodes[i].isVisible() ) {
                  return false;
                }
              }
              return true;
            },
        
            getOpacity: function() {
              var opacity = 1;
              var i = this.nodes.length;
              while ( i-- ) {
                opacity *= this.nodes[i].getOpacity();
              }
              return opacity;
            },
        
            // essentially whether this node is visited in the hit-testing operation
            isPickable: function() {
              // it won't be if it or any ancestor is pickable: false, or is invisible
              if ( _.some( this.nodes, function( node ) { return node._pickable === false || node._visible === false; } ) ) { return false; }
        
              // if there is any listener or pickable: true, it will be pickable
              if ( _.some( this.nodes, function( node ) { return node._pickable === true || node._inputListeners.length > 0; } ) ) { return true; }
        
              if ( this.lastNode()._subtreePickableCount > 0 ) {
                return true;
              }
        
              // no listeners or pickable: true, so it will be pruned
              return false;
            },
        
            get: function( index ) {
              if ( index >= 0 ) {
                return this.nodes[index];
              }
              else {
                // negative index goes from the end of the array
                return this.nodes[this.nodes.length + index];
              }
            },
        
            slice: function( startIndex, endIndex ) {
              return new Trail( this.nodes.slice( startIndex, endIndex ) );
            },
        
            subtrailTo: function( node, excludeNode ) {
              return this.slice( 0, _.indexOf( this.nodes, node ) + ( excludeNode ? 0 : 1 ) );
            },
        
            isEmpty: function() {
              return this.nodes.length === 0;
            },
        
            getInstance: function() {
              return this.lastNode().getInstanceFromTrail( this );
            },
        
            // from local to global
            getMatrix: function() {
              // TODO: performance: can we cache this ever? would need the scene to not really change in between
              // this matrix will be modified in place, so always start fresh
              var matrix = Matrix3.identity();
        
              // from the root up
              var nodes = this.nodes;
              var length = nodes.length;
              for ( var i = 0; i < length; i++ ) {
                matrix.multiplyMatrix( nodes[i]._transform.getMatrix() );
              }
              return matrix;
            },
        
            // from parent to global
            getParentMatrix: function() {
              // this matrix will be modified in place, so always start fresh
              var matrix = Matrix3.identity();
        
              // from the root up
              var nodes = this.nodes;
              var length = nodes.length;
              for ( var i = 0; i < length - 1; i++ ) {
                matrix.multiplyMatrix( nodes[i]._transform.getMatrix() );
              }
              return matrix;
            },
        
            // from local to global
            getTransform: function() {
              return new Transform3( this.getMatrix() );
            },
        
            // from parent to global
            getParentTransform: function() {
              return new Transform3( this.getParentMatrix() );
            },
        
            addAncestor: function( node, index ) {
              assert && assert( !this.immutable, 'cannot modify an immutable Trail with addAncestor' );
              assert && assert( node, 'cannot add falsy value to a Trail' );
        
        
              if ( this.nodes.length ) {
                var oldRoot = this.nodes[0];
                this.indices.unshift( index === undefined ? _.indexOf( node._children, oldRoot ) : index );
              }
              this.nodes.unshift( node );
        
              this.length++;
              // accelerated version of this.updateUniqueId()
              this.uniqueId = ( this.uniqueId ? node._id + '-' + this.uniqueId : node._id + '' );
              return this;
            },
        
            removeAncestor: function() {
              assert && assert( !this.immutable, 'cannot modify an immutable Trail with removeAncestor' );
              assert && assert( this.length > 0, 'cannot remove a Node from an empty trail' );
        
              this.nodes.shift();
              if ( this.indices.length ) {
                this.indices.shift();
              }
        
              this.length--;
              this.updateUniqueId();
              return this;
            },
        
            addDescendant: function( node, index ) {
              assert && assert( !this.immutable, 'cannot modify an immutable Trail with addDescendant' );
              assert && assert( node, 'cannot add falsy value to a Trail' );
        
        
              if ( this.nodes.length ) {
                var parent = this.lastNode();
                this.indices.push( index === undefined ? _.indexOf( parent._children, node ) : index );
              }
              this.nodes.push( node );
        
              this.length++;
              // accelerated version of this.updateUniqueId()
              this.uniqueId = ( this.uniqueId ? this.uniqueId + '-' + node._id : node._id + '' );
              return this;
            },
        
            removeDescendant: function() {
              assert && assert( !this.immutable, 'cannot modify an immutable Trail with removeDescendant' );
              assert && assert( this.length > 0, 'cannot remove a Node from an empty trail' );
        
              this.nodes.pop();
              if ( this.indices.length ) {
                this.indices.pop();
              }
        
              this.length--;
              this.updateUniqueId();
              return this;
            },
        
            // refreshes the internal index references (important if any children arrays were modified!)
            reindex: function() {
              var length = this.length;
              for ( var i = 1; i < length; i++ ) {
                // only replace indices where they have changed (this was a performance hotspot)
                var currentIndex = this.indices[i - 1];
                var baseNode = this.nodes[i - 1];
        
                if ( baseNode._children[currentIndex] !== this.nodes[i] ) {
                  this.indices[i - 1] = _.indexOf( baseNode._children, this.nodes[i] );
                }
              }
            },
        
            setImmutable: function() {
              // if assertions are disabled, we hope this is inlined as a no-op
              if ( assert ) {
                assert( this.immutable !== false, 'A trail cannot be made immutable after being flagged as mutable' );
                this.immutable = true;
              }
        
              // TODO: consider setting mutators to null here instead of the function call check (for performance, and profile the differences)
        
              return this; // allow chaining
            },
        
            setMutable: function() {
              // if assertions are disabled, we hope this is inlined as a no-op
              if ( assert ) {
                assert( this.immutable !== true, 'A trail cannot be made mutable after being flagged as immutable' );
                this.immutable = false;
              }
        
              return this; // allow chaining
            },
        
            areIndicesValid: function() {
              for ( var i = 1; i < this.length; i++ ) {
                var currentIndex = this.indices[i - 1];
                if ( this.nodes[i - 1]._children[currentIndex] !== this.nodes[i] ) {
                  return false;
                }
              }
              return true;
            },
        
            equals: function( other ) {
              if ( this.length !== other.length ) {
                return false;
              }
        
              for ( var i = 0; i < this.nodes.length; i++ ) {
                if ( this.nodes[i] !== other.nodes[i] ) {
                  return false;
                }
              }
        
              return true;
            },
        
            // returns a new Trail from the root up to the parameter node.
            upToNode: function( node ) {
              var nodeIndex = _.indexOf( this.nodes, node );
              assert && assert( nodeIndex >= 0, 'Trail does not contain the node' );
              return this.slice( 0, _.indexOf( this.nodes, node ) + 1 );
            },
        
            // whether this trail contains the complete 'other' trail, but with added descendants afterwards
            isExtensionOf: function( other, allowSameTrail ) {
              assertSlow && assertSlow( this.areIndicesValid(), 'Trail.compare this.areIndicesValid() failed' );
              assertSlow && assertSlow( other.areIndicesValid(), 'Trail.compare other.areIndicesValid() failed' );
        
              if ( this.length <= other.length - ( allowSameTrail ? 1 : 0 ) ) {
                return false;
              }
        
              for ( var i = 0; i < other.nodes.length; i++ ) {
                if ( this.nodes[i] !== other.nodes[i] ) {
                  return false;
                }
              }
        
              return true;
            },
        
            // a transform from our local coordinate frame to the other trail's local coordinate frame
            getTransformTo: function( otherTrail ) {
              return new Transform3( this.getMatrixTo( otherTrail ) );
            },
        
            // returns a matrix that transforms a point in our last node's local coordinate frame to the other trail's last node's local coordinate frame
            getMatrixTo: function( otherTrail ) {
              this.reindex();
              otherTrail.reindex();
        
              var branchIndex = this.getBranchIndexTo( otherTrail );
              var idx;
        
              var matrix = Matrix3.IDENTITY;
        
              // walk our transform down, prepending
              for ( idx = this.length - 1; idx >= branchIndex; idx-- ) {
                matrix = this.nodes[idx].getTransform().getMatrix().timesMatrix( matrix );
              }
        
              // walk our transform up, prepending inverses
              for ( idx = branchIndex; idx < otherTrail.length; idx++ ) {
                matrix = otherTrail.nodes[idx].getTransform().getInverse().timesMatrix( matrix );
              }
        
              return matrix;
            },
        
            // the first index that is different between this trail and the other trail
            getBranchIndexTo: function( otherTrail ) {
              assert && assert( this.nodes[0] === otherTrail.nodes[0], 'To get a branch index, the trails must have the same root' );
        
              var branchIndex;
        
              for ( branchIndex = 0; branchIndex < Math.min( this.length, otherTrail.length ); branchIndex++ ) {
                if ( this.nodes[branchIndex] !== otherTrail.nodes[branchIndex] ) {
                  break;
                }
              }
        
              return branchIndex;
            },
        
            // TODO: phase out in favor of get()
            nodeFromTop: function( offset ) {
              return this.nodes[this.length - 1 - offset];
            },
        
            lastNode: function() {
              return this.nodeFromTop( 0 );
            },
        
            rootNode: function() {
              return this.nodes[0];
            },
        
            // returns the previous graph trail in the order of self-rendering
            previous: function() {
              if ( this.nodes.length <= 1 ) {
                return null;
              }
        
              var top = this.nodeFromTop( 0 );
              var parent = this.nodeFromTop( 1 );
        
              var parentIndex = _.indexOf( parent._children, top );
              assert && assert( parentIndex !== -1 );
              var arr = this.nodes.slice( 0, this.nodes.length - 1 );
              if ( parentIndex === 0 ) {
                // we were the first child, so give it the trail to the parent
                return new Trail( arr );
              }
              else {
                // previous child
                arr.push( parent._children[parentIndex - 1] );
        
                // and find its last terminal
                while ( arr[arr.length - 1]._children.length !== 0 ) {
                  var last = arr[arr.length - 1];
                  arr.push( last._children[last._children.length - 1] );
                }
        
                return new Trail( arr );
              }
            },
        
            // like previous(), but keeps moving back until the trail goes to a node with isPainted() === true
            previousPainted: function() {
              var result = this.previous();
              while ( result && !result.isPainted() ) {
                result = result.previous();
              }
              return result;
            },
        
            // in the order of self-rendering
            next: function() {
              var arr = this.nodes.slice( 0 );
        
              var top = this.nodeFromTop( 0 );
              if ( top._children.length > 0 ) {
                // if we have children, return the first child
                arr.push( top._children[0] );
                return new Trail( arr );
              }
              else {
                // walk down and attempt to find the next parent
                var depth = this.nodes.length - 1;
        
                while ( depth > 0 ) {
                  var node = this.nodes[depth];
                  var parent = this.nodes[depth - 1];
        
                  arr.pop(); // take off the node so we can add the next sibling if it exists
        
                  var index = _.indexOf( parent._children, node );
                  if ( index !== parent._children.length - 1 ) {
                    // there is another (later) sibling. use that!
                    arr.push( parent._children[index + 1] );
                    return new Trail( arr );
                  }
                  else {
                    depth--;
                  }
                }
        
                // if we didn't reach a later sibling by now, it doesn't exist
                return null;
              }
            },
        
            // like next(), but keeps moving back until the trail goes to a node with isPainted() === true
            nextPainted: function() {
              var result = this.next();
              while ( result && !result.isPainted() ) {
                result = result.next();
              }
              return result;
            },
        
            // calls callback( trail ) for this trail, and each descendant trail. If callback returns true, subtree will be skipped
            eachTrailUnder: function( callback ) {
              // TODO: performance: should be optimized to be much faster, since we don't have to deal with the before/after
              new scenery.TrailPointer( this, true ).eachTrailBetween( new scenery.TrailPointer( this, false ), callback );
            },
        
            /*
             * Standard Java-style compare. -1 means this trail is before (under) the other trail, 0 means equal, and 1 means this trail is
             * after (on top of) the other trail.
             * A shorter subtrail will compare as -1.
             *
             * Assumes that the Trails are properly indexed. If not, please reindex them!
             *
             * Comparison is for the rendering order, so an ancestor is 'before' a descendant
             */
            compare: function( other ) {
              assert && assert( !this.isEmpty(), 'cannot compare with an empty trail' );
              assert && assert( !other.isEmpty(), 'cannot compare with an empty trail' );
              assert && assert( this.nodes[0] === other.nodes[0], 'for Trail comparison, trails must have the same root node' );
              assertSlow && assertSlow( this.areIndicesValid(), 'Trail.compare this.areIndicesValid() failed on ' + this.toString() );
              assertSlow && assertSlow( other.areIndicesValid(), 'Trail.compare other.areIndicesValid() failed on ' + other.toString() );
        
              var minNodeIndex = Math.min( this.indices.length, other.indices.length );
              for ( var i = 0; i < minNodeIndex; i++ ) {
                if ( this.indices[i] !== other.indices[i] ) {
                  if ( this.indices[i] < other.indices[i] ) {
                    return -1;
                  }
                  else {
                    return 1;
                  }
                }
              }
        
              // we scanned through and no nodes were different (one is a subtrail of the other)
              if ( this.nodes.length < other.nodes.length ) {
                return -1;
              }
              else if ( this.nodes.length > other.nodes.length ) {
                return 1;
              }
              else {
                return 0;
              }
            },
        
            isBefore: function( other ) {
              return this.compare( other ) === -1;
            },
        
            isAfter: function( other ) {
              return this.compare( other ) === 1;
            },
        
            localToGlobalPoint: function( point ) {
              // TODO: performance: multiple timesVector2 calls up the chain is probably faster
              return this.getMatrix().timesVector2( point );
            },
        
            localToGlobalBounds: function( bounds ) {
              return bounds.transformed( this.getMatrix() );
            },
        
            globalToLocalPoint: function( point ) {
              return this.getTransform().inversePosition2( point );
            },
        
            globalToLocalBounds: function( bounds ) {
              return this.getTransform().inverseBounds2( bounds );
            },
        
            parentToGlobalPoint: function( point ) {
              // TODO: performance: multiple timesVector2 calls up the chain is probably faster
              return this.getParentMatrix().timesVector2( point );
            },
        
            parentToGlobalBounds: function( bounds ) {
              return bounds.transformed( this.getParentMatrix() );
            },
        
            globalToParentPoint: function( point ) {
              return this.getParentTransform().inversePosition2( point );
            },
        
            globalToParentBounds: function( bounds ) {
              return this.getParentTransform().inverseBounds2( bounds );
            },
        
            updateUniqueId: function() {
              // string concatenation is faster, see http://jsperf.com/string-concat-vs-joins
              var result = '';
              var len = this.nodes.length;
              if ( len > 0 ) {
                result += this.nodes[0]._id;
              }
              for ( var i = 1; i < len; i++ ) {
                result += '-' + this.nodes[i]._id;
              }
              this.uniqueId = result;
              // this.uniqueId = _.map( this.nodes, function( node ) { return node.getId(); } ).join( '-' );
            },
        
            // concatenates the unique IDs of nodes in the trail, so that we can do id-based lookups
            getUniqueId: function() {
              // sanity checks
              if ( assert ) {
                var oldUniqueId = this.uniqueId;
                this.updateUniqueId();
                assert( oldUniqueId === this.uniqueId );
              }
              return this.uniqueId;
            },
        
            toString: function() {
              this.reindex();
              if ( !this.length ) {
                return 'Empty Trail';
              }
              return '[Trail ' + this.indices.join( '.' ) + ' ' + this.getUniqueId() + ']';
            }
          };
        
          // like eachTrailBetween, but only fires for painted trails. If callback returns true, subtree will be skipped
          Trail.eachPaintedTrailBetween = function( a, b, callback, excludeEndTrails, scene ) {
            Trail.eachTrailBetween( a, b, function( trail ) {
              if ( trail && trail.isPainted() ) {
                return callback( trail );
              }
            }, excludeEndTrails, scene );
          };
        
          // global way of iterating across trails. when callback returns true, subtree will be skipped
          Trail.eachTrailBetween = function( a, b, callback, excludeEndTrails, scene ) {
            var aPointer = a ? new scenery.TrailPointer( a.copy(), true ) : new scenery.TrailPointer( new scenery.Trail( scene ), true );
            var bPointer = b ? new scenery.TrailPointer( b.copy(), true ) : new scenery.TrailPointer( new scenery.Trail( scene ), false );
        
            // if we are excluding endpoints, just bump the pointers towards each other by one step
            if ( excludeEndTrails ) {
              aPointer.nestedForwards();
              bPointer.nestedBackwards();
        
              // they were adjacent, so no callbacks will be executed
              if ( aPointer.compareNested( bPointer ) === 1 ) {
                return;
              }
            }
        
            aPointer.depthFirstUntil( bPointer, function( pointer ) {
              if ( pointer.isBefore ) {
                return callback( pointer.trail );
              }
            }, false );
          };
        
          // The index at which the two trails diverge. If a.length === b.length === branchIndex, the trails are identical
          Trail.branchIndex = function( a, b ) {
            assert && assert( a.nodes[0] === b.nodes[0], 'Branch changes require roots to be the same' );
            var branchIndex;
            var shortestLength = Math.min( a.length, b.length );
            for ( branchIndex = 0; branchIndex < shortestLength; branchIndex++ ) {
              if ( a.nodes[branchIndex] !== b.nodes[branchIndex] ) {
                break;
              }
            }
            return branchIndex;
          };
        
          // The subtrail from the root that both trails share
          Trail.sharedTrail = function( a, b ) {
            return a.slice( 0, Trail.branchIndex( a, b ) );
          };
        
          /*
           * Fires subtree(trail) or self(trail) on the callbacks to create disjoint subtrees (trails) that cover exactly the nodes
           * inclusively between a and b in rendering order.
           * We try to consolidate these as much as possible.
           *
           * "a" and "b" are treated like self painted trails in the rendering order
           * 
           *
           * Example tree:
           *   a
           *   - b
           *   --- c
           *   --- d
           *   - e
           *   --- f
           *   ----- g
           *   ----- h
           *   ----- i
           *   --- j
           *   ----- k
           *   - l
           *   - m
           *   --- n
           *
           * spannedSubtrees( a, a ) -> self( a );
           * spannedSubtrees( c, n ) -> subtree( a ); NOTE: if b is painted, that wouldn't work!
           * spannedSubtrees( h, l ) -> subtree( h ); subtree( i ); subtree( j ); self( l );
           * spannedSubtrees( c, i ) -> [b,f] --- wait, include e self?
           */
          Trail.spannedSubtrees = function( a, b ) {
            // assert && assert( a.nodes[0] === b.nodes[0], 'Spanned subtrees for a and b requires that a and b have the same root' );
        
            // a.reindex();
            // b.reindex();
        
            // var subtrees = [];
        
            // var branchIndex = Trail.branchIndex( a, b );
            // assert && assert( branchIndex > 0, 'Branch index should always be > 0' );
        
            // if ( a.length === branchIndex && b.length === branchIndex ) {
            //   // the two trails are equal
            //   subtrees.push( a );
            // } else {
            //   // find the first place where our start isn't the first child
            //   for ( var before = a.length - 1; before >= branchIndex; before-- ) {
            //     if ( a.indices[before-1] !== 0 ) {
            //       break;
            //     }
            //   }
        
            //   // find the first place where our end isn't the last child
            //   for ( var after = a.length - 1; after >= branchIndex; after-- ) {
            //     if ( b.indices[after-1] !== b.nodes[after-1]._children.length - 1 ) {
            //       break;
            //     }
            //   }
        
            //   if ( before < branchIndex && after < branchIndex ) {
            //     // we span the entire tree up to nodes[branchIndex-1], so return only that subtree
            //     subtrees.push( a.slice( 0, branchIndex ) );
            //   } else {
            //     // walk the subtrees down from the start
            //     for ( var ia = before; ia >= branchIndex; ia-- ) {
            //       subtrees.push( a.slice( 0, ia + 1 ) );
            //     }
        
            //     // walk through the middle
            //     var iStart = a.indices[branchIndex-1];
            //     var iEnd = b.indices[branchIndex-1];
            //     var base = a.slice( 0, branchIndex );
            //     var children = base.lastNode()._children;
            //     for ( var im = iStart; im <= iEnd; im++ ) {
            //       subtrees.push( base.copy().addDescendant( children[im], im ) );
            //     }
        
            //     // walk the subtrees up to the end
            //     for ( var ib = branchIndex; ib <= after; ib++ ) {
            //       subtrees.push( b.slice( 0, ib + 1 ) );
            //     }
            //   }
            // }
        
            // return subtrees;
          };
        
          return Trail;
        } );
        
        
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Base code for layers that helps with shared layer functions
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/layers/Layer',['require','DOT/Bounds2','DOT/Transform3','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
          
          
          var Bounds2 = require( 'DOT/Bounds2' );
          var Transform3 = require( 'DOT/Transform3' );
          
          var scenery = require( 'SCENERY/scenery' );
          require( 'SCENERY/util/Trail' );
          
          var globalIdCounter = 1;
          
          /*
           * Required arguments:
           * $main     - the jQuery-wrapped container for the scene
           * scene     - the scene itself
           * baseNode  - the base node for this layer
           */
          scenery.Layer = function Layer( args ) {
            
            // assign a unique ID to this layer
            this._id = globalIdCounter++;
            
            this.$main = args.$main;
            this.scene = args.scene;
            this.baseNode = args.baseNode;
            
            // TODO: cleanup of flags!
            this.usesPartialCSSTransforms = args.cssTranslation || args.cssRotation || args.cssScale;
            this.cssTranslation = args.cssTranslation; // CSS for the translation
            this.cssRotation = args.cssRotation;       // CSS for the rotation
            this.cssScale = args.cssScale;             // CSS for the scaling
            this.cssTransform = args.cssTransform;     // CSS for the entire base node (will ignore other partial transforms)
            assert && assert( !( this.usesPartialCSSTransforms && this.cssTransform ), 'Do not specify both partial and complete CSS transform arguments.' );
            
            // initialize to fully dirty so we draw everything the first time
            // bounds in global coordinate frame
            this.dirtyBounds = Bounds2.EVERYTHING;
            
            this.setStartBoundary( args.startBoundary );
            this.setEndBoundary( args.endBoundary );
            
            // set baseTrail from the scene to our baseNode
            if ( this.baseNode === this.scene ) {
              this.baseTrail = new scenery.Trail( this.scene );
            } else {
              this.baseTrail = this.startPaintedTrail.upToNode( this.baseNode );
              assert && assert( this.baseTrail.lastNode() === this.baseNode );
            }
            
            // we reference all painted trails in an unordered way
            this._layerTrails = []; // TODO: performance: remove layerTrails if possible!
            this._instanceCount = 0; // track how many instances we are tracking (updated in stitching by instances)
            
            var layer = this;
            
            // whenever the base node's children or self change bounds, signal this. we want to explicitly ignore the base node's main bounds for
            // CSS transforms, since the self / children bounds may not have changed
            this.baseNodeBoundsListener = function( bounds ) {
              layer.baseNodeInternalBoundsChange(); // TODO: verify that this is working as expected
            };
            this.baseNode.addEventListener( 'selfBounds', this.baseNodeBoundsListener );
            this.baseNode.addEventListener( 'childBounds', this.baseNodeBoundsListener );
            
            this.fitToBounds = this.usesPartialCSSTransforms || this.cssTransform;
            assert && assert( this.fitToBounds || this.baseNode === this.scene, 'If the baseNode is not the scene, we need to fit the bounds' );
            
            // used for CSS transforms where we need to transform our base node's bounds into the (0,0,w,h) bounds range
            this.baseNodeTransform = new Transform3();
            //this.baseNodeInteralBounds = Bounds2.NOTHING; // stores the bounds transformed into (0,0,w,h)
            
            this.disposed = false; // track whether we have been disposed or not
          };
          var Layer = scenery.Layer;
          
          Layer.prototype = {
            constructor: Layer,
            
            setStartBoundary: function( boundary ) {
              // console.log( 'setting start boundary on layer ' + this.getId() + ': ' + boundary.toString() );
              this.startBoundary = boundary;
              
              // TODO: deprecate these, use boundary references instead? or boundary convenience functions
              this.startPaintedTrail = this.startBoundary.nextPaintedTrail;
              
              // set immutability guarantees
              this.startPaintedTrail.setImmutable();
            },
            
            setEndBoundary: function( boundary ) {
              // console.log( 'setting end boundary on layer ' + this.getId() + ': ' + boundary.toString() );
              this.endBoundary = boundary;
              
              // TODO: deprecate these, use boundary references instead? or boundary convenience functions
              this.endPaintedTrail = this.endBoundary.previousPaintedTrail;
              
              // set immutability guarantees
              this.endPaintedTrail.setImmutable();
            },
            
            toString: function() {
              return this.getName() + ' ' + ( this.startPaintedTrail ? this.startPaintedTrail.toString() : '!' ) + ' => ' + ( this.endPaintedTrail ? this.endPaintedTrail.toString() : '!' );
            },
            
            getId: function() {
              return this._id;
            },
            get id() { return this._id; }, // ES5 version
            
            // painted trails associated with the layer, NOT necessarily in order
            getLayerTrails: function() {
              return this._layerTrails.slice( 0 );
            },
            
            getPaintedTrailCount: function() {
              return this._layerTrails.length;
            },
            
            /*---------------------------------------------------------------------------*
            * Abstract
            *----------------------------------------------------------------------------*/
            
            render: function( state ) {
              throw new Error( 'Layer.render unimplemented' );
            },
            
            // TODO: consider a stack-based model for transforms?
            // TODO: is this necessary? verify with the render state
            applyTransformationMatrix: function( matrix ) {
              throw new Error( 'Layer.applyTransformationMatrix unimplemented' );
            },
            
            // adds a trail (with the last node) to the layer
            addInstance: function( instance ) {
              var trail = instance.trail;
              
              if ( assert ) {
                _.each( this._layerTrails, function( otherTrail ) {
                  assert( !trail.equals( otherTrail ), 'trail in addInstance should not already exist in a layer' );
                } );
              }
              
              // TODO: sync this with DOMLayer's implementation
              this._layerTrails.push( trail );
              trail.setImmutable(); // don't allow this Trail to be changed
            },
            
            // removes a trail (with the last node) to the layer
            removeInstance: function( instance ) {
              // TODO: sync this with DOMLayer's implementation
              var i;
              for ( i = 0; i < this._layerTrails.length; i++ ) {
                this._layerTrails[i].reindex();
                if ( this._layerTrails[i].compare( instance.trail ) === 0 ) {
                  break;
                }
              }
              assert && assert( i < this._layerTrails.length );
              
              this._layerTrails.splice( i, 1 );
            },
            
            // returns next zIndex in place. allows layers to take up more than one single zIndex
            reindex: function( zIndex ) {
              this.startBoundary.reindex();
              this.endBoundary.reindex();
            },
            
            pushClipShape: function( shape ) {
              throw new Error( 'Layer.pushClipShape unimplemented' );
            },
            
            popClipShape: function() {
              throw new Error( 'Layer.popClipShape unimplemented' );
            },
            
            renderToCanvas: function( canvas, context, delayCounts ) {
              throw new Error( 'Layer.renderToCanvas unimplemented' );
            },
            
            dispose: function() {
              assert && assert( !this.disposed, 'Layer has already been disposed!' );
              
              this.disposed = true;
              
              // clean up listeners
              this.baseNode.removeEventListener( 'selfBounds', this.baseNodeBoundsListener );
              this.baseNode.removeEventListener( 'childBounds', this.baseNodeBoundsListener );
            },
            
            getName: function() {
              throw new Error( 'Layer.getName unimplemented' );
            },
            
            // called when the base node's "internal" (self or child) bounds change, but not when it is just from the base node's own transform changing
            baseNodeInternalBoundsChange: function() {
              // no error, many times this doesn't need to be handled
            }
            
          };
          
          Layer.cssTransformPadding = 3;
          
          return Layer;
        } );
        
        
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Wraps the context and contains a reference to the canvas, so that we can absorb unnecessary state changes,
         * and possibly combine certain fill operations.
         *
         * TODO: performance analysis, possibly axe this and use direct modification.
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/util/CanvasContextWrapper',['require','SCENERY/scenery'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          
          scenery.CanvasContextWrapper = function CanvasContextWrapper( canvas, context ) {
            this.canvas = canvas;
            this.context = context;
            
            this.resetStyles();
            
            phetAllocation && phetAllocation( 'CanvasContextWrapper' );
          };
          var CanvasContextWrapper = scenery.CanvasContextWrapper;
          
          CanvasContextWrapper.prototype = {
            constructor: CanvasContextWrapper,
            
            // set local styles to undefined, so that they will be invalidated later
            resetStyles: function() {
              this.fillStyle = undefined; // null
              this.strokeStyle = undefined; // null
              this.lineWidth = undefined; // 1
              this.lineCap = undefined; // 'butt'
              this.lineJoin = undefined; // 'miter'
              this.lineDash = undefined; // []
              this.lineDashOffset = undefined; // 0
              this.miterLimit = undefined; // 10
              
              this.font = undefined; // '10px sans-serif'
              this.direction = undefined; // 'inherit'
            },
        
            /**
             * Sets a (possibly) new width and height, and clears the canvas.
             * @param width
             * @param height
             */
            setDimensions: function( width, height ) {
        
              //Don't guard against width and height, because we need to clear the canvas.
              //TODO: Is it expensive to clear by setting both the width and the height?  Maybe we just need to set the width to clear it.
              this.canvas.width = width;
              this.canvas.height = height;
        
              // assume all persistent data could have changed
              this.resetStyles();
            },
            
            setFillStyle: function( style ) {
              if ( this.fillStyle !== style ) {
                this.fillStyle = style;
                
                // allow gradients / patterns
                this.context.fillStyle = ( style && style.getCanvasStyle ) ? style.getCanvasStyle() : style;
              }
            },
            
            setStrokeStyle: function( style ) {
              if ( this.strokeStyle !== style ) {
                this.strokeStyle = style;
                
                // allow gradients / patterns
                this.context.strokeStyle = ( style && style.getCanvasStyle ) ? style.getCanvasStyle() : style;
              }
            },
            
            setLineWidth: function( width ) {
              if ( this.lineWidth !== width ) {
                this.lineWidth = width;
                this.context.lineWidth = width;
              }
            },
            
            setLineCap: function( cap ) {
              if ( this.lineCap !== cap ) {
                this.lineCap = cap;
                this.context.lineCap = cap;
              }
            },
            
            setLineJoin: function( join ) {
              if ( this.lineJoin !== join ) {
                this.lineJoin = join;
                this.context.lineJoin = join;
              }
            },
            
            setLineDash: function( dash ) {
              assert && assert( dash !== undefined, 'undefined line dash would cause hard-to-trace errors' );
              if ( this.lineDash !== dash ) {
                this.lineDash = dash;
                if ( this.context.setLineDash ) {
                  this.context.setLineDash( dash === null ? [] : dash ); // see https://github.com/phetsims/scenery/issues/101 for null line-dash workaround
                } else if ( this.context.mozDash !== undefined ) {
                  this.context.mozDash = dash;
                } else if ( this.context.webkitLineDash !== undefined ) {
                  this.context.webkitLineDash = dash ? dash : [];
                } else {
                  // unsupported line dash! do... nothing?
                }
              }
            },
            
            setLineDashOffset: function( lineDashOffset ) {
              if ( this.lineDashOffset !== lineDashOffset ) {
                this.lineDashOffset = lineDashOffset;
                if ( this.context.lineDashOffset !== undefined ) {
                  this.context.lineDashOffset = lineDashOffset;
                } else if ( this.context.webkitLineDashOffset !== undefined ) {
                  this.context.webkitLineDashOffset = lineDashOffset;
                } else {
                  // unsupported line dash! do... nothing?
                }
              }
            },
            
            setFont: function( font ) {
              if ( this.font !== font ) {
                this.font = font;
                this.context.font = font;
              }
            },
            
            setDirection: function( direction ) {
              if ( this.direction !== direction ) {
                this.direction = direction;
                this.context.direction = direction;
              }
            }
          };
          
          return CanvasContextWrapper;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Points to a specific node (with a trail), and whether it is conceptually before or after the node.
         *
         * There are two orderings:
         * - rendering order: the order that node selves would be rendered, matching the Trail implicit order
         * - nesting order:   the order in depth first with entering a node being "before" and exiting a node being "after"
         *
         * TODO: more seamless handling of the orders. or just exclusively use the nesting order
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/util/TrailPointer',['require','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          
          require( 'SCENERY/util/Trail' );
          
          /*
           * isBefore: whether this points to before the node (and its children) have been rendered, or after
           */
          scenery.TrailPointer = function TrailPointer( trail, isBefore ) {
            assert && assert( trail instanceof scenery.Trail, 'trail is not a trail' );
            this.trail = trail;
            
            this.setBefore( isBefore );
            
            phetAllocation && phetAllocation( 'TrailPointer' );
          };
          var TrailPointer = scenery.TrailPointer;
          
          TrailPointer.prototype = {
            constructor: TrailPointer,
            
            copy: function() {
              return new TrailPointer( this.trail.copy(), this.isBefore );
            },
            
            setBefore: function( isBefore ) {
              this.isBefore = isBefore;
              this.isAfter = !isBefore;
            },
            
            // return the equivalent pointer that swaps before and after (may return null if it doesn't exist)
            getRenderSwappedPointer: function() {
              var newTrail = this.isBefore ? this.trail.previous() : this.trail.next();
              
              if ( newTrail === null ) {
                return null;
              } else {
                return new TrailPointer( newTrail, !this.isBefore );
              }
            },
            
            getRenderBeforePointer: function() {
              return this.isBefore ? this : this.getRenderSwappedPointer();
            },
            
            getRenderAfterPointer: function() {
              return this.isAfter ? this : this.getRenderSwappedPointer();
            },
            
            /*
             * In the render order, will return 0 if the pointers are equivalent, -1 if this pointer is before the
             * other pointer, and 1 if this pointer is after the other pointer.
             */
            compareRender: function( other ) {
              assert && assert( other !== null );
              
              var a = this.getRenderBeforePointer();
              var b = other.getRenderBeforePointer();
              
              if ( a !== null && b !== null ) {
                // normal (non-degenerate) case
                return a.trail.compare( b.trail );
              } else {
                // null "before" point is equivalent to the "after" pointer on the last rendered node.
                if ( a === b ) {
                  return 0; // uniqueness guarantees they were the same
                } else {
                  return a === null ? 1 : -1;
                }
              }
            },
            
            /*
             * Like compareRender, but for the nested (depth-first) order
             *
             * TODO: optimization?
             */
            compareNested: function( other ) {
              assert && assert( other );
              
              var comparison = this.trail.compare( other.trail );
              
              if ( comparison === 0 ) {
                // if trails are equal, just compare before/after
                if ( this.isBefore === other.isBefore ) {
                  return 0;
                } else {
                  return this.isBefore ? -1 : 1;
                }
              } else {
                // if one is an extension of the other, the shorter isBefore flag determines the order completely
                if ( this.trail.isExtensionOf( other.trail ) ) {
                  return other.isBefore ? 1 : -1;
                } else if ( other.trail.isExtensionOf( this.trail ) ) {
                  return this.isBefore ? -1 : 1;
                } else {
                  // neither is a subtrail of the other, so a straight trail comparison should give the answer
                  return comparison;
                }
              }
            },
            
            equalsRender: function( other ) {
              return this.compareRender( other ) === 0;
            },
            
            equalsNested: function( other ) {
              return this.compareNested( other ) === 0;
            },
            
            // will return false if this pointer has gone off of the beginning or end of the tree (will be marked with isAfter or isBefore though)
            hasTrail: function() {
              return !!this.trail;
            },
            
            // TODO: refactor with "Side"-like handling
            // moves this pointer forwards one step in the nested order
            nestedForwards: function() {
              if ( this.isBefore ) {
                if ( this.trail.lastNode()._children.length > 0 ) {
                  // stay as before, just walk to the first child
                  this.trail.addDescendant( this.trail.lastNode()._children[0], 0 );
                } else {
                  // stay on the same node, but switch to after
                  this.setBefore( false );
                }
              } else {
                if ( this.trail.indices.length === 0 ) {
                  // nothing else to jump to below, so indicate the lack of existence
                  this.trail = null;
                  // stays isAfter
                  return null;
                } else {
                  var index = this.trail.indices[this.trail.indices.length - 1];
                  this.trail.removeDescendant();
                  
                  if ( this.trail.lastNode()._children.length > index + 1 ) {
                    // more siblings, switch to the beginning of the next one
                    this.trail.addDescendant( this.trail.lastNode()._children[index+1], index + 1 );
                    this.setBefore( true );
                  } else {
                    // no more siblings. exit on parent. nothing else needed since we're already isAfter
                  }
                }
              }
              return this;
            },
            
            // moves this pointer backwards one step in the nested order
            nestedBackwards: function() {
              if ( this.isBefore ) {
                if ( this.trail.indices.length === 0 ) {
                  // jumping off the front
                  this.trail = null;
                  // stays isBefore
                  return null;
                } else {
                  var index = this.trail.indices[this.trail.indices.length - 1];
                  this.trail.removeDescendant();
                  
                  if ( index - 1 >= 0 ) {
                    // more siblings, switch to the beginning of the previous one and switch to isAfter
                    this.trail.addDescendant( this.trail.lastNode()._children[index-1], index - 1 );
                    this.setBefore( false );
                  } else {
                    // no more siblings. enter on parent. nothing else needed since we're already isBefore
                  }
                }
              } else {
                if ( this.trail.lastNode()._children.length > 0 ) {
                  // stay isAfter, but walk to the last child
                  var children = this.trail.lastNode()._children;
                  this.trail.addDescendant( children[children.length-1], children.length - 1 );
                } else {
                  // switch to isBefore, since this is a leaf node
                  this.setBefore( true );
                }
              }
              return this;
            },
            
            // treats the pointer as render-ordered (includes the start pointer 'before' if applicable, excludes the end pointer 'before' if applicable
            eachNodeBetween: function( other, callback ) {
              this.eachTrailBetween( other, function( trail ) {
                return callback( trail.lastNode() );
              } );
            },
            
            // treats the pointer as render-ordered (includes the start pointer 'before' if applicable, excludes the end pointer 'before' if applicable
            eachTrailBetween: function( other, callback ) {
              // this should trigger on all pointers that have the 'before' flag, except a pointer equal to 'other'.
              
              // since we exclude endpoints in the depthFirstUntil call, we need to fire this off first
              if ( this.isBefore ) {
                callback( this.trail );
              }
              
              this.depthFirstUntil( other, function( pointer ) {
                if ( pointer.isBefore ) {
                  return callback( pointer.trail );
                }
              }, true ); // exclude the endpoints so we can ignore the ending 'before' case
            },
            
            /*
             * Recursively (depth-first) iterates over all pointers between this pointer and 'other', calling
             * callback( pointer ) for each pointer. If excludeEndpoints is truthy, the callback will not be
             * called if pointer is equivalent to this pointer or 'other'.
             *
             * If the callback returns a truthy value, the subtree for the current pointer will be skipped
             * (applies only to before-pointers)
             */
            depthFirstUntil: function( other, callback, excludeEndpoints ) {
              // make sure this pointer is before the other, but allow start === end if we are not excluding endpoints
              assert && assert( this.compareNested( other ) <= ( excludeEndpoints ? -1 : 0 ), 'TrailPointer.depthFirstUntil pointers out of order, possibly in both meanings of the phrase!' );
              assert && assert( this.trail.rootNode() === other.trail.rootNode(), 'TrailPointer.depthFirstUntil takes pointers with the same root' );
              
              // sanity check TODO: remove later
              this.trail.reindex();
              other.trail.reindex();
              
              var pointer = this.copy();
              pointer.trail.setMutable(); // this trail will be modified in the iteration, so references to it may be modified
              
              var first = true;
              
              while ( !pointer.equalsNested( other ) ) {
                assert && assert( pointer.compareNested( other ) !== 1, 'skipped in depthFirstUntil' );
                var skipSubtree = false;
                
                if ( first ) {
                  // start point
                  if ( !excludeEndpoints ) {
                    skipSubtree = callback( pointer );
                  }
                  first = false;
                } else {
                  // between point
                  skipSubtree = callback( pointer );
                }
                
                if ( skipSubtree && pointer.isBefore ) {
                  // to skip the subtree, we just change to isAfter
                  pointer.setBefore( false );
                  
                  // if we skip a subtree, make sure we don't run past the ending pointer
                  if ( pointer.compareNested( other ) === 1 ) {
                    break;
                  }
                } else {
                  pointer.nestedForwards();
                }
              }
              
              // end point
              if ( !excludeEndpoints ) {
                callback( pointer );
              }
            },
            
            toString: function() {
              return '[' + ( this.isBefore ? 'before' : 'after' ) + ' ' + this.trail.toString().slice( 1 );
            }
          };
          
          // same as new TrailPointer( trailA, isBeforeA ).compareNested( new TrailPointer( trailB, isBeforeB ) )
          TrailPointer.compareNested = function( trailA, isBeforeA, trailB, isBeforeB ) {
            var comparison = trailA.compare( trailB );
            
            if ( comparison === 0 ) {
              // if trails are equal, just compare before/after
              if ( isBeforeA === isBeforeB ) {
                return 0;
              } else {
                return isBeforeA ? -1 : 1;
              }
            } else {
              // if one is an extension of the other, the shorter isBefore flag determines the order completely
              if ( trailA.isExtensionOf( trailB ) ) {
                return isBeforeB ? 1 : -1;
              } else if ( trailB.isExtensionOf( trailA ) ) {
                return isBeforeA ? -1 : 1;
              } else {
                // neither is a subtrail of the other, so a straight trail comparison should give the answer
                return comparison;
              }
            }
          };
          
          return TrailPointer;
        } );
        
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Feature detection
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/util/Features',['require','SCENERY/scenery'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          
          var Features = scenery.Features = {};
          
          function supportsDataURLFormatOutput( format ) {
            try {
              var canvas = document.createElement( 'canvas' );
              canvas.width = 1;
              canvas.height = 1;
              var context = canvas.getContext( '2d' );
              context.fillStyle = 'black';
              context.fillRect( 0, 0, 1, 1 );
              var url = canvas.toDataURL( [ format ] );
              
              var target = 'data:' + format;
        
              return url.slice( 0, target.length ) === target;
            } catch ( e ) {
              return false;
            }
          }
          
          function supportsDataURLFormatOrigin( name, black1x1Url ) {
            var canvas = document.createElement( 'canvas' );
            canvas.width = 1;
            canvas.height = 1;
            var context = canvas.getContext( '2d' );
            
            var img = document.createElement( 'img' );
            img.crossOrigin = 'Anonymous'; // maybe setting the CORS attribute will help?
            
            var loadCall = function() {
              try {
                context.drawImage( img, 0, 0 );
                canvas.toDataURL();
                Features[name] = true;
              } catch ( e ) {
                Features[name] = false;
              }
            };
            img.onload = loadCall;
            try {
              img.src = black1x1Url;
              if ( img.complete ) {
                loadCall();
              }
            } catch ( e ) {
              Features[name] = false;
            }
          }
          
          function prefixed( name ) {
            var result = [];
            result.push( name );
            
            // prepare for camel case
            name = name.charAt( 0 ).toUpperCase() + name.slice( 1 );
            
            // Chrome planning to not introduce prefixes in the future, hopefully we will be safe
            result.push( 'moz' + name );
            result.push( 'Moz' + name ); // some prefixes seem to have all-caps?
            result.push( 'webkit' + name );
            result.push( 'ms' + name );
            result.push( 'o' + name );
            
            return result;
          }
          
          function detect( obj, names ) {
            for ( var i = 0; i < names.length; i++ ) {
              if ( obj[names[i]] !== undefined ) {
                return names[i];
              }
            }
            return undefined;
          }
          
          Features.canvasPNGOutput = supportsDataURLFormatOutput( 'image/png' );
          Features.canvasJPEGOutput = supportsDataURLFormatOutput( 'image/jpeg' );
          Features.canvasGIFOutput = supportsDataURLFormatOutput( 'image/gif' );
          Features.canvasICONOutput = supportsDataURLFormatOutput( 'image/x-icon' );
          
          // 1x1 black output from Chrome Canvas in PNG
          supportsDataURLFormatOrigin( 'canvasPNGInput', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIW2NkYGD4DwABCQEBtxmN7wAAAABJRU5ErkJggg==' );
          
          // 1x1 black output from Chrome Canvas in JPEG
          supportsDataURLFormatOrigin( 'canvasJPEGInput', 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgICAgMCAgIDAwMDBAYEBAQEBAgGBgUGCQgKCgkICQkKDA8MCgsOCwkJDRENDg8QEBEQCgwSExIQEw8QEBD/2wBDAQMDAwQDBAgEBAgQCwkLEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBD/wAARCAABAAEDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD8qqKKKAP/2Q==' );
          
          /*
           * This is from the following SVG:
           *
           * <?xml version="1.0"?>
           * <svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewport="0 0 1 1" width="1" height="1" >
           *   <rect x="0" y="0" width="1" height="1" rx="0" ry="0" style="fill: black; stroke: none;"></rect>
           * </svg>
           */
          supportsDataURLFormatOrigin( 'canvasSVGInput', 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIj8+DQo8c3ZnIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3cG9ydD0iMCAwIDEgMSIgd2lkdGg9IjEiIGhlaWdodD0iMSIgPg0KICA8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMSIgaGVpZ2h0PSIxIiByeD0iMCIgcnk9IjAiIHN0eWxlPSJmaWxsOiBibGFjazsgc3Ryb2tlOiBub25lOyI+PC9yZWN0Pg0KPC9zdmc+DQo=' );
          
          // 1x1 black output from Photoshop in GIF
          supportsDataURLFormatOrigin( 'canvasGIFInput', 'data:image/gif;base64,R0lGODlhAQABAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAABAAEAAAICRAEAOw==' );
          
          // canvas prefixed names
          var canvas = document.createElement( 'canvas' );
          var ctx = canvas.getContext( '2d' );
          Features.toDataURLHD = detect( canvas, prefixed( 'toDataURLHD' ) );
          Features.createImageDataHD = detect( ctx, prefixed( 'createImageDataHD' ) );
          Features.getImageDataHD = detect( ctx, prefixed( 'getImageDataHD' ) );
          Features.putImageDataHD = detect( ctx, prefixed( 'putImageDataHD' ) );
          Features.currentTransform = detect( ctx, prefixed( 'currentTransform' ) );
          
          var span = document.createElement( 'span' );
          var div = document.createElement( 'div' );
          Features.textStroke = detect( span.style, prefixed( 'textStroke' ) );
          Features.textStrokeColor = detect( span.style, prefixed( 'textStrokeColor' ) );
          Features.textStrokeWidth = detect( span.style, prefixed( 'textStrokeWidth' ) );
          
          Features.transform = detect( div.style, prefixed( 'transform' ) );
          Features.transformOrigin = detect( div.style, prefixed( 'transformOrigin' ) );
          Features.backfaceVisibility = detect( div.style, prefixed( 'backfaceVisibility' ) );
          Features.borderRadius = detect( div.style, prefixed( 'borderRadius' ) );
          
          return Features;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * General utility functions for Scenery
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/util/Util',['require','SCENERY/scenery','DOT/Matrix3','DOT/Transform3','DOT/Bounds2','DOT/Vector2','SCENERY/util/Features'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          
          var Matrix3 = require( 'DOT/Matrix3' );
          var Transform3 = require( 'DOT/Transform3' );
          var Bounds2 = require( 'DOT/Bounds2' );
          var Vector2 = require( 'DOT/Vector2' );
          var Features = require( 'SCENERY/util/Features' );
          
          // convenience function
          function p( x, y ) {
            return new Vector2( x, y );
          }
          
          // TODO: remove flag and tests after we're done
          var debugChromeBoundsScanning = false;
          
          // detect properly prefixed transform and transformOrigin properties
          var transformProperty = Features.transform;
          var transformOriginProperty = Features.transformOrigin || 'transformOrigin'; // fallback, so we don't try to set an empty string property later
          
          scenery.Util = {
            // like _.extend, but with hardcoded support for https://github.com/documentcloud/underscore/pull/986
            extend: function( obj ) {
              _.each( Array.prototype.slice.call( arguments, 1 ), function( source ) {
                if ( source ) {
                  for ( var prop in source ) {
                    Object.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );
                  }
                }
              });
              return obj;
            },
            
            // Object.create polyfill
            objectCreate: Object.create || function ( o ) {
              if ( arguments.length > 1 ) {
                throw new Error( 'Object.create implementation only accepts the first parameter.' );
              }
              function F() {}
        
              F.prototype = o;
              return new F();
            },
            
            applyCSSTransform: function( matrix, element, forceAcceleration ) {
              var transformCSS = matrix.getCSSTransform();
              // notes on triggering hardware acceleration: http://creativejs.com/2011/12/day-2-gpu-accelerate-your-dom-elements/
              
              if ( forceAcceleration ) {
                element.style.webkitBackfaceVisibility = 'hidden';
                transformCSS += ' translateZ(0)';
              }
              
              element.style[transformProperty] = transformCSS;
              element.style[transformOriginProperty] = 'top left'; // TODO: performance: this only needs to be set once!
            },
            
            testAssert: function() {
              return 'assert.basic: ' + ( assert ? 'true' : 'false' );
            },
            
            testAssertExtra: function() {
              return 'assert.slow: ' + ( assertSlow ? 'true' : 'false' );
            },
            
            /*---------------------------------------------------------------------------*
             * window.requestAnimationFrame polyfill, by Erik Moller (http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating)
             * referenced by initial Paul Irish article at http://paulirish.com/2011/requestanimationframe-for-smart-animating/
             *----------------------------------------------------------------------------*/
            polyfillRequestAnimationFrame: function() {
              var lastTime = 0;
              var vendors = [ 'ms', 'moz', 'webkit', 'o' ];
              for ( var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x ) {
                window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
                window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
              }
             
              if ( !window.requestAnimationFrame ) {
                window.requestAnimationFrame = function(callback) {
                  var currTime = new Date().getTime();
                  var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                  var id = window.setTimeout(function() { callback(currTime + timeToCall); },
                    timeToCall);
                  lastTime = currTime + timeToCall;
                  return id;
                };
              }
             
              if ( !window.cancelAnimationFrame ) {
                window.cancelAnimationFrame = function(id) {
                  clearTimeout(id);
                };
              }
            },
            
            backingStorePixelRatio: function( context ) {
              return context.webkitBackingStorePixelRatio ||
                     context.mozBackingStorePixelRatio ||
                     context.msBackingStorePixelRatio ||
                     context.oBackingStorePixelRatio ||
                     context.backingStorePixelRatio || 1;
            },
            
            // see http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html#//apple_ref/doc/uid/TP40010542-CH2-SW5
            // and updated based on http://www.html5rocks.com/en/tutorials/canvas/hidpi/
            backingScale: function ( context ) {
              if ( 'devicePixelRatio' in window ) {
                var backingStoreRatio = Util.backingStorePixelRatio( context );
                
                return window.devicePixelRatio / backingStoreRatio;
              }
              return 1;
            },
            
            // given a data snapshot and transform, calculate range on how large / small the bounds can be
            // very conservative, with an effective 1px extra range to allow for differences in anti-aliasing
            // for performance concerns, this does not support skews / rotations / anything but translation and scaling
            scanBounds: function( imageData, resolution, transform ) {
              
              // entry will be true if any pixel with the given x or y value is non-rgba(0,0,0,0)
              var dirtyX = _.map( _.range( resolution ), function() { return false; } );
              var dirtyY = _.map( _.range( resolution ), function() { return false; } );
              
              for ( var x = 0; x < resolution; x++ ) {
                for ( var y = 0; y < resolution; y++ ) {
                  var offset = 4 * ( y * resolution + x );
                  if ( imageData.data[offset] !== 0 || imageData.data[offset+1] !== 0 || imageData.data[offset+2] !== 0 || imageData.data[offset+3] !== 0 ) {
                    dirtyX[x] = true;
                    dirtyY[y] = true;
                  }
                }
              }
              
              var minX = _.indexOf( dirtyX, true );
              var maxX = _.lastIndexOf( dirtyX, true );
              var minY = _.indexOf( dirtyY, true );
              var maxY = _.lastIndexOf( dirtyY, true );
              
              // based on pixel boundaries. for minBounds, the inner edge of the dirty pixel. for maxBounds, the outer edge of the adjacent non-dirty pixel
              // results in a spread of 2 for the identity transform (or any translated form)
              var extraSpread = resolution / 16; // is Chrome antialiasing really like this? dear god... TODO!!!
              return {
                minBounds: new Bounds2(
                  ( minX < 1 || minX >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( minX + 1 + extraSpread, 0 ) ).x,
                  ( minY < 1 || minY >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( 0, minY + 1 + extraSpread ) ).y,
                  ( maxX < 1 || maxX >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( maxX - extraSpread, 0 ) ).x,
                  ( maxY < 1 || maxY >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( 0, maxY - extraSpread ) ).y
                ),
                maxBounds: new Bounds2(
                  ( minX < 1 || minX >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( minX - 1 - extraSpread, 0 ) ).x,
                  ( minY < 1 || minY >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( 0, minY - 1 - extraSpread ) ).y,
                  ( maxX < 1 || maxX >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( maxX + 2 + extraSpread, 0 ) ).x,
                  ( maxY < 1 || maxY >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( 0, maxY + 2 + extraSpread ) ).y
                )
              };
            },
            
            canvasAccurateBounds: function( renderToContext, options ) {
              // how close to the actual bounds do we need to be?
              var precision = ( options && options.precision ) ? options.precision : 0.001;
              
              // 512x512 default square resolution
              var resolution = ( options && options.resolution ) ? options.resolution : 128;
              
              // at 1/16x default, we want to be able to get the bounds accurately for something as large as 16x our initial resolution
              // divisible by 2 so hopefully we avoid more quirks from Canvas rendering engines
              var initialScale = ( options && options.initialScale ) ? options.initialScale : (1/16);
              
              var minBounds = Bounds2.NOTHING;
              var maxBounds = Bounds2.EVERYTHING;
              
              var canvas = document.createElement( 'canvas' );
              canvas.width = resolution;
              canvas.height = resolution;
              var context = canvas.getContext( '2d' );
              
              if ( debugChromeBoundsScanning ) {
                $( window ).ready( function() {
                  var header = document.createElement( 'h2' );
                  $( header ).text( 'Bounds Scan' );
                  $( '#display' ).append( header );
                } );
              }
              
              function scan( transform ) {
                // save/restore, in case the render tries to do any funny stuff like clipping, etc.
                context.save();
                transform.matrix.canvasSetTransform( context );
                renderToContext( context );
                context.restore();
                
                var data = context.getImageData( 0, 0, resolution, resolution );
                var minMaxBounds = Util.scanBounds( data, resolution, transform );
                
                function snapshotToCanvas( snapshot ) {
                    var canvas = document.createElement( 'canvas' );
                    canvas.width = resolution;
                    canvas.height = resolution;
                    var context = canvas.getContext( '2d' );
                    context.putImageData( snapshot, 0, 0 );
                    $( canvas ).css( 'border', '1px solid black' );
                    $( window ).ready( function() {
                      //$( '#display' ).append( $( document.createElement( 'div' ) ).text( 'Bounds: ' +  ) );
                      $( '#display' ).append( canvas );
                    } );
                  }
                
                // TODO: remove after debug
                if ( debugChromeBoundsScanning ) {
                  snapshotToCanvas( data );
                }
                
                context.clearRect( 0, 0, resolution, resolution );
                
                return minMaxBounds;
              }
              
              // attempts to map the bounds specified to the entire testing canvas (minus a fine border), so we can nail down the location quickly
              function idealTransform( bounds ) {
                // so that the bounds-edge doesn't land squarely on the boundary
                var borderSize = 2;
                
                var scaleX = ( resolution - borderSize * 2 ) / ( bounds.maxX - bounds.minX );
                var scaleY = ( resolution - borderSize * 2 ) / ( bounds.maxY - bounds.minY );
                var translationX = -scaleX * bounds.minX + borderSize;
                var translationY = -scaleY * bounds.minY + borderSize;
                
                return new Transform3( Matrix3.translation( translationX, translationY ).timesMatrix( Matrix3.scaling( scaleX, scaleY ) ) );
              }
              
              var initialTransform = new Transform3( );
              // make sure to initially center our object, so we don't miss the bounds
              initialTransform.append( Matrix3.translation( resolution / 2, resolution / 2 ) );
              initialTransform.append( Matrix3.scaling( initialScale ) );
              
              var coarseBounds = scan( initialTransform );
              
              minBounds = minBounds.union( coarseBounds.minBounds );
              maxBounds = maxBounds.intersection( coarseBounds.maxBounds );
              
              var tempMin, tempMax, refinedBounds;
              
              // minX
              tempMin = maxBounds.minY;
              tempMax = maxBounds.maxY;
              while ( isFinite( minBounds.minX ) && isFinite( maxBounds.minX ) && Math.abs( minBounds.minX - maxBounds.minX ) > precision ) {
                // use maximum bounds except for the x direction, so we don't miss things that we are looking for
                refinedBounds = scan( idealTransform( new Bounds2( maxBounds.minX, tempMin, minBounds.minX, tempMax ) ) );
                
                if ( minBounds.minX <= refinedBounds.minBounds.minX && maxBounds.minX >= refinedBounds.maxBounds.minX ) {
                  // sanity check - break out of an infinite loop!
                  if ( debugChromeBoundsScanning ) {
                    console.log( 'warning, exiting infinite loop!' );
                    console.log( 'transformed "min" minX: ' + idealTransform( new Bounds2( maxBounds.minX, maxBounds.minY, minBounds.minX, maxBounds.maxY ) ).transformPosition2( p( minBounds.minX, 0 ) ) );
                    console.log( 'transformed "max" minX: ' + idealTransform( new Bounds2( maxBounds.minX, maxBounds.minY, minBounds.minX, maxBounds.maxY ) ).transformPosition2( p( maxBounds.minX, 0 ) ) );
                  }
                  break;
                }
                
                minBounds = minBounds.withMinX( Math.min( minBounds.minX, refinedBounds.minBounds.minX ) );
                maxBounds = maxBounds.withMinX( Math.max( maxBounds.minX, refinedBounds.maxBounds.minX ) );
                tempMin = Math.max( tempMin, refinedBounds.maxBounds.minY );
                tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxY );
              }
              
              // maxX
              tempMin = maxBounds.minY;
              tempMax = maxBounds.maxY;
              while ( isFinite( minBounds.maxX ) && isFinite( maxBounds.maxX ) && Math.abs( minBounds.maxX - maxBounds.maxX ) > precision ) {
                // use maximum bounds except for the x direction, so we don't miss things that we are looking for
                refinedBounds = scan( idealTransform( new Bounds2( minBounds.maxX, tempMin, maxBounds.maxX, tempMax ) ) );
                
                if ( minBounds.maxX >= refinedBounds.minBounds.maxX && maxBounds.maxX <= refinedBounds.maxBounds.maxX ) {
                  // sanity check - break out of an infinite loop!
                  if ( debugChromeBoundsScanning ) {
                    console.log( 'warning, exiting infinite loop!' );
                  }
                  break;
                }
                
                minBounds = minBounds.withMaxX( Math.max( minBounds.maxX, refinedBounds.minBounds.maxX ) );
                maxBounds = maxBounds.withMaxX( Math.min( maxBounds.maxX, refinedBounds.maxBounds.maxX ) );
                tempMin = Math.max( tempMin, refinedBounds.maxBounds.minY );
                tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxY );
              }
              
              // minY
              tempMin = maxBounds.minX;
              tempMax = maxBounds.maxX;
              while ( isFinite( minBounds.minY ) && isFinite( maxBounds.minY ) && Math.abs( minBounds.minY - maxBounds.minY ) > precision ) {
                // use maximum bounds except for the y direction, so we don't miss things that we are looking for
                refinedBounds = scan( idealTransform( new Bounds2( tempMin, maxBounds.minY, tempMax, minBounds.minY ) ) );
                
                if ( minBounds.minY <= refinedBounds.minBounds.minY && maxBounds.minY >= refinedBounds.maxBounds.minY ) {
                  // sanity check - break out of an infinite loop!
                  if ( debugChromeBoundsScanning ) {
                    console.log( 'warning, exiting infinite loop!' );
                  }
                  break;
                }
                
                minBounds = minBounds.withMinY( Math.min( minBounds.minY, refinedBounds.minBounds.minY ) );
                maxBounds = maxBounds.withMinY( Math.max( maxBounds.minY, refinedBounds.maxBounds.minY ) );
                tempMin = Math.max( tempMin, refinedBounds.maxBounds.minX );
                tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxX );
              }
              
              // maxY
              tempMin = maxBounds.minX;
              tempMax = maxBounds.maxX;
              while ( isFinite( minBounds.maxY ) && isFinite( maxBounds.maxY ) && Math.abs( minBounds.maxY - maxBounds.maxY ) > precision ) {
                // use maximum bounds except for the y direction, so we don't miss things that we are looking for
                refinedBounds = scan( idealTransform( new Bounds2( tempMin, minBounds.maxY, tempMax, maxBounds.maxY ) ) );
                
                if ( minBounds.maxY >= refinedBounds.minBounds.maxY && maxBounds.maxY <= refinedBounds.maxBounds.maxY ) {
                  // sanity check - break out of an infinite loop!
                  if ( debugChromeBoundsScanning ) {
                    console.log( 'warning, exiting infinite loop!' );
                  }
                  break;
                }
                
                minBounds = minBounds.withMaxY( Math.max( minBounds.maxY, refinedBounds.minBounds.maxY ) );
                maxBounds = maxBounds.withMaxY( Math.min( maxBounds.maxY, refinedBounds.maxBounds.maxY ) );
                tempMin = Math.max( tempMin, refinedBounds.maxBounds.minX );
                tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxX );
              }
              
              if ( debugChromeBoundsScanning ) {
                console.log( 'minBounds: ' + minBounds );
                console.log( 'maxBounds: ' + maxBounds );
              }
              
              var result = new Bounds2(
                ( minBounds.minX + maxBounds.minX ) / 2,
                ( minBounds.minY + maxBounds.minY ) / 2,
                ( minBounds.maxX + maxBounds.maxX ) / 2,
                ( minBounds.maxY + maxBounds.maxY ) / 2
              );
              
              // extra data about our bounds
              result.minBounds = minBounds;
              result.maxBounds = maxBounds;
              result.isConsistent = maxBounds.containsBounds( minBounds );
              result.precision = Math.max(
                Math.abs( minBounds.minX - maxBounds.minX ),
                Math.abs( minBounds.minY - maxBounds.minY ),
                Math.abs( minBounds.maxX - maxBounds.maxX ),
                Math.abs( minBounds.maxY - maxBounds.maxY )
              );
              
              // return the average
              return result;
            }
          };
          var Util = scenery.Util;
          
          return Util;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * A Canvas-backed layer in the scene graph. Each layer handles dirty-region handling separately,
         * and corresponds to a single canvas / svg element / DOM element in the main container.
         * Importantly, it does not contain rendered content from a subtree of the main
         * scene graph. It only will render a contiguous block of nodes visited in a depth-first
         * manner.
         *
         * Backing store pixel ratio info: http://www.html5rocks.com/en/tutorials/canvas/hidpi/
         *
         * TODO: update internal documentation
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/layers/CanvasLayer',['require','PHET_CORE/inherit','DOT/Bounds2','SCENERY/scenery','KITE/Shape','SCENERY/layers/Layer','SCENERY/util/CanvasContextWrapper','SCENERY/util/Trail','SCENERY/util/TrailPointer','SCENERY/util/Util'],function( require ) {
          
          
          var inherit = require( 'PHET_CORE/inherit' );
          var Bounds2 = require( 'DOT/Bounds2' );
          
          var scenery = require( 'SCENERY/scenery' );
          
          var Shape = require( 'KITE/Shape' );
          
          var Layer = require( 'SCENERY/layers/Layer' ); // uses Layer's prototype for inheritance
          require( 'SCENERY/util/CanvasContextWrapper' );
          require( 'SCENERY/util/Trail' );
          require( 'SCENERY/util/TrailPointer' );
          require( 'SCENERY/util/Util' );
          
          // stores CanvasContextWrappers to be re-used
          var canvasContextPool = [];
          
          // assumes main is wrapped with JQuery
          /*
           *
           */
          scenery.CanvasLayer = function CanvasLayer( args ) {
            sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' constructor' );
            Layer.call( this, args );
            
            // TODO: deprecate Scene's backing scale, and handle this on a layer-by-layer option?
            this.backingScale = args.scene.backingScale;
            if ( args.fullResolution !== undefined ) {
              this.backingScale = args.fullResolution ? scenery.Util.backingScale( document.createElement( 'canvas' ).getContext( '2d' ) ) : 1;
            }
            
            this.logicalWidth = this.scene.sceneBounds.width;
            this.logicalHeight = this.scene.sceneBounds.height;
            
            var canvas = document.createElement( 'canvas' );
            canvas.width = this.logicalWidth * this.backingScale;
            canvas.height = this.logicalHeight * this.backingScale;
            canvas.style.width = this.logicalWidth + 'px';
            canvas.style.height = this.logicalHeight + 'px';
            canvas.style.position = 'absolute';
            canvas.style.left = '0';
            canvas.style.top = '0';
            
            // add this layer on top (importantly, the constructors of the layers are called in order)
            this.$main.append( canvas );
            
            this.canvas = canvas;
            // this.context = new DebugContext( canvas.getContext( '2d' ) );
            this.context = canvas.getContext( '2d' );
            this.scene = args.scene;
            
            // workaround for Chrome (WebKit) miterLimit bug: https://bugs.webkit.org/show_bug.cgi?id=108763
            this.context.miterLimit = 20;
            this.context.miterLimit = 10;
            
            this.isCanvasLayer = true;
            
            this.wrapper = new scenery.CanvasContextWrapper( this.canvas, this.context );
            
            this.boundlessCount = 0; // count of how many trails do not support bounds. we only will use dirty region repainting if this number is 0.
          };
          var CanvasLayer = scenery.CanvasLayer;
          
          inherit( Layer, CanvasLayer, {
            
            /*
             * Renders the canvas layer from the scene
             *
             * Supported args: {
             *   fullRender: true, // disables drawing to just dirty rectangles
             *   TODO: pruning with bounds and flag to disable
             * }
             */
            render: function( scene, args ) {
              args = args || {};
              
              var dirtyBoundsEnabled = this.canUseDirtyRegions() && !args.fullRender;
              
              // bail out quickly if possible
              if ( dirtyBoundsEnabled && this.dirtyBounds.isEmpty() ) {
                return;
              }
              
              // switch to an identity transform
              this.context.setTransform( this.backingScale, 0, 0, this.backingScale, 0, 0 );
              
              var visibleDirtyBounds = dirtyBoundsEnabled ? this.dirtyBounds.intersection( scene.sceneBounds ) : scene.sceneBounds;
              
              if ( !visibleDirtyBounds.isEmpty() ) {
                this.clearGlobalBounds( visibleDirtyBounds );
                
                if ( dirtyBoundsEnabled ) {
                  this.pushClipShape( Shape.bounds( visibleDirtyBounds ) );
                }
                
                // dirty bounds (clear, possibly set restricted bounds and handling for that)
                // visibility checks
                this.recursiveRender( scene, args );
                
                // exists for now so that we pop the necessary context state
                if ( dirtyBoundsEnabled ) {
                  this.popClipShape();
                }
              }
              
              // we rendered everything, no more dirty bounds
              this.dirtyBounds = Bounds2.NOTHING;
            },
            
            recursiveRender: function( scene, args ) {
              var layer = this;
              var i;
              var startPointer = new scenery.TrailPointer( this.startPaintedTrail, true );
              var endPointer = new scenery.TrailPointer( this.endPaintedTrail, true );
              
              // stack for canvases that need to be painted, since some effects require scratch canvases
              var wrapperStack = [ this.wrapper ]; // type {CanvasContextWrapper}
              this.wrapper.resetStyles(); // let's be defensive, save() and restore() may have been called previously
              
              function requiresScratchCanvas( trail ) {
                return trail.lastNode().getOpacity() < 1;
              }
              
              function getCanvasWrapper() {
                var width = layer.logicalWidth * layer.backingScale;
                var height = layer.logicalHeight * layer.backingScale;
                
                if ( canvasContextPool.length ) {
                  // use a pooled wrapper
                  var wrapper = canvasContextPool.pop();
                  wrapper.setDimensions( width, height );
                  return wrapper;
                } else {
                  // create a new wrapper
                  var canvas = document.createElement( 'canvas' );
                  canvas.width = layer.logicalWidth * layer.backingScale;
                  canvas.height = layer.logicalHeight * layer.backingScale;
                  var context = canvas.getContext( '2d' );
                  
                  return new scenery.CanvasContextWrapper( canvas, context );
                }
              }
              
              function topWrapper() {
                return wrapperStack[wrapperStack.length-1];
              }
              
              function enter( trail ) {
                var node = trail.lastNode();
                
                if ( requiresScratchCanvas( trail ) ) {
                  var wrapper = getCanvasWrapper();
                  wrapperStack.push( wrapper );
                  
                  var newContext = wrapper.context;
                  
                  // switch to an identity transform
                  newContext.setTransform( layer.backingScale, 0, 0, layer.backingScale, 0, 0 );
                  
                  // properly set the necessary transform on the context
                  var length = trail.nodes.length;
                  for ( var i = 0; i < length; i++ ) {
                    trail.nodes[i].transform.getMatrix().canvasAppendTransform( newContext );
                  }
                } else {
                  node.transform.getMatrix().canvasAppendTransform( topWrapper().context );
                }
                
                if ( node._clipArea ) {
                  // TODO: move to wrapper-specific part
                  layer.pushClipShape( node._clipArea );
                }
              }
              
              function exit( trail ) {
                var node = trail.lastNode();
                
                if ( node._clipArea ) {
                  // TODO: move to wrapper-specific part
                  layer.popClipShape();
                }
                
                if ( requiresScratchCanvas( trail ) ) {
                  var baseContext = wrapperStack[wrapperStack.length-2].context;
                  var topCanvas = wrapperStack[wrapperStack.length-1].canvas;
                  
                  // apply necessary style transforms before painting our popped canvas onto the next canvas
                  var opacityChange = trail.lastNode().getOpacity() < 1;
                  if ( opacityChange ) {
                    baseContext.globalAlpha = trail.lastNode().getOpacity();
                  }
                  
                  // paint our canvas onto the level below with a straight transform
                  baseContext.save();
                  baseContext.setTransform( 1, 0, 0, 1, 0, 0 );
                  baseContext.drawImage( topCanvas, 0, 0 );
                  baseContext.restore();
                  
                  // reset styles
                  if ( opacityChange ) {
                    baseContext.globalAlpha = 1;
                  }
                  
                  var wrapper = wrapperStack.pop();
                  if ( wrapper !== layer.wrapper ) {
                    // store the CanvasContextWrapper for recycling if it isn't our core wrapper
                    canvasContextPool.push( wrapper );
                  }
                } else {
                  node.transform.getInverse().canvasAppendTransform( topWrapper().context );
                }
              }
              
              /*
               * We count how many invisible nodes are in our trail, so we can properly iterate without inspecting everything.
               * Additionally, state changes (enter/exit) are only done when nodes are visible, so we skip overhead. If
               * invisibleCount > 0, then the current node is invisible.
               */
              var invisibleCount = 0;
              
              var boundaryTrail;
              
              // sanity check, and allows us to get faster speed
              startPointer.trail.reindex();
              endPointer.trail.reindex();
              
              // first, we need to walk the state up to before our pointer (as far as the recursive handling is concerned)
              // if the pointer is 'before' the node, don't call its enterState since this will be taken care of as the first step.
              // if the pointer is 'after' the node, call enterState since it will call exitState immediately inside the loop
              var startWalkLength = startPointer.trail.length - ( startPointer.isBefore ? 1 : 0 );
              boundaryTrail = new scenery.Trail();
              for ( i = 0; i < startWalkLength; i++ ) {
                var startNode = startPointer.trail.nodes[i];
                boundaryTrail.addDescendant( startNode );
                invisibleCount += startNode.isVisible() ? 0 : 1;
                
                if ( invisibleCount === 0 ) {
                  // walk up initial state
                  enter( boundaryTrail );
                }
              }
              
              startPointer.depthFirstUntil( endPointer, function renderPointer( pointer ) {
                // handle render here
                
                var node = pointer.trail.lastNode();
                
                if ( pointer.isBefore ) {
                  invisibleCount += node.isVisible() ? 0 : 1;
                  
                  if ( invisibleCount === 0 ) {
                    enter( pointer.trail );
                    
                    if ( node.isPainted() ) {
                      var wrapper = wrapperStack[wrapperStack.length-1];
                      
                      // TODO: consider just passing the wrapper. state not needed (for now), context easily accessible
                      node.paintCanvas( wrapper );
                    }
                    
                    // TODO: restricted bounds rendering, and possibly generalize depthFirstUntil
                    // var children = node._children;
                    
                    // check if we need to filter the children we render, and ignore nodes with few children (but allow 2, since that may prevent branches)
                    // if ( state.childRestrictedBounds && children.length > 1 ) {
                    //   var localRestrictedBounds = node.globalToLocalBounds( state.childRestrictedBounds );
                      
                    //   // don't filter if every child is inside the bounds
                    //   if ( !localRestrictedBounds.containsBounds( node.parentToLocalBounds( node._bounds ) ) ) {
                    //     children = node.getChildrenWithinBounds( localRestrictedBounds );
                    //   }
                    // }
                    
                    // _.each( children, function( child ) {
                    //   fullRender( child, state );
                    // } );
                  } else {
                    // not visible, so don't render the entire subtree
                    return true;
                  }
                } else {
                  if ( invisibleCount === 0 ) {
                    exit( pointer.trail );
                  }
                  
                  invisibleCount -= node.isVisible() ? 0 : 1;
                }
                
              }, false ); // include endpoints (for now)
              
              // then walk the state back so we don't muck up any context saving that is going on, similar to how we walked it at the start
              // if the pointer is 'before' the node, call exitState since it called enterState inside the loop on it
              // if the pointer is 'after' the node, don't call its exitState since this was already done
              boundaryTrail = endPointer.trail.copy();
              var endWalkLength = endPointer.trail.length - ( endPointer.isAfter ? 1 : 0 );
              for ( i = endWalkLength - 1; i >= 0; i-- ) {
                var endNode = endPointer.trail.nodes[i];
                invisibleCount -= endNode.isVisible() ? 0 : 1;
                
                if ( invisibleCount === 0 ) {
                  // walk back the state
                  exit( boundaryTrail );
                }
                
                boundaryTrail.removeDescendant();
              }
            },
            
            dispose: function() {
              Layer.prototype.dispose.call( this );
              
              this.canvas.parentNode.removeChild( this.canvas );
            },
            
            // TODO: consider a stack-based model for transforms?
            applyTransformationMatrix: function( matrix ) {
              matrix.canvasAppendTransform( this.context );
            },
            
            // returns next zIndex in place. allows layers to take up more than one single zIndex
            reindex: function( zIndex ) {
              Layer.prototype.reindex.call( this, zIndex );
              
              if ( this.zIndex !== zIndex ) {
                this.canvas.style.zIndex = zIndex;
                this.zIndex = zIndex;
              }
              return zIndex + 1;
            },
            
            pushClipShape: function( shape ) {
              // store the current state, since browser support for context.resetClip() is not yet in the stable browser versions
              this.context.save();
              
              this.writeClipShape( shape );
            },
            
            popClipShape: function() {
              this.context.restore();
            },
            
            // canvas-specific
            writeClipShape: function( shape ) {
              // set up the clipping
              this.context.beginPath();
              shape.writeToContext( this.context );
              this.context.clip();
            },
            
            clearGlobalBounds: function( bounds ) {
              if ( !bounds.isEmpty() ) {
                this.context.save();
                this.context.setTransform( this.backingScale, 0, 0, this.backingScale, 0, 0 );
                this.context.clearRect( bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight() );
                // use this for debugging cleared (dirty) regions for now
                // this.context.fillStyle = '#' + Math.floor( Math.random() * 0xffffff ).toString( 16 );
                // this.context.fillRect( bounds.x, bounds.y, bounds.width, bounds.height );
                this.context.restore();
              }
            },
            
            getSVGString: function() {
              return '<image xmlns:xlink="' + scenery.xlinkns + '" xlink:href="' + this.canvas.toDataURL() + '" x="0" y="0" height="' + this.canvas.height + 'px" width="' + this.canvas.width + 'px"/>';
            },
            
            // TODO: note for DOM we can do https://developer.mozilla.org/en-US/docs/HTML/Canvas/Drawing_DOM_objects_into_a_canvas
            renderToCanvas: function( canvas, context, delayCounts ) {
              context.drawImage( this.canvas, 0, 0 );
            },
            
            addInstance: function( instance ) {
              var trail = instance.trail;
              
              sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' addInstance: ' + trail.toString() );
              Layer.prototype.addInstance.call( this, instance );
              
              // since the node's getBounds() are in the parent coordinate frame, we peel off the last node to get the correct (relevant) transform
              // TODO: more efficient way of getting this transform?
              this.canvasMarkLocalBounds( trail.lastNode().getBounds(), trail.slice( 0, trail.length - 1 ) );
              
              if ( trail.lastNode().boundsInaccurate ) {
                this.boundlessCount++;
              }
            },
            
            removeInstance: function( instance ) {
              var trail = instance.trail;
              
              sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' removeInstance: ' + trail.toString() );
              Layer.prototype.removeInstance.call( this, instance );
              
              // since the node's getBounds() are in the parent coordinate frame, we peel off the last node to get the correct (relevant) transform
              // TODO: more efficient way of getting this transform?
              this.canvasMarkLocalBounds( trail.lastNode().getBounds(), trail.slice( 0, trail.length - 1 ) );
              
              if ( trail.lastNode().boundsInaccurate ) {
                this.boundlessCount--;
              }
            },
            
            canUseDirtyRegions: function() {
              assert && assert( this.boundlessCount >= 0 );
              return this.boundlessCount === 0;
            },
            
            // NOTE: for performance, we will mutate the bounds passed in (they are almost assuredly from the local or parent bounds functions)
            canvasMarkGlobalBounds: function( globalBounds ) {
              sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' canvasMarkGlobalBounds: ' + globalBounds.toString() );
              assert && assert( globalBounds.isEmpty() || globalBounds.isFinite(), 'Infinite (non-empty) dirty bounds passed to canvasMarkGlobalBounds' );
              
              // TODO: for performance, consider more than just a single dirty bounding box
              this.dirtyBounds = this.dirtyBounds.union( globalBounds.dilate( 2 ).roundOut() );
            },
            
            canvasMarkLocalBounds: function( localBounds, trail ) {
              sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' canvasMarkLocalBounds: ' + localBounds.toString() + ' on ' + trail.toString() );
              if ( !this.canUseDirtyRegions() ) {
                this.dirtyBounds = Bounds2.EVERYTHING;
              } else {
                this.canvasMarkGlobalBounds( trail.localToGlobalBounds( localBounds ) );
              }
            },
            
            canvasMarkParentBounds: function( parentBounds, trail ) {
              sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' canvasMarkParentBounds: ' + parentBounds.toString() + ' on ' + trail.toString() );
              if ( !this.canUseDirtyRegions() ) {
                this.dirtyBounds = Bounds2.EVERYTHING;
              } else {
                this.canvasMarkGlobalBounds( trail.parentToGlobalBounds( parentBounds ) );
              }
            },
            
            canvasMarkSelf: function( instance ) {
              this.canvasMarkLocalBounds( instance.getNode().getSelfBounds(), instance.trail );
            },
            
            canvasMarkSubtree: function( instance ) {
              this.canvasMarkParentBounds( instance.getNode().getBounds(), instance.trail );
            },
            
            getName: function() {
              return 'canvas';
            },
            
            /*---------------------------------------------------------------------------*
            * Events from Instances
            *----------------------------------------------------------------------------*/
            
            notifyVisibilityChange: function( instance ) {
              sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyVisibilityChange: ' + instance.trail.toString() );
              // old paint taken care of in notifyBeforeSubtreeChange()
              
              if ( instance.trail.isVisible() ) {
                this.canvasMarkSubtree( instance );
              }
            },
            
            notifyOpacityChange: function( instance ) {
              sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyOpacityChange: ' + instance.trail.toString() );
              // old paint taken care of in notifyBeforeSubtreeChange()
              
              this.canvasMarkSubtree( instance );
            },
            
            notifyClipChange: function( instance ) {
              sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyClipChange: ' + instance.trail.toString() );
              // old paint taken care of in notifyBeforeSubtreeChange()
              
              this.canvasMarkSubtree( instance );
            },
            
            // only a painted trail under this layer
            notifyBeforeSelfChange: function( instance ) {
              sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyBeforeSelfChange: ' + instance.trail.toString() );
              this.canvasMarkSelf( instance );
            },
            
            notifyBeforeSubtreeChange: function( instance ) {
              sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyBeforeSubtreeChange: ' + instance.trail.toString() );
              this.canvasMarkSubtree( instance );
            },
            
            // only a painted trail under this layer
            notifyDirtySelfPaint: function( instance ) {
              sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyDirtySelfPaint: ' + instance.trail.toString() );
              this.canvasMarkSelf( instance );
            },
            
            notifyDirtySubtreePaint: function( instance ) {
              sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyDirtySubtreePaint: ' + instance.trail.toString() );
              this.canvasMarkSubtree( instance );
            },
            
            notifyTransformChange: function( instance ) {
              // sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyTransformChange: ' + instance.trail.toString() );
              // TODO: how best to mark this so if there are multiple 'movements' we don't get called more than needed?
              // this.canvasMarkSubtree( instance );
            },
            
            // only a painted trail under this layer (for now)
            notifyBoundsAccuracyChange: function( instance ) {
              sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyBoundsAccuracyChange: ' + instance.trail.toString() );
              
              if ( instance.node.boundsInaccurate ) {
                this.boundlessCount++;
              } else {
                this.boundlessCount--;
              }
            }
          } );
          
          return CanvasLayer;
        } );
        
        
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * A DOM-based layer in the scene graph. Each layer handles dirty-region handling separately,
         * and corresponds to a single canvas / svg element / DOM element in the main container.
         * Importantly, it does not contain rendered content from a subtree of the main
         * scene graph. It only will render a contiguous block of nodes visited in a depth-first
         * manner.
         *
         * Nodes supporting the DOM renderer should have the following functions:
         *   allowsMultipleDOMInstances:               {Boolean} whether getDOMElement will return the same element every time, or new elements.
         *   getDOMElement():                          Returns a DOM element that represents this node.
         *   updateDOMElement( element ):              Updates the DOM element with any changes that were made.
         *   updateCSSTransform( transform, element ): Updates the CSS transform of the element
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/layers/DOMLayer',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/layers/Layer','SCENERY/util/Trail'],function( require ) {
          
          
          var inherit = require( 'PHET_CORE/inherit' );
        
          var scenery = require( 'SCENERY/scenery' );
          
          var Layer = require( 'SCENERY/layers/Layer' ); // DOMLayer inherits from Layer
          require( 'SCENERY/util/Trail' );
          
          scenery.DOMLayer = function DOMLayer( args ) {
            sceneryLayerLog && sceneryLayerLog( 'DOMLayer constructor' );
            
            Layer.call( this, args );
            
            var width = args.scene.sceneBounds.width;
            var height = args.scene.sceneBounds.height;
            
            this.div = document.createElement( 'div' );
            var div = this.div;
            div.style.position = 'absolute';
            div.style.left = '0';
            div.style.top = '0';
            div.style.width = '0';
            div.style.height = '0';
            div.style.clip = 'rect(0px,' + width + 'px,' + height + 'px,0px)';
            this.$div = $( this.div );
            this.$main.append( this.div );
            
            this.scene = args.scene; // TODO: should already be set in the supertype Layer
            
            this.isDOMLayer = true;
            
            // maps trail ID => DOM element fragment
            this.idElementMap = {};
            
            // maps trail ID => Trail. trails need to be reindexed
            this.idTrailMap = {};
            
            this.trails = [];
          };
          var DOMLayer = scenery.DOMLayer;
          
          inherit( Layer, DOMLayer, {
            
            addInstance: function( instance ) {
              Layer.prototype.addInstance.call( this, instance );
              
              var trail = instance.trail;
              this.reindexTrails();
              
              var node = trail.lastNode();
              
              var element = node.getDOMElement();
              node.updateDOMElement( element );
              this.updateVisibility( trail, element );
              
              this.idElementMap[trail.getUniqueId()] = element;
              this.idTrailMap[trail.getUniqueId()] = trail;
              
              // walk the insertion index up the array. TODO: performance: binary search version?
              var insertionIndex;
              for ( insertionIndex = 0; insertionIndex < this.trails.length; insertionIndex++ ) {
                var otherTrail = this.trails[insertionIndex];
                otherTrail.reindex();
                var comparison = otherTrail.compare( trail );
                assert && assert( comparison !== 0, 'Trail has already been inserted into the DOMLayer' );
                if ( comparison === 1 ) { // TODO: enum values!
                  break;
                }
              }
              
              if ( insertionIndex === this.div.childNodes.length ) {
                this.div.appendChild( element );
                this.trails.push( trail );
              } else {
                this.div.insertBefore( this.getElementFromTrail( this.trails[insertionIndex] ) );
                this.trails.splice( insertionIndex, 0, trail );
              }
              node.updateCSSTransform( trail.getTransform(), element );
            },
            
            removeInstance: function( instance ) {
              Layer.prototype.removeInstance.call( this, instance );
              
              var trail = instance.trail;
              this.reindexTrails();
              
              var element = this.getElementFromTrail( trail );
              assert && assert( element, 'Trail does not exist in the DOMLayer' );
              
              delete this.idElementMap[trail.getUniqueId];
              delete this.idTrailMap[trail.getUniqueId];
              
              this.div.removeChild( element );
              
              var removalIndex = this.getIndexOfTrail( trail );
              this.trails.splice( removalIndex, 1 );
            },
            
            getElementFromTrail: function( trail ) {
              return this.idElementMap[trail.getUniqueId()];
            },
            
            reindexTrails: function( zIndex ) {
              Layer.prototype.reindex.call( this, zIndex );
              
              var i = this.trails.length;
              while ( i-- ) {
                this.trails[i].reindex();
              }
            },
            
            getIndexOfTrail: function( trail ) {
              // find the index where our trail is at. strict equality won't work, we want to compare differently
              var i;
              for ( i = 0; i < this.trails.length; i++ ) {
                if ( this.trails[i].compare( trail ) === 0 ) {
                  return i;
                }
              }
              throw new Error( 'DOMLayer.getIndexOfTrail unable to find trail: ' + trail.toString() );
            },
            
            render: function( scene, args ) {
              // nothing at all needed here, CSS transforms taken care of when dirty regions are notified
            },
            
            dispose: function() {
              Layer.prototype.dispose.call( this );
              
              this.div.parentNode.removeChild( this.div );
            },
            
            updateVisibility: function( trail, element ) {
              if ( trail.isVisible() ) {
                element.style.visibility = 'visible';
              } else {
                element.style.visibility = 'hidden';
              }
            },
            
            // TODO: consider a stack-based model for transforms?
            // TODO: deprecated? remove this?
            applyTransformationMatrix: function( matrix ) {
              // nothing at all needed here
            },
            
            getContainer: function() {
              return this.div;
            },
            
            // returns next zIndex in place. allows layers to take up more than one single zIndex
            reindex: function( zIndex ) {
              Layer.prototype.reindex.call( this, zIndex );
              
              if ( this.zIndex !== zIndex ) {
                this.div.style.zIndex = zIndex;
                this.zIndex = zIndex;
              }
              return zIndex + 1;
            },
            
            pushClipShape: function( shape ) {
              // TODO: clipping
            },
            
            popClipShape: function() {
              // TODO: clipping
            },
            
            getSVGString: function() {
              return "<svg xmlns='" + scenery.svgns + "' width='" + this.$main.width() + "' height='" + this.$main.height() + "'>" +
                "<foreignObject width='100%' height='100%'>" +
                $( this.div ).html() +
                "</foreignObject></svg>";
            },
            
            // TODO: note for DOM we can do https://developer.mozilla.org/en-US/docs/HTML/Canvas/Drawing_DOM_objects_into_a_canvas
            // TODO: note that http://pbakaus.github.com/domvas/ may work better, but lacks IE support
            renderToCanvas: function( canvas, context, delayCounts ) {
              // TODO: consider not silently failing?
              // var data = "<svg xmlns='" + scenery.svgns + "' width='" + this.$main.width() + "' height='" + this.$main.height() + "'>" +
              //   "<foreignObject width='100%' height='100%'>" +
              //   $( this.div ).html() +
              //   "</foreignObject></svg>";
              
              // var DOMURL = window.URL || window.webkitURL || window;
              // var img = new Image();
              // var svg = new Blob( [ data ] , { type: "image/svg+xml;charset=utf-8" } );
              // var url = DOMURL.createObjectURL( svg );
              // delayCounts.increment();
              // img.onload = function() {
              //   context.drawImage( img, 0, 0 );
              //   // TODO: this loading is delayed!!! ... figure out a solution to potentially delay?
              //   DOMURL.revokeObjectURL( url );
              //   delayCounts.decrement();
              // };
              // img.src = url;
            },
            
            getName: function() {
              return 'dom';
            },
            
            /*---------------------------------------------------------------------------*
            * Events from Instances
            *----------------------------------------------------------------------------*/
            
            notifyVisibilityChange: function( instance ) {
              sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyVisibilityChange: ' + instance.trail.toString() );
              var trail = instance.trail;
              
              // TODO: performance: faster way to iterate through!
              for ( var trailId in this.idTrailMap ) {
                var subtrail = this.idTrailMap[trailId];
                subtrail.reindex();
                if ( subtrail.isExtensionOf( trail, true ) ) {
                  this.updateVisibility( subtrail, this.idElementMap[trailId] );
                }
              }
            },
            
            notifyOpacityChange: function( instance ) {
              sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyOpacityChange: ' + instance.trail.toString() );
              // TODO: BROKEN: FIXME: DOM opacity is not handled yet, see issue #31: https://github.com/phetsims/scenery/issues/31
            },
            
            notifyClipChange: function( instance ) {
              sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyClipChange: ' + instance.trail.toString() );
              // TODO: BROKEN: FIXME: DOM clipping is not handled, see issue #31: https://github.com/phetsims/scenery/issues/31
            },
            
            // only a painted trail under this layer
            notifyBeforeSelfChange: function( instance ) {
              // sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyBeforeSelfChange: ' + instance.trail.toString() );
              // no-op, we don't need paint changes
            },
            
            notifyBeforeSubtreeChange: function( instance ) {
              // sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyBeforeSubtreeChange: ' + instance.trail.toString() );
              // no-op, we don't need paint changes
            },
            
            // only a painted trail under this layer
            notifyDirtySelfPaint: function( instance ) {
              sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyDirtySelfPaint: ' + instance.trail.toString() );
              var node = instance.getNode();
              var trail = instance.trail;
              
              // TODO: performance: store this in the Instance itself?
              var dirtyElement = this.idElementMap[trail.getUniqueId()];
              if ( dirtyElement ) {
                node.updateDOMElement( dirtyElement );
                
                if ( node.domUpdateTransformOnRepaint ) {
                  node.updateCSSTransform( trail.getTransform(), dirtyElement );
                }
              }
            },
        
            notifyDirtySubtreePaint: function( instance ) {
              if ( instance.layer === this ) {
                this.notifyDirtySelfPaint( instance );
              }
            },
            
            notifyTransformChange: function( instance ) {
              sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyTransformChange: ' + instance.trail.toString() );
              var layer = this;
              
              var baseTrail = instance.trail;
              
              // TODO: performance: efficiency! this computes way more matrix transforms than needed
              scenery.Trail.eachPaintedTrailBetween( this.startPaintedTrail, this.endPaintedTrail, function( trail ) {
                if ( trail.isExtensionOf( baseTrail, true ) ) {
                  // TODO: put the element on the instance?
                  var element = layer.idElementMap[trail.getUniqueId()];
                  var node = trail.lastNode();
                  node.updateCSSTransform( trail.getTransform(), element );
                }
              }, false, this.scene );
            },
            
            // only a painted trail under this layer (for now)
            notifyBoundsAccuracyChange: function( instance ) {
              // sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyBoundsAccuracyChange: ' + instance.trail.toString() );
              // no-op, we don't care about bounds
            }
            
          } );
          
          return DOMLayer;
        } );
        
        
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * An SVG-based layer in the scene graph. Each layer handles dirty-region handling separately,
         * and corresponds to a single canvas / svg element / DOM element in the main container.
         * Importantly, it does not contain rendered content from a subtree of the main
         * scene graph. It only will render a contiguous block of nodes visited in a depth-first
         * manner.
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/layers/SVGLayer',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Transform3','DOT/Matrix3','SCENERY/scenery','SCENERY/layers/Layer','SCENERY/util/Trail','SCENERY/util/Util'],function( require ) {
          
          
          var inherit = require( 'PHET_CORE/inherit' );
          var Bounds2 = require( 'DOT/Bounds2' );
          var Transform3 = require( 'DOT/Transform3' );
          var Matrix3 = require( 'DOT/Matrix3' );
          
          var scenery = require( 'SCENERY/scenery' );
          
          var Layer = require( 'SCENERY/layers/Layer' ); // extends Layer
          require( 'SCENERY/util/Trail' );
          require( 'SCENERY/util/Util' );
          
          scenery.SVGLayer = function SVGLayer( args ) {
            sceneryLayerLog && sceneryLayerLog( 'SVGLayer constructor' );
            var $main = args.$main;
            
            this.scene = args.scene;
            
            // main SVG element
            this.svg = document.createElementNS( scenery.svgns, 'svg' );
            
            // the SVG has a single group under it, which corresponds to the transform of the layer's base node
            // TODO: consider renaming to 'this.baseGroup'
            this.g = document.createElementNS( scenery.svgns, 'g' );
            
            // the <defs> block that we will be stuffing gradients and patterns into
            this.defs = document.createElementNS( scenery.svgns, 'defs' );
            
            var width = args.scene.sceneBounds.width;
            var height = args.scene.sceneBounds.height;
            
            this.svg.appendChild( this.defs );
            this.svg.appendChild( this.g );
            this.$svg = $( this.svg );
            this.svg.setAttribute( 'width', width );
            this.svg.setAttribute( 'height', height );
            this.svg.setAttribute( 'stroke-miterlimit', 10 ); // to match our Canvas brethren so we have the same default behavior
            this.svg.style.position = 'absolute';
            this.svg.style.left = '0';
            this.svg.style.top = '0';
            this.svg.style.clip = 'rect(0px,' + width + 'px,' + height + 'px,0px)';
            this.svg.style['pointer-events'] = 'none';
            $main.append( this.svg );
            
            this.isSVGLayer = true;
            
            // maps trail ID => SVG self fragment (that displays shapes, text, etc.)
            this.idFragmentMap = {};
            
            // maps trail ID => SVG <g> that contains that node's self and everything under it
            this.idGroupMap = {};
            
            
            Layer.call( this, args );
            
            this.baseTransformDirty = true;
            this.baseTransformChange = true;
          };
          var SVGLayer = scenery.SVGLayer;
          
          // used as an object pool for marking internal base node bounds
          
          var scratchBounds1 = Bounds2.NOTHING.copy();
          
          inherit( Layer, SVGLayer, {
            
            /*
             * Notes about how state is tracked here:
             * Trails are stored on group.trail so that we can look this up when inserting new groups
             */
            addInstance: function( instance ) {
              var trail = instance.trail;
              
              sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' addInstance: ' + trail.toString() );
              
              assert && assert( !( trail.getUniqueId() in this.idFragmentMap ), 'Already contained that trail!' );
              assert && assert( trail.isPainted(), 'Don\'t add nodes without isPainted() to SVGLayer' );
              
              Layer.prototype.addInstance.call( this, instance );
              
              var subtrail = this.baseTrail.copy(); // grab the trail up to (and including) the base node, so we don't create superfluous groups
              var lastId = null;
              
              // walk a subtrail up from the root node all the way to the full trail, creating groups where necessary
              while ( subtrail.length <= trail.length ) {
                var id = subtrail.getUniqueId();
                var group = this.idGroupMap[id];
                
                if ( !group ) {
                  // we need to create a new group
                  
                  if ( lastId ) {
                    // we have a parent group to which we need to be added
                    group = document.createElementNS( scenery.svgns, 'g' );
                    
                    // apply the node's transform to the group
                    this.applyTransform( subtrail.lastNode().getTransform(), group );
                    
                    // add the group to its parent
                    this.insertGroupIntoParent( group, this.idGroupMap[lastId], subtrail );
                  } else {
                    // we are ensuring the base group
                    assert && assert( subtrail.lastNode() === this.baseNode );
                    
                    group = this.g;
                    
                    // sets up the proper transform for the base
                    this.initializeBase();
                    
                    // immediately update the base transform so we don't temporarily display.
                    // fixes https://github.com/phetsims/beers-law-lab/issues/20
                    this.refreshBaseTransform();
                  }
                  
                  // apply any stylings to the group (opacity, visibility)
                  this.updateNodeGroup( subtrail.lastNode(), group );
                  
                  group.referenceCount = 0; // initialize a reference count, so we can know when to remove unused groups
                  group.trail = subtrail.copy(); // put a reference to the trail on the group, so we can efficiently scan and see where to insert future groups
                  
                  this.idGroupMap[id] = group;
                }
                
                // this trail will depend on this group, so increment the reference counter
                group.referenceCount++;
                
                if ( subtrail.length === trail.length ) {
                  // TODO: cleaner control structures
                  break;
                }
                
                // step down towards our full trail
                subtrail.addDescendant( trail.nodes[subtrail.length] );
                lastId = id;
              }
              
              // actually add the node into its own group
              var node = trail.lastNode();
              var trailId = trail.getUniqueId();
              
              var nodeGroup = this.idGroupMap[trailId];
              var svgFragment = node.createSVGFragment( this.svg, this.defs, nodeGroup );
              this.updateNode( node, svgFragment );
              this.updateNodeGroup( node, nodeGroup );
              this.idFragmentMap[trailId] = svgFragment;
              nodeGroup.appendChild( svgFragment );
            },
            
            removeInstance: function( instance ) {
              var trail = instance.trail;
              
              sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' removeInstance: ' + trail.toString() );
              assert && assert( trail.getUniqueId() in this.idFragmentMap, 'Did not contain that trail!' );
              
              Layer.prototype.removeInstance.call( this, instance );
              
              // clean up the fragment and defs directly died to the node
              var trailId = trail.getUniqueId();
              var node = trail.lastNode();
              var fragment = this.idFragmentMap[trailId];
              this.idGroupMap[trailId].removeChild( fragment );
              delete this.idFragmentMap[trailId];
              if ( node.removeSVGDefs ) {
                node.removeSVGDefs( this.svg, this.defs );
              }
              
              // clean up any unneeded groups
              var subtrail = trail.copy();
              while ( subtrail.length > this.baseTrail.length ) {
                var id = subtrail.getUniqueId();
                
                var group = this.idGroupMap[id];
                group.referenceCount--;
                if ( group.referenceCount === 0 ) {
                  // completely kill the group
                  group.parentNode.removeChild( group );
                  delete group.trail; // just in case someone held a reference
                  delete this.idGroupMap[id];
                }
                
                subtrail.removeDescendant();
              }
              this.g.referenceCount--; // since we don't go down to the base group, adjust its reference count
            },
            
            // subtrail is to group, and should include parentGroup below
            insertGroupIntoParent: function( group, parentGroup, subtrail ) {
              sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' insertGroupIntoParent subtrail:' + subtrail.toString() );
              if ( !parentGroup.childNodes.length ) {
                parentGroup.appendChild( group );
              } else {
                // if there is already a child, we need to do a scan to ensure we place our group as a child in the correct order (above/below)
                
                // scan other child groups in the parentGroup to find where we need to be (index i)
                var indexIndex = subtrail.length - 2; // index into the trail's indices
                var ourIndex = subtrail.indices[indexIndex];
                var i;
                for ( i = 0; i < parentGroup.childNodes.length; i++ ) {
                  var child = parentGroup.childNodes[i];
                  if ( child.trail ) {
                    child.trail.reindex();
                    var otherIndex = child.trail.indices[indexIndex];
                    if ( otherIndex > ourIndex ) {
                      // this other group is above us
                      break;
                    }
                  }
                }
                
                // insert our group before parentGroup.childNodes[i] (or append if that doesn't exist)
                if ( i === parentGroup.childNodes.length ) {
                  parentGroup.appendChild( group );
                } else {
                  parentGroup.insertBefore( group, parentGroup.childNodes[i] );
                }
              }
            },
            
            // updates visual styles on an existing SVG fragment
            updateNode: function( node, fragment ) {
              sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' updateNode: ' + node.constructor.name + ' #' + node.id );
              if ( node.updateSVGFragment ) {
                node.updateSVGFragment( fragment );
              }
              if ( node.updateSVGDefs ) {
                node.updateSVGDefs( this.svg, this.defs );
              }
            },
            
            // updates necessary paint attributes on a group (not including transform)
            updateNodeGroup: function( node, group ) {
              sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' updateNodeGroup: ' + node.constructor.name + ' #' + node.id );
              this.updateGroupVisibility( node, group );
              this.updateGroupOpacity( node, group );
              this.updateGroupClip( node, group );
            },
            
            updateGroupVisibility: function( node, group ) {
              // if we're updating visibility for the base trail, apply its visibility and everything beneath it
              if ( node === this.baseNode ? this.baseTrail.isVisible() : node.isVisible() ) {
                group.style.display = 'inherit';
              } else {
                group.style.display = 'none';
              }
            },
            
            updateGroupOpacity: function( node, group ) {
              var opacity;
              if ( node === this.baseNode ) {
                opacity = this.baseTrail.getOpacity(); // multiplied by opacities of all ancestors
              } else {
                opacity = node.getOpacity();
              }
              group.setAttribute( 'opacity', opacity );
            },
            
            updateGroupClip: function( node, group ) {
              // TODO: optimization! this is not the fastest way of doing things
              var clipId = 'clip' + node.getId();
              
              assert && assert( !( node === this.baseNode && node !== this.scene && node._clipArea ), 'clipArea not supported on CSS-transformed SVG elements (or the base for now)' );
              
              // remove any old defs
              var oldDef = this.svg.getElementById( clipId );
              if ( oldDef ) {
                this.defs.removeChild( oldDef );
              }
              
              if ( node._clipArea ) {
                var definition = document.createElementNS( scenery.svgns, 'clipPath' );
                definition.setAttribute( 'id', clipId );
                definition.setAttribute( 'clipPathUnits', 'userSpaceOnUse' );
                
                var path = document.createElementNS( scenery.svgns, 'path' );
                path.setAttribute( 'd', node._clipArea.getSVGPath() );
                definition.appendChild( path );
                
                this.defs.appendChild( definition );
                
                group.setAttribute( 'clip-path', 'url(#' + clipId + ')' );
              } else {
                group.removeAttribute( 'clip-path' );
              }
            },
            
            getFragmentFromInstance: function( instance ) {
              // TODO: performance: key optimization point for SVG layers
              return this.idFragmentMap[instance.trail.getUniqueId()];
            },
            
            getGroupFromInstance: function( instance ) {
              // TODO: performance: key optimization point for SVG layers
              return this.idGroupMap[instance.trail.getUniqueId()];
            },
            
            applyTransform: function( transform, group ) {
              if ( transform.isIdentity() ) {
                if ( group.hasAttribute( 'transform' ) ) {
                  group.removeAttribute( 'transform' );
                }
              } else {
                group.setAttribute( 'transform', transform.getMatrix().getSVGTransform() );
              }
            },
            
            render: function( scene, args ) {
              this.refreshBaseTransform();
            },
            
            refreshBaseTransform: function() {
              if ( this.baseTransformDirty ) {
                // this will be run either now or at the end of flushing changes
                var includesBaseTransformChange = this.baseTransformChange;
                this.updateBaseTransform( includesBaseTransformChange );
                
                this.baseTransformDirty = false;
                this.baseTransformChange = false;
              }
            },
            
            dispose: function() {
              Layer.prototype.dispose.call( this );
              
              this.svg.parentNode.removeChild( this.svg );
            },
            
            markBaseTransformDirty: function( changed ) {
              sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' markBaseTransformDirty' );
              var baseTransformChange = this.baseTransformChange || !!changed;
              this.baseTransformDirty = true;
              this.baseTransformChange = baseTransformChange;
            },
            
            initializeBase: function() {
              // we don't want to call updateBaseTransform() twice, since baseNodeInternalBoundsChange() will call it if we use CSS transform
              if ( this.cssTransform ) {
                this.baseNodeInternalBoundsChange();
              } else {
                this.markBaseTransformDirty( true );
              }
            },
            
            // called when the base node's "internal" (self or child) bounds change, but not when it is just from the base node's own transform changing
            baseNodeInternalBoundsChange: function() {
              sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' baseNodeInternalBoundsChange' );
              if ( this.cssTransform ) {
                // we want to set the baseNodeTransform to a translation so that it maps the baseNode's self/children in the baseNode's local bounds to (0,0,w,h)
                var internalBounds = scratchBounds1; // pooled copy
                internalBounds.set( this.baseNode.getBounds() );
                this.baseNode.transformBoundsFromParentToLocal( internalBounds );
                var padding = scenery.Layer.cssTransformPadding;
                
                // if there is nothing, or the bounds are empty for some reason, skip this!
                if ( !internalBounds.isEmpty() ) {
                  this.baseNodeTransform.setMatrix( Matrix3.translation( Math.ceil( -internalBounds.minX + padding), Math.ceil( -internalBounds.minY + padding ) ) );
                  
                  // NOTE: this is mutable! don't use internalBounds after this
                  var baseNodeInternalBounds = internalBounds.transform( this.baseNodeTransform.getMatrix() );
                  
                  // sanity check to ensure we are within that range
                  assert && assert( baseNodeInternalBounds.minX >= 0 && baseNodeInternalBounds.minY >= 0 );
                  
                  this.updateContainerDimensions( Math.ceil( baseNodeInternalBounds.maxX + padding ),
                                                  Math.ceil( baseNodeInternalBounds.maxY + padding ) );
                }
                
                // if this gets removed, update initializeBase()
                this.markBaseTransformDirty( true );
              } else if ( this.usesPartialCSSTransforms ) {
                this.markBaseTransformDirty( true );
              }
            },
            
            updateContainerDimensions: function( width, height ) {
              this.svg.setAttribute( 'width', width );
              this.svg.setAttribute( 'height', height );
            },
            
            updateBaseTransform: function( includesBaseTransformChange ) {
              sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' updateBaseTransform' );
              var transform = this.baseTrail.getTransform(); // TODO: consider improving this, CSS+SVG bottleneck
              
              if ( this.cssTransform ) {
                // set the full transform!
                scenery.Util.applyCSSTransform( transform.getMatrix().timesMatrix( this.baseNodeTransform.getInverse() ), this.svg );
                
                if ( includesBaseTransformChange ) {
                  this.applyTransform( this.baseNodeTransform, this.g );
                }
              } else if ( this.usesPartialCSSTransforms ) {
                // calculate what our CSS transform should be
                var cssTransform = new Transform3();
                var matrix = transform.getMatrix();
                if ( this.cssTranslation ) {
                  cssTransform.append( Matrix3.translation( matrix.m02(), matrix.m12() ) );
                }
                if ( this.cssRotation ) {
                  cssTransform.append( Matrix3.rotation2( matrix.getRotation() ) );
                }
                if ( this.cssScale ) {
                  var scaleVector = matrix.getScaleVector();
                  cssTransform.append( Matrix3.scaling( scaleVector.x, scaleVector.y ) );
                }
                
                // take the CSS transform out of what we will apply to the group
                transform.prepend( cssTransform.getInverse() );
                
                // now we need to see where our baseNode bounds are mapped to with our transform,
                // so that we can apply an extra translation and adjust dimensions as necessary
                var padding = scenery.Layer.cssTransformPadding;
                var internalBounds = this.baseNode.parentToLocalBounds( this.baseNode.getBounds() );
                var mappedBounds = transform.transformBounds2( internalBounds );
                var translation = Matrix3.translation( Math.ceil( -mappedBounds.minX + padding ), Math.ceil( -mappedBounds.minY + padding ) );
                var inverseTranslation = translation.inverted();
                this.updateContainerDimensions( Math.ceil( mappedBounds.getWidth()  + 2 * padding ),
                                                Math.ceil( mappedBounds.getHeight() + 2 * padding ) );
                
                // put the translation adjustment and its inverse in-between the two transforms
                cssTransform.append( inverseTranslation );
                transform.prepend( translation );
                
                // apply the transforms
                // TODO: checks to make sure we don't apply them in a row if one didn't change!
                scenery.Util.applyCSSTransform( cssTransform.getMatrix(), this.svg );
                this.applyTransform( transform, this.g );
              } else {
                this.applyTransform( transform, this.g );
              }
            },
            
            // TODO: consider a stack-based model for transforms?
            applyTransformationMatrix: function( matrix ) {
              // nothing at all needed here
            },
            
            getContainer: function() {
              return this.svg;
            },
            
            // returns next zIndex in place. allows layers to take up more than one single zIndex
            reindex: function( zIndex ) {
              Layer.prototype.reindex.call( this, zIndex );
              
              if ( this.zIndex !== zIndex ) {
                this.svg.style.zIndex = zIndex;
                this.zIndex = zIndex;
              }
              return zIndex + 1;
            },
            
            pushClipShape: function( shape ) {
              // TODO: clipping
            },
            
            popClipShape: function() {
              // TODO: clipping
            },
            
            getSVGString: function() {
              // TODO: jQuery seems to be stripping namespaces, so figure that one out?
              return $( '<div>' ).append( this.$svg.clone() ).html();
              
              // also note:
              // var doc = document.implementation.createHTMLDocument("");
              // doc.write(html);
               
              // // You must manually set the xmlns if you intend to immediately serialize the HTML
              // // document to a string as opposed to appending it to a <foreignObject> in the DOM
              // doc.documentElement.setAttribute("xmlns", doc.documentElement.namespaceURI);
               
              // // Get well-formed markup
              // html = (new XMLSerializer).serializeToString(doc);
            },
            
            // TODO: note for DOM we can do https://developer.mozilla.org/en-US/docs/HTML/Canvas/Drawing_DOM_objects_into_a_canvas
            renderToCanvas: function( canvas, context, delayCounts ) {
              // temporarily put the full transform on the containing group so the rendering is correct (CSS transforms can take this away)
              this.applyTransform( this.baseTrail.getTransform(), this.g );
              
              if ( window.canvg ) {
                delayCounts.increment();
                
                // TODO: if we are using CSS3 transforms, run that here
                canvg( canvas, this.getSVGString(), {
                  ignoreMouse: true,
                  ignoreAnimation: true,
                  ignoreDimensions: true,
                  ignoreClear: true,
                  renderCallback: function() {
                    delayCounts.decrement();
                  }
                } );
              } else {
                // will not work on Internet Explorer 9/10
                
                // TODO: very much not convinced that this is better than setting src of image
                var DOMURL = window.URL || window.webkitURL || window;
                var img = new Image();
                var raw = this.getSVGString();
                console.log( raw );
                var svg = new Blob( [ raw ] , { type: "image/svg+xml;charset=utf-8" } );
                var url = DOMURL.createObjectURL( svg );
                delayCounts.increment();
                img.onload = function() {
                  context.drawImage( img, 0, 0 );
                  // TODO: this loading is delayed!!! ... figure out a solution to potentially delay?
                  DOMURL.revokeObjectURL( url );
                  delayCounts.decrement();
                };
                img.src = url;
                
                throw new Error( 'this implementation hits Chrome bugs, won\'t work on IE9/10, etc. deprecated' );
              }
              
              // revert the transform damage that we did to our base group
              this.updateBaseTransform();
            },
            
            getName: function() {
              return 'svg';
            },
            
            /*---------------------------------------------------------------------------*
            * Events from Instances
            *----------------------------------------------------------------------------*/
            
            notifyVisibilityChange: function( instance ) {
              sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyVisibilityChange: ' + instance.trail.toString() );
              var group = this.getGroupFromInstance( instance );
              if ( group ) {
                this.updateGroupVisibility( instance.getNode(), group );
              } else if ( this.baseNode !== this.scene ) {
                // if we are using a CSS transform (basically)
                this.updateGroupVisibility( this.baseNode, this.getGroupFromInstance( this.baseTrail.getInstance() ) );
              }
            },
            
            notifyOpacityChange: function( instance ) {
              sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyOpacityChange: ' + instance.trail.toString() );
              var group = this.getGroupFromInstance( instance );
              if ( group ) {
                this.updateGroupOpacity( instance.getNode(), group );
              } else if ( this.baseNode !== this.scene ) {
                // if we are using a CSS transform (basically)
                this.updateGroupOpacity( this.baseNode, this.getGroupFromInstance( this.baseTrail.getInstance() ) );
              }
            },
            
            notifyClipChange: function( instance ) {
              sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyClipChange: ' + instance.trail.toString() );
              var group = this.getGroupFromInstance( instance );
              if ( group ) {
                this.updateGroupClip( instance.getNode(), group );
              } else if ( this.baseNode !== this.scene ) {
                // if we are using a CSS transform (basically)
                // TODO: clip combinations don't work yet, this won't really do anything (probably errors out)
                this.updateGroupClip( this.baseNode, this.getGroupFromInstance( this.baseTrail.getInstance() ) );
              }
            },
            
            // only a painted trail under this layer
            notifyBeforeSelfChange: function( instance ) {
              // sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyBeforeSelfChange: ' + instance.trail.toString() );
              // no-op, we don't need paint changes
            },
            
            notifyBeforeSubtreeChange: function( instance ) {
              // sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyBeforeSubtreeChange: ' + instance.trail.toString() );
              // no-op, we don't need paint changes
            },
            
            // only a painted trail under this layer
            notifyDirtySelfPaint: function( instance ) {
              sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyDirtySelfPaint: ' + instance.trail.toString() );
              var fragment = this.getFragmentFromInstance( instance );
              
              if ( fragment ) {
                var node = instance.getNode();
                
                if ( node.updateSVGFragment ) {
                  // TODO: performance: don't re-do all of the fragment here! intelligent updating?
                  node.updateSVGFragment( fragment );
                }
                if ( node.updateSVGDefs ) {
                  // TODO: performance: don't re-do all of the defs here! intelligent updating?
                  node.updateSVGDefs( this.svg, this.defs );
                }
              }
            },
            
            notifyDirtySubtreePaint: function( instance ) {
              // TODO: performance: this caused a 50% increase for the fast-svg transform steps, what were we missing?
              if ( instance.layer === this ) {
                this.notifyDirtySelfPaint( instance );
              }
            },
            
            notifyTransformChange: function( instance ) {
              sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyTransformChange: ' + instance.trail.toString() );
              var node = instance.node;
              var trail = instance.trail;
              
              if ( trail.lastNode() === this.baseNode ) {
                // our trail points to the base node. handle this case as special
                this.markBaseTransformDirty();
              } else if ( _.contains( trail.nodes, this.baseNode ) ) { // TODO: performance: this linear scan looks slower than needed
                var group = this.idGroupMap[trail.getUniqueId()];
                
                // apply the transform to the group
                this.applyTransform( node.getTransform(), group );
              } else {
                // ancestor node changed a transform. rebuild the base transform
                this.markBaseTransformDirty();
              }
            },
            
            // only a painted trail under this layer (for now)
            notifyBoundsAccuracyChange: function( instance ) {
              // sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyBoundsAccuracyChange: ' + instance.trail.toString() );
              // no-op, we don't care about bounds
            }
            
          } );
          
          return SVGLayer;
        } );
        
        
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * An enumeration of different back-end technologies used for rendering. It also essentially
         * represents the API that nodes need to implement to be used with this specified back-end.
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/layers/Renderer',['require','SCENERY/scenery','SCENERY/layers/LayerType','SCENERY/layers/CanvasLayer','SCENERY/layers/DOMLayer','SCENERY/layers/SVGLayer'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          
          require( 'SCENERY/layers/LayerType' );
          require( 'SCENERY/layers/CanvasLayer' );
          require( 'SCENERY/layers/DOMLayer' );
          require( 'SCENERY/layers/SVGLayer' );
          
          scenery.Renderer = function Renderer( layerConstructor, name, bitmask, defaultOptions ) {
            this.layerConstructor = layerConstructor;
            this.name = name;
            this.bitmask = bitmask;
            this.defaultOptions = defaultOptions;
            
            this.defaultLayerType = this.createLayerType( {} ); // default options are handled in createLayerType
          };
          var Renderer = scenery.Renderer;
          
          Renderer.prototype = {
            constructor: Renderer,
            
            createLayerType: function( rendererOptions ) {
              return new scenery.LayerType( this.layerConstructor, this.name, this.bitmask, this, _.extend( {}, this.defaultOptions, rendererOptions ) );
            }
          };
          
          Renderer.Canvas = new Renderer( scenery.CanvasLayer, 'canvas', scenery.bitmaskSupportsCanvas, {} );
          Renderer.DOM = new Renderer( scenery.DOMLayer, 'dom', scenery.bitmaskSupportsDOM, {} );
          Renderer.SVG = new Renderer( scenery.SVGLayer, 'svg', scenery.bitmaskSupportsSVG, {} );
          
          // add shortcuts for the default layer types
          scenery.CanvasDefaultLayerType = Renderer.Canvas.defaultLayerType;
          scenery.DOMDefaultLayerType    = Renderer.DOM.defaultLayerType;
          scenery.SVGDefaultLayerType    = Renderer.SVG.defaultLayerType;
          
          // and shortcuts so we can index in with shorthands like 'svg', 'dom', etc.
          Renderer.canvas = Renderer.Canvas;
          Renderer.dom = Renderer.DOM;
          Renderer.svg = Renderer.SVG;
          Renderer.webgl = Renderer.WebGL;
          
          return Renderer;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Images
         *
         * TODO: allow multiple DOM instances (create new HTMLImageElement elements)
         * TODO: SVG support
         * TODO: support rendering a Canvas to DOM (single instance)
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/nodes/Image',['require','PHET_CORE/inherit','DOT/Bounds2','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/layers/Renderer','SCENERY/util/Util'],function( require ) {
          
        
          var inherit = require( 'PHET_CORE/inherit' );
          var Bounds2 = require( 'DOT/Bounds2' );
        
          var scenery = require( 'SCENERY/scenery' );
        
          var Node = require( 'SCENERY/nodes/Node' ); // Image inherits from Node
          require( 'SCENERY/layers/Renderer' ); // we need to specify the Renderer in the prototype
          require( 'SCENERY/util/Util' );
        
          /*
           * Canvas renderer supports the following as 'image':
           *     URL (string)             // works, but does NOT support bounds-based parameter object keys like 'left', 'centerX', etc.
           *                              // also necessary to force updateScene() after it has loaded
           *     HTMLImageElement         // works
           *     HTMLVideoElement         // not tested
           *     HTMLCanvasElement        // works, and forces the canvas renderer
           *     CanvasRenderingContext2D // not tested, but bad luck in past
           *     ImageBitmap              // good luck creating this. currently API for window.createImageBitmap not implemented
           * SVG renderer supports the following as 'image':
           *     URL (string)
           *     HTMLImageElement
           */
          scenery.Image = function Image( image, options ) {
            assert && assert( image, "image should be available" );
        
            // allow not passing an options object
            options = options || {};
        
            // rely on the setImage call from the super constructor to do the setup
            if ( image ) {
              options.image = image;
            }
        
            var self = this;
            // allows us to invalidate our bounds whenever an image is loaded
            this.loadListener = function( event ) {
              self.invalidateImage();
        
              // don't leak memory!
              self._image.removeEventListener( 'load', self.loadListener );
            };
        
            Node.call( this, options );
            this.invalidateSupportedRenderers();
          };
          var Image = scenery.Image;
        
          inherit( Node, Image, {
            allowsMultipleDOMInstances: false, // TODO: support multiple instances
        
            invalidateImage: function() {
              this.invalidateSelf( new Bounds2( 0, 0, this.getImageWidth(), this.getImageHeight() ) );
            },
        
            getImage: function() {
              return this._image;
            },
            
            invalidateSupportedRenderers: function() {
              if ( this._image instanceof HTMLCanvasElement ) {
                this.setRendererBitmask( scenery.bitmaskSupportsCanvas );
              } else {
                // assumes HTMLImageElement
                this.setRendererBitmask( scenery.bitmaskSupportsCanvas | scenery.bitmaskSupportsSVG | scenery.bitmaskSupportsDOM );
              }
            },
        
            setImage: function( image ) {
              if ( this._image !== image && ( typeof image !== 'string' || !this._image || image !== this._image.src ) ) {
                // don't leak memory by referencing old images
                if ( this._image ) {
                  this._image.removeEventListener( 'load', this.loadListener );
                }
        
                if ( typeof image === 'string' ) {
                  // create an image with the assumed URL
                  var src = image;
                  image = document.createElement( 'img' );
                  image.addEventListener( 'load', this.loadListener );
                  image.src = src;
                } else if ( image instanceof HTMLImageElement ) {
                  // only add a listener if we probably haven't loaded yet
                  if ( !image.width || !image.height ) {
                    image.addEventListener( 'load', this.loadListener );
                  }
                }
        
                // swap supported renderers if necessary
                this.invalidateSupportedRenderers();
        
                this._image = image;
                this.invalidateImage(); // yes, if we aren't loaded yet this will give us 0x0 bounds
              }
              return this;
            },
        
            getImageWidth: function() {
              return this._image.naturalWidth || this._image.width;
            },
        
            getImageHeight: function() {
              return this._image.naturalHeight || this._image.height;
            },
        
            getImageURL: function() {
              return this._image.src;
            },
        
            // signal that we are actually rendering something
            isPainted: function() {
              return true;
            },
        
            /*---------------------------------------------------------------------------*
            * Canvas support
            *----------------------------------------------------------------------------*/
        
            // TODO: add SVG / DOM support
            paintCanvas: function( wrapper ) {
              wrapper.context.drawImage( this._image, 0, 0 );
            },
        
            /*---------------------------------------------------------------------------*
             * WebGL support
             *----------------------------------------------------------------------------*/
        
            paintWebGL: function( state ) {
              throw new Error( 'paintWebGL:nimplemented' );
            },
        
            /*---------------------------------------------------------------------------*
            * SVG support
            *----------------------------------------------------------------------------*/
        
            createSVGFragment: function( svg, defs, group ) {
              var element = document.createElementNS( scenery.svgns, 'image' );
              element.setAttribute( 'x', 0 );
              element.setAttribute( 'y', 0 );
              return element;
            },
        
            updateSVGFragment: function( element ) {
              // like <image xlink:href='http://phet.colorado.edu/images/phet-logo-yellow.png' x='0' y='0' height='127px' width='242px'/>
              element.setAttribute( 'width', this.getImageWidth() + 'px' );
              element.setAttribute( 'height', this.getImageHeight() + 'px' );
              element.setAttributeNS( scenery.xlinkns, 'xlink:href', this.getImageURL() );
            },
        
            /*---------------------------------------------------------------------------*
             * DOM support
             *----------------------------------------------------------------------------*/
        
            getDOMElement: function() {
              this._image.style.display = 'block';
              this._image.style.position = 'absolute';
              this._image.style.left = '0';
              this._image.style.top = '0';
              return this._image;
            },
        
            updateDOMElement: function( image ) {
              if ( image.src !== this._image.src ) {
                image.src = this._image.src;
              }
            },
        
            updateCSSTransform: function( transform, element ) {
              // TODO: extract this out, it's completely shared!
              scenery.Util.applyCSSTransform( transform.getMatrix(), element );
            },
        
            set image( value ) { this.setImage( value ); },
            get image() { return this.getImage(); },
        
            getBasicConstructor: function( propLines ) {
              return 'new scenery.Image( \'' + ( this._image.src ? this._image.src.replace( /'/g, '\\\'' ) : 'other' ) + '\', {' + propLines + '} )';
            }
          } );
        
          Image.prototype._mutatorKeys = [ 'image' ].concat( Node.prototype._mutatorKeys );
        
          // utility for others
          Image.createSVGImage = function( url, width, height ) {
            var element = document.createElementNS( scenery.svgns, 'image' );
            element.setAttribute( 'x', 0 );
            element.setAttribute( 'y', 0 );
            element.setAttribute( 'width', width + 'px' );
            element.setAttribute( 'height', height + 'px' );
            element.setAttributeNS( scenery.xlinkns, 'xlink:href', url );
        
            return element;
          };
        
          return Image;
        } );
        
        
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Basic dragging for a node.
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/input/SimpleDragHandler',['require','SCENERY/scenery'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          
          /*
           * Allowed options: {
           *    allowTouchSnag: false // allow touch swipes across an object to pick it up. If a function is passed, the value allowTouchSnag( event ) is used
           *    dragCursor: 'pointer' // while dragging with the mouse, sets the cursor to this value (or use null to not override the cursor while dragging)
           *    mouseButton: 0        // allow changing the mouse button that activates the drag listener. -1 should activate on any mouse button, 0 on left, 1 for middle, 2 for right, etc.
           *    start: null           // if non-null, called when a drag is started. start( event, trail )
           *    drag: null            // if non-null, called when the user moves something with a drag (not a start or end event).
           *                                                                         drag( event, trail )
           *    end: null             // if non-null, called when a drag is ended.   end( event, trail )
           *    translate:            // if this exists, translate( { delta: _, oldPosition: _, position: _ } ) will be called.
           * }
           */
          scenery.SimpleDragHandler = function SimpleDragHandler( options ) {
            var handler = this;
            
            this.options = _.extend( {
              allowTouchSnag: false,
              mouseButton: 0,
              dragCursor: 'pointer'
            }, options );
            
            this.dragging              = false;     // whether a node is being dragged with this handler
            this.pointer               = null;      // the pointer doing the current dragging
            this.trail                 = null;      // stores the path to the node that is being dragged
            this.transform             = null;      // transform of the trail to our node (but not including our node, so we can prepend the deltas)
            this.node                  = null;      // the node that we are handling the drag for
            this.lastDragPoint         = null;      // the location of the drag at the previous event (so we can calculate a delta)
            this.startTransformMatrix  = null;      // the node's transform at the start of the drag, so we can reset on a touch cancel
            this.mouseButton           = undefined; // tracks which mouse button was pressed, so we can handle that specifically
            // TODO: consider mouse buttons as separate pointers?
            
            // if an ancestor is transformed, pin our node
            this.transformListener = {
              transform: function( args ) {
                if ( !handler.trail.isExtensionOf( args.trail, true ) ) {
                  return;
                }
                
                var newMatrix = args.trail.getTransform().getMatrix();
                var oldMatrix = handler.transform.getMatrix();
                
                // if A was the trail's old transform, B is the trail's new transform, we need to apply (B^-1 A) to our node
                handler.node.prependMatrix( newMatrix.inverted().timesMatrix( oldMatrix ) );
                
                // store the new matrix so we can do deltas using it now
                handler.transform.setMatrix( newMatrix );
              }
            };
            
            // this listener gets added to the pointer when it starts dragging our node
            this.dragListener = {
              // mouse/touch up
              up: function( event ) {
                assert && assert( event.pointer === handler.pointer );
                if ( !event.pointer.isMouse || event.domEvent.button === handler.mouseButton ) {
                  var saveCurrentTarget = event.currentTarget;
                  event.currentTarget = handler.node; // #66: currentTarget on a pointer is null, so set it to the node we're dragging
                  handler.endDrag( event );
                  event.currentTarget = saveCurrentTarget; // be polite to other listeners, restore currentTarget
                }
              },
              
              // touch cancel
              cancel: function( event ) {
                assert && assert( event.pointer === handler.pointer );
        
                var saveCurrentTarget = event.currentTarget;
                event.currentTarget = handler.node; // #66: currentTarget on a pointer is null, so set it to the node we're dragging
                handler.endDrag( event );
                event.currentTarget = saveCurrentTarget; // be polite to other listeners, restore currentTarget
        
                // since it's a cancel event, go back!
                if ( !handler.transform ) {
                  handler.node.setMatrix( handler.startTransformMatrix );
                }
              },
              
              // mouse/touch move
              move: function( event ) {
                assert && assert( event.pointer === handler.pointer );
                
                var globalDelta = handler.pointer.point.minus( handler.lastDragPoint );
                
                // ignore move events that have 0-length (Chrome seems to be auto-firing these on Windows, see https://code.google.com/p/chromium/issues/detail?id=327114)
                if ( globalDelta.magnitudeSquared() === 0 ) {
                  return;
                }
                
                var delta = handler.transform.inverseDelta2( globalDelta );
                
                // move by the delta between the previous point, using the precomputed transform
                // prepend the translation on the node, so we can ignore whatever other transform state the node has
                if ( handler.options.translate ) {
                  var translation = handler.node.getTransform().getMatrix().getTranslation();
                  handler.options.translate( {
                    delta: delta,
                    oldPosition: translation,
                    position: translation.plus( delta )
                  } );
                }
                handler.lastDragPoint = handler.pointer.point;
                
                if ( handler.options.drag ) {
                  // TODO: consider adding in a delta to the listener
                  // TODO: add the position in to the listener
                  var saveCurrentTarget = event.currentTarget;
                  event.currentTarget = handler.node; // #66: currentTarget on a pointer is null, so set it to the node we're dragging
                  handler.options.drag( event, handler.trail ); // new position (old position?) delta
                  event.currentTarget = saveCurrentTarget; // be polite to other listeners, restore currentTarget
                }
              }
            };
          };
          var SimpleDragHandler = scenery.SimpleDragHandler;
          
          SimpleDragHandler.prototype = {
            constructor: SimpleDragHandler,
            
            startDrag: function( event ) {
              // set a flag on the pointer so it won't pick up other nodes
              event.pointer.active = true;
              event.pointer.cursor = this.options.dragCursor;
              event.pointer.addInputListener( this.dragListener );
              // event.trail.rootNode().addEventListener( this.transformListener ); // TODO: replace with new parent transform listening solution
              
              // set all of our persistent information
              this.dragging = true;
              this.pointer = event.pointer;
              this.trail = event.trail.subtrailTo( event.currentTarget, true );
              this.transform = this.trail.getTransform();
              this.node = event.currentTarget;
              this.lastDragPoint = event.pointer.point;
              this.startTransformMatrix = event.currentTarget.getMatrix();
              // event.domEvent may not exist if this is touch-to-snag
              this.mouseButton = event.pointer.isMouse ? event.domEvent.button : undefined;
              
              if ( this.options.start ) {
                this.options.start( event, this.trail );
              }
            },
            
            endDrag: function( event ) {
              this.pointer.active = false;
              this.pointer.cursor = null;
              this.pointer.removeInputListener( this.dragListener );
              // this.trail.rootNode().removeEventListener( this.transformListener ); // TODO: replace with new parent transform listening solution
              this.dragging = false;
              
              if ( this.options.end ) {
                this.options.end( event, this.trail );
              }
            },
            
            tryToSnag: function( event ) {
              // don't allow drag attempts that use the wrong mouse button (-1 indicates any mouse button works)
              if ( event.pointer.isMouse && event.domEvent && this.options.mouseButton !== event.domEvent.button && this.options.mouseButton !== -1 ) {
                return;
              }
              
              // only start dragging if the pointer isn't dragging anything, we aren't being dragged, and if it's a mouse it's button is down
              if ( !this.dragging && !event.pointer.active ) {
                this.startDrag( event );
              }
            },
            
            tryTouchToSnag: function( event ) {
              // allow touches to start a drag by moving "over" this node, and allows clients to specify custom logic for when touchSnag is allowable
              if ( this.options.allowTouchSnag && ( this.options.allowTouchSnag === true || this.options.allowTouchSnag( event ) ) ) {
                this.tryToSnag( event );
              }
            },
            
            /*---------------------------------------------------------------------------*
            * events called from the node input listener
            *----------------------------------------------------------------------------*/
            
            // mouse/touch down on this node
            down: function( event ) {
              this.tryToSnag( event );
            },
            
            // touch enters this node
            touchenter: function( event ) {
              this.tryTouchToSnag( event );
            },
            
            // touch moves over this node
            touchmove: function( event ) {
              this.tryTouchToSnag( event );
            }
          };
          
          return SimpleDragHandler;
        } );
        
        
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Shows the graphic for the puller, which can be dragged from the toolbox to the rope to apply force.
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/tugofwar/view/PullerNode',['require','SCENERY/nodes/Image','SCENERY/input/SimpleDragHandler','PHET_CORE/inherit','DOT/Vector2'],function( require ) {
          
        
          var Image = require( 'SCENERY/nodes/Image' );
          var SimpleDragHandler = require( 'SCENERY/input/SimpleDragHandler' );
          var inherit = require( 'PHET_CORE/inherit' );
          var Vector2 = require( 'DOT/Vector2' );
        
          /**
           * Create a PullerNode for the specified puller
           * @param {Puller} puller
           * @param {TugOfWarModel} model
           * @param {Image} image image of the puller standing upright
           * @param {Image} pullImage image of the puller exerting a force
           * @constructor
           */
          function PullerNode( puller, model, image, pullImage ) {
            this.puller = puller;
            var pullerNode = this;
            this.puller.node = this;//Wire up so node can be looked up by model element.
            var x = puller.position.x;
            var y = puller.position.y;
        
            Image.call( this, image, {x: x, y: y, fontSize: 42, cursor: 'pointer', scale: 0.86} );
        
            var updateLocation = function() {
              var knotted = puller.knot;
              var pulling = model.started && knotted;
              if ( knotted ) {
                var pullingOffset = pulling ? -puller.dragOffsetX : puller.standOffsetX;
                var blueOffset = pullerNode.puller.type === 'blue' ? -60 + 10 : 0;
                pullerNode.setTranslation( puller.knot.x + pullingOffset + blueOffset, puller.knot.y - pullerNode.height + 90 );
              }
              else {
                pullerNode.setTranslation( puller.position );
              }
            };
        
            model.startedProperty.link( updateLocation );
            puller.positionProperty.link( updateLocation );
        
            var updateImage = function() {
              var knotted = puller.knot;
              var pulling = model.started && knotted;
              pullerNode.image = pulling ? pullImage : image;
        
              //Reshape the focus rect when image changes
              //This was copied from updateLocation above to solve https://github.com/phetsims/forces-and-motion-basics/issues/55
              if ( knotted ) {
                var pullingOffset = pulling ? -puller.dragOffsetX : puller.standOffsetX;
                var blueOffset = pullerNode.puller.type === 'blue' ? -60 + 10 : 0;
                pullerNode.setTranslation( puller.knot.x + pullingOffset + blueOffset, puller.knot.y - pullerNode.height + 90 );
              }
              else {
                pullerNode.setTranslation( puller.position );
              }
            };
            model.startedProperty.link( updateImage );
            model.runningProperty.link( updateImage );
        
            pullerNode.addInputListener( new SimpleDragHandler(
              {
                allowTouchSnag: true,
                start: function() {
                  var knot = puller.knot;
                  puller.disconnect();
                  puller.dragging = true;
                  pullerNode.moveToFront();
                  puller.trigger( 'dragged' );
                  updateImage();
        
                  //Hack around the puller position, which seems to be broken for blue pullers for unknown reasons
                  if ( knot && puller.type === 'blue' ) {
                    puller.position = puller.position.plusXY(
                      puller.size === 'small' ? -50 :
                      puller.size === 'medium' ? -30 :
                      -40,
                      puller.size === 'small' ? -30 :
                      puller.size === 'medium' ? -90 :
                      -140 );
                  }
                  updateLocation();
                },
                end: function() {
                  updateLocation();
                  puller.dragging = false;
                  puller.trigger( 'dropped' );
                  updateImage();
                },
                translate: function( event ) {
                  pullerNode.puller.position = event.position;
                }
              } ) );
        
            //Add accessibility peer
            this.addPeer( '<input type="button" aria-label="' + puller.name + '">', {click: function() {
              if ( puller.knot ) {
                puller.disconnect();
                puller.positionProperty.reset();
                model.numberPullersAttached = model.countAttachedPullers();
              }
              else {
                puller.disconnect();
                var knot = model.getClosestOpenKnot( puller );
                puller.set( {position: new Vector2( knot.x, knot.y ), knot: knot} );
                model.numberPullersAttached = model.countAttachedPullers();
                puller.dragging = false;
                puller.trigger( 'dropped' );
                updateImage();
              }
            }} );
          }
        
          return inherit( Image, PullerNode );
        } );
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Code for testing which platform is running.  Use sparingly, if at all!
         *
         * Sample usage:
         * if (platform.firefox) {node.renderer = 'canvas';}
         *
         * @author Sam Reid
         */
        define( 'PHET_CORE/platform',['require','PHET_CORE/core'],function( require ) {
          
        
          var core = require( 'PHET_CORE/core' );
        
          var ua = navigator.userAgent;
        
          // taken from HomeScreen
          function isIE( version ) {
            var r = new RegExp( 'msie' + (!isNaN( version ) ? ('\\s' + version) : ''), 'i' );
            return r.test( ua );
          }
        
          core.platform = {
            get firefox() { return ua.toLowerCase().indexOf( 'firefox' ) > -1; },
        
            //see http://stackoverflow.com/questions/3007480/determine-if-user-navigated-from-mobile-safari
            get mobileSafari() { return ua.match( /(iPod|iPhone|iPad)/ ) && ua.match( /AppleWebKit/ ); },
            get safari5() { return ua.match( /Version\/5\./ ) && ua.match( /Safari\// ) && ua.match( /AppleWebKit/ ); },
            get safari6() { return ua.match( /Version\/6\./ ) && ua.match( /Safari\// ) && ua.match( /AppleWebKit/ ); },
            get safari7() { return ua.match( /Version\/7\./ ) && ua.match( /Safari\// ) && ua.match( /AppleWebKit/ ); },
        
            get ie9() { return isIE( 9 ); },
            get ie10() { return isIE( 10 ); },
            get ie11() { return isIE( 11 ); },
            get ie() { return ua.indexOf( 'MSIE' ) !== -1; },
        
            // from HomeScreen
            get android() { return ua.indexOf( 'Android' ) > 0; }
          };
        
          return core.platform;
        } );
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Mix-in for nodes that support a standard fill.
         *
         * TODO: pattern and gradient handling
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/nodes/Fillable',['require','SCENERY/scenery','PHET_CORE/platform'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          var platform = require( 'PHET_CORE/platform' );
          
          var isSafari5 = platform.safari5;
          
          scenery.Fillable = function Fillable( type ) {
            var proto = type.prototype;
            
            // this should be called in the constructor to initialize
            proto.initializeFillable = function() {
              this._fill = null;
              this._fillPickable = true;
              
              var that = this;
              this._fillListener = function() {
                that.invalidatePaint(); // TODO: move this to invalidateFill?
                that.invalidateFill();
              };
            };
            
            proto.hasFill = function() {
              return this._fill !== null;
            };
            
            proto.getFill = function() {
              return this._fill;
            };
            
            proto.setFill = function( fill ) {
              if ( this.getFill() !== fill ) {
                var hasInstances = this._instances.length > 0;
                
                if ( hasInstances && this._fill && this._fill.removeChangeListener ) {
                  this._fill.removeChangeListener( this._fillListener );
                }
                
                this._fill = fill;
                
                if ( hasInstances && this._fill && this._fill.addChangeListener ) {
                  this._fill.addChangeListener( this._fillListener );
                }
                
                this.invalidatePaint();
                
                this.invalidateFill();
              }
              return this;
            };
            
            proto.isFillPickable = function() {
              return this._fillPickable;
            };
            
            proto.setFillPickable = function( pickable ) {
              assert && assert( typeof pickable === 'boolean' );
              if ( this._fillPickable !== pickable ) {
                this._fillPickable = pickable;
                
                // TODO: better way of indicating that only the node under pointers could have changed, but no paint change is needed?
                this.invalidateFill();
              }
              return this;
            };
            
            var superFirstInstanceAdded = proto.firstInstanceAdded;
            proto.firstInstanceAdded = function() {
              if ( this._fill && this._fill.addChangeListener ) {
                this._fill.addChangeListener( this._fillListener );
              }
              
              if ( superFirstInstanceAdded ) {
                superFirstInstanceAdded.call( this );
              }
            };
            
            var superLastInstanceRemoved = proto.lastInstanceRemoved;
            proto.lastInstanceRemoved = function() {
              if ( this._fill && this._fill.removeChangeListener ) {
                this._fill.removeChangeListener( this._fillListener );
              }
              
              if ( superLastInstanceRemoved ) {
                superLastInstanceRemoved.call( this );
              }
            };
            
            proto.beforeCanvasFill = function( wrapper ) {
              wrapper.setFillStyle( this._fill );
              if ( this._fill.transformMatrix ) {
                wrapper.context.save();
                this._fill.transformMatrix.canvasAppendTransform( wrapper.context );
              }
            };
            
            proto.afterCanvasFill = function( wrapper ) {
              if ( this._fill.transformMatrix ) {
                wrapper.context.restore();
              }
            };
            
            proto.getSVGFillStyle = function() {
              var style = 'fill: ';
              if ( !this._fill ) {
                // no fill
                style += 'none;';
              } else if ( this._fill.toCSS ) {
                // Color object fill
                style += this._fill.toCSS() + ';';
              } else if ( this._fill.getSVGDefinition ) {
                // reference the SVG definition with a URL
                style += 'url(#fill' + this.getId() + ');';
              } else {
                // plain CSS color
                style += this._fill + ';';
              }
              return style;
            };
            
            proto.getCSSFill = function() {
              // if it's a Color object, get the corresponding CSS
              // 'transparent' will make us invisible if the fill is null
              return this._fill ? ( this._fill.toCSS ? this._fill.toCSS() : this._fill ) : 'transparent';
            };
            
            proto.addSVGFillDef = function( svg, defs ) {
              var fill = this.getFill();
              var fillId = 'fill' + this.getId();
              
              // add new definitions if necessary
              if ( fill && fill.getSVGDefinition ) {
                defs.appendChild( fill.getSVGDefinition( fillId ) );
              }
            };
            
            proto.removeSVGFillDef = function( svg, defs ) {
              var fillId = 'fill' + this.getId();
              
              // wipe away any old definition
              var oldFillDef = svg.getElementById( fillId );
              if ( oldFillDef ) {
                defs.removeChild( oldFillDef );
              }
            };
            
            proto.appendFillablePropString = function( spaces, result ) {
              if ( this._fill ) {
                if ( result ) {
                  result += ',\n';
                }
                if ( typeof this._fill === 'string' ) {
                  result += spaces + 'fill: \'' + this._fill + '\'';
                } else {
                  result += spaces + 'fill: ' + this._fill.toString();
                }
              }
              
              return result;
            };
            
            proto.getFillRendererBitmask = function() {
              var bitmask = 0;
              
              // Safari 5 has buggy issues with SVG gradients
              if ( !( isSafari5 && this._fill && this._fill.isGradient ) ) {
                bitmask |= scenery.bitmaskSupportsSVG;
              }
              
              // we always have Canvas support?
              bitmask |= scenery.bitmaskSupportsCanvas;
              
              if ( !this._fill ) {
                // if there is no fill, it is supported by DOM
                bitmask |= scenery.bitmaskSupportsDOM;
              } else if ( this._fill.isPattern ) {
                // no pattern support for DOM (for now!)
              } else if ( this._fill.isGradient ) {
                // no gradient support for DOM (for now!)
              } else {
                // solid fills always supported for DOM
                bitmask |= scenery.bitmaskSupportsDOM;
              }
              
              return bitmask;
            };
            
            // on mutation, set the fill parameter first
            proto._mutatorKeys = [ 'fill', 'fillPickable' ].concat( proto._mutatorKeys );
            
            Object.defineProperty( proto, 'fill', { set: proto.setFill, get: proto.getFill } );
            Object.defineProperty( proto, 'fillPickable', { set: proto.setFillPickable, get: proto.isFillPickable } );
            
            if ( proto.invalidateFill ) {
              var oldInvalidateFill = proto.invalidateFill;
              proto.invalidateFill = function() {
                this.invalidateSupportedRenderers();
                oldInvalidateFill.call( this );
              };
            } else {
              proto.invalidateFill = function() {
                this.invalidateSupportedRenderers();
              };
            }
          };
          var Fillable = scenery.Fillable;
          
          return Fillable;
        } );
        
        
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Mix-in for nodes that support a standard stroke.
         *
         * TODO: miterLimit handling
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/nodes/Strokable',['require','SCENERY/scenery','KITE/util/LineStyles','PHET_CORE/platform'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          var LineStyles = require( 'KITE/util/LineStyles' );
          
          var platform = require( 'PHET_CORE/platform' );
          
          var isIE9 = platform.ie9;
          
          scenery.Strokable = function Strokable( type ) {
            var proto = type.prototype;
            
            // this should be called in the constructor to initialize
            proto.initializeStrokable = function() {
              this._stroke = null;
              this._strokePickable = false;
              this._lineDrawingStyles = new LineStyles();
              
              var that = this;
              this._strokeListener = function() {
                that.invalidatePaint(); // TODO: move this to invalidateStroke?
                that.invalidateStroke();
              };
            };
            
            proto.hasStroke = function() {
              return this._stroke !== null;
            };
            
            // TODO: setting these properties looks like a good candidate for refactoring to lessen file size
            proto.getLineWidth = function() {
              return this._lineDrawingStyles.lineWidth;
            };
            
            proto.setLineWidth = function( lineWidth ) {
              if ( this.getLineWidth() !== lineWidth ) {
                this.markOldSelfPaint(); // since the previous line width may have been wider
                
                this._lineDrawingStyles.lineWidth = lineWidth;
                
                this.invalidateStroke();
              }
              return this;
            };
            
            proto.getLineCap = function() {
              return this._lineDrawingStyles.lineCap;
            };
            
            proto.setLineCap = function( lineCap ) {
              if ( this._lineDrawingStyles.lineCap !== lineCap ) {
                this.markOldSelfPaint();
                
                this._lineDrawingStyles.lineCap = lineCap;
                
                this.invalidateStroke();
              }
              return this;
            };
            
            proto.getLineJoin = function() {
              return this._lineDrawingStyles.lineJoin;
            };
            
            proto.setLineJoin = function( lineJoin ) {
              if ( this._lineDrawingStyles.lineJoin !== lineJoin ) {
                this.markOldSelfPaint();
                
                this._lineDrawingStyles.lineJoin = lineJoin;
                
                this.invalidateStroke();
              }
              return this;
            };
            
            proto.getLineDash = function() {
              return this._lineDrawingStyles.lineDash;
            };
            
            proto.hasLineDash = function() {
              return !!this._lineDrawingStyles.lineDash.length;
            };
            
            proto.setLineDash = function( lineDash ) {
              if ( this._lineDrawingStyles.lineDash !== lineDash ) {
                this.markOldSelfPaint();
                
                this._lineDrawingStyles.lineDash = lineDash || [];
                
                this.invalidateStroke();
              }
              return this;
            };
            
            proto.getLineDashOffset = function() {
              return this._lineDrawingStyles.lineDashOffset;
            };
            
            proto.setLineDashOffset = function( lineDashOffset ) {
              if ( this._lineDrawingStyles.lineDashOffset !== lineDashOffset ) {
                this.markOldSelfPaint();
                
                this._lineDrawingStyles.lineDashOffset = lineDashOffset;
                
                this.invalidateStroke();
              }
              return this;
            };
            
            proto.isStrokePickable = function() {
              return this._strokePickable;
            };
            
            proto.setStrokePickable = function( pickable ) {
              assert && assert( typeof pickable === 'boolean' );
              if ( this._strokePickable !== pickable ) {
                this._strokePickable = pickable;
                
                // TODO: better way of indicating that only the node under pointers could have changed, but no paint change is needed?
                this.invalidateStroke();
              }
              return this;
            };
            
            proto.setLineStyles = function( lineStyles ) {
              // TODO: since we have been using lineStyles as mutable for now, lack of change check is good here?
              this.markOldSelfPaint();
              
              this._lineDrawingStyles = lineStyles;
              this.invalidateStroke();
              return this;
            };
            
            proto.getLineStyles = function() {
              return this._lineDrawingStyles;
            };
            
            proto.getStroke = function() {
              return this._stroke;
            };
            
            proto.setStroke = function( stroke ) {
              if ( this.getStroke() !== stroke ) {
                // since this can actually change the bounds, we need to handle a few things differently than the fill
                this.markOldSelfPaint();
                
                var hasInstances = this._instances.length > 0;
                
                if ( hasInstances && this._stroke && this._stroke.removeChangeListener ) {
                  this._stroke.removeChangeListener( this._strokeListener );
                }
                
                this._stroke = stroke;
                
                if ( hasInstances && this._stroke && this._stroke.addChangeListener ) {
                  this._stroke.addChangeListener( this._strokeListener );
                }
                
                this.invalidateStroke();
              }
              return this;
            };
            
            var superFirstInstanceAdded = proto.firstInstanceAdded;
            proto.firstInstanceAdded = function() {
              if ( this._stroke && this._stroke.addChangeListener ) {
                this._stroke.addChangeListener( this._strokeListener );
              }
              
              if ( superFirstInstanceAdded ) {
                superFirstInstanceAdded.call( this );
              }
            };
            
            var superLastInstanceRemoved = proto.lastInstanceRemoved;
            proto.lastInstanceRemoved = function() {
              if ( this._stroke && this._stroke.removeChangeListener ) {
                this._stroke.removeChangeListener( this._strokeListener );
              }
              
              if ( superLastInstanceRemoved ) {
                superLastInstanceRemoved.call( this );
              }
            };
            
            proto.beforeCanvasStroke = function( wrapper ) {
              // TODO: is there a better way of not calling so many things on each stroke?
              wrapper.setStrokeStyle( this._stroke );
              wrapper.setLineWidth( this.getLineWidth() );
              wrapper.setLineCap( this.getLineCap() );
              wrapper.setLineJoin( this.getLineJoin() );
              wrapper.setLineDash( this.getLineDash() );
              wrapper.setLineDashOffset( this.getLineDashOffset() );
              if ( this._stroke.transformMatrix ) {
                wrapper.context.save();
                this._stroke.transformMatrix.canvasAppendTransform( wrapper.context );
              }
            };
            
            proto.afterCanvasStroke = function( wrapper ) {
              if ( this._stroke.transformMatrix ) {
                wrapper.context.restore();
              }
            };
            
            proto.getSVGStrokeStyle = function() {
              if ( !this._stroke ) {
                // no stroke
                return 'stroke: none;';
              }
              
              var style = 'stroke: ';
              if ( this._stroke.toCSS ) {
                // Color object stroke
                style += this._stroke.toCSS() + ';';
              } else if ( this._stroke.getSVGDefinition ) {
                // reference the SVG definition with a URL
                style += 'url(#stroke' + this.getId() + ');';
              } else {
                // plain CSS color
                style += this._stroke + ';';
              }
              
              // TODO: don't include unnecessary directives? - is it worth any branching cost?
              style += 'stroke-width: ' + this.getLineWidth() + ';';
              style += 'stroke-linecap: ' + this.getLineCap() + ';';
              style += 'stroke-linejoin: ' + this.getLineJoin() + ';';
              if ( this.hasLineDash() ) {
                style += 'stroke-dasharray: ' + this.getLineDash().join( ',' ) + ';';
                style += 'stroke-dashoffset: ' + this.getLineDashOffset() + ';';
              }
              
              return style;
            };
            
            // if we have to apply a transform workaround for https://github.com/phetsims/scenery/issues/196 (only when we have a pattern or gradient)
            proto.requiresSVGBoundsWorkaround = function() {
              if ( !this._stroke || !this._stroke.getSVGDefinition ) {
                return false;
              }
              
              var bounds = this.computeShapeBounds( false ); // without stroke
              return bounds.x * bounds.y === 0; // at least one of them was zero, so the bounding box has no area
            };
            
            proto.getSimpleCSSFill = function() {
              // if it's a Color object, get the corresponding CSS
              // 'transparent' will make us invisible if the fill is null
              return this._stroke ? ( this._stroke.toCSS ? this._stroke.toCSS() : this._stroke ) : 'transparent';
            };
            
            proto.addSVGStrokeDef = function( svg, defs ) {
              var stroke = this.getStroke();
              var strokeId = 'stroke' + this.getId();
              
              // add new definitions if necessary
              if ( stroke && stroke.getSVGDefinition ) {
                defs.appendChild( stroke.getSVGDefinition( strokeId ) );
              }
            };
            
            proto.removeSVGStrokeDef = function( svg, defs ) {
              var strokeId = 'stroke' + this.getId();
              
              // wipe away any old definition
              var oldStrokeDef = svg.getElementById( strokeId );
              if ( oldStrokeDef ) {
                defs.removeChild( oldStrokeDef );
              }
            };
            
            proto.appendStrokablePropString = function( spaces, result ) {
              var self = this;
              
              function addProp( key, value, nowrap ) {
                if ( result ) {
                  result += ',\n';
                }
                if ( !nowrap && typeof value === 'string' ) {
                  result += spaces + key + ': \'' + value + '\'';
                } else {
                  result += spaces + key + ': ' + value;
                }
              }
              
              if ( this._stroke ) {
                var defaultStyles = new LineStyles();
                if ( typeof this._stroke === 'string' ) {
                  addProp( 'stroke', this._stroke );
                } else {
                  addProp( 'stroke', this._stroke.toString(), true );
                }
                
                _.each( [ 'lineWidth', 'lineCap', 'lineJoin', 'lineDashOffset' ], function( prop ) {
                  if ( self[prop] !== defaultStyles[prop] ) {
                    addProp( prop, self[prop] );
                  }
                } );
                
                if ( this.lineDash.length ) {
                  addProp( 'lineDash', JSON.stringify( this.lineDash ), true );
                }
              }
              
              return result;
            };
            
            proto.getStrokeRendererBitmask = function() {
              var bitmask = 0;
              
              if ( !( isIE9 && this.hasStroke() && this.hasLineDash() ) ) {
                bitmask |= scenery.bitmaskSupportsCanvas;
              }
              
              // always have SVG support (for now?)
              bitmask |= scenery.bitmaskSupportsSVG;
              
              if ( !this.hasStroke() ) {
                // allow DOM support if there is no stroke
                bitmask |= scenery.bitmaskSupportsDOM;
              }
              
              return bitmask;
            };
            
            // on mutation, set the stroke parameters first since they may affect the bounds (and thus later operations)
            proto._mutatorKeys = [ 'stroke', 'lineWidth', 'lineCap', 'lineJoin', 'lineDash', 'lineDashOffset', 'strokePickable' ].concat( proto._mutatorKeys );
            
            // TODO: miterLimit support?
            Object.defineProperty( proto, 'stroke', { set: proto.setStroke, get: proto.getStroke } );
            Object.defineProperty( proto, 'lineWidth', { set: proto.setLineWidth, get: proto.getLineWidth } );
            Object.defineProperty( proto, 'lineCap', { set: proto.setLineCap, get: proto.getLineCap } );
            Object.defineProperty( proto, 'lineJoin', { set: proto.setLineJoin, get: proto.getLineJoin } );
            Object.defineProperty( proto, 'lineDash', { set: proto.setLineDash, get: proto.getLineDash } );
            Object.defineProperty( proto, 'lineDashOffset', { set: proto.setLineDashOffset, get: proto.getLineDashOffset } );
            Object.defineProperty( proto, 'strokePickable', { set: proto.setStrokePickable, get: proto.isStrokePickable } );
            
            if ( proto.invalidateStroke ) {
              var oldInvalidateStroke = proto.invalidateStroke;
              proto.invalidateStroke = function() {
                this.invalidateSupportedRenderers();
                oldInvalidateStroke.call( this );
              };
            } else {
              proto.invalidateStroke = function() {
                this.invalidateSupportedRenderers();
              };
            }
          };
          var Strokable = scenery.Strokable;
          
          return Strokable;
        } );
        
        
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * A Path draws a Shape with a specific type of fill and stroke.
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/nodes/Path',['require','PHET_CORE/inherit','KITE/Shape','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/layers/Renderer','SCENERY/nodes/Fillable','SCENERY/nodes/Strokable'],function( require ) {
          
          
          var inherit = require( 'PHET_CORE/inherit' );
          var Shape = require( 'KITE/Shape' );
        
          var scenery = require( 'SCENERY/scenery' );
          var Node = require( 'SCENERY/nodes/Node' );
          require( 'SCENERY/layers/Renderer' );
          var Fillable = require( 'SCENERY/nodes/Fillable' );
          var Strokable = require( 'SCENERY/nodes/Strokable' );
        
          scenery.Path = function Path( shape, options ) {
            // TODO: consider directly passing in a shape object (or at least handling that case)
            // NOTE: _shape can be lazily constructed, in the case of types like Rectangle where they have their own drawing code
            this._shape = null;
            this._strokedShape = null; // a stroked copy of the shape, lazily computed
        
            // ensure we have a parameter object
            options = options || {};
            
            this.initializeFillable();
            this.initializeStrokable();
        
            Node.call( this );
            this.invalidateSupportedRenderers();
            this.setShape( shape );
            this.mutate( options );
          };
          var Path = scenery.Path;
          
          inherit( Node, Path, {
            // allow more specific path types (Rectangle, Line) to override what restrictions we have
            getPathRendererBitmask: function() {
              return scenery.bitmaskSupportsCanvas | scenery.bitmaskSupportsSVG;
            },
            
            invalidateSupportedRenderers: function() {
              this.setRendererBitmask( this.getFillRendererBitmask() & this.getStrokeRendererBitmask() & this.getPathRendererBitmask() );
            },
            
            // sets the shape drawn, or null to remove the shape
            setShape: function( shape ) {
              if ( this._shape !== shape ) {
                if ( typeof shape === 'string' ) {
                  // be content with setShape always invalidating the shape?
                  shape = new Shape( shape );
                }
                this._shape = shape;
                this.invalidateShape();
              }
              return this;
            },
            
            getShape: function() {
              return this._shape;
            },
            
            getStrokedShape: function() {
              if ( !this._strokedShape ) {
                this._strokedShape = this.getShape().getStrokedShape( this._lineDrawingStyles );
              }
              return this._strokedShape;
            },
            
            invalidateShape: function() {
              this.markOldSelfPaint();
              
              this._strokedShape = null;
              
              if ( this.hasShape() ) {
                this.invalidateSelf( this.computeShapeBounds() );
                this.invalidatePaint();
              }
            },
            
            // separated out, so that we can override this with a faster version in subtypes. includes the Stroke, if any
            computeShapeBounds: function() {
              return this._stroke ? this.getStrokedShape().bounds : this.getShape().bounds;
            },
        
            // @override
            getTransformedSelfBounds: function( matrix ) {
              return ( this._stroke ? this.getStrokedShape() : this.getShape() ).getBoundsWithTransform( matrix );
            },
            
            // hook stroke mixin changes to invalidation
            invalidateStroke: function() {
              this.invalidateShape();
            },
            
            hasShape: function() {
              return this._shape;
            },
            
            paintCanvas: function( wrapper ) {
              var context = wrapper.context;
              
              if ( this.hasShape() ) {
                // TODO: fill/stroke delay optimizations?
                context.beginPath();
                this._shape.writeToContext( context );
        
                if ( this._fill ) {
                  this.beforeCanvasFill( wrapper ); // defined in Fillable
                  context.fill();
                  this.afterCanvasFill( wrapper ); // defined in Fillable
                }
                if ( this._stroke ) {
                  this.beforeCanvasStroke( wrapper ); // defined in Strokable
                  context.stroke();
                  this.afterCanvasStroke( wrapper ); // defined in Strokable
                }
              }
            },
            
            paintWebGL: function( state ) {
              throw new Error( 'Path.prototype.paintWebGL unimplemented' );
            },
            
            // svg element, the <defs> block, and the associated group for this node's transform
            createSVGFragment: function( svg, defs, group ) {
              return document.createElementNS( scenery.svgns, 'path' );
            },
            
            updateSVGFragment: function( path ) {
              var svgPath = this.hasShape() ? this._shape.getSVGPath() : "";
              
              // temporary workaround for https://bugs.webkit.org/show_bug.cgi?id=78980
              // and http://code.google.com/p/chromium/issues/detail?id=231626 where even removing
              // the attribute can cause this bug
              if ( !svgPath ) { svgPath = 'M0 0'; }
              
              if ( svgPath ) {
                // only set the SVG path if it's not the empty string
                path.setAttribute( 'd', svgPath );
              } else if ( path.hasAttribute( 'd' ) ) {
                path.removeAttribute( 'd' );
              }
              
              path.setAttribute( 'style', this.getSVGFillStyle() + this.getSVGStrokeStyle() );
            },
            
            // support patterns, gradients, and anything else we need to put in the <defs> block
            updateSVGDefs: function( svg, defs ) {
              // remove old definitions if they exist
              this.removeSVGDefs( svg, defs );
              
              // add new ones if applicable
              this.addSVGFillDef( svg, defs );
              this.addSVGStrokeDef( svg, defs );
              
              assert && assert( !this.requiresSVGBoundsWorkaround(), 'No workaround for https://github.com/phetsims/scenery/issues/196 is provided at this time, please add an epsilon' );
            },
            
            // cleans up references created with udpateSVGDefs()
            removeSVGDefs: function( svg, defs ) {
              this.removeSVGFillDef( svg, defs );
              this.removeSVGStrokeDef( svg, defs );
            },
            
            isPainted: function() {
              return true;
            },
            
            // override for computation of whether a point is inside the self content
            // point is considered to be in the local coordinate frame
            containsPointSelf: function( point ) {
              var result = false;
              if ( !this.hasShape() ) {
                return result;
              }
              
              // if this node is fillPickable, we will return true if the point is inside our fill area
              if ( this._fillPickable ) {
                result = this.getShape().containsPoint( point );
              }
              
              // also include the stroked region in the hit area if strokePickable
              if ( !result && this._strokePickable ) {
                result = this.getStrokedShape().containsPoint( point );
              }
              return result;
            },
            
            // whether this node's self intersects the specified bounds, in the local coordinate frame
            intersectsBoundsSelf: function( bounds ) {
              // TODO: should a shape's stroke be included?
              return this.hasShape() ? this._shape.intersectsBounds( bounds ) : false;
            },
            
            set shape( value ) { this.setShape( value ); },
            get shape() { return this.getShape(); },
            
            getBasicConstructor: function( propLines ) {
              return 'new scenery.Path( ' + ( this._shape ? this._shape.toString() : this._shape ) + ', {' + propLines + '} )';
            },
            
            getPropString: function( spaces, includeChildren ) {
              var result = Node.prototype.getPropString.call( this, spaces, includeChildren );
              result = this.appendFillablePropString( spaces, result );
              result = this.appendStrokablePropString( spaces, result );
              return result;
            }
          } );
          
          Path.prototype._mutatorKeys = [ 'shape' ].concat( Node.prototype._mutatorKeys );
          
          // mix in fill/stroke handling code. for now, this is done after 'shape' is added to the mutatorKeys so that stroke parameters
          // get set first
          /* jshint -W064 */
          Fillable( Path );
          Strokable( Path );
          
          return Path;
        } );
        
        
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Escaping of HTML content that will be placed in the body, inside an element as a node.
         *
         * This is NOT for escaping something in other HTML contexts, for example as an attribute value
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        define( 'PHET_CORE/escapeHTML',['require','PHET_CORE/core'],function( require ) {
          
        
          var core = require( 'PHET_CORE/core' );
        
          core.escapeHTML = function escapeHTML( str ) {
            // see https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet
            // HTML Entity Encoding
            return str
              .replace( /&/g, '&amp;' )
              .replace( /</g, '&lt;' )
              .replace( />/g, '&gt;' )
              .replace( /\"/g, '&quot;' )
              .replace( /\'/g, '&#x27;' )
              .replace( /\//g, '&#x2F;' );
          };
          return core.escapeHTML;
        } );
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Font handling for text drawing
         *
         * Examples:
         * new scenery.Font().font                      // "10px sans-serif" (the default)
         * new scenery.Font( { family: 'serif' } ).font // "10px serif"
         * new scenery.Font( { weight: 'bold' } ).font  // "bold 10px sans-serif"
         * new scenery.Font( { size: 16 } ).font        // "16px sans-serif"
         * var font = new scenery.Font( {
         *   family: '"Times New Roman", serif',
         *   style: 'italic',
         *   lineHeight: 10
         * } );
         * font.font;                                   // "italic 10px/10 'Times New Roman', serif"
         * font.family;                                 // "'Times New Roman', serif"
         * font.weight;                                 // 400 (the default)
         *
         * Useful specs:
         * http://www.w3.org/TR/css3-fonts/
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/util/Font',['require','SCENERY/scenery'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          
          // constants used for detection (since styles/variants/weights/stretches can be mixed in the preamble of the shorthand string)
          var styles = [ 'normal', 'italic', 'oblique' ];
          var variants = [ 'normal', 'small-caps' ];
          var weights = [ 'normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '700', '800', '900' ];
          var stretches = [ 'normal', 'ultra-condensed', 'extra-condensed', 'condensed', 'semi-condensed', 'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded' ];
          
          function castSize( size ) {
            if ( typeof size === 'number' ) {
              return size + 'px'; // add the pixels suffix by default for numbers
            } else {
              return size; // assume that it's a valid to-spec string
            }
          }
          
          scenery.Font = function Font( options ) {
            // options from http://www.w3.org/TR/css3-fonts/
            this._style = 'normal';      // normal | italic | oblique
            this._variant = 'normal';    // normal | small-caps
            this._weight = 'normal';     // normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900
            this._stretch = 'normal';    // normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded
            this._size = '10px';         // <absolute-size> | <relative-size> | <length> | <percentage> -- unitless number interpreted as px. absolute suffixes: cm, mm, in, pt, pc, px. relative suffixes: em, ex, ch, rem, vw, vh, vmin, vmax.
            this._lineHeight = 'normal'; // normal | <number> | <length> | <percentage> -- NOTE: Canvas spec forces line-height to normal
            this._family = 'sans-serif'; // comma-separated list of families, including generic families (serif, sans-serif, cursive, fantasy, monospace). ideally escape with double-quotes
            
            // font  [ [ <‘font-style’> || <font-variant-css21> || <‘font-weight’> || <‘font-stretch’> ]? <‘font-size’> [ / <‘line-height’> ]? <‘font-family’> ] | caption | icon | menu | message-box | small-caption | status-bar
            // <font-variant-css21> = [normal | small-caps]
            
            var type = typeof options;
            if ( type === 'string' ) {
              // parse a somewhat proper CSS3 form (not guaranteed to handle it precisely the same as browsers yet)
              
              // split based on whitespace allowed by CSS spec (more restrictive than regular regexp whitespace)
              var tokens = _.filter( options.split( /[\x09\x0A\x0C\x0D\x20]/ ), function( token ) { return token.length > 0; } );
              
              // pull tokens out until we reach something that doesn't match. that must be the font size (according to spec)
              for ( var i = 0; i < tokens.length; i++ ) {
                var token = tokens[i];
                if ( token === 'normal' ) {
                  // nothing has to be done, everything already normal as default
                } else if ( _.contains( styles, token ) ) {
                  assert && assert( this._style === 'normal', 'Style cannot be applied twice. Already set to "' + this._style + '", attempt to replace with "' + token + '"' );
                  this._style = token;
                } else if ( _.contains( variants, token ) ) {
                  assert && assert( this._variant === 'normal', 'Variant cannot be applied twice. Already set to "' + this._variant + '", attempt to replace with "' + token + '"' );
                  this._variant = token;
                } else if ( _.contains( weights, token ) ) {
                  assert && assert( this._weight === 'normal', 'Weight cannot be applied twice. Already set to "' + this._weight + '", attempt to replace with "' + token + '"' );
                  this._weight = token;
                } else if ( _.contains( stretches, token ) ) {
                  assert && assert( this._stretch === 'normal', 'Stretch cannot be applied twice. Already set to "' + this._stretch + '", attempt to replace with "' + token + '"' );
                  this._stretch = token;
                } else {
                  // not a style/variant/weight/stretch, must be a font size, possibly with an included line-height
                  var subtokens = token.split( /\// ); // extract font size from any line-height
                  this._size = subtokens[0];
                  if ( subtokens[1] ) {
                    this._lineHeight = subtokens[1];
                  }
                  // all future tokens are guaranteed to be part of the font-family if it is given according to spec
                  this._family = tokens.slice( i + 1 ).join( ' ' );
                  break;
                }
              }
            } else if ( type === 'object' ) {
              if ( options.style !== undefined ) {
                this._style = options.style;
              }
              if ( options.variant !== undefined ) {
                this._variant = options.variant;
              }
              if ( options.weight !== undefined ) {
                this._weight = '' + options.weight; // cast it to a string explicitly
              }
              if ( options.stretch !== undefined ) {
                this._stretch = options.stretch;
              }
              if ( options.size !== undefined ) {
                this._size = castSize( options.size );
              }
              if ( options.lineHeight !== undefined ) {
                this._lineHeight = options.lineHeight;
              }
              if ( options.family !== undefined ) {
                this._family = options.family;
              }
            }
            
            // sanity checks to prevent errors in interpretation or in the font shorthand usage
            assert && assert( typeof this._style === 'string' &&
                                            _.contains( styles, this._style ),
                                            'Font style must be one of "normal", "italic", or "oblique"' );
            assert && assert( typeof this._variant === 'string' &&
                                            _.contains( variants, this._variant ),
                                            'Font variant must be "normal" or "small-caps"' );
            assert && assert( typeof this._weight === 'string' &&
                                            _.contains( weights, this._weight ),
                                            'Font weight must be one of "normal", "bold", "bolder", "lighter", "100", "200", "300", "400", "500", "600", "700", "800", or "900"' );
            assert && assert( typeof this._stretch === 'string' &&
                                            _.contains( stretches, this._stretch ),
                                            'Font stretch must be one of "normal", "ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "semi-expanded", "expanded", "extra-expanded", or "ultra-expanded"' );
            assert && assert( typeof this._size === 'string' &&
                                            !_.contains( [ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' ], this._size[this._size.length - 1] ),
                                            'Font size must be either passed as a number (not a string, interpreted as px), or must contain a suffix for percentage, absolute or relative units, or an explicit size constant' );
            assert && assert( typeof this._lineHeight === 'string' );
            assert && assert( typeof this._family === 'string' );
            
            // initialize the shorthand font property (stored as _font)
            this._font = this.computeShorthand();
            
            phetAllocation && phetAllocation( 'Font' );
          };
          var Font = scenery.Font;
          
          Font.prototype = {
            constructor: Font,
            
            getFont:       function() { return this._font; },
            getStyle:      function() { return this._style; },
            getVariant:    function() { return this._variant; },
            getWeight:     function() { return this._weight; },
            getStretch:    function() { return this._stretch; },
            getSize:       function() { return this._size; },
            getLineHeight: function() { return this._lineHeight; },
            getFamily:     function() { return this._family; },
            
            get font()       { return this.getFont(); },
            get style()      { return this.getStyle(); },
            get variant()    { return this.getVariant(); },
            get weight()     { return this.getWeight(); },
            get stretch()    { return this.getStretch(); },
            get size()       { return this.getSize(); },
            get lineHeight() { return this.getLineHeight(); },
            get family()     { return this.getFamily(); },
            
            copy: function( options ) {
              return new Font( _.extend( {
                style: this._style,
                variant: this._variant,
                weight: this._weight,
                stretch: this._stretch,
                size: this._size,
                lineHeight: this._lineHeight,
                family: this._family
              }, options ) );
            },
            
            computeShorthand: function() {
              var ret = '';
              if ( this._style !== 'normal' ) { ret += this._style + ' '; }
              if ( this._variant !== 'normal' ) { ret += this._variant + ' '; }
              if ( this._weight !== 'normal' ) { ret += this._weight + ' '; }
              if ( this._stretch !== 'normal' ) { ret += this._stretch + ' '; }
              ret += this._size;
              if ( this._lineHeight !== 'normal' ) { ret += '/' + this._lineHeight; }
              ret += ' ' + this._family;
              return ret;
            },
            
            toCSS: function() {
              return this.getFont();
            }
          };
          
          Font.DEFAULT = new Font();
          
          return Font;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Text
         *
         * TODO: newlines (multiline)
         * TODO: htmlText support (and DOM renderer)
         * TODO: don't get bounds until the Text node is fully mutated?
         * TODO: remove some support for centering, since Scenery's Node already handles that better?
         *
         * Useful specs:
         * http://www.w3.org/TR/css3-text/
         * http://www.w3.org/TR/css3-fonts/
         * http://www.w3.org/TR/SVG/text.html
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/nodes/Text',['require','PHET_CORE/inherit','PHET_CORE/escapeHTML','DOT/Bounds2','DOT/Matrix3','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/layers/Renderer','SCENERY/nodes/Fillable','SCENERY/nodes/Strokable','SCENERY/util/Font','SCENERY/util/Util'],function( require ) {
          
          
          var inherit = require( 'PHET_CORE/inherit' );
          var escapeHTML = require( 'PHET_CORE/escapeHTML' );
          var Bounds2 = require( 'DOT/Bounds2' );
          var Matrix3 = require( 'DOT/Matrix3' );
          
          var scenery = require( 'SCENERY/scenery' );
          
          var Node = require( 'SCENERY/nodes/Node' ); // inherits from Node
          require( 'SCENERY/layers/Renderer' );
          var Fillable = require( 'SCENERY/nodes/Fillable' );
          var Strokable = require( 'SCENERY/nodes/Strokable' );
          require( 'SCENERY/util/Font' );
          require( 'SCENERY/util/Util' ); // for canvasAccurateBounds and CSS transforms
          
          var textSizeContainerId = 'sceneryTextSizeContainer';
          var textSizeElementId = 'sceneryTextSizeElement';
          var svgTextSizeContainer = document.getElementById( textSizeContainerId );
          var svgTextSizeElement = document.getElementById( textSizeElementId );
          
          if ( !svgTextSizeContainer ) {
            // set up the container and text for testing text bounds quickly (using approximateSVGBounds)
            svgTextSizeContainer = document.createElementNS( scenery.svgns, 'svg' );
            svgTextSizeContainer.setAttribute( 'width', '2' );
            svgTextSizeContainer.setAttribute( 'height', '2' );
            svgTextSizeContainer.setAttribute( 'id', textSizeContainerId );
            svgTextSizeContainer.setAttribute( 'style', 'visibility: hidden; pointer-events: none; position: absolute; left: -65535; right: -65535;' ); // so we don't flash it in a visible way to the user
          }
          // NOTE! copies createSVGElement
          if ( !svgTextSizeElement ) {
            svgTextSizeElement = document.createElementNS( scenery.svgns, 'text' );
            svgTextSizeElement.appendChild( document.createTextNode( '' ) );
            svgTextSizeElement.setAttribute( 'dominant-baseline', 'alphabetic' ); // to match Canvas right now
            svgTextSizeElement.setAttribute( 'text-rendering', 'geometricPrecision' );
            svgTextSizeElement.setAttribute( 'lengthAdjust', 'spacingAndGlyphs' );
            svgTextSizeElement.setAttribute( 'id', textSizeElementId );
            svgTextSizeContainer.appendChild( svgTextSizeElement );
          }
          
          // SVG bounds seems to be malfunctioning for Safari 5. Since we don't have a reproducible test machine for
          // fast iteration, we'll guess the user agent and use DOM bounds instead of SVG.
          // Hopefully the two contraints rule out any future Safari versions (fairly safe, but not impossible!)
          var useDOMAsFastBounds = window.navigator.userAgent.indexOf( 'like Gecko) Version/5' ) !== -1 &&
                                   window.navigator.userAgent.indexOf( 'Safari/' ) !== -1;
          
          var hybridTextNode; // a node that is used to measure SVG text top/height for hybrid caching purposes
          var initializingHybridTextNode = false;
          
          scenery.Text = function Text( text, options ) {
            this._text         = '';                   // filled in with mutator
            this._font         = scenery.Font.DEFAULT; // default font, usually 10px sans-serif
            this._direction    = 'ltr';                // ltr, rtl, inherit -- consider inherit deprecated, due to how we compute text bounds in an off-screen canvas
            this._boundsMethod = 'hybrid';             // fast (SVG/DOM, no canvas rendering allowed), fastCanvas (SVG/DOM, canvas rendering allowed without dirty regions),
                                                       // accurate (Canvas accurate recursive), or hybrid (cache SVG height, use canvas measureText for width)
            
            // whether the text is rendered as HTML or not. if defined (in a subtype constructor), use that value instead
            this._isHTML = this._isHTML === undefined ? false : this._isHTML;
            
            // ensure we have a parameter object
            options = options || {};
            
            // default to black filled text
            if ( options.fill === undefined ) {
              options.fill = '#000000';
            }
            
            if ( text !== undefined ) {
              // set the text parameter so that setText( text ) is effectively called in the mutator from the super call
              options.text = text;
            }
            
            this.initializeFillable();
            this.initializeStrokable();
            
            Node.call( this, options );
            this.updateTextFlags(); // takes care of setting up supported renderers
          };
          var Text = scenery.Text;
          
          inherit( Node, Text, {
            domUpdateTransformOnRepaint: true, // since we have to integrate the baseline offset into the CSS transform, signal to DOMLayer
            
            setText: function( text ) {
              assert && assert( text !== null && text !== undefined, 'Text should be defined and non-null. Use the empty string if needed.' );
              
              // cast it to a string (for numbers, etc.)
              text = '' + text;
              
              if ( text !== this._text ) {
                this._text = text;
                this.invalidateText();
              }
              return this;
            },
            
            getText: function() {
              return this._text;
            },
            
            // Using the non-breaking space (&nbsp;) encoded as 0x00A0 in UTF-8
            getNonBreakingText: function() {
              return this._text.replace( ' ', '\xA0' );
            },
            
            setBoundsMethod: function( method ) {
              assert && assert( method === 'fast' || method === 'fastCanvas' || method === 'accurate' || method === 'hybrid', 'Unknown Text boundsMethod' );
              if ( method !== this._boundsMethod ) {
                this._boundsMethod = method;
                this.updateTextFlags();
                this.dispatchEvent( 'boundsAccuracy', { node: this } ); // TODO: consider standardizing this, or attaching listeners in a different manner?
                this.invalidateText();
              }
              return this;
            },
            
            getBoundsMethod: function() {
              return this._boundsMethod;
            },
            
            // allow more specific path types (Rectangle, Line) to override what restrictions we have
            getTextRendererBitmask: function() {
              var bitmask = 0;
              
              // canvas support (fast bounds may leak out of dirty rectangles)
              if ( this._boundsMethod !== 'fast' && !this._isHTML ) {
                bitmask |= scenery.bitmaskSupportsCanvas;
              }
              if( !this._isHTML ) {
                bitmask |= scenery.bitmaskSupportsSVG;
              }
              
              // fill and stroke will determine whether we have DOM text support
              bitmask |= scenery.bitmaskSupportsDOM;
              
              return bitmask;
            },
            
            invalidateSupportedRenderers: function() {
              this.setRendererBitmask( this.getFillRendererBitmask() & this.getStrokeRendererBitmask() & this.getTextRendererBitmask() );
            },
            
            updateTextFlags: function() {
              this.boundsInaccurate = this._boundsMethod !== 'accurate';
              this.invalidateSupportedRenderers();
            },
            
            invalidateText: function() {
              // investigate http://mudcu.be/journal/2011/01/html5-typographic-metrics/
              if ( this._isHTML || ( useDOMAsFastBounds && this._boundsMethod !== 'accurate' ) ) {
                this.invalidateSelf( this.approximateDOMBounds() );
              } else if ( this._boundsMethod === 'hybrid' ) {
                this.invalidateSelf( this.approximateHybridBounds() );
              } else if ( this._boundsMethod === 'fast' || this._boundsMethod === 'fastCanvas' ) {
                this.invalidateSelf( this.approximateSVGBounds() );
              } else {
                this.invalidateSelf( this.accurateCanvasBounds() );
              }
              
              // we may have changed renderers if parameters were changed!
              this.updateTextFlags();
            },
            
            // overrides from Strokable
            invalidateStroke: function() {
              // stroke can change both the bounds and renderer
              this.invalidateText();
            },
            
            // overrides from Fillable
            invalidateFill: function() {
              // fill type can change the renderer (gradient/fill not supported by DOM)
              this.invalidateText();
            },
            
            /*---------------------------------------------------------------------------*
            * Canvas support
            *----------------------------------------------------------------------------*/
            
            paintCanvas: function( wrapper ) {
              var context = wrapper.context;
              
              // extra parameters we need to set, but should avoid setting if we aren't drawing anything
              if ( this.hasFill() || this.hasStroke() ) {
                wrapper.setFont( this._font.getFont() );
                wrapper.setDirection( this._direction );
              }
              
              if ( this.hasFill() ) {
                this.beforeCanvasFill( wrapper ); // defined in Fillable
                context.fillText( this._text, 0, 0 );
                this.afterCanvasFill( wrapper ); // defined in Fillable
              }
              if ( this.hasStroke() ) {
                this.beforeCanvasStroke( wrapper ); // defined in Strokable
                context.strokeText( this._text, 0, 0 );
                this.afterCanvasStroke( wrapper ); // defined in Strokable
              }
            },
            
            /*---------------------------------------------------------------------------*
            * WebGL support
            *----------------------------------------------------------------------------*/
            
            paintWebGL: function( state ) {
              throw new Error( 'Text.prototype.paintWebGL unimplemented' );
            },
            
            /*---------------------------------------------------------------------------*
            * SVG support
            *----------------------------------------------------------------------------*/
            
            createSVGFragment: function( svg, defs, group ) {
              // NOTE! reference SVG element at top of file copies createSVGElement!
              var element = document.createElementNS( scenery.svgns, 'text' );
              element.appendChild( document.createTextNode( '' ) );
              element.setAttribute( 'dominant-baseline', 'alphabetic' ); // to match Canvas right now
              element.setAttribute( 'text-rendering', 'geometricPrecision' );
              element.setAttribute( 'lengthAdjust', 'spacingAndGlyphs' );
              element.setAttributeNS( 'http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve' );
              return element;
            },
            
            updateSVGFragment: function( element ) {
              // update the text-node's value
              element.lastChild.nodeValue = this.getNonBreakingText();
              
              element.setAttribute( 'style', this.getSVGFillStyle() + this.getSVGStrokeStyle() );
              element.setAttribute( 'direction', this._direction );
              
              // text length correction, tested with scenery/tests/text-quality-test.html to determine how to match Canvas/SVG rendering (and overall length)
              if ( isFinite( this._selfBounds.width ) ) {
                element.setAttribute( 'textLength', this._selfBounds.width );
              }
              
              // set all of the font attributes, since we can't use the combined one
              // TODO: optimize so we only set what is changed!!!
              element.setAttribute( 'font-family', this._font.getFamily() );
              element.setAttribute( 'font-size', this._font.getSize() );
              element.setAttribute( 'font-style', this._font.getStyle() );
              element.setAttribute( 'font-weight', this._font.getWeight() );
              element.setAttribute( 'font-stretch', this._font.getStretch() );
            },
            
            // support patterns, gradients, and anything else we need to put in the <defs> block
            updateSVGDefs: function( svg, defs ) {
              // remove old definitions if they exist
              this.removeSVGDefs( svg, defs );
              
              // add new ones if applicable
              this.addSVGFillDef( svg, defs );
              this.addSVGStrokeDef( svg, defs );
            },
            
            // cleans up references created with udpateSVGDefs()
            removeSVGDefs: function( svg, defs ) {
              this.removeSVGFillDef( svg, defs );
              this.removeSVGStrokeDef( svg, defs );
            },
            
            /*---------------------------------------------------------------------------*
            * DOM support
            *----------------------------------------------------------------------------*/
            
            allowsMultipleDOMInstances: true,
            
            getDOMElement: function() {
              var div = document.createElement( 'div' );
              
              // so they are absolutely positioned compared to the containing DOM layer (that is positioned).
              // otherwise, two adjacent HTMLText elements will 'flow' and be positioned incorrectly
              div.style.position = 'absolute';
              return div;
            },
            
            updateDOMElement: function( div ) {
              var $div = $( div );
              div.style.font = this.getFont();
              div.style.color = this.getCSSFill();
              $div.width( this.getSelfBounds().width );
              $div.height( this.getSelfBounds().height );
              $div.empty(); // remove all children, including previously-created text nodes
              div.appendChild( this.getDOMTextNode() );
              div.setAttribute( 'dir', this._direction );
            },
            
            updateCSSTransform: function( transform, element ) {
              // since the DOM origin of the text is at the upper-left, and our Scenery origin is at the lower-left, we need to
              // shift the text vertically, postmultiplied with the entire transform.
              var yOffset = this.getSelfBounds().minY;
              var matrix = transform.getMatrix().timesMatrix( Matrix3.translation( 0, yOffset ) );
              scenery.Util.applyCSSTransform( matrix, element );
            },
            
            // a DOM node (not a Scenery DOM node, but an actual DOM node) with the text
            getDOMTextNode: function() {
              if ( this._isHTML ) {
                var span = document.createElement( 'span' );
                span.innerHTML = this._text;
                return span;
              } else {
                return document.createTextNode( this.getNonBreakingText() );
              }
            },
            
            /*---------------------------------------------------------------------------*
            * Bounds
            *----------------------------------------------------------------------------*/
            
            accurateCanvasBounds: function() {
              var node = this;
              var svgBounds = this.approximateSVGBounds(); // this seems to be slower than expected, mostly due to Font getters
        
              //If svgBounds are zero, then return the zero bounds
              if ( !this._text || svgBounds.width === 0 ) {
                return svgBounds;
              }
              return scenery.Util.canvasAccurateBounds( function( context ) {
                context.font = node.font;
                context.direction = node.direction;
                context.fillText( node.text, 0, 0 );
              }, {
                precision: 0.5,
                resolution: 128,
                initialScale: 32 / Math.max( Math.abs( svgBounds.minX ), Math.abs( svgBounds.minY ), Math.abs( svgBounds.maxX ), Math.abs( svgBounds.maxY ) )
              } );
            },
            
            approximateCanvasWidth: function() {
              var context = scenery.scratchContext;
              context.font = this.font;
              context.direction = this.direction;
              return context.measureText( this.text ).width;
            },
            
            approximateSVGBounds: function() {
              if ( !svgTextSizeContainer.parentNode ) {
                if ( document.body ) {
                  document.body.appendChild( svgTextSizeContainer );
                } else {
                  // TODO: better way to handle the hybridTextNode being added inside the HEAD? Requiring a body for proper operation might be a problem.
                  if ( initializingHybridTextNode ) {
                    // if this is almost assuredly the hybridTextNode, return nothing for now. TODO: better way of handling this! it's a hack!
                    return Bounds2.NOTHING;
                  } else {
                    throw new Error( 'No document.body and trying to get approximate SVG bounds of a Text node' );
                  }
                }
              }
              this.updateSVGFragment( svgTextSizeElement );
              svgTextSizeElement.removeAttribute( 'textLength' ); // since we may set textLength, remove that so we can get accurate widths
              var rect = svgTextSizeElement.getBBox();
              return new Bounds2( rect.x, rect.y, rect.x + rect.width, rect.y + rect.height );
            },
            
            approximateHybridBounds: function() {
              if ( !hybridTextNode ) {
                return Bounds2.NOTHING; // we are the hybridTextNode, ignore us
              }
              
              if ( this._font._cachedSVGBounds === undefined ) {
                hybridTextNode.setFont( this._font );
                this._font._cachedSVGBounds = hybridTextNode.getBounds();
              }
              
              var canvasWidth = this.approximateCanvasWidth();
              var verticalBounds = this._font._cachedSVGBounds;
              
              // it seems that SVG bounds generally have x=0, so we hard code that here
              return new Bounds2( 0, verticalBounds.minY, canvasWidth, verticalBounds.maxY );
            },
            
            approximateDOMBounds: function() {
              var maxHeight = 1024; // technically this will fail if the font is taller than this!
              var isRTL = this.direction === 'rtl';
              
              // <div style="position: absolute; left: 0; top: 0; padding: 0 !important; margin: 0 !important;"><span id="baselineSpan" style="font-family: Verdana; font-size: 25px;">QuipTaQiy</span><div style="vertical-align: baseline; display: inline-block; width: 0; height: 500px; margin: 0 important!; padding: 0 important!;"></div></div>
              
              var div = document.createElement( 'div' );
              $( div ).css( {
                position: 'absolute',
                left: 0,
                top: 0,
                padding: '0 !important',
                margin: '0 !important',
                display: 'hidden'
              } );
              
              var span = document.createElement( 'span' );
              $( span ).css( 'font', this.getFont() );
              span.appendChild( this.getDOMTextNode() );
              span.setAttribute( 'direction', this._direction );
              
              var fakeImage = document.createElement( 'div' );
              $( fakeImage ).css( {
                'vertical-align': 'baseline',
                display: 'inline-block',
                width: 0,
                height: maxHeight + 'px',
                margin: '0 !important',
                padding: '0 !important'
              } );
              
              div.appendChild( span );
              div.appendChild( fakeImage );
              
              document.body.appendChild( div );
              var rect = span.getBoundingClientRect();
              var divRect = div.getBoundingClientRect();
              // add 1 pixel to rect.right to prevent HTML text wrapping
              var result = new Bounds2( rect.left, rect.top - maxHeight, rect.right + 1, rect.bottom - maxHeight ).shifted( -divRect.left, -divRect.top );
              // console.log( 'result: ' + result );
              document.body.removeChild( div );
              
              var width = rect.right - rect.left;
              return result.shiftedX( isRTL ? -width : 0 ); // should we even swap here?
            },
            
            // @override from Node
            getSafeSelfBounds: function() {
              var expansionFactor = 1; // we use a new bounding box with a new size of size * ( 1 + 2 * expansionFactor )
              
              var selfBounds = this.getSelfBounds();
              return selfBounds.dilatedXY( expansionFactor * selfBounds.width, expansionFactor * selfBounds.height );
            },
            
            /*---------------------------------------------------------------------------*
            * Self setters / getters
            *----------------------------------------------------------------------------*/
            
            setFont: function( font ) {
              if ( this.font !== font ) {
                this._font = font instanceof scenery.Font ? font : new scenery.Font( font );
                this.invalidateText();
              }
              return this;
            },
            
            // NOTE: returns mutable copy for now, consider either immutable version, defensive copy, or note about invalidateText()
            getFont: function() {
              return this._font.getFont();
            },
            
            setDirection: function( direction ) {
              this._direction = direction;
              this.invalidateText();
              return this;
            },
            
            getDirection: function() {
              return this._direction;
            },
            
            isPainted: function() {
              return true;
            },
            
            getBasicConstructor: function( propLines ) {
              return 'new scenery.Text( \'' + escapeHTML( this._text.replace( /'/g, '\\\'' ) ) + '\', {' + propLines + '} )';
            },
            
            getPropString: function( spaces, includeChildren ) {
              var result = Node.prototype.getPropString.call( this, spaces, includeChildren );
              result = this.appendFillablePropString( spaces, result );
              result = this.appendStrokablePropString( spaces, result );
              
              // TODO: if created again, deduplicate with Node's getPropString
              function addProp( key, value, nowrap ) {
                if ( result ) {
                  result += ',\n';
                }
                if ( !nowrap && typeof value === 'string' ) {
                  result += spaces + key + ': \'' + value + '\'';
                } else {
                  result += spaces + key + ': ' + value;
                }
              }
              
              if ( this.font !== new scenery.Font().getFont() ) {
                addProp( 'font', this.font.replace( /'/g, '\\\'' ) );
              }
              
              if ( this._direction !== 'ltr' ) {
                addProp( 'direction', this._direction );
              }
              
              return result;
            }
          } );
          
          /*---------------------------------------------------------------------------*
          * Font setters / getters
          *----------------------------------------------------------------------------*/
          
          function addFontForwarding( propertyName, fullCapitalized, shortUncapitalized ) {
            var getterName = 'get' + fullCapitalized;
            var setterName = 'set' + fullCapitalized;
            
            Text.prototype[getterName] = function() {
              // use the ES5 getter to retrieve the property. probably somewhat slow.
              return this._font[ shortUncapitalized ];
            };
            
            Text.prototype[setterName] = function( value ) {
              // create a full copy of our font instance
              var ob = {};
              ob[shortUncapitalized] = value;
              var newFont = this._font.copy( ob );
              
              // apply the new Font. this should call invalidateText() as normal
              this.setFont( newFont );
              return this;
            };
            
            Object.defineProperty( Text.prototype, propertyName, { set: Text.prototype[setterName], get: Text.prototype[getterName] } );
          }
          
          addFontForwarding( 'fontWeight', 'FontWeight', 'weight' );
          addFontForwarding( 'fontFamily', 'FontFamily', 'family' );
          addFontForwarding( 'fontStretch', 'FontStretch', 'stretch' );
          addFontForwarding( 'fontStyle', 'FontStyle', 'style' );
          addFontForwarding( 'fontSize', 'FontSize', 'size' );
          addFontForwarding( 'lineHeight', 'LineHeight', 'lineHeight' );
          
          Text.prototype._mutatorKeys = [ 'boundsMethod', 'text', 'font', 'fontWeight', 'fontFamily', 'fontStretch', 'fontStyle', 'fontSize', 'lineHeight',
                                          'direction' ].concat( Node.prototype._mutatorKeys );
          
          // font-specific ES5 setters and getters are defined using addFontForwarding above
          Object.defineProperty( Text.prototype, 'font', { set: Text.prototype.setFont, get: Text.prototype.getFont } );
          Object.defineProperty( Text.prototype, 'text', { set: Text.prototype.setText, get: Text.prototype.getText } );
          Object.defineProperty( Text.prototype, 'direction', { set: Text.prototype.setDirection, get: Text.prototype.getDirection } );
          Object.defineProperty( Text.prototype, 'boundsMethod', { set: Text.prototype.setBoundsMethod, get: Text.prototype.getBoundsMethod } );
          
          // mix in support for fills and strokes
          /* jshint -W064 */
          Fillable( Text );
          Strokable( Text );
          
          initializingHybridTextNode = true;
          hybridTextNode = new Text( 'm', { boundsMethod: 'fast' } );
          initializingHybridTextNode = false;
        
          return Text;
        } );
        
        
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * A rectangular node that inherits Path, and allows for optimized drawing,
         * and improved rectangle handling.
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/nodes/Rectangle',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Path','KITE/Shape','DOT/Bounds2','DOT/Matrix3','SCENERY/util/Features'],function( require ) {
          
          
          var inherit = require( 'PHET_CORE/inherit' );
          var scenery = require( 'SCENERY/scenery' );
          
          var Path = require( 'SCENERY/nodes/Path' );
          var Shape = require( 'KITE/Shape' );
          var Bounds2 = require( 'DOT/Bounds2' );
          var Matrix3 = require( 'DOT/Matrix3' );
          var Features = require( 'SCENERY/util/Features' );
          
          /**
           * Currently, all numerical parameters should be finite.
           * x:         x-position of the upper-left corner (left bound)
           * y:         y-position of the upper-left corner (top bound)
           * width:     width of the rectangle to the right of the upper-left corner, required to be >= 0
           * height:    height of the rectangle below the upper-left corner, required to be >= 0
           * arcWidth:  positive width of the rounded corner, or 0 to indicate the corner should be sharp
           * arcHeight: positive height of the rounded corner, or 0 to indicate the corner should be sharp
           */
          scenery.Rectangle = function Rectangle( x, y, width, height, arcWidth, arcHeight, options ) {
            if ( typeof x === 'object' ) {
              if ( x instanceof Bounds2 ) {
                // allow new Rectangle( bounds2, { ... } ) or new Rectangle( bounds2, arcWidth, arcHeight, options )
                this._rectX = x.minX;
                this._rectY = x.minY;
                this._rectWidth = x.width;
                this._rectHeight = x.height;
                if ( arguments.length < 3 ) {
                  // Rectangle( bounds2, { ... } )
                  options = y;
                  this._rectArcWidth = 0;
                  this._rectArcHeight = 0;
                } else {
                  // Rectangle( bounds2, arcWidth, arcHeight, { ... } )
                  options = height;
                  this._rectArcWidth = y;
                  this._rectArcHeight = width;
                }
              } else {
                // allow new Rectangle( { rectX: x, rectY: y, rectWidth: width, rectHeight: height, ... } )
                // the mutators will call invalidateRectangle() and properly set the shape
                options = x;
                this._rectX = options.rectX || 0;
                this._rectY = options.rectY || 0;
                this._rectWidth = options.rectWidth;
                this._rectHeight = options.rectHeight;
                this._rectArcWidth = options.rectArcWidth || 0;
                this._rectArcHeight = options.rectArcHeight || 0;
              }
            } else if ( arguments.length < 6 ) {
              // new Rectangle( x, y, width, height, [options] )
              this._rectX = x;
              this._rectY = y;
              this._rectWidth = width;
              this._rectHeight = height;
              this._rectArcWidth = 0;
              this._rectArcHeight = 0;
              
              // ensure we have a parameter object
              options = arcWidth || {};
              
            } else {
              // normal case with args (including arcWidth / arcHeight)
              this._rectX = x;
              this._rectY = y;
              this._rectWidth = width;
              this._rectHeight = height;
              this._rectArcWidth = arcWidth;
              this._rectArcHeight = arcHeight;
              
              // ensure we have a parameter object
              options = options || {};
              
            }
            // fallback for non-canvas or non-svg rendering, and for proper bounds computation
        
            Path.call( this, null, options );
          };
          var Rectangle = scenery.Rectangle;
          
          inherit( Path, Rectangle, {
            
            getMaximumArcSize: function() {
              return Math.min( this._rectWidth / 2, this._rectHeight / 2 );
            },
            
            getStrokeRendererBitmask: function() {
              var bitmask = Path.prototype.getStrokeRendererBitmask.call( this );
              if ( this.hasStroke() && !this.getStroke().isGradient && !this.getStroke().isPattern ) {
                if ( this.getLineJoin() === 'miter' || ( this.getLineJoin() === 'round' && Features.borderRadius ) ) {
                  bitmask |= scenery.bitmaskSupportsDOM;
                }
              }
              return bitmask;
            },
            
            getPathRendererBitmask: function() {
              var bitmask = scenery.bitmaskSupportsCanvas | scenery.bitmaskSupportsSVG;
              
              var maximumArcSize = this.getMaximumArcSize();
              
              // If the top/bottom or left/right strokes touch and overlap in the middle (small rectangle, big stroke), our DOM method won't work.
              // Additionally, if we're handling rounded rectangles or a stroke with lineJoin 'round', we'll need borderRadius
              // We also require for DOM that if it's a rounded rectangle, it's rounded with circular arcs (for now, could potentially do a transform trick!)
              if ( ( !this.hasStroke() || ( this.getLineWidth() <= this._rectHeight && this.getLineWidth() <= this._rectWidth ) ) &&
                   ( !this.isRounded() || ( Features.borderRadius && this._rectArcWidth === this._rectArcHeight ) ) &&
                   this._rectArcHeight <= maximumArcSize && this._rectArcWidth <= maximumArcSize ) {
                bitmask |= scenery.bitmaskSupportsDOM;
              }
              
              return bitmask;
            },
            
            setRect: function( x, y, width, height, arcWidth, arcHeight ) {
              assert && assert( x !== undefined && y !== undefined && width !== undefined && height !== undefined, 'x/y/width/height need to be defined' );
              
              this._rectX = x;
              this._rectY = y;
              this._rectWidth = width;
              this._rectHeight = height;
              this._rectArcWidth = arcWidth || 0;
              this._rectArcHeight = arcHeight || 0;
              this.invalidateRectangle();
            },
            
            setRectBounds: function( bounds ) {
              this.setRect( bounds.x, bounds.y, bounds.width, bounds.height );
            },
            
            isRounded: function() {
              return this._rectArcWidth !== 0 && this._rectArcHeight !== 0;
            },
            
            computeShapeBounds: function() {
              var bounds = new Bounds2( this._rectX, this._rectY, this._rectX + this._rectWidth, this._rectY + this._rectHeight );
              if ( this._stroke ) {
                // since we are axis-aligned, any stroke will expand our bounds by a guaranteed set amount
                bounds = bounds.dilated( this.getLineWidth() / 2 );
              }
              return bounds;
            },
            
            createRectangleShape: function() {
              if ( this.isRounded() ) {
                // copy border-radius CSS behavior in Chrome, where the arcs won't intersect, in cases where the arc segments at full size would intersect each other
                var maximumArcSize = Math.min( this._rectWidth / 2, this._rectHeight / 2 );
                return Shape.roundRectangle( this._rectX, this._rectY, this._rectWidth, this._rectHeight,
                                             Math.min( maximumArcSize, this._rectArcWidth ), Math.min( maximumArcSize, this._rectArcHeight ) );
              } else {
                return Shape.rectangle( this._rectX, this._rectY, this._rectWidth, this._rectHeight );
              }
            },
            
            invalidateRectangle: function() {
              assert && assert( isFinite( this._rectX ), 'A rectangle needs to have a finite x (' + this._rectX + ')' );
              assert && assert( isFinite( this._rectY ), 'A rectangle needs to have a finite x (' + this._rectY + ')' );
              assert && assert( this._rectWidth >= 0 && isFinite( this._rectWidth ),
                                              'A rectangle needs to have a non-negative finite width (' + this._rectWidth + ')' );
              assert && assert( this._rectHeight >= 0 && isFinite( this._rectHeight ),
                                              'A rectangle needs to have a non-negative finite height (' + this._rectHeight + ')' );
              assert && assert( this._rectArcWidth >= 0 && isFinite( this._rectArcWidth ),
                                              'A rectangle needs to have a non-negative finite arcWidth (' + this._rectArcWidth + ')' );
              assert && assert( this._rectArcHeight >= 0 && isFinite( this._rectArcHeight ),
                                              'A rectangle needs to have a non-negative finite arcHeight (' + this._rectArcHeight + ')' );
              // assert && assert( !this.isRounded() || ( this._rectWidth >= this._rectArcWidth * 2 && this._rectHeight >= this._rectArcHeight * 2 ),
              //                                 'The rounded sections of the rectangle should not intersect (the length of the straight sections shouldn\'t be negative' );
              
              // sets our 'cache' to null, so we don't always have to recompute our shape
              this._shape = null;
              
              // should invalidate the path and ensure a redraw
              this.invalidateShape();
              
              // since we changed the rectangle arc width/height, it could make DOM work or not
              this.invalidateSupportedRenderers();
            },
            
            // accelerated hit detection for axis-aligned optionally-rounded rectangle
            // fast computation if it isn't rounded. if rounded, we check if a corner computation is needed (usually isn't), and only check that one needed corner
            containsPointSelf: function( point ) {
              var x = this._rectX;
              var y = this._rectY;
              var width = this._rectWidth;
              var height = this._rectHeight;
              var arcWidth = this._rectArcWidth;
              var arcHeight = this._rectArcHeight;
              var halfLine = this.getLineWidth() / 2;
              
              var result = true;
              if ( this._strokePickable ) {
                // test the outer boundary if we are stroke-pickable (if also fill-pickable, this is the only test we need)
                var rounded = this.isRounded();
                if ( !rounded && this.getLineJoin() === 'bevel' ) {
                  // fall-back for bevel
                  return Path.prototype.containsPointSelf.call( this, point );
                }
                var miter = this.getLineJoin() === 'miter' && !rounded;
                result = result && Rectangle.intersects( x - halfLine, y - halfLine,
                                                         width + 2 * halfLine, height + 2 * halfLine,
                                                         miter ? 0 : ( arcWidth + halfLine ), miter ? 0 : ( arcHeight + halfLine ),
                                                         point );
              }
              
              if ( this._fillPickable ) {
                if ( this._strokePickable ) {
                  return result;
                } else {
                  return Rectangle.intersects( x, y, width, height, arcWidth, arcHeight, point );
                }
              } else if ( this._strokePickable ) {
                return result && !Rectangle.intersects( x + halfLine, y + halfLine,
                                                       width - 2 * halfLine, height - 2 * halfLine,
                                                       arcWidth - halfLine, arcHeight - halfLine,
                                                       point );
              } else {
                return false; // either fill nor stroke is pickable
              }
            },
            
            intersectsBoundsSelf: function( bounds ) {
              return !this.computeShapeBounds().intersection( bounds ).isEmpty();
            },
            
            // override paintCanvas with a faster version, since fillRect and drawRect don't affect the current default path
            paintCanvas: function( wrapper ) {
              var context = wrapper.context;
              
              // use the standard version if it's a rounded rectangle, since there is no Canvas-optimized version for that
              if ( this.isRounded() ) {
                context.beginPath();
                var maximumArcSize = this.getMaximumArcSize();
                var arcw = Math.min( this._rectArcWidth, maximumArcSize );
                var arch = Math.min( this._rectArcHeight, maximumArcSize );
                var lowX = this._rectX + arcw;
                var highX = this._rectX + this._rectWidth - arcw;
                var lowY = this._rectY + arch;
                var highY = this._rectY + this._rectHeight - arch;
                if ( arcw === arch ) {
                  // we can use circular arcs, which have well defined stroked offsets
                  context.arc( highX, lowY, arcw, -Math.PI / 2, 0, false );
                  context.arc( highX, highY, arcw, 0, Math.PI / 2, false );
                  context.arc( lowX, highY, arcw, Math.PI / 2, Math.PI, false );
                  context.arc( lowX, lowY, arcw, Math.PI, Math.PI * 3 / 2, false );
                } else {
                  // we have to resort to elliptical arcs
                  context.ellipse( highX, lowY, arcw, arch, 0, -Math.PI / 2, 0, false );
                  context.ellipse( highX, highY, arcw, arch, 0, 0, Math.PI / 2, false );
                  context.ellipse( lowX, highY, arcw, arch, 0, Math.PI / 2, Math.PI, false );
                  context.ellipse( lowX, lowY, arcw, arch, 0, Math.PI, Math.PI * 3 / 2, false );
                }
                context.closePath();
                
                if ( this._fill ) {
                  this.beforeCanvasFill( wrapper ); // defined in Fillable
                  context.fill();
                  this.afterCanvasFill( wrapper ); // defined in Fillable
                }
                if ( this._stroke ) {
                  this.beforeCanvasStroke( wrapper ); // defined in Strokable
                  context.stroke();
                  this.afterCanvasStroke( wrapper ); // defined in Strokable
                }
              } else {
                // TODO: how to handle fill/stroke delay optimizations here?
                if ( this._fill ) {
                  this.beforeCanvasFill( wrapper ); // defined in Fillable
                  context.fillRect( this._rectX, this._rectY, this._rectWidth, this._rectHeight );
                  this.afterCanvasFill( wrapper ); // defined in Fillable
                }
                if ( this._stroke ) {
                  this.beforeCanvasStroke( wrapper ); // defined in Strokable
                  context.strokeRect( this._rectX, this._rectY, this._rectWidth, this._rectHeight );
                  this.afterCanvasStroke( wrapper ); // defined in Strokable
                }
              }
            },
            
            // create a rect instead of a path, hopefully it is faster in implementations
            createSVGFragment: function( svg, defs, group ) {
              return document.createElementNS( scenery.svgns, 'rect' );
            },
            
            // optimized for the rect element instead of path
            updateSVGFragment: function( rect ) {
              // see http://www.w3.org/TR/SVG/shapes.html#RectElement
              rect.setAttribute( 'x', this._rectX );
              rect.setAttribute( 'y', this._rectY );
              rect.setAttribute( 'width', this._rectWidth );
              rect.setAttribute( 'height', this._rectHeight );
              
              // workaround for various browsers if rx=20, ry=0 (behavior is inconsistent, either identical to rx=20,ry=20, rx=0,ry=0. We'll treat it as rx=0,ry=0)
              // see https://github.com/phetsims/scenery/issues/183
              if ( this.isRounded() ) {
                var maximumArcSize = this.getMaximumArcSize();
                var arcw = Math.min( this._rectArcWidth, maximumArcSize );
                var arch = Math.min( this._rectArcHeight, maximumArcSize );
                rect.setAttribute( 'rx', arcw );
                rect.setAttribute( 'ry', arch );
              } else {
                rect.setAttribute( 'rx', 0 );
                rect.setAttribute( 'ry', 0 );
              }
              
              rect.setAttribute( 'style', this.getSVGFillStyle() + this.getSVGStrokeStyle() );
            },
            
            /*---------------------------------------------------------------------------*
             * DOM support
             *----------------------------------------------------------------------------*/
            
            domUpdateTransformOnRepaint: true, // since we have to integrate the baseline offset into the CSS transform, signal to DOMLayer
            
            getDOMElement: function() {
              var fill = document.createElement( 'div' );
              var stroke = document.createElement( 'div' );
              fill.appendChild( stroke );
              fill.style.display = 'block';
              fill.style.position = 'absolute';
              fill.style.left = '0';
              fill.style.top = '0';
              stroke.style.display = 'block';
              stroke.style.position = 'absolute';
              stroke.style.left = '0';
              stroke.style.top = '0';
              return fill;
            },
        
            updateDOMElement: function( fill ) {
              var borderRadius = Math.min( this._rectArcWidth, this._rectArcHeight );
              
              fill.style.width = this._rectWidth + 'px';
              fill.style.height = this._rectHeight + 'px';
              fill.style[Features.borderRadius] = borderRadius + 'px'; // if one is zero, we are not rounded, so we do the min here
              fill.style.backgroundColor = this.getCSSFill();
              
              var stroke = fill.childNodes[0];
              if ( this.hasStroke() ) {
                stroke.style.width = ( this._rectWidth - this.getLineWidth() ) + 'px';
                stroke.style.height = ( this._rectHeight - this.getLineWidth() ) + 'px';
                stroke.style.left = ( -this.getLineWidth() / 2 ) + 'px';
                stroke.style.top = ( -this.getLineWidth() / 2 ) + 'px';
                stroke.style.borderStyle = 'solid';
                stroke.style.borderColor = this.getSimpleCSSFill();
                stroke.style.borderWidth = this.getLineWidth() + 'px';
                stroke.style[Features.borderRadius] = ( this.isRounded() || this.getLineJoin() === 'round' ) ? ( borderRadius + this.getLineWidth() / 2 ) + 'px' : '0';
              } else {
                stroke.style.borderStyle = 'none';
              }
            },
            
            // override the transform since we need to customize it with a DOM offset
            updateCSSTransform: function( transform, element ) {
              // shift the text vertically, postmultiplied with the entire transform.
              var matrix = transform.getMatrix().timesMatrix( Matrix3.translation( this._rectX, this._rectY ) );
              scenery.Util.applyCSSTransform( matrix, element );
            },
            
            getBasicConstructor: function( propLines ) {
              return 'new scenery.Rectangle( ' + this._rectX + ', ' + this._rectY + ', ' + 
                                                 this._rectWidth + ', ' + this._rectHeight + ', ' +
                                                 this._rectArcWidth + ', ' + this._rectArcHeight + ', {' + propLines + '} )';
            },
            
            setShape: function( shape ) {
              if ( shape !== null ) {
                throw new Error( 'Cannot set the shape of a scenery.Rectangle to something non-null' );
              } else {
                // probably called from the Path constructor
                this.invalidateShape();
              }
            },
            
            getShape: function() {
              if ( !this._shape ) {
                this._shape = this.createRectangleShape();
              }
              return this._shape;
            },
            
            hasShape: function() {
              return true;
            }
          } );
          
          function addRectProp( capitalizedShort ) {
            var getName = 'getRect' + capitalizedShort;
            var setName = 'setRect' + capitalizedShort;
            var privateName = '_rect' + capitalizedShort;
            
            Rectangle.prototype[getName] = function() {
              return this[privateName];
            };
            
            Rectangle.prototype[setName] = function( value ) {
              if ( this[privateName] !== value ) {
                this[privateName] = value;
                this.invalidateRectangle();
              }
              return this;
            };
            
            Object.defineProperty( Rectangle.prototype, 'rect' + capitalizedShort, {
              set: Rectangle.prototype[setName],
              get: Rectangle.prototype[getName]
            } );
          }
          
          addRectProp( 'X' );
          addRectProp( 'Y' );
          addRectProp( 'Width' );
          addRectProp( 'Height' );
          addRectProp( 'ArcWidth' );
          addRectProp( 'ArcHeight' );
          
          // not adding mutators for now
          Rectangle.prototype._mutatorKeys = [ 'rectX', 'rectY', 'rectWidth', 'rectHeight', 'rectArcWidth', 'rectArcHeight' ].concat( Path.prototype._mutatorKeys );
          
          Rectangle.intersects = function( x, y, width, height, arcWidth, arcHeight, point ) {
            var result = point.x >= x &&
                         point.x <= x + width &&
                         point.y >= y &&
                         point.y <= y + height;
            
            if ( !result || arcWidth <= 0 || arcHeight <= 0 ) {
              return result;
            }
            
            // copy border-radius CSS behavior in Chrome, where the arcs won't intersect, in cases where the arc segments at full size would intersect each other
            var maximumArcSize = Math.min( width / 2, height / 2 );
            arcWidth = Math.min( maximumArcSize, arcWidth );
            arcHeight = Math.min( maximumArcSize, arcHeight );
            
            // we are rounded and inside the logical rectangle (if it didn't have rounded corners)
            
            // closest corner arc's center (we assume the rounded rectangle's arcs are 90 degrees fully, and don't intersect)
            var closestCornerX, closestCornerY, guaranteedInside = false;
            
            // if we are to the inside of the closest corner arc's center, we are guaranteed to be in the rounded rectangle (guaranteedInside)
            if ( point.x < x + width / 2 ) {
              closestCornerX = x + arcWidth;
              guaranteedInside = guaranteedInside || point.x >= closestCornerX;
            } else {
              closestCornerX = x + width - arcWidth;
              guaranteedInside = guaranteedInside || point.x <= closestCornerX;
            }
            if ( guaranteedInside ) { return true; }
            
            if ( point.y < y + height / 2 ) {
              closestCornerY = y + arcHeight;
              guaranteedInside = guaranteedInside || point.y >= closestCornerY;
            } else {
              closestCornerY = y + height - arcHeight;
              guaranteedInside = guaranteedInside || point.y <= closestCornerY;
            }
            if ( guaranteedInside ) { return true; }
            
            // we are now in the rectangular region between the logical corner and the center of the closest corner's arc.
            
            // offset from the closest corner's arc center
            var offsetX = point.x - closestCornerX;
            var offsetY = point.y - closestCornerY;
            
            // normalize the coordinates so now we are dealing with a unit circle
            // (technically arc, but we are guaranteed to be in the area covered by the arc, so we just consider the circle)
            // NOTE: we are rounded, so both arcWidth and arcHeight are non-zero (this is well defined)
            offsetX /= arcWidth;
            offsetY /= arcHeight;
            
            offsetX *= offsetX;
            offsetY *= offsetY;
            return offsetX + offsetY <= 1; // return whether we are in the rounded corner. see the formula for an ellipse
          };
          
          Rectangle.rect = function( x, y, width, height, options ) {
            return new Rectangle( x, y, width, height, 0, 0, options );
          };
          
          Rectangle.roundedRect = function( x, y, width, height, arcWidth, arcHeight, options ) {
            return new Rectangle( x, y, width, height, arcWidth, arcHeight, options );
          };
          
          Rectangle.bounds = function( bounds, options ) {
            return new Rectangle( bounds.minX, bounds.minY, bounds.width, bounds.height, 0, 0, options );
          };
          
          Rectangle.roundedBounds = function( bounds, arcWidth, arcHeight, options ) {
            return new Rectangle( bounds.minX, bounds.minY, bounds.width, bounds.height, arcWidth, arcHeight, options );
          };
          
          return Rectangle;
        } );
        
        
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Shows the highlight graphic for a knot.  The knots are always visible as part of the image, but when the visible flag is set,
         * the highlight is shown.
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/tugofwar/view/KnotHighlightNode',['require','SCENERY/nodes/Path','KITE/Shape','PHET_CORE/inherit'],function( require ) {
          
        
          var Path = require( 'SCENERY/nodes/Path' );
          var Shape = require( 'KITE/Shape' );
          var inherit = require( 'PHET_CORE/inherit' );
        
          var knotWidth = 20;
        
          function KnotHighlightNode( knot ) {
            Path.call( this, Shape.circle( 0, 0, knotWidth ), {stroke: '#FFFF00', lineWidth: 4, visible: false, x: knot.x, y: knot.y} );
            knot.visibleProperty.linkAttribute( this, 'visible' );
            knot.xProperty.linkAttribute( this, 'x' );
          }
        
          return inherit( Path, KnotHighlightNode );
        } );
        /**
         * @license RequireJS text 2.0.10 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
         * Available via the MIT or new BSD license.
         * see: http://github.com/requirejs/text for details
         */
        /*jslint regexp: true */
        /*global require, XMLHttpRequest, ActiveXObject,
         define, window, process, Packages,
         java, location, Components, FileUtils */
        
        define('text',['module'], function (module) {
          
        
          var text, fs, Cc, Ci, xpcIsWindows,
            progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
            xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
            bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
            hasLocation = typeof location !== 'undefined' && location.href,
            defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
            defaultHostName = hasLocation && location.hostname,
            defaultPort = hasLocation && (location.port || undefined),
            buildMap = {},
            masterConfig = (module.config && module.config()) || {};
        
          text = {
            version: '2.0.10',
        
            strip: function (content) {
              //Strips <?xml ...?> declarations so that external SVG and XML
              //documents can be added to a document without worry. Also, if the string
              //is an HTML document, only the part inside the body tag is returned.
              if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                  content = matches[1];
                }
              } else {
                content = "";
              }
              return content;
            },
        
            jsEscape: function (content) {
              return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
            },
        
            createXhr: masterConfig.createXhr || function () {
              //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
              var xhr, i, progId;
              if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
              } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                  progId = progIds[i];
                  try {
                    xhr = new ActiveXObject(progId);
                  } catch (e) {}
        
                  if (xhr) {
                    progIds = [progId];  // so faster next time
                    break;
                  }
                }
              }
        
              return xhr;
            },
        
            /**
             * Parses a resource name into its component parts. Resource names
             * look like: module/name.ext!strip, where the !strip part is
             * optional.
             * @param {String} name the resource name
             * @returns {Object} with properties "moduleName", "ext" and "strip"
             * where strip is a boolean.
             */
            parseName: function (name) {
              var modName, ext, temp,
                strip = false,
                index = name.indexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;
        
              if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1, name.length);
              } else {
                modName = name;
              }
        
              temp = ext || modName;
              index = temp.indexOf("!");
              if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                  ext = temp;
                } else {
                  modName = temp;
                }
              }
        
              return {
                moduleName: modName,
                ext: ext,
                strip: strip
              };
            },
        
            xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,
        
            /**
             * Is an URL on another domain. Only works for browser use, returns
             * false in non-browser environments. Only used to know if an
             * optimized .js version of a text resource should be loaded
             * instead.
             * @param {String} url
             * @returns Boolean
             */
            useXhr: function (url, protocol, hostname, port) {
              var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
              if (!match) {
                return true;
              }
              uProtocol = match[2];
              uHostName = match[3];
        
              uHostName = uHostName.split(':');
              uPort = uHostName[1];
              uHostName = uHostName[0];
        
              return (!uProtocol || uProtocol === protocol) &&
                     (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                     ((!uPort && !uHostName) || uPort === port);
            },
        
            finishLoad: function (name, strip, content, onLoad) {
              content = strip ? text.strip(content) : content;
              if (masterConfig.isBuild) {
                buildMap[name] = content;
              }
              onLoad(content);
            },
        
            load: function (name, req, onLoad, config) {
              //Name has format: some.module.filext!strip
              //The strip part is optional.
              //if strip is present, then that means only get the string contents
              //inside a body tag in an HTML string. For XML/SVG content it means
              //removing the <?xml ...?> declarations so the content can be inserted
              //into the current doc without problems.
        
              // Do not bother with the work if a build and text will
              // not be inlined.
              if (config.isBuild && !config.inlineText) {
                onLoad();
                return;
              }
        
              masterConfig.isBuild = config.isBuild;
        
              var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                               (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;
        
              // Do not load if it is an empty: url
              if (url.indexOf('empty:') === 0) {
                onLoad();
                return;
              }
        
              //Load the text. Use XHR if possible and in a browser.
              if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                  text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                  if (onLoad.error) {
                    onLoad.error(err);
                  }
                });
              } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                  text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                    parsed.strip, content, onLoad);
                });
              }
            },
        
            write: function (pluginName, moduleName, write, config) {
              if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                  "define(function () { return '" +
                  content +
                  "';});\n");
              }
            },
        
            writeFile: function (pluginName, moduleName, req, write, config) {
              var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
              //Use a '.js' file name so that it indicates it is a
              //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';
        
              //Leverage own load() method to load plugin value, but only
              //write out values that do not have the strip argument,
              //to avoid any potential issues with ! in file names.
              text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                  return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                  return write.asModule(moduleName, fileName, contents);
                };
        
                text.write(pluginName, nonStripName, textWrite, config);
              }, config);
            }
          };
        
          if (masterConfig.env === 'node' || (!masterConfig.env &&
                                              typeof process !== "undefined" &&
                                              process.versions &&
                                              !!process.versions.node &&
                                              !process.versions['node-webkit'])) {
            //Using special require.nodeRequire, something added by r.js.
            fs = require.nodeRequire('fs');
        
            text.get = function (url, callback, errback) {
              try {
                var file = fs.readFileSync(url, 'utf8');
                //Remove BOM (Byte Mark Order) from utf8 files if it is there.
                if (file.indexOf('\uFEFF') === 0) {
                  file = file.substring(1);
                }
                callback(file);
              } catch (e) {
                errback(e);
              }
            };
          } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
                                                    text.createXhr())) {
            text.get = function (url, callback, errback, headers) {
              var xhr = text.createXhr(), header;
              xhr.open('GET', url, true);
        
              //Allow plugins direct access to xhr headers
              if (headers) {
                for (header in headers) {
                  if (headers.hasOwnProperty(header)) {
                    xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                  }
                }
              }
        
              //Allow overrides specified in config
              if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
              }
        
              xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                  status = xhr.status;
                  if (status > 399 && status < 600) {
                    //An http 4xx or 5xx error. Signal an error.
                    err = new Error(url + ' HTTP status: ' + status);
                    err.xhr = xhr;
                    errback(err);
                  } else {
                    callback(xhr.responseText);
                  }
        
                  if (masterConfig.onXhrComplete) {
                    masterConfig.onXhrComplete(xhr, url);
                  }
                }
              };
              xhr.send(null);
            };
          } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
                                                      typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
            //Why Java, why is this so awkward?
            text.get = function (url, callback) {
              var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
              try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();
        
                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html
        
                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                  // Eat the BOM, since we've already found the encoding on this file,
                  // and we plan to concatenating this buffer with others; the BOM should
                  // only appear at the top of a file.
                  line = line.substring(1);
                }
        
                if (line !== null) {
                  stringBuffer.append(line);
                }
        
                while ((line = input.readLine()) !== null) {
                  stringBuffer.append(lineSeparator);
                  stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
              } finally {
                input.close();
              }
              callback(content);
            };
          } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
                                                          typeof Components !== 'undefined' && Components.classes &&
                                                          Components.interfaces)) {
            //Avert your gaze!
            Cc = Components.classes,
              Ci = Components.interfaces;
            Components.utils['import']('resource://gre/modules/FileUtils.jsm');
            xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);
        
            text.get = function (url, callback) {
              var inStream, convertStream, fileObj,
                readData = {};
        
              if (xpcIsWindows) {
                url = url.replace(/\//g, '\\');
              }
        
              fileObj = new FileUtils.File(url);
        
              //XPCOM, you so crazy
              try {
                inStream = Cc['@mozilla.org/network/file-input-stream;1']
                  .createInstance(Ci.nsIFileInputStream);
                inStream.init(fileObj, 1, 0, false);
        
                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
                  .createInstance(Ci.nsIConverterInputStream);
                convertStream.init(inStream, "utf-8", inStream.available(),
                  Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);
        
                convertStream.readString(inStream.available(), readData);
                convertStream.close();
                inStream.close();
                callback(readData.value);
              } catch (e) {
                throw new Error((fileObj && fileObj.path || '') + ': ' + e);
              }
            };
          }
          return text;
        });
        /**
         * @license
         * Lo-Dash 2.4.1 (Custom Build) lodash.com/license | Underscore.js 1.5.2 underscorejs.org/LICENSE
         * Build: `lodash modern -o ./dist/lodash.js`
         */
        ;(function(){function n(n,t,e){e=(e||0)-1;for(var r=n?n.length:0;++e<r;)if(n[e]===t)return e;return-1}function t(t,e){var r=typeof e;if(t=t.l,"boolean"==r||null==e)return t[e]?0:-1;"number"!=r&&"string"!=r&&(r="object");var u="number"==r?e:m+e;return t=(t=t[r])&&t[u],"object"==r?t&&-1<n(t,e)?0:-1:t?0:-1}function e(n){var t=this.l,e=typeof n;if("boolean"==e||null==n)t[n]=true;else{"number"!=e&&"string"!=e&&(e="object");var r="number"==e?n:m+n,t=t[e]||(t[e]={});"object"==e?(t[r]||(t[r]=[])).push(n):t[r]=true
        }}function r(n){return n.charCodeAt(0)}function u(n,t){for(var e=n.m,r=t.m,u=-1,o=e.length;++u<o;){var i=e[u],a=r[u];if(i!==a){if(i>a||typeof i=="undefined")return 1;if(i<a||typeof a=="undefined")return-1}}return n.n-t.n}function o(n){var t=-1,r=n.length,u=n[0],o=n[r/2|0],i=n[r-1];if(u&&typeof u=="object"&&o&&typeof o=="object"&&i&&typeof i=="object")return false;for(u=f(),u["false"]=u["null"]=u["true"]=u.undefined=false,o=f(),o.k=n,o.l=u,o.push=e;++t<r;)o.push(n[t]);return o}function i(n){return"\\"+U[n]
        }function a(){return h.pop()||[]}function f(){return g.pop()||{k:null,l:null,m:null,"false":false,n:0,"null":false,number:null,object:null,push:null,string:null,"true":false,undefined:false,o:null}}function l(n){n.length=0,h.length<_&&h.push(n)}function c(n){var t=n.l;t&&c(t),n.k=n.l=n.m=n.object=n.number=n.string=n.o=null,g.length<_&&g.push(n)}function p(n,t,e){t||(t=0),typeof e=="undefined"&&(e=n?n.length:0);var r=-1;e=e-t||0;for(var u=Array(0>e?0:e);++r<e;)u[r]=n[t+r];return u}function s(e){function h(n,t,e){if(!n||!V[typeof n])return n;
          t=t&&typeof e=="undefined"?t:tt(t,e,3);for(var r=-1,u=V[typeof n]&&Fe(n),o=u?u.length:0;++r<o&&(e=u[r],false!==t(n[e],e,n)););return n}function g(n,t,e){var r;if(!n||!V[typeof n])return n;t=t&&typeof e=="undefined"?t:tt(t,e,3);for(r in n)if(false===t(n[r],r,n))break;return n}function _(n,t,e){var r,u=n,o=u;if(!u)return o;for(var i=arguments,a=0,f=typeof e=="number"?2:i.length;++a<f;)if((u=i[a])&&V[typeof u])for(var l=-1,c=V[typeof u]&&Fe(u),p=c?c.length:0;++l<p;)r=c[l],"undefined"==typeof o[r]&&(o[r]=u[r]);
          return o}function U(n,t,e){var r,u=n,o=u;if(!u)return o;var i=arguments,a=0,f=typeof e=="number"?2:i.length;if(3<f&&"function"==typeof i[f-2])var l=tt(i[--f-1],i[f--],2);else 2<f&&"function"==typeof i[f-1]&&(l=i[--f]);for(;++a<f;)if((u=i[a])&&V[typeof u])for(var c=-1,p=V[typeof u]&&Fe(u),s=p?p.length:0;++c<s;)r=p[c],o[r]=l?l(o[r],u[r]):u[r];return o}function H(n){var t,e=[];if(!n||!V[typeof n])return e;for(t in n)me.call(n,t)&&e.push(t);return e}function J(n){return n&&typeof n=="object"&&!Te(n)&&me.call(n,"__wrapped__")?n:new Q(n)
        }function Q(n,t){this.__chain__=!!t,this.__wrapped__=n}function X(n){function t(){if(r){var n=p(r);be.apply(n,arguments)}if(this instanceof t){var o=nt(e.prototype),n=e.apply(o,n||arguments);return wt(n)?n:o}return e.apply(u,n||arguments)}var e=n[0],r=n[2],u=n[4];return $e(t,n),t}function Z(n,t,e,r,u){if(e){var o=e(n);if(typeof o!="undefined")return o}if(!wt(n))return n;var i=ce.call(n);if(!K[i])return n;var f=Ae[i];switch(i){case T:case F:return new f(+n);case W:case P:return new f(n);case z:return o=f(n.source,C.exec(n)),o.lastIndex=n.lastIndex,o
        }if(i=Te(n),t){var c=!r;r||(r=a()),u||(u=a());for(var s=r.length;s--;)if(r[s]==n)return u[s];o=i?f(n.length):{}}else o=i?p(n):U({},n);return i&&(me.call(n,"index")&&(o.index=n.index),me.call(n,"input")&&(o.input=n.input)),t?(r.push(n),u.push(o),(i?St:h)(n,function(n,i){o[i]=Z(n,t,e,r,u)}),c&&(l(r),l(u)),o):o}function nt(n){return wt(n)?ke(n):{}}function tt(n,t,e){if(typeof n!="function")return Ut;if(typeof t=="undefined"||!("prototype"in n))return n;var r=n.__bindData__;if(typeof r=="undefined"&&(De.funcNames&&(r=!n.name),r=r||!De.funcDecomp,!r)){var u=ge.call(n);
          De.funcNames||(r=!O.test(u)),r||(r=E.test(u),$e(n,r))}if(false===r||true!==r&&1&r[1])return n;switch(e){case 1:return function(e){return n.call(t,e)};case 2:return function(e,r){return n.call(t,e,r)};case 3:return function(e,r,u){return n.call(t,e,r,u)};case 4:return function(e,r,u,o){return n.call(t,e,r,u,o)}}return Mt(n,t)}function et(n){function t(){var n=f?i:this;if(u){var h=p(u);be.apply(h,arguments)}return(o||c)&&(h||(h=p(arguments)),o&&be.apply(h,o),c&&h.length<a)?(r|=16,et([e,s?r:-4&r,h,null,i,a])):(h||(h=arguments),l&&(e=n[v]),this instanceof t?(n=nt(e.prototype),h=e.apply(n,h),wt(h)?h:n):e.apply(n,h))
        }var e=n[0],r=n[1],u=n[2],o=n[3],i=n[4],a=n[5],f=1&r,l=2&r,c=4&r,s=8&r,v=e;return $e(t,n),t}function rt(e,r){var u=-1,i=st(),a=e?e.length:0,f=a>=b&&i===n,l=[];if(f){var p=o(r);p?(i=t,r=p):f=false}for(;++u<a;)p=e[u],0>i(r,p)&&l.push(p);return f&&c(r),l}function ut(n,t,e,r){r=(r||0)-1;for(var u=n?n.length:0,o=[];++r<u;){var i=n[r];if(i&&typeof i=="object"&&typeof i.length=="number"&&(Te(i)||yt(i))){t||(i=ut(i,t,e));var a=-1,f=i.length,l=o.length;for(o.length+=f;++a<f;)o[l++]=i[a]}else e||o.push(i)}return o
        }function ot(n,t,e,r,u,o){if(e){var i=e(n,t);if(typeof i!="undefined")return!!i}if(n===t)return 0!==n||1/n==1/t;if(n===n&&!(n&&V[typeof n]||t&&V[typeof t]))return false;if(null==n||null==t)return n===t;var f=ce.call(n),c=ce.call(t);if(f==D&&(f=q),c==D&&(c=q),f!=c)return false;switch(f){case T:case F:return+n==+t;case W:return n!=+n?t!=+t:0==n?1/n==1/t:n==+t;case z:case P:return n==oe(t)}if(c=f==$,!c){var p=me.call(n,"__wrapped__"),s=me.call(t,"__wrapped__");if(p||s)return ot(p?n.__wrapped__:n,s?t.__wrapped__:t,e,r,u,o);
          if(f!=q)return false;if(f=n.constructor,p=t.constructor,f!=p&&!(dt(f)&&f instanceof f&&dt(p)&&p instanceof p)&&"constructor"in n&&"constructor"in t)return false}for(f=!u,u||(u=a()),o||(o=a()),p=u.length;p--;)if(u[p]==n)return o[p]==t;var v=0,i=true;if(u.push(n),o.push(t),c){if(p=n.length,v=t.length,(i=v==p)||r)for(;v--;)if(c=p,s=t[v],r)for(;c--&&!(i=ot(n[c],s,e,r,u,o)););else if(!(i=ot(n[v],s,e,r,u,o)))break}else g(t,function(t,a,f){return me.call(f,a)?(v++,i=me.call(n,a)&&ot(n[a],t,e,r,u,o)):void 0}),i&&!r&&g(n,function(n,t,e){return me.call(e,t)?i=-1<--v:void 0
        });return u.pop(),o.pop(),f&&(l(u),l(o)),i}function it(n,t,e,r,u){(Te(t)?St:h)(t,function(t,o){var i,a,f=t,l=n[o];if(t&&((a=Te(t))||Pe(t))){for(f=r.length;f--;)if(i=r[f]==t){l=u[f];break}if(!i){var c;e&&(f=e(l,t),c=typeof f!="undefined")&&(l=f),c||(l=a?Te(l)?l:[]:Pe(l)?l:{}),r.push(t),u.push(l),c||it(l,t,e,r,u)}}else e&&(f=e(l,t),typeof f=="undefined"&&(f=t)),typeof f!="undefined"&&(l=f);n[o]=l})}function at(n,t){return n+he(Re()*(t-n+1))}function ft(e,r,u){var i=-1,f=st(),p=e?e.length:0,s=[],v=!r&&p>=b&&f===n,h=u||v?a():s;
          for(v&&(h=o(h),f=t);++i<p;){var g=e[i],y=u?u(g,i,e):g;(r?!i||h[h.length-1]!==y:0>f(h,y))&&((u||v)&&h.push(y),s.push(g))}return v?(l(h.k),c(h)):u&&l(h),s}function lt(n){return function(t,e,r){var u={};e=J.createCallback(e,r,3),r=-1;var o=t?t.length:0;if(typeof o=="number")for(;++r<o;){var i=t[r];n(u,i,e(i,r,t),t)}else h(t,function(t,r,o){n(u,t,e(t,r,o),o)});return u}}function ct(n,t,e,r,u,o){var i=1&t,a=4&t,f=16&t,l=32&t;if(!(2&t||dt(n)))throw new ie;f&&!e.length&&(t&=-17,f=e=false),l&&!r.length&&(t&=-33,l=r=false);
          var c=n&&n.__bindData__;return c&&true!==c?(c=p(c),c[2]&&(c[2]=p(c[2])),c[3]&&(c[3]=p(c[3])),!i||1&c[1]||(c[4]=u),!i&&1&c[1]&&(t|=8),!a||4&c[1]||(c[5]=o),f&&be.apply(c[2]||(c[2]=[]),e),l&&we.apply(c[3]||(c[3]=[]),r),c[1]|=t,ct.apply(null,c)):(1==t||17===t?X:et)([n,t,e,r,u,o])}function pt(n){return Be[n]}function st(){var t=(t=J.indexOf)===Wt?n:t;return t}function vt(n){return typeof n=="function"&&pe.test(n)}function ht(n){var t,e;return n&&ce.call(n)==q&&(t=n.constructor,!dt(t)||t instanceof t)?(g(n,function(n,t){e=t
        }),typeof e=="undefined"||me.call(n,e)):false}function gt(n){return We[n]}function yt(n){return n&&typeof n=="object"&&typeof n.length=="number"&&ce.call(n)==D||false}function mt(n,t,e){var r=Fe(n),u=r.length;for(t=tt(t,e,3);u--&&(e=r[u],false!==t(n[e],e,n)););return n}function bt(n){var t=[];return g(n,function(n,e){dt(n)&&t.push(e)}),t.sort()}function _t(n){for(var t=-1,e=Fe(n),r=e.length,u={};++t<r;){var o=e[t];u[n[o]]=o}return u}function dt(n){return typeof n=="function"}function wt(n){return!(!n||!V[typeof n])
        }function jt(n){return typeof n=="number"||n&&typeof n=="object"&&ce.call(n)==W||false}function kt(n){return typeof n=="string"||n&&typeof n=="object"&&ce.call(n)==P||false}function xt(n){for(var t=-1,e=Fe(n),r=e.length,u=Xt(r);++t<r;)u[t]=n[e[t]];return u}function Ct(n,t,e){var r=-1,u=st(),o=n?n.length:0,i=false;return e=(0>e?Ie(0,o+e):e)||0,Te(n)?i=-1<u(n,t,e):typeof o=="number"?i=-1<(kt(n)?n.indexOf(t,e):u(n,t,e)):h(n,function(n){return++r<e?void 0:!(i=n===t)}),i}function Ot(n,t,e){var r=true;t=J.createCallback(t,e,3),e=-1;
          var u=n?n.length:0;if(typeof u=="number")for(;++e<u&&(r=!!t(n[e],e,n)););else h(n,function(n,e,u){return r=!!t(n,e,u)});return r}function Nt(n,t,e){var r=[];t=J.createCallback(t,e,3),e=-1;var u=n?n.length:0;if(typeof u=="number")for(;++e<u;){var o=n[e];t(o,e,n)&&r.push(o)}else h(n,function(n,e,u){t(n,e,u)&&r.push(n)});return r}function It(n,t,e){t=J.createCallback(t,e,3),e=-1;var r=n?n.length:0;if(typeof r!="number"){var u;return h(n,function(n,e,r){return t(n,e,r)?(u=n,false):void 0}),u}for(;++e<r;){var o=n[e];
          if(t(o,e,n))return o}}function St(n,t,e){var r=-1,u=n?n.length:0;if(t=t&&typeof e=="undefined"?t:tt(t,e,3),typeof u=="number")for(;++r<u&&false!==t(n[r],r,n););else h(n,t);return n}function Et(n,t,e){var r=n?n.length:0;if(t=t&&typeof e=="undefined"?t:tt(t,e,3),typeof r=="number")for(;r--&&false!==t(n[r],r,n););else{var u=Fe(n),r=u.length;h(n,function(n,e,o){return e=u?u[--r]:--r,t(o[e],e,o)})}return n}function Rt(n,t,e){var r=-1,u=n?n.length:0;if(t=J.createCallback(t,e,3),typeof u=="number")for(var o=Xt(u);++r<u;)o[r]=t(n[r],r,n);
        else o=[],h(n,function(n,e,u){o[++r]=t(n,e,u)});return o}function At(n,t,e){var u=-1/0,o=u;if(typeof t!="function"&&e&&e[t]===n&&(t=null),null==t&&Te(n)){e=-1;for(var i=n.length;++e<i;){var a=n[e];a>o&&(o=a)}}else t=null==t&&kt(n)?r:J.createCallback(t,e,3),St(n,function(n,e,r){e=t(n,e,r),e>u&&(u=e,o=n)});return o}function Dt(n,t,e,r){if(!n)return e;var u=3>arguments.length;t=J.createCallback(t,r,4);var o=-1,i=n.length;if(typeof i=="number")for(u&&(e=n[++o]);++o<i;)e=t(e,n[o],o,n);else h(n,function(n,r,o){e=u?(u=false,n):t(e,n,r,o)
        });return e}function $t(n,t,e,r){var u=3>arguments.length;return t=J.createCallback(t,r,4),Et(n,function(n,r,o){e=u?(u=false,n):t(e,n,r,o)}),e}function Tt(n){var t=-1,e=n?n.length:0,r=Xt(typeof e=="number"?e:0);return St(n,function(n){var e=at(0,++t);r[t]=r[e],r[e]=n}),r}function Ft(n,t,e){var r;t=J.createCallback(t,e,3),e=-1;var u=n?n.length:0;if(typeof u=="number")for(;++e<u&&!(r=t(n[e],e,n)););else h(n,function(n,e,u){return!(r=t(n,e,u))});return!!r}function Bt(n,t,e){var r=0,u=n?n.length:0;if(typeof t!="number"&&null!=t){var o=-1;
          for(t=J.createCallback(t,e,3);++o<u&&t(n[o],o,n);)r++}else if(r=t,null==r||e)return n?n[0]:v;return p(n,0,Se(Ie(0,r),u))}function Wt(t,e,r){if(typeof r=="number"){var u=t?t.length:0;r=0>r?Ie(0,u+r):r||0}else if(r)return r=zt(t,e),t[r]===e?r:-1;return n(t,e,r)}function qt(n,t,e){if(typeof t!="number"&&null!=t){var r=0,u=-1,o=n?n.length:0;for(t=J.createCallback(t,e,3);++u<o&&t(n[u],u,n);)r++}else r=null==t||e?1:Ie(0,t);return p(n,r)}function zt(n,t,e,r){var u=0,o=n?n.length:u;for(e=e?J.createCallback(e,r,1):Ut,t=e(t);u<o;)r=u+o>>>1,e(n[r])<t?u=r+1:o=r;
          return u}function Pt(n,t,e,r){return typeof t!="boolean"&&null!=t&&(r=e,e=typeof t!="function"&&r&&r[t]===n?null:t,t=false),null!=e&&(e=J.createCallback(e,r,3)),ft(n,t,e)}function Kt(){for(var n=1<arguments.length?arguments:arguments[0],t=-1,e=n?At(Ve(n,"length")):0,r=Xt(0>e?0:e);++t<e;)r[t]=Ve(n,t);return r}function Lt(n,t){var e=-1,r=n?n.length:0,u={};for(t||!r||Te(n[0])||(t=[]);++e<r;){var o=n[e];t?u[o]=t[e]:o&&(u[o[0]]=o[1])}return u}function Mt(n,t){return 2<arguments.length?ct(n,17,p(arguments,2),null,t):ct(n,1,null,null,t)
        }function Vt(n,t,e){function r(){c&&ve(c),i=c=p=v,(g||h!==t)&&(s=Ue(),a=n.apply(l,o),c||i||(o=l=null))}function u(){var e=t-(Ue()-f);0<e?c=_e(u,e):(i&&ve(i),e=p,i=c=p=v,e&&(s=Ue(),a=n.apply(l,o),c||i||(o=l=null)))}var o,i,a,f,l,c,p,s=0,h=false,g=true;if(!dt(n))throw new ie;if(t=Ie(0,t)||0,true===e)var y=true,g=false;else wt(e)&&(y=e.leading,h="maxWait"in e&&(Ie(t,e.maxWait)||0),g="trailing"in e?e.trailing:g);return function(){if(o=arguments,f=Ue(),l=this,p=g&&(c||!y),false===h)var e=y&&!c;else{i||y||(s=f);var v=h-(f-s),m=0>=v;
          m?(i&&(i=ve(i)),s=f,a=n.apply(l,o)):i||(i=_e(r,v))}return m&&c?c=ve(c):c||t===h||(c=_e(u,t)),e&&(m=true,a=n.apply(l,o)),!m||c||i||(o=l=null),a}}function Ut(n){return n}function Gt(n,t,e){var r=true,u=t&&bt(t);t&&(e||u.length)||(null==e&&(e=t),o=Q,t=n,n=J,u=bt(t)),false===e?r=false:wt(e)&&"chain"in e&&(r=e.chain);var o=n,i=dt(o);St(u,function(e){var u=n[e]=t[e];i&&(o.prototype[e]=function(){var t=this.__chain__,e=this.__wrapped__,i=[e];if(be.apply(i,arguments),i=u.apply(n,i),r||t){if(e===i&&wt(i))return this;
          i=new o(i),i.__chain__=t}return i})})}function Ht(){}function Jt(n){return function(t){return t[n]}}function Qt(){return this.__wrapped__}e=e?Y.defaults(G.Object(),e,Y.pick(G,A)):G;var Xt=e.Array,Yt=e.Boolean,Zt=e.Date,ne=e.Function,te=e.Math,ee=e.Number,re=e.Object,ue=e.RegExp,oe=e.String,ie=e.TypeError,ae=[],fe=re.prototype,le=e._,ce=fe.toString,pe=ue("^"+oe(ce).replace(/[.*+?^${}()|[\]\\]/g,"\\$&").replace(/toString| for [^\]]+/g,".*?")+"$"),se=te.ceil,ve=e.clearTimeout,he=te.floor,ge=ne.prototype.toString,ye=vt(ye=re.getPrototypeOf)&&ye,me=fe.hasOwnProperty,be=ae.push,_e=e.setTimeout,de=ae.splice,we=ae.unshift,je=function(){try{var n={},t=vt(t=re.defineProperty)&&t,e=t(n,n,n)&&t
        }catch(r){}return e}(),ke=vt(ke=re.create)&&ke,xe=vt(xe=Xt.isArray)&&xe,Ce=e.isFinite,Oe=e.isNaN,Ne=vt(Ne=re.keys)&&Ne,Ie=te.max,Se=te.min,Ee=e.parseInt,Re=te.random,Ae={};Ae[$]=Xt,Ae[T]=Yt,Ae[F]=Zt,Ae[B]=ne,Ae[q]=re,Ae[W]=ee,Ae[z]=ue,Ae[P]=oe,Q.prototype=J.prototype;var De=J.support={};De.funcDecomp=!vt(e.a)&&E.test(s),De.funcNames=typeof ne.name=="string",J.templateSettings={escape:/<%-([\s\S]+?)%>/g,evaluate:/<%([\s\S]+?)%>/g,interpolate:N,variable:"",imports:{_:J}},ke||(nt=function(){function n(){}return function(t){if(wt(t)){n.prototype=t;
          var r=new n;n.prototype=null}return r||e.Object()}}());var $e=je?function(n,t){M.value=t,je(n,"__bindData__",M)}:Ht,Te=xe||function(n){return n&&typeof n=="object"&&typeof n.length=="number"&&ce.call(n)==$||false},Fe=Ne?function(n){return wt(n)?Ne(n):[]}:H,Be={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},We=_t(Be),qe=ue("("+Fe(We).join("|")+")","g"),ze=ue("["+Fe(Be).join("")+"]","g"),Pe=ye?function(n){if(!n||ce.call(n)!=q)return false;var t=n.valueOf,e=vt(t)&&(e=ye(t))&&ye(e);return e?n==e||ye(n)==e:ht(n)
        }:ht,Ke=lt(function(n,t,e){me.call(n,e)?n[e]++:n[e]=1}),Le=lt(function(n,t,e){(me.call(n,e)?n[e]:n[e]=[]).push(t)}),Me=lt(function(n,t,e){n[e]=t}),Ve=Rt,Ue=vt(Ue=Zt.now)&&Ue||function(){return(new Zt).getTime()},Ge=8==Ee(d+"08")?Ee:function(n,t){return Ee(kt(n)?n.replace(I,""):n,t||0)};return J.after=function(n,t){if(!dt(t))throw new ie;return function(){return 1>--n?t.apply(this,arguments):void 0}},J.assign=U,J.at=function(n){for(var t=arguments,e=-1,r=ut(t,true,false,1),t=t[2]&&t[2][t[1]]===n?1:r.length,u=Xt(t);++e<t;)u[e]=n[r[e]];
          return u},J.bind=Mt,J.bindAll=function(n){for(var t=1<arguments.length?ut(arguments,true,false,1):bt(n),e=-1,r=t.length;++e<r;){var u=t[e];n[u]=ct(n[u],1,null,null,n)}return n},J.bindKey=function(n,t){return 2<arguments.length?ct(t,19,p(arguments,2),null,n):ct(t,3,null,null,n)},J.chain=function(n){return n=new Q(n),n.__chain__=true,n},J.compact=function(n){for(var t=-1,e=n?n.length:0,r=[];++t<e;){var u=n[t];u&&r.push(u)}return r},J.compose=function(){for(var n=arguments,t=n.length;t--;)if(!dt(n[t]))throw new ie;
          return function(){for(var t=arguments,e=n.length;e--;)t=[n[e].apply(this,t)];return t[0]}},J.constant=function(n){return function(){return n}},J.countBy=Ke,J.create=function(n,t){var e=nt(n);return t?U(e,t):e},J.createCallback=function(n,t,e){var r=typeof n;if(null==n||"function"==r)return tt(n,t,e);if("object"!=r)return Jt(n);var u=Fe(n),o=u[0],i=n[o];return 1!=u.length||i!==i||wt(i)?function(t){for(var e=u.length,r=false;e--&&(r=ot(t[u[e]],n[u[e]],null,true)););return r}:function(n){return n=n[o],i===n&&(0!==i||1/i==1/n)
        }},J.curry=function(n,t){return t=typeof t=="number"?t:+t||n.length,ct(n,4,null,null,null,t)},J.debounce=Vt,J.defaults=_,J.defer=function(n){if(!dt(n))throw new ie;var t=p(arguments,1);return _e(function(){n.apply(v,t)},1)},J.delay=function(n,t){if(!dt(n))throw new ie;var e=p(arguments,2);return _e(function(){n.apply(v,e)},t)},J.difference=function(n){return rt(n,ut(arguments,true,true,1))},J.filter=Nt,J.flatten=function(n,t,e,r){return typeof t!="boolean"&&null!=t&&(r=e,e=typeof t!="function"&&r&&r[t]===n?null:t,t=false),null!=e&&(n=Rt(n,e,r)),ut(n,t)
        },J.forEach=St,J.forEachRight=Et,J.forIn=g,J.forInRight=function(n,t,e){var r=[];g(n,function(n,t){r.push(t,n)});var u=r.length;for(t=tt(t,e,3);u--&&false!==t(r[u--],r[u],n););return n},J.forOwn=h,J.forOwnRight=mt,J.functions=bt,J.groupBy=Le,J.indexBy=Me,J.initial=function(n,t,e){var r=0,u=n?n.length:0;if(typeof t!="number"&&null!=t){var o=u;for(t=J.createCallback(t,e,3);o--&&t(n[o],o,n);)r++}else r=null==t||e?1:t||r;return p(n,0,Se(Ie(0,u-r),u))},J.intersection=function(){for(var e=[],r=-1,u=arguments.length,i=a(),f=st(),p=f===n,s=a();++r<u;){var v=arguments[r];
          (Te(v)||yt(v))&&(e.push(v),i.push(p&&v.length>=b&&o(r?e[r]:s)))}var p=e[0],h=-1,g=p?p.length:0,y=[];n:for(;++h<g;){var m=i[0],v=p[h];if(0>(m?t(m,v):f(s,v))){for(r=u,(m||s).push(v);--r;)if(m=i[r],0>(m?t(m,v):f(e[r],v)))continue n;y.push(v)}}for(;u--;)(m=i[u])&&c(m);return l(i),l(s),y},J.invert=_t,J.invoke=function(n,t){var e=p(arguments,2),r=-1,u=typeof t=="function",o=n?n.length:0,i=Xt(typeof o=="number"?o:0);return St(n,function(n){i[++r]=(u?t:n[t]).apply(n,e)}),i},J.keys=Fe,J.map=Rt,J.mapValues=function(n,t,e){var r={};
          return t=J.createCallback(t,e,3),h(n,function(n,e,u){r[e]=t(n,e,u)}),r},J.max=At,J.memoize=function(n,t){function e(){var r=e.cache,u=t?t.apply(this,arguments):m+arguments[0];return me.call(r,u)?r[u]:r[u]=n.apply(this,arguments)}if(!dt(n))throw new ie;return e.cache={},e},J.merge=function(n){var t=arguments,e=2;if(!wt(n))return n;if("number"!=typeof t[2]&&(e=t.length),3<e&&"function"==typeof t[e-2])var r=tt(t[--e-1],t[e--],2);else 2<e&&"function"==typeof t[e-1]&&(r=t[--e]);for(var t=p(arguments,1,e),u=-1,o=a(),i=a();++u<e;)it(n,t[u],r,o,i);
          return l(o),l(i),n},J.min=function(n,t,e){var u=1/0,o=u;if(typeof t!="function"&&e&&e[t]===n&&(t=null),null==t&&Te(n)){e=-1;for(var i=n.length;++e<i;){var a=n[e];a<o&&(o=a)}}else t=null==t&&kt(n)?r:J.createCallback(t,e,3),St(n,function(n,e,r){e=t(n,e,r),e<u&&(u=e,o=n)});return o},J.omit=function(n,t,e){var r={};if(typeof t!="function"){var u=[];g(n,function(n,t){u.push(t)});for(var u=rt(u,ut(arguments,true,false,1)),o=-1,i=u.length;++o<i;){var a=u[o];r[a]=n[a]}}else t=J.createCallback(t,e,3),g(n,function(n,e,u){t(n,e,u)||(r[e]=n)
        });return r},J.once=function(n){var t,e;if(!dt(n))throw new ie;return function(){return t?e:(t=true,e=n.apply(this,arguments),n=null,e)}},J.pairs=function(n){for(var t=-1,e=Fe(n),r=e.length,u=Xt(r);++t<r;){var o=e[t];u[t]=[o,n[o]]}return u},J.partial=function(n){return ct(n,16,p(arguments,1))},J.partialRight=function(n){return ct(n,32,null,p(arguments,1))},J.pick=function(n,t,e){var r={};if(typeof t!="function")for(var u=-1,o=ut(arguments,true,false,1),i=wt(n)?o.length:0;++u<i;){var a=o[u];a in n&&(r[a]=n[a])
        }else t=J.createCallback(t,e,3),g(n,function(n,e,u){t(n,e,u)&&(r[e]=n)});return r},J.pluck=Ve,J.property=Jt,J.pull=function(n){for(var t=arguments,e=0,r=t.length,u=n?n.length:0;++e<r;)for(var o=-1,i=t[e];++o<u;)n[o]===i&&(de.call(n,o--,1),u--);return n},J.range=function(n,t,e){n=+n||0,e=typeof e=="number"?e:+e||1,null==t&&(t=n,n=0);var r=-1;t=Ie(0,se((t-n)/(e||1)));for(var u=Xt(t);++r<t;)u[r]=n,n+=e;return u},J.reject=function(n,t,e){return t=J.createCallback(t,e,3),Nt(n,function(n,e,r){return!t(n,e,r)
        })},J.remove=function(n,t,e){var r=-1,u=n?n.length:0,o=[];for(t=J.createCallback(t,e,3);++r<u;)e=n[r],t(e,r,n)&&(o.push(e),de.call(n,r--,1),u--);return o},J.rest=qt,J.shuffle=Tt,J.sortBy=function(n,t,e){var r=-1,o=Te(t),i=n?n.length:0,p=Xt(typeof i=="number"?i:0);for(o||(t=J.createCallback(t,e,3)),St(n,function(n,e,u){var i=p[++r]=f();o?i.m=Rt(t,function(t){return n[t]}):(i.m=a())[0]=t(n,e,u),i.n=r,i.o=n}),i=p.length,p.sort(u);i--;)n=p[i],p[i]=n.o,o||l(n.m),c(n);return p},J.tap=function(n,t){return t(n),n
        },J.throttle=function(n,t,e){var r=true,u=true;if(!dt(n))throw new ie;return false===e?r=false:wt(e)&&(r="leading"in e?e.leading:r,u="trailing"in e?e.trailing:u),L.leading=r,L.maxWait=t,L.trailing=u,Vt(n,t,L)},J.times=function(n,t,e){n=-1<(n=+n)?n:0;var r=-1,u=Xt(n);for(t=tt(t,e,1);++r<n;)u[r]=t(r);return u},J.toArray=function(n){return n&&typeof n.length=="number"?p(n):xt(n)},J.transform=function(n,t,e,r){var u=Te(n);if(null==e)if(u)e=[];else{var o=n&&n.constructor;e=nt(o&&o.prototype)}return t&&(t=J.createCallback(t,r,4),(u?St:h)(n,function(n,r,u){return t(e,n,r,u)
        })),e},J.union=function(){return ft(ut(arguments,true,true))},J.uniq=Pt,J.values=xt,J.where=Nt,J.without=function(n){return rt(n,p(arguments,1))},J.wrap=function(n,t){return ct(t,16,[n])},J.xor=function(){for(var n=-1,t=arguments.length;++n<t;){var e=arguments[n];if(Te(e)||yt(e))var r=r?ft(rt(r,e).concat(rt(e,r))):e}return r||[]},J.zip=Kt,J.zipObject=Lt,J.collect=Rt,J.drop=qt,J.each=St,J.eachRight=Et,J.extend=U,J.methods=bt,J.object=Lt,J.select=Nt,J.tail=qt,J.unique=Pt,J.unzip=Kt,Gt(J),J.clone=function(n,t,e,r){return typeof t!="boolean"&&null!=t&&(r=e,e=t,t=false),Z(n,t,typeof e=="function"&&tt(e,r,1))
        },J.cloneDeep=function(n,t,e){return Z(n,true,typeof t=="function"&&tt(t,e,1))},J.contains=Ct,J.escape=function(n){return null==n?"":oe(n).replace(ze,pt)},J.every=Ot,J.find=It,J.findIndex=function(n,t,e){var r=-1,u=n?n.length:0;for(t=J.createCallback(t,e,3);++r<u;)if(t(n[r],r,n))return r;return-1},J.findKey=function(n,t,e){var r;return t=J.createCallback(t,e,3),h(n,function(n,e,u){return t(n,e,u)?(r=e,false):void 0}),r},J.findLast=function(n,t,e){var r;return t=J.createCallback(t,e,3),Et(n,function(n,e,u){return t(n,e,u)?(r=n,false):void 0
        }),r},J.findLastIndex=function(n,t,e){var r=n?n.length:0;for(t=J.createCallback(t,e,3);r--;)if(t(n[r],r,n))return r;return-1},J.findLastKey=function(n,t,e){var r;return t=J.createCallback(t,e,3),mt(n,function(n,e,u){return t(n,e,u)?(r=e,false):void 0}),r},J.has=function(n,t){return n?me.call(n,t):false},J.identity=Ut,J.indexOf=Wt,J.isArguments=yt,J.isArray=Te,J.isBoolean=function(n){return true===n||false===n||n&&typeof n=="object"&&ce.call(n)==T||false},J.isDate=function(n){return n&&typeof n=="object"&&ce.call(n)==F||false
        },J.isElement=function(n){return n&&1===n.nodeType||false},J.isEmpty=function(n){var t=true;if(!n)return t;var e=ce.call(n),r=n.length;return e==$||e==P||e==D||e==q&&typeof r=="number"&&dt(n.splice)?!r:(h(n,function(){return t=false}),t)},J.isEqual=function(n,t,e,r){return ot(n,t,typeof e=="function"&&tt(e,r,2))},J.isFinite=function(n){return Ce(n)&&!Oe(parseFloat(n))},J.isFunction=dt,J.isNaN=function(n){return jt(n)&&n!=+n},J.isNull=function(n){return null===n},J.isNumber=jt,J.isObject=wt,J.isPlainObject=Pe,J.isRegExp=function(n){return n&&typeof n=="object"&&ce.call(n)==z||false
        },J.isString=kt,J.isUndefined=function(n){return typeof n=="undefined"},J.lastIndexOf=function(n,t,e){var r=n?n.length:0;for(typeof e=="number"&&(r=(0>e?Ie(0,r+e):Se(e,r-1))+1);r--;)if(n[r]===t)return r;return-1},J.mixin=Gt,J.noConflict=function(){return e._=le,this},J.noop=Ht,J.now=Ue,J.parseInt=Ge,J.random=function(n,t,e){var r=null==n,u=null==t;return null==e&&(typeof n=="boolean"&&u?(e=n,n=1):u||typeof t!="boolean"||(e=t,u=true)),r&&u&&(t=1),n=+n||0,u?(t=n,n=0):t=+t||0,e||n%1||t%1?(e=Re(),Se(n+e*(t-n+parseFloat("1e-"+((e+"").length-1))),t)):at(n,t)
        },J.reduce=Dt,J.reduceRight=$t,J.result=function(n,t){if(n){var e=n[t];return dt(e)?n[t]():e}},J.runInContext=s,J.size=function(n){var t=n?n.length:0;return typeof t=="number"?t:Fe(n).length},J.some=Ft,J.sortedIndex=zt,J.template=function(n,t,e){var r=J.templateSettings;n=oe(n||""),e=_({},e,r);var u,o=_({},e.imports,r.imports),r=Fe(o),o=xt(o),a=0,f=e.interpolate||S,l="__p+='",f=ue((e.escape||S).source+"|"+f.source+"|"+(f===N?x:S).source+"|"+(e.evaluate||S).source+"|$","g");n.replace(f,function(t,e,r,o,f,c){return r||(r=o),l+=n.slice(a,c).replace(R,i),e&&(l+="'+__e("+e+")+'"),f&&(u=true,l+="';"+f+";\n__p+='"),r&&(l+="'+((__t=("+r+"))==null?'':__t)+'"),a=c+t.length,t
        }),l+="';",f=e=e.variable,f||(e="obj",l="with("+e+"){"+l+"}"),l=(u?l.replace(w,""):l).replace(j,"$1").replace(k,"$1;"),l="function("+e+"){"+(f?"":e+"||("+e+"={});")+"var __t,__p='',__e=_.escape"+(u?",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}":";")+l+"return __p}";try{var c=ne(r,"return "+l).apply(v,o)}catch(p){throw p.source=l,p}return t?c(t):(c.source=l,c)},J.unescape=function(n){return null==n?"":oe(n).replace(qe,gt)},J.uniqueId=function(n){var t=++y;return oe(null==n?"":n)+t
        },J.all=Ot,J.any=Ft,J.detect=It,J.findWhere=It,J.foldl=Dt,J.foldr=$t,J.include=Ct,J.inject=Dt,Gt(function(){var n={};return h(J,function(t,e){J.prototype[e]||(n[e]=t)}),n}(),false),J.first=Bt,J.last=function(n,t,e){var r=0,u=n?n.length:0;if(typeof t!="number"&&null!=t){var o=u;for(t=J.createCallback(t,e,3);o--&&t(n[o],o,n);)r++}else if(r=t,null==r||e)return n?n[u-1]:v;return p(n,Ie(0,u-r))},J.sample=function(n,t,e){return n&&typeof n.length!="number"&&(n=xt(n)),null==t||e?n?n[at(0,n.length-1)]:v:(n=Tt(n),n.length=Se(Ie(0,t),n.length),n)
        },J.take=Bt,J.head=Bt,h(J,function(n,t){var e="sample"!==t;J.prototype[t]||(J.prototype[t]=function(t,r){var u=this.__chain__,o=n(this.__wrapped__,t,r);return u||null!=t&&(!r||e&&typeof t=="function")?new Q(o,u):o})}),J.VERSION="2.4.1",J.prototype.chain=function(){return this.__chain__=true,this},J.prototype.toString=function(){return oe(this.__wrapped__)},J.prototype.value=Qt,J.prototype.valueOf=Qt,St(["join","pop","shift"],function(n){var t=ae[n];J.prototype[n]=function(){var n=this.__chain__,e=t.apply(this.__wrapped__,arguments);
          return n?new Q(e,n):e}}),St(["push","reverse","sort","unshift"],function(n){var t=ae[n];J.prototype[n]=function(){return t.apply(this.__wrapped__,arguments),this}}),St(["concat","slice","splice"],function(n){var t=ae[n];J.prototype[n]=function(){return new Q(t.apply(this.__wrapped__,arguments),this.__chain__)}}),J}var v,h=[],g=[],y=0,m=+new Date+"",b=75,_=40,d=" \t\x0B\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000",w=/\b__p\+='';/g,j=/\b(__p\+=)''\+/g,k=/(__e\(.*?\)|\b__t\))\+'';/g,x=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,C=/\w*$/,O=/^\s*function[ \n\r\t]+\w/,N=/<%=([\s\S]+?)%>/g,I=RegExp("^["+d+"]*0+(?=.$)"),S=/($^)/,E=/\bthis\b/,R=/['\n\r\t\u2028\u2029\\]/g,A="Array Boolean Date Function Math Number Object RegExp String _ attachEvent clearTimeout isFinite isNaN parseInt setTimeout".split(" "),D="[object Arguments]",$="[object Array]",T="[object Boolean]",F="[object Date]",B="[object Function]",W="[object Number]",q="[object Object]",z="[object RegExp]",P="[object String]",K={};
          K[B]=false,K[D]=K[$]=K[T]=K[F]=K[W]=K[q]=K[z]=K[P]=true;var L={leading:false,maxWait:0,trailing:false},M={configurable:false,enumerable:false,value:null,writable:false},V={"boolean":false,"function":true,object:true,number:false,string:false,undefined:false},U={"\\":"\\","'":"'","\n":"n","\r":"r","\t":"t","\u2028":"u2028","\u2029":"u2029"},G=V[typeof window]&&window||this,H=V[typeof exports]&&exports&&!exports.nodeType&&exports,J=V[typeof module]&&module&&!module.nodeType&&module,Q=J&&J.exports===H&&H,X=V[typeof global]&&global;!X||X.global!==X&&X.window!==X||(G=X);
          var Y=s();typeof define=="function"&&typeof define.amd=="object"&&define.amd?(G._=Y, define('../../sherpa/lodash-2.4.1.min',[],function(){return Y})):H&&J?Q?(J.exports=Y)._=Y:H._=Y:G._=Y}).call(this);
        // Copyright 2002-2013, University of Colorado Boulder
        
        define( '../../chipper/requirejs-plugins/getProjectURL',[],function() {
        
          return function( name, parentRequire ) {
            //trim the ? suffix, resolve on the last / (could later be converted to :)
            var url = parentRequire.toUrl( name.substring( 0, name.indexOf( '/' ) ) );
        
            return (url.indexOf( '?' ) >= 0 ? url.substring( 0, url.indexOf( '?' ) ) : url) + '/../';
          };
        } );
        define('string',{load: function(id){throw new Error("Dynamic load not allowed: " + id);}});
        
        define("string!FORCES_AND_MOTION_BASICS/go",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/go");});
        
        
        define("string!FORCES_AND_MOTION_BASICS/pause",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/pause");});
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Encapsulation of the font used for PhET simulations.
         * Provides PhET-specific defaults, and guarantees a fallback for font family.
         * <p>
         * Sample use:
         * new PhetFont( { family: 'Futura', size: 24, weight: 'bold' } )
         * new PhetFont( 24 )
         *
         * @author Chris Malley (PixelZoom, Inc.)
         */
        define( 'SCENERY_PHET/PhetFont',['require','SCENERY/util/Font','PHET_CORE/inherit'],function( require ) {
          
        
          // modules
          var Font = require( 'SCENERY/util/Font' );
          var inherit = require( 'PHET_CORE/inherit' );
        
          /**
           * @param {Number|*} options if number this is the font size, otherwise same options as scenery.Font
           * @constructor
           */
          function PhetFont( options ) {
        
            // convenience constructor: new PhetFont( {number|string} size )
            if ( typeof options === 'number' || typeof options === 'string' ) {
              options = { size: options };
            }
        
            // PhET defaults
            options = _.extend( {
              family: 'Arial'
            }, options );
        
            // Guarantee a fallback family
            assert && assert( options.family );
            options.family = options.family + ', sans-serif';
        
            Font.call( this, options );
          }
        
          return inherit( Font, PhetFont );
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Base class for button models, which describe the behavior of buttons when users interact with them.  Property values
         * are set by an associated listener, see ButtonListener for details.
         */
        define( 'SUN/buttons/ButtonModel',['require','PHET_CORE/inherit','AXON/PropertySet'],function( require ) {
          
        
          // Imports
          var inherit = require( 'PHET_CORE/inherit' );
          var PropertySet = require( 'AXON/PropertySet' );
        
          function ButtonModel() {
        
            PropertySet.call( this, {
        
              // Property that tracks whether or not a pointer that could interact with the button is currently over the button.
              over: false,
        
              // Property that tracks whether a pointer is currently down on, a.k.a. pressing, the button.
              down: false,
        
              // Property that tracks whether or not the button is enabled.
              enabled: true
            } );
          }
        
          return inherit( PropertySet, ButtonModel );
        } );
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Basic model for a push button, including over/down/enabled properties.
         *
         * @author Sam Reid
         * @author John Blanco
         */
        define( 'SUN/buttons/PushButtonModel',['require','PHET_CORE/inherit','SUN/buttons/ButtonModel'],function( require ) {
          
        
          // modules
          var inherit = require( 'PHET_CORE/inherit' );
          var ButtonModel = require( 'SUN/buttons/ButtonModel' );
        
          /**
           * @param {Object} options
           * @constructor
           */
          function PushButtonModel( options ) {
            var pushButtonModel = this;
        
            options = _.extend( {
              fireOnDown: false, // true: fire on pointer down; false: fire on pointer up if pointer is over button
              listener: null
            }, options );
        
            ButtonModel.call( this );
        
            this.listeners = []; //@private
            if ( options.listener !== null ) {
              this.listeners.push( options.listener );
            }
        
            // If button was pressed and "fire on down" was set, fire the listeners
            this.property( 'down' ).onValue( true, function() {
              if ( options.fireOnDown && pushButtonModel.enabled ) {
                pushButtonModel.fire();
              }
            } );
        
            // If button was released and "fire on down" was not set, fire the listeners
            this.property( 'down' ).onValue( false, function() {
              if ( !options.fireOnDown && pushButtonModel.over && pushButtonModel.enabled ) {
                pushButtonModel.fire();
              }
            } );
          }
        
          return inherit( ButtonModel, PushButtonModel, {
        
            // Adds a listener. If already a listener, this is a no-op.
            addListener: function( listener ) {
              if ( this.listeners.indexOf( listener ) === -1 ) {
                this.listeners.push( listener );
              }
            },
        
            // Remove a listener. If not a listener, this is a no-op.
            removeListener: function( listener ) {
              var i = this.listeners.indexOf( listener );
              if ( i !== -1 ) {
                this.listeners.splice( i, 1 );
              }
            },
        
            // Fires all listeners.
            // @private with the possible exception of hooking up for accessibility.
            fire: function() {
              var copy = this.listeners.slice( 0 );
              copy.forEach( function( listener ) {
                listener();
              } );
            }
          } );
        } );
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Basic down/up pointer handling for a Node, so that it's easy to handle buttons
         *
         * TODO: test hand handle down, go off screen, up. How to handle that properly?
         * TODO: tests
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/input/DownUpListener',['require','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          require( 'SCENERY/util/Trail' );
          
          /*
           * The 'trail' parameter passed to down/upInside/upOutside will end with the node to which this DownUpListener has been added.
           *
           * Allowed options: {
           *    mouseButton: 0  // The mouse button to use: left: 0, middle: 1, right: 2, see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent
           *    down: null      // down( event, trail ) is called when the pointer is pressed down on this node
           *                    // (and another pointer is not already down on it).
           *    up: null        // up( event, trail ) is called after 'down', regardless of the pointer's current location.
           *                    // Additionally, it is called AFTER upInside or upOutside, whichever is relevant
           *    upInside: null  // upInside( event, trail ) is called after 'down', when the pointer is released inside
           *                    // this node (it or a descendant is the top pickable node under the pointer)
           *    upOutside: null // upOutside( event, trail ) is called after 'down', when the pointer is released outside
           *                    // this node (it or a descendant is the not top pickable node under the pointer, even if the
           *                    // same instance is still directly under the pointer)
           * }
           */
          scenery.DownUpListener = function DownUpListener( options ) {
            var handler = this;
            
            this.options = _.extend( {
              mouseButton: 0 // allow a different mouse button 
            }, options );
            this.isDown = false;   // public, whether this listener is down
            this.downCurrentTarget = null; // 'up' is handled via a pointer lister, which will have null currentTarget, so save the 'down' currentTarget
            this.downTrail = null;
            this.pointer = null;
            
            // this listener gets added to the pointer on a 'down'
            this.downListener = {
              // mouse/touch up
              up: function( event ) {
                sceneryEventLog && sceneryEventLog( 'DownUpListener (pointer) up for ' + handler.downTrail.toString() );
                assert && assert( event.pointer === handler.pointer );
                if ( !event.pointer.isMouse || event.domEvent.button === handler.options.mouseButton ) {
                  handler.buttonUp( event );
                }
              },
              
              // touch cancel
              cancel: function( event ) {
                sceneryEventLog && sceneryEventLog( 'DownUpListener (pointer) cancel for ' + handler.downTrail.toString() );
                assert && assert( event.pointer === handler.pointer );
                handler.buttonUp( event );
              }
            };
          };
          var DownUpListener = scenery.DownUpListener;
          
          DownUpListener.prototype = {
            constructor: DownUpListener,
            
            buttonDown: function( event ) {
              // already down from another pointer, don't do anything
              if ( this.isDown ) { return; }
              
              // ignore other mouse buttons
              if ( event.pointer.isMouse && event.domEvent.button !== this.options.mouseButton ) { return; }
              
              // add our listener so we catch the up wherever we are
              event.pointer.addInputListener( this.downListener );
              
              this.isDown = true;
              this.downCurrentTarget = event.currentTarget;
              this.downTrail = event.trail.subtrailTo( event.currentTarget, false );
              this.pointer = event.pointer;
              
              sceneryEventLog && sceneryEventLog( 'DownUpListener buttonDown for ' + this.downTrail.toString() ); 
              if ( this.options.down ) {
                this.options.down( event, this.downTrail );
              }
            },
            
            buttonUp: function( event ) {
              this.isDown = false;
              this.pointer.removeInputListener( this.downListener );
        
              var currentTargetSave = event.currentTarget;
              event.currentTarget = this.downCurrentTarget; // up is handled by a pointer listener, so currentTarget would be null.
              if ( this.options.upInside || this.options.upOutside ) {
                var trailUnderPointer = event.trail;
                
                // TODO: consider changing this so that it just does a hit check and ignores anything in front?
                var isInside = trailUnderPointer.isExtensionOf( this.downTrail, true );
                
                if ( isInside && this.options.upInside ) {
                  this.options.upInside( event, this.downTrail );
                } else if ( !isInside && this.options.upOutside ) {
                  this.options.upOutside( event, this.downTrail );
                }
              }
              sceneryEventLog && sceneryEventLog( 'DownUpListener buttonUp for ' + this.downTrail.toString() ); 
              if ( this.options.up ) {
                this.options.up( event, this.downTrail );
              }
              event.currentTarget = currentTargetSave; // be polite to other listeners, restore currentTarget
            },
            
            /*---------------------------------------------------------------------------*
            * events called from the node input listener
            *----------------------------------------------------------------------------*/
            
            // mouse/touch down on this node
            down: function( event ) {
              this.buttonDown( event );
            }
          };
          
          return DownUpListener;
        } );
        
        
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * The ButtonListener is a scenery Input Listener that translates input events
         * (down, up, enter, exit) into states in a button model.  Duck typing is used
         * for the buttonModel, it can be anything with "down" and "over" boolean properties,
         * such as a PushButtonModel or a StickyToggleButtonModel.
         *
         * One assumption of this ButtonListener is that only one pointer can interact
         * with the button at a time, and the other pointers are effectively "locked
         * out" while another pointer is using the button.
         *
         * @author John Blanco
         * @author Sam Reid
         */
        define( 'SUN/buttons/ButtonListener',['require','SCENERY/input/DownUpListener','PHET_CORE/inherit'],function( require ) {
          
        
          // modules
          var DownUpListener = require( 'SCENERY/input/DownUpListener' );
          var inherit = require( 'PHET_CORE/inherit' );
        
          /**
           * @param {*} buttonModel any object with 'down' and 'over' boolean properties
           * @constructor
           */
          function ButtonListener( buttonModel ) {
            this.buttonModel = buttonModel; // @private
            var buttonListener = this;
        
            // Track the pointer that is currently interacting with this button, ignore others.
            this.overPointer = null; // @private
            this.downPointer = null; // @private
        
            DownUpListener.call( this, {
                down: function( event, trail ) {
                  if ( buttonListener.downPointer === null ) {
                    buttonListener.downPointer = event.pointer;
                  }
                  if ( event.pointer === buttonListener.downPointer ) {
                    buttonModel.down = true;
                  }
                },
        
                up: function( event, trail ) {
                  if ( event.pointer === buttonListener.downPointer ) {
                    buttonListener.downPointer = null;
                    buttonModel.down = false;
                  }
                }
              }
            );
          }
        
          return inherit( DownUpListener, ButtonListener, {
            enter: function( event, trail ) {
              if ( this.overPointer === null ) {
                this.overPointer = event.pointer;
                this.buttonModel.over = true;
              }
            },
        
            exit: function( event, trail ) {
              if ( event.pointer === this.overPointer ) {
                this.overPointer = null;
                this.buttonModel.over = false;
              }
            } } );
        } );
        // Copyright 2002-2013, University of Colorado
        
        /**
         * A circular node that inherits Path, and allows for optimized drawing,
         * and improved parameter handling.
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/nodes/Circle',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Bounds2','DOT/Matrix3','SCENERY/nodes/Path','KITE/Shape','SCENERY/util/Features'],function( require ) {
          
        
          var inherit = require( 'PHET_CORE/inherit' );
          var scenery = require( 'SCENERY/scenery' );
          var Bounds2 = require( 'DOT/Bounds2' );
          var Matrix3 = require( 'DOT/Matrix3' );
        
          var Path = require( 'SCENERY/nodes/Path' );
          var Shape = require( 'KITE/Shape' );
          var Features = require( 'SCENERY/util/Features' );
        
          scenery.Circle = function Circle( radius, options ) {
            if ( typeof radius === 'object' ) {
              // allow new Circle( { radius: ... } )
              // the mutators will call invalidateCircle() and properly set the shape
              options = radius;
              this._radius = options.radius;
            } else {
              this._radius = radius;
        
              // ensure we have a parameter object
              options = options || {};
        
            }
            // fallback for non-canvas or non-svg rendering, and for proper bounds computation
        
            Path.call( this, null, options );
          };
          var Circle = scenery.Circle;
        
          inherit( Path, Circle, {
            getStrokeRendererBitmask: function() {
              var bitmask = Path.prototype.getStrokeRendererBitmask.call( this );
              if ( this.hasStroke() && !this.getStroke().isGradient && !this.getStroke().isPattern && this.getLineWidth() <= this.getRadius() ) {
                bitmask |= scenery.bitmaskSupportsDOM;
              }
              return bitmask;
            },
            
            getPathRendererBitmask: function() {
              return scenery.bitmaskSupportsCanvas | scenery.bitmaskSupportsSVG | ( Features.borderRadius ? scenery.bitmaskSupportsDOM : 0 );
            },
            
            invalidateCircle: function() {
              assert && assert( this._radius >= 0, 'A circle needs a non-negative radius' );
              
              // sets our 'cache' to null, so we don't always have to recompute our shape
              this._shape = null;
              
              // should invalidate the path and ensure a redraw
              this.invalidateShape();
            },
            
            createCircleShape: function() {
              return Shape.circle( 0, 0, this._radius );
            },
            
            intersectsBoundsSelf: function( bounds ) {
              // TODO: handle intersection with somewhat-infinite bounds!
              var x = Math.abs( bounds.centerX );
              var y = Math.abs( bounds.centerY );
              var halfWidth = bounds.maxX - x;
              var halfHeight = bounds.maxY - y;
              
              // too far to have a possible intersection
              if ( x > halfWidth + this._radius || y > halfHeight + this._radius ) {
                return false;
              }
              
              // guaranteed intersection
              if ( x <= halfWidth || y <= halfHeight ) {
                return true;
              }
              
              // corner case
              x -= halfWidth;
              y -= halfHeight;
              return x * x + y * y <= this._radius * this._radius;
            },
            
            paintCanvas: function( wrapper ) {
              var context = wrapper.context;
              
              context.beginPath();
              context.arc( 0, 0, this._radius, 0, Math.PI * 2, false );
              context.closePath();
              
              if ( this._fill ) {
                this.beforeCanvasFill( wrapper ); // defined in Fillable
                context.fill();
                this.afterCanvasFill( wrapper ); // defined in Fillable
              }
              if ( this._stroke ) {
                this.beforeCanvasStroke( wrapper ); // defined in Strokable
                context.stroke();
                this.afterCanvasStroke( wrapper ); // defined in Strokable
              }
            },
            
            // create a circle instead of a path, hopefully it is faster in implementations
            createSVGFragment: function( svg, defs, group ) {
              return document.createElementNS( scenery.svgns, 'circle' );
            },
        
            // optimized for the circle element instead of path
            updateSVGFragment: function( circle ) {
              circle.setAttribute( 'r', this._radius );
        
              circle.setAttribute( 'style', this.getSVGFillStyle() + this.getSVGStrokeStyle() );
            },
            
            /*---------------------------------------------------------------------------*
             * DOM support
             *----------------------------------------------------------------------------*/
            
            domUpdateTransformOnRepaint: true, // since we have to integrate the baseline offset into the CSS transform, signal to DOMLayer
            
            getDOMElement: function() {
              var fill = document.createElement( 'div' );
              var stroke = document.createElement( 'div' );
              fill.appendChild( stroke );
              fill.style.display = 'block';
              fill.style.position = 'absolute';
              fill.style.left = '0';
              fill.style.top = '0';
              stroke.style.display = 'block';
              stroke.style.position = 'absolute';
              stroke.style.left = '0';
              stroke.style.top = '0';
              return fill;
            },
        
            updateDOMElement: function( fill ) {
              fill.style.width = ( 2 * this._radius ) + 'px';
              fill.style.height = ( 2 * this._radius ) + 'px';
              fill.style[Features.borderRadius] = this._radius + 'px';
              fill.style.backgroundColor = this.getCSSFill();
              
              var stroke = fill.childNodes[0];
              if ( this.hasStroke() ) {
                stroke.style.width = ( 2 * this._radius - this.getLineWidth() ) + 'px';
                stroke.style.height = ( 2 * this._radius - this.getLineWidth() ) + 'px';
                stroke.style.left = ( -this.getLineWidth() / 2 ) + 'px';
                stroke.style.top = ( -this.getLineWidth() / 2 ) + 'px';
                stroke.style.borderStyle = 'solid';
                stroke.style.borderColor = this.getSimpleCSSFill();
                stroke.style.borderWidth = this.getLineWidth() + 'px';
                stroke.style[Features.borderRadius] = ( this._radius + this.getLineWidth() / 2 ) + 'px';
              } else {
                stroke.style.borderStyle = 'none';
              }
            },
            
            // override the transform since we need to customize it with a DOM offset
            updateCSSTransform: function( transform, element ) {
              // shift the text vertically, postmultiplied with the entire transform.
              var matrix = transform.getMatrix().timesMatrix( Matrix3.translation( -this._radius, -this._radius ) );
              scenery.Util.applyCSSTransform( matrix, element );
            },
        
            getBasicConstructor: function( propLines ) {
              return 'new scenery.Circle( ' + this._radius + ', {' + propLines + '} )';
            },
        
            getRadius: function() {
              return this._radius;
            },
        
            setRadius: function( radius ) {
              if ( this._radius !== radius ) {
                this._radius = radius;
                this.invalidateCircle();
              }
              return this;
            },
        
            computeShapeBounds: function() {
              var bounds = new Bounds2( -this._radius, -this._radius, this._radius, this._radius );
              if ( this._stroke ) {
                // since we are axis-aligned, any stroke will expand our bounds by a guaranteed set amount
                bounds = bounds.dilated( this.getLineWidth() / 2 );
              }
              return bounds;
            },
        
            // accelerated hit detection
            containsPointSelf: function( point ) {
              var magSq = point.x * point.x + point.y * point.y;
              var result = true;
              var iRadius;
              if ( this._strokePickable ) {
                iRadius = this.getLineWidth() / 2;
                var outerRadius = this._radius + iRadius;
                result = result && magSq <= outerRadius * outerRadius;
              }
              
              if ( this._fillPickable ) {
                if ( this._strokePickable ) {
                  // we were either within the outer radius, or not
                  return result;
                } else {
                  // just testing in the fill range
                  return magSq <= this._radius * this._radius;
                }
              } else if ( this._strokePickable ) {
                var innerRadius = this._radius - iRadius;
                return result && magSq >= innerRadius * innerRadius;
              } else {
                return false; // neither stroke nor fill is pickable
              }
            },
        
            get radius() { return this.getRadius(); },
            set radius( value ) { return this.setRadius( value ); },
            
            setShape: function( shape ) {
              if ( shape !== null ) {
                throw new Error( 'Cannot set the shape of a scenery.Circle to something non-null' );
              } else {
                // probably called from the Path constructor
                this.invalidateShape();
              }
            },
            
            getShape: function() {
              if ( !this._shape ) {
                this._shape = this.createCircleShape();
              }
              return this._shape;
            },
            
            hasShape: function() {
              return true;
            }
          } );
        
          // not adding mutators for now
          Circle.prototype._mutatorKeys = [ 'radius' ].concat( Path.prototype._mutatorKeys );
        
          return Circle;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Encapsulates common color information and transformations.
         *
         * See http://www.w3.org/TR/css3-color/
         *
         * TODO: make a getHue, getSaturation, getLightness. we can then expose them via ES5!
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/util/Color',['require','SCENERY/scenery','DOT/Util','DOT/Util'],function( require ) {
          
        
          // modules
          var scenery = require( 'SCENERY/scenery' );
          var clamp = require( 'DOT/Util' ).clamp;
          var linear = require( 'DOT/Util' ).linear;
        
          // r,g,b integers 0-255, 'a' float 0-1
          scenery.Color = function Color( r, g, b, a ) {
            
            // allow listeners to be notified on any changes. called with listener()
            this.listeners = [];
        
            if ( typeof r === 'string' ) {
              var str = r.replace( / /g, '' ).toLowerCase();
              var success = false;
              
              // replace colors based on keywords
              var keywordMatch = Color.colorKeywords[str];
              if ( keywordMatch ) {
                str = '#' + keywordMatch;
              }
              
              // run through the available text formats
              for ( var i = 0; i < Color.formatParsers.length; i++ ) {
                var parser = Color.formatParsers[i];
                
                var matches = parser.regexp.exec( str );
                if ( matches ) {
                  parser.apply( this, matches );
                  success = true;
                  break;
                }
              }
              
              if ( !success ) {
                throw new Error( 'scenery.Color unable to parse color string: ' + r );
              }
            } else {
              // alpha
              var alpha = a === undefined ? 1 : a;
        
              // bitwise handling if 3 elements aren't defined
              if ( g === undefined || b === undefined ) {
                this.setRGBA( ( r >> 16 ) && 0xFF,
                              ( r >> 8 ) && 0xFF,
                              ( r >> 0 ) && 0xFF,
                              alpha );
              }
              else {
                // otherwise, copy them over
                this.setRGBA( r, g, b, alpha );
              }
            }
            
            phetAllocation && phetAllocation( 'Color' );
          };
          var Color = scenery.Color;
          
          // regex utilities
          var rgbNumber = '(-?\\d{1,3}%?)'; // syntax allows negative integers and percentages
          var aNumber = '(\\d+|\\d*\\.\\d+)'; // decimal point number. technically we allow for '255', even though this will be clamped to 1.
          var rawNumber = '(\\d{1,3})'; // a 1-3 digit number
          
          // handles negative and percentage values
          function parseRGBNumber( str ) {
            var multiplier = 1;
            
            // if it's a percentage, strip it off and handle it that way
            if ( str.charAt( str.length - 1 ) === '%' ) {
              multiplier = 2.55;
              str = str.slice( 0, str.length - 1 );
            }
            
            return Math.round( parseInt( str, 10 ) * multiplier );
          }
          
          Color.formatParsers = [
            {
              // 'transparent'
              regexp: /^transparent$/,
              apply: function( color, matches ) {
                color.setRGBA( 0, 0, 0, 0 );
              }
            },{
              // short hex form, a la '#fff'
              regexp: /^#(\w{1})(\w{1})(\w{1})$/,
              apply: function( color, matches ) {
                color.setRGBA( parseInt( matches[1] + matches[1], 16 ),
                               parseInt( matches[2] + matches[2], 16 ),
                               parseInt( matches[3] + matches[3], 16 ),
                               1 );
              }
            },{
              // long hex form, a la '#ffffff'
              regexp: /^#(\w{2})(\w{2})(\w{2})$/,
              apply: function( color, matches ) {
                color.setRGBA( parseInt( matches[1], 16 ),
                               parseInt( matches[2], 16 ),
                               parseInt( matches[3], 16 ),
                               1 );
              }
            },{
              // rgb(...)
              regexp: new RegExp( '^rgb\\(' + rgbNumber + ',' + rgbNumber + ',' + rgbNumber + '\\)$' ),
              apply: function( color, matches ) {
                color.setRGBA( parseRGBNumber( matches[1] ),
                               parseRGBNumber( matches[2] ),
                               parseRGBNumber( matches[3] ),
                               1 );
              }
            },{
              // rgba(...)
              regexp: new RegExp( '^rgba\\(' + rgbNumber + ',' + rgbNumber + ',' + rgbNumber + ',' + aNumber + '\\)$' ),
              apply: function( color, matches ) {
                color.setRGBA( parseRGBNumber( matches[1] ),
                               parseRGBNumber( matches[2] ),
                               parseRGBNumber( matches[3] ),
                               parseFloat( matches[4] ) );
              }
            },{
              // hsl(...)
              regexp: new RegExp( '^hsl\\(' + rawNumber + ',' + rawNumber + '%,' + rawNumber + '%\\)$' ),
              apply: function( color, matches ) {
                color.setHSLA( parseInt( matches[1], 10 ),
                               parseInt( matches[2], 10 ),
                               parseInt( matches[3], 10 ),
                               1 );
              }
            },{
              // hsla(...)
              regexp: new RegExp( '^hsla\\(' + rawNumber + ',' + rawNumber + '%,' + rawNumber + '%,' + aNumber + '\\)$' ),
              apply: function( color, matches ) {
                color.setHSLA( parseInt( matches[1], 10 ),
                               parseInt( matches[2], 10 ),
                               parseInt( matches[3], 10 ),
                               parseFloat( matches[4] ) );
              }
            }
          ];
          
          // see http://www.w3.org/TR/css3-color/
          Color.hueToRGB = function( m1, m2, h ) {
            if ( h < 0 ) {
              h = h + 1;
            }
            if ( h > 1 ) {
              h = h - 1;
            }
            if ( h * 6 < 1 ) {
              return m1 + ( m2 - m1 ) * h * 6;
            }
            if ( h * 2 < 1 ) {
              return m2;
            }
            if ( h * 3 < 2 ) {
              return m1 + ( m2 - m1 ) * ( 2 / 3 - h ) * 6;
            }
            return m1;
          };
        
          /**
           * Convenience function that converts a color spec to a color object if
           * necessary, or simply returns the color object if not.
           * @param {String|Color} colorSpec
           */
          Color.toColor = function( colorSpec ) {
            return colorSpec instanceof Color ? colorSpec : new Color( colorSpec );
          };
          
          Color.prototype = {
            constructor: Color,
            
            copy: function() {
              return new Color( this.r, this.g, this.b, this.a );
            },
            
            // red, integral 0-255
            getRed: function() { return this.r; },
            setRed: function( value ) { return this.setRGBA( value, this.g, this.b, this.a ); },
            get red() { return this.getRed(); },
            set red( value ) { return this.setRed( value ); },
            
            // green, integral 0-255
            getGreen: function() { return this.g; },
            setGreen: function( value ) { return this.setRGBA( this.r, value, this.b, this.a ); },
            get green() { return this.getGreen(); },
            set green( value ) { return this.setGreen( value ); },
            
            // blue, integral 0-255
            getBlue: function() { return this.b; },
            setBlue: function( value ) { return this.setRGBA( this.r, this.g, value, this.a ); },
            get blue() { return this.getBlue(); },
            set blue( value ) { return this.setBlue( value ); },
            
            // alpha, floating 0-1
            getAlpha: function() { return this.a; },
            setAlpha: function( value ) { return this.setRGBA( this.r, this.g, this.b, value ); },
            get alpha() { return this.getAlpha(); },
            set alpha( value ) { return this.setAlpha( value ); },
            
            // RGB integral between 0-255, alpha (float) between 0-1
            setRGBA: function( red, green, blue, alpha ) {
              this.r = Math.round( clamp( red, 0, 255 ) );
              this.g = Math.round( clamp( green, 0, 255 ) );
              this.b = Math.round( clamp( blue, 0, 255 ) );
              this.a = clamp( alpha, 0, 1 );
              
              this.updateColor(); // update the cached value
              
              return this; // allow chaining
            },
            
            computeCSS: function() {
              if ( this.a === 1 ) {
                return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';
              } else {
                var alphaString = this.a === 0 || this.a === 1 ? this.a : this.a.toFixed( 20 ); // toFixed prevents scientific notation
                return 'rgba(' + this.r + ',' + this.g + ',' + this.b + ',' + alphaString + ')';
              }
            },
            
            toCSS: function() {
              // verify that the cached value is correct (in debugging builds only, defeats the point of caching otherwise)
              assert && assert( this._css === this.computeCSS(), 'CSS cached value is ' + this._css + ', but the computed value appears to be ' + this.computeCSS() );
              
              return this._css;
            },
            
            // called to update the interally cached CSS value
            updateColor: function() {
              assert && assert( !this.immutable, 'Cannot modify an immutable color' );
              
              var oldCSS = this._css;
              this._css = this.computeCSS();
              
              // notify listeners if it changed
              if ( oldCSS !== this._css && this.listeners.length ) {
                var listeners = this.listeners.slice( 0 ); // defensive copy. consider removing if it's a performance bottleneck?
                var length = listeners.length;
                
                for ( var i = 0; i < length; i++ ) {
                  listeners[i]();
                }
              }
            },
            
            // allow setting this Color to be immutable when assertions are disabled. any change will throw an error
            setImmutable: function() {
              if ( assert ) {
                this.immutable = true;
              }
              
              return this; // allow chaining
            },
            
            // to what value a Canvas's context.fillStyle should be set
            getCanvasStyle: function() {
              return this.toCSS(); // should be inlined, leave like this for future maintainability
            },
            
            // TODO: make a getHue, getSaturation, getLightness. we can then expose them via ES5!
            setHSLA: function( hue, saturation, lightness, alpha ) {
              hue = ( hue % 360 ) / 360;                    // integer modulo 360
              saturation = clamp( saturation / 100, 0, 1 ); // percentage
              lightness = clamp( lightness / 100, 0, 1 );   // percentage
              
              // see http://www.w3.org/TR/css3-color/
              var m1, m2;
              if ( lightness < 0.5 ) {
                m2 = lightness * ( saturation + 1 );
              } else {
                m2 = lightness + saturation - lightness * saturation;
              }
              m1 = lightness * 2 - m2;
              
              this.r = Math.round( Color.hueToRGB( m1, m2, hue + 1/3 ) * 255 );
              this.g = Math.round( Color.hueToRGB( m1, m2, hue ) * 255 );
              this.b = Math.round( Color.hueToRGB( m1, m2, hue - 1/3 ) * 255 );
              this.a = clamp( alpha, 0, 1 );
              
              this.updateColor(); // update the cached value
              
              return this; // allow chaining
            },
            
            equals: function( color ) {
              return this.r === color.r && this.g === color.g && this.b === color.b && this.a === color.a;
            },
            
            withAlpha: function( alpha ) {
              return new Color( this.r, this.g, this.b, alpha );
            },
            
            checkFactor: function( factor ) {
              if ( factor < 0 || factor > 1 ) {
                throw new Error( 'factor must be between 0 and 1: ' + factor );
              }
              return ( factor === undefined ) ? 0.7 : factor;
            },
            
            // matches Java's Color.brighter()
            brighterColor: function( factor ) {
              factor = this.checkFactor( factor );
              var red   = Math.min( 255, Math.floor( this.r / factor ) );
              var green = Math.min( 255, Math.floor( this.g / factor ) );
              var blue  = Math.min( 255, Math.floor( this.b / factor ) );
              return new Color( red, green, blue, this.a );
            },
            
            /**
             * Brightens a color in RGB space. Useful when creating gradients from a
             * single base color.
             *
             * @param color
             * @param factor 0 (no change) to 1 (white)
             * @return lighter (closer to white) version of the original color.
             */
            colorUtilsBrighter: function( factor ) {
              factor = this.checkFactor( factor );
              var red = Math.min( 255, this.getRed() + Math.floor( factor * ( 255 - this.getRed() ) ) );
              var green = Math.min( 255, this.getGreen() + Math.floor( factor * ( 255 - this.getGreen() ) ) );
              var blue = Math.min( 255, this.getBlue() + Math.floor( factor * ( 255 - this.getBlue() ) ) );
              return new Color( red, green, blue, this.getAlpha() );
            },
            
            // matches Java's Color.darker()
            darkerColor: function( factor ) {
              factor = this.checkFactor( factor );
              var red   = Math.max( 0, Math.floor( factor * this.r ) );
              var green = Math.max( 0, Math.floor( factor * this.g ) );
              var blue  = Math.max( 0, Math.floor( factor * this.b ) );
              return new Color( red, green, blue, this.a );
            },
            
            /**
             * Darken a color in RGB space. Useful when creating gradients from a single
             * base color.
             *
             * @param color  the original color
             * @param factor 0 (no change) to 1 (black)
             * @return darker (closer to black) version of the original color.
             */
            colorUtilsDarker: function( factor ) {
              factor = this.checkFactor( factor );
              var red = Math.max( 0, this.getRed() - Math.floor( factor * this.getRed() ) );
              var green = Math.max( 0, this.getGreen() - Math.floor( factor * this.getGreen() ) );
              var blue = Math.max( 0, this.getBlue() - Math.floor( factor * this.getBlue() ) );
              return new Color( red, green, blue, this.getAlpha() );
            },
            
            /*
             * Like colorUtilsBrighter/Darker, however factor should be in the range -1 to 1, and it will call:
             *   colorUtilsBrighter( factor )   for factor >  0
             *   this                           for factor == 0
             *   colorUtilsDarker( -factor )    for factor <  0
             * Thus:
             * @param factor from -1 (black), to 0 (no change), to 1 (white)
             */
            colorUtilsBrightness: function( factor ) {
              if ( factor === 0 ) {
                return this;
              } else if ( factor > 0 ) {
                return this.colorUtilsBrighter( factor );
              } else {
                return this.colorUtilsDarker( -factor );
              }
            },
            
            /*---------------------------------------------------------------------------*
            * listeners TODO: consider mixing in this behavior, it's common
            *----------------------------------------------------------------------------*/
            
            // listener should be a callback expecting no arguments, listener() will be called when the color changes
            addChangeListener: function( listener ) {
              assert && assert( listener !== undefined && listener !== null, 'Verify that the listener exists' );
              assert && assert( !_.contains( this.listeners, listener ) );
              this.listeners.push( listener );
            },
            
            removeChangeListener: function( listener ) {
              assert && assert( _.contains( this.listeners, listener ) );
              this.listeners.splice( _.indexOf( this.listeners, listener ), 1 );
            },
        
            toString: function() {
              return this.constructor.name + "[r:" + this.r + " g:" + this.g + " b:" + this.b + " a:" + this.a + "]";
            }
          };
          
          Color.basicColorKeywords = {
            aqua:    '00ffff',
            black:   '000000',
            blue:    '0000ff',
            fuchsia: 'ff00ff',
            gray:    '808080',
            green:   '008000',
            lime:    '00ff00',
            maroon:  '800000',
            navy:    '000080',
            olive:   '808000',
            purple:  '800080',
            red:     'ff0000',
            silver:  'c0c0c0',
            teal:    '008080',
            white:   'ffffff',
            yellow:  'ffff00'
          };
          
          Color.colorKeywords = {
            aliceblue:            'f0f8ff',
            antiquewhite:         'faebd7',
            aqua:                 '00ffff',
            aquamarine:           '7fffd4',
            azure:                'f0ffff',
            beige:                'f5f5dc',
            bisque:               'ffe4c4',
            black:                '000000',
            blanchedalmond:       'ffebcd',
            blue:                 '0000ff',
            blueviolet:           '8a2be2',
            brown:                'a52a2a',
            burlywood:            'deb887',
            cadetblue:            '5f9ea0',
            chartreuse:           '7fff00',
            chocolate:            'd2691e',
            coral:                'ff7f50',
            cornflowerblue:       '6495ed',
            cornsilk:             'fff8dc',
            crimson:              'dc143c',
            cyan:                 '00ffff',
            darkblue:             '00008b',
            darkcyan:             '008b8b',
            darkgoldenrod:        'b8860b',
            darkgray:             'a9a9a9',
            darkgreen:            '006400',
            darkkhaki:            'bdb76b',
            darkmagenta:          '8b008b',
            darkolivegreen:       '556b2f',
            darkorange:           'ff8c00',
            darkorchid:           '9932cc',
            darkred:              '8b0000',
            darksalmon:           'e9967a',
            darkseagreen:         '8fbc8f',
            darkslateblue:        '483d8b',
            darkslategray:        '2f4f4f',
            darkturquoise:        '00ced1',
            darkviolet:           '9400d3',
            deeppink:             'ff1493',
            deepskyblue:          '00bfff',
            dimgray:              '696969',
            dodgerblue:           '1e90ff',
            feldspar:             'd19275',
            firebrick:            'b22222',
            floralwhite:          'fffaf0',
            forestgreen:          '228b22',
            fuchsia:              'ff00ff',
            gainsboro:            'dcdcdc',
            ghostwhite:           'f8f8ff',
            gold:                 'ffd700',
            goldenrod:            'daa520',
            gray:                 '808080',
            green:                '008000',
            greenyellow:          'adff2f',
            honeydew:             'f0fff0',
            hotpink:              'ff69b4',
            indianred :           'cd5c5c',
            indigo :              '4b0082',
            ivory:                'fffff0',
            khaki:                'f0e68c',
            lavender:             'e6e6fa',
            lavenderblush:        'fff0f5',
            lawngreen:            '7cfc00',
            lemonchiffon:         'fffacd',
            lightblue:            'add8e6',
            lightcoral:           'f08080',
            lightcyan:            'e0ffff',
            lightgoldenrodyellow: 'fafad2',
            lightgrey:            'd3d3d3',
            lightgreen:           '90ee90',
            lightpink:            'ffb6c1',
            lightsalmon:          'ffa07a',
            lightseagreen:        '20b2aa',
            lightskyblue:         '87cefa',
            lightslateblue:       '8470ff',
            lightslategray:       '778899',
            lightsteelblue:       'b0c4de',
            lightyellow:          'ffffe0',
            lime:                 '00ff00',
            limegreen:            '32cd32',
            linen:                'faf0e6',
            magenta:              'ff00ff',
            maroon:               '800000',
            mediumaquamarine:     '66cdaa',
            mediumblue:           '0000cd',
            mediumorchid:         'ba55d3',
            mediumpurple:         '9370d8',
            mediumseagreen:       '3cb371',
            mediumslateblue:      '7b68ee',
            mediumspringgreen:    '00fa9a',
            mediumturquoise:      '48d1cc',
            mediumvioletred:      'c71585',
            midnightblue:         '191970',
            mintcream:            'f5fffa',
            mistyrose:            'ffe4e1',
            moccasin:             'ffe4b5',
            navajowhite:          'ffdead',
            navy:                 '000080',
            oldlace:              'fdf5e6',
            olive:                '808000',
            olivedrab:            '6b8e23',
            orange:               'ffa500',
            orangered:            'ff4500',
            orchid:               'da70d6',
            palegoldenrod:        'eee8aa',
            palegreen:            '98fb98',
            paleturquoise:        'afeeee',
            palevioletred:        'd87093',
            papayawhip:           'ffefd5',
            peachpuff:            'ffdab9',
            peru:                 'cd853f',
            pink:                 'ffc0cb',
            plum:                 'dda0dd',
            powderblue:           'b0e0e6',
            purple:               '800080',
            red:                  'ff0000',
            rosybrown:            'bc8f8f',
            royalblue:            '4169e1',
            saddlebrown:          '8b4513',
            salmon:               'fa8072',
            sandybrown:           'f4a460',
            seagreen:             '2e8b57',
            seashell:             'fff5ee',
            sienna:               'a0522d',
            silver:               'c0c0c0',
            skyblue:              '87ceeb',
            slateblue:            '6a5acd',
            slategray:            '708090',
            snow:                 'fffafa',
            springgreen:          '00ff7f',
            steelblue:            '4682b4',
            tan:                  'd2b48c',
            teal:                 '008080',
            thistle:              'd8bfd8',
            tomato:               'ff6347',
            turquoise:            '40e0d0',
            violet:               'ee82ee',
            violetred:            'd02090',
            wheat:                'f5deb3',
            white:                'ffffff',
            whitesmoke:           'f5f5f5',
            yellow:               'ffff00',
            yellowgreen:          '9acd32'
          };
          
          // Java compatibility
          Color.BLACK      = new Color( 0,   0,   0   ).setImmutable();
          Color.BLUE       = new Color( 0,   0,   255 ).setImmutable();
          Color.CYAN       = new Color( 0,   255, 255 ).setImmutable();
          Color.DARK_GRAY  = new Color( 64,  64,  64  ).setImmutable();
          Color.GRAY       = new Color( 128, 128, 128 ).setImmutable();
          Color.GREEN      = new Color( 0,   255, 0   ).setImmutable();
          Color.LIGHT_GRAY = new Color( 192, 192, 192 ).setImmutable();
          Color.MAGENTA    = new Color( 255, 0,   255 ).setImmutable();
          Color.ORANGE     = new Color( 255, 200, 0   ).setImmutable();
          Color.PINK       = new Color( 255, 175, 175 ).setImmutable();
          Color.RED        = new Color( 255, 0,   0   ).setImmutable();
          Color.WHITE      = new Color( 255, 255, 255 ).setImmutable();
          Color.YELLOW     = new Color( 255, 255, 0   ).setImmutable();
        
          /**
           * Interpolates between 2 colors in RGBA space. When distance is 0, color1
           * is returned. When distance is 1, color2 is returned. Other values of
           * distance return a color somewhere between color1 and color2. Each color
           * component is interpolated separately.
           *
           * @param {Color} color1
           * @param {Color} color2
           * @param {Number} distance distance between color1 and color2, 0 <= distance <= 1
           * @return {Color}
           */
          Color.interpolateRBGA = function( color1, color2, distance ) {
            if ( distance < 0 || distance > 1 ) {
              throw new Error( 'distance must be between 0 and 1: ' + distance );
            }
            var r = Math.floor( linear( 0, 1, color1.r, color2.r, distance ) );
            var g = Math.floor( linear( 0, 1, color1.g, color2.g, distance ) );
            var b = Math.floor( linear( 0, 1, color1.b, color2.b, distance ) );
            var a = linear( 0, 1, color1.a, color2.a, distance );
            return new Color( r, g, b, a );
          };
        
          return Color;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Gradient base type for LinearGradient and RadialGradient. Will not function on its own
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/util/Gradient',['require','SCENERY/util/Color','SCENERY/scenery'],function( require ) {
          
          
          require( 'SCENERY/util/Color' );
          var scenery = require( 'SCENERY/scenery' );
          
          // TODO: add the ability to specify the color-stops inline. possibly [ [0,color1], [0.5,color2], [1,color3] ]
          scenery.Gradient = function Gradient( canvasGradient ) {
            assert && assert( this.constructor.name !== 'Gradient', 'Please create a LinearGradient or RadialGradient. Do not directly use the supertype Gradient.' );
            
            this.stops = [];
            this.lastStopRatio = 0;
            
            this.canvasGradient = canvasGradient;
            
            this.transformMatrix = null;
          };
          var Gradient = scenery.Gradient;
          
          Gradient.prototype = {
            constructor: Gradient,
            
            isGradient: true,
            
            /**
             * @param {Number} ratio        Monotonically increasing value in the range of 0 to 1
             * @param {Color|String} color  Color for the stop, either a scenery.Color or CSS color string
             */
            addColorStop: function( ratio, color ) {
              // TODO: invalidate the gradient?
              if ( this.lastStopRatio > ratio ) {
                // fail out, since browser quirks go crazy for this case
                throw new Error( 'Color stops not specified in the order of increasing ratios' );
              } else {
                this.lastStopRatio = ratio;
              }
              
              // make sure we have a scenery.Color now
              if ( typeof color === 'string' ) {
                color = new scenery.Color( color );
              }
              
              this.stops.push( {
                ratio: ratio,
                color: color
              } );
              
              // construct the Canvas gradient as we go
              this.canvasGradient.addColorStop( ratio, color.toCSS() );
              return this;
            },
            
            setTransformMatrix: function( transformMatrix ) {
              // TODO: invalidate the gradient?
              if ( this.transformMatrix !== transformMatrix ) {
                this.transformMatrix = transformMatrix;
              }
              return this;
            },
            
            getCanvasStyle: function() {
              return this.canvasGradient;
            }
          };
          
          return Gradient;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * A radial gradient that can be passed into the 'fill' or 'stroke' parameters.
         *
         * SVG gradients, see http://www.w3.org/TR/SVG/pservers.html
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/util/RadialGradient',['require','SCENERY/scenery','PHET_CORE/inherit','DOT/Vector2','SCENERY/util/Gradient'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          
          var inherit = require( 'PHET_CORE/inherit' );
          var Vector2 = require( 'DOT/Vector2' );
          var Gradient = require( 'SCENERY/util/Gradient' );
          
          // TODO: support Vector2s for p0 and p1
          scenery.RadialGradient = function RadialGradient( x0, y0, r0, x1, y1, r1 ) {
            this.start = new Vector2( x0, y0 );
            this.end = new Vector2( x1, y1 );
            this.startRadius = r0;
            this.endRadius = r1;
            
            // linear function from radius to point on the line from start to end
            this.focalPoint = this.start.plus( this.end.minus( this.start ).times( this.startRadius / ( this.startRadius - this.endRadius ) ) );
            
            // make sure that the focal point is in both circles. SVG doesn't support rendering outside of them
            if ( this.startRadius >= this.endRadius ) {
              assert && assert( this.focalPoint.minus( this.start ).magnitude() <= this.startRadius );
            } else {
              assert && assert( this.focalPoint.minus( this.end ).magnitude() <= this.endRadius );
            }
            
            // use the global scratch canvas instead of creating a new Canvas
            Gradient.call( this, scenery.scratchContext.createRadialGradient( x0, y0, r0, x1, y1, r1 ) );
          };
          var RadialGradient = scenery.RadialGradient;
          
          inherit( Gradient, RadialGradient, {
            
            isRadialGradient: true,
            
            getSVGDefinition: function( id ) {
              var startIsLarger = this.startRadius > this.endRadius;
              var largePoint = startIsLarger ? this.start : this.end;
              var maxRadius = Math.max( this.startRadius, this.endRadius );
              var minRadius = Math.min( this.startRadius, this.endRadius );
              
              var definition = document.createElementNS( scenery.svgns, 'radialGradient' );
              
              // TODO:
              definition.setAttribute( 'id', id );
              definition.setAttribute( 'gradientUnits', 'userSpaceOnUse' ); // so we don't depend on the bounds of the object being drawn with the gradient
              definition.setAttribute( 'cx', largePoint.x );
              definition.setAttribute( 'cy', largePoint.y );
              definition.setAttribute( 'r', maxRadius );
              definition.setAttribute( 'fx', this.focalPoint.x );
              definition.setAttribute( 'fy', this.focalPoint.y );
              if ( this.transformMatrix ) {
                definition.setAttribute( 'gradientTransform', this.transformMatrix.getSVGTransform() );
              }
        
              //TODO: replace with dot.Util.linear
              // maps x linearly from [a0,b0] => [a1,b1]
              function linearMap( a0, b0, a1, b1, x ) {
                return a1 + ( x - a0 ) * ( b1 - a1 ) / ( b0 - a0 );
              }
              
              function applyStop( stop ) {
                // flip the stops if the start has a larger radius
                var ratio = startIsLarger ? 1 - stop.ratio : stop.ratio;
                
                // scale the stops properly if the smaller radius isn't 0
                if ( minRadius > 0 ) {
                  // scales our ratio from [0,1] => [minRadius/maxRadius,0]
                  ratio = linearMap( 0, 1, minRadius / maxRadius, 1, ratio );
                }
                
                // TODO: store color in our stops array, so we don't have to create additional objects every time?
                var stopElement = document.createElementNS( scenery.svgns, 'stop' );
                stopElement.setAttribute( 'offset', ratio );
                stopElement.setAttribute( 'style', 'stop-color: ' + stop.color.withAlpha( 1 ).toCSS() + '; stop-opacity: ' + stop.color.a.toFixed( 20 ) + ';' );
                definition.appendChild( stopElement );
              }
              
              var i;
              // switch the direction we apply stops in, so that the ratios always are increasing.
              if ( startIsLarger ) {
                for ( i = this.stops.length - 1; i >= 0; i-- ) {
                  applyStop( this.stops[i] );
                }
              } else {
                for ( i = 0; i < this.stops.length; i++ ) {
                  applyStop( this.stops[i] );
                }
              }
              
              return definition;
            },
            
            toString: function() {
              var result = 'new scenery.RadialGradient( ' + this.start.x + ', ' + this.start.y + ', ' + this.startRadius + ', ' + this.end.x + ', ' + this.end.y + ', ' + this.endRadius + ' )';
              
              _.each( this.stops, function( stop ) {
                result += '.addColorStop( ' + stop.ratio + ', \'' + stop.color.toString() + '\' )';
              } );
              
              return result;
            }
          } );
          
          return RadialGradient;
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Visual representation of a round button.  It is provided with a 'button
         * model' that is monitored to change the appearance of the button.
         *
         * Note: this is only the visual representation and does not have associated
         * input listeners so that it can be reused in multiple contexts.
         *
         * @author John Blanco
         * @author Sam Reid
         */
        define( 'SUN/buttons/RoundButtonView',['require','SUN/buttons/ButtonListener','SCENERY/nodes/Circle','SCENERY/util/Color','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/util/RadialGradient','KITE/Shape','DOT/Vector2'],function( require ) {
          
        
          // modules
          var ButtonListener = require( 'SUN/buttons/ButtonListener' );
          var Circle = require( 'SCENERY/nodes/Circle' );
          var Color = require( 'SCENERY/util/Color' );
          var inherit = require( 'PHET_CORE/inherit' );
          var Node = require( 'SCENERY/nodes/Node' );
          var RadialGradient = require( 'SCENERY/util/RadialGradient' );
          var Shape = require( 'KITE/Shape' );
          var Vector2 = require( 'DOT/Vector2' );
        
          // Constants
          var HIGHLIGHT_GRADIENT_LENGTH = 5; // In screen coords, which are roughly pixels.
          var DEFAULT_COLOR = new Color( 153, 206, 255 );
        
          /**
           * @param {ButtonModel} buttonModel
           * @param {Property} interactionStateProperty - A property that is used to drive the visual appearance of the button.
           * @param {Object} options
           * @constructor
           */
          function RoundButtonView( buttonModel, interactionStateProperty, options ) {
            this.buttonModel = buttonModel; // @protected
            var thisButton = this;
        
            options = _.extend( {
              // Default values.
              radius: options.content ? undefined : 30,
              content: null,
              cursor: 'pointer',
              baseColor: DEFAULT_COLOR,
              disabledBaseColor: new Color( 220, 220, 220 ),
              minXMargin: 5, // Minimum margin in x direction, i.e. on left and right
              minYMargin: 5, // Minimum margin in y direction, i.e. on top and bottom
              fireOnDown: false,
              touchExpansion: 5, // Radius expansion for touch area, in screen units (roughly pixels)
              stroke: DEFAULT_COLOR.colorUtilsDarker( 0.4 ),
              lineWidth: 0.5, // Only meaningful if stroke is non-null
        
              // By default, icons are centered in the button, but icons with odd
              // shapes that are not wrapped in a normalizing parent node may need to
              // specify offsets to line things up properly
              xContentOffset: 0,
              yContentOffset: 0,
        
              // Strategy for controlling the button's appearance, excluding any
              // content.  This can be a stock strategy from this file or custom.  To
              // create a custom one, model it off of the stock strategies defined in
              // this file.
              buttonAppearanceStrategy: RoundButtonView.threeDAppearanceStrategy,
        
              // Strategy for controlling the appearance of the button's content based
              // on the button's state.  This can be a stock strategy from this file,
              // or custom.  To create a custom one, model it off of the stock
              // version(s) defined in this file.
              contentAppearanceStrategy: RoundButtonView.fadeContentWhenDisabled
            }, options );
        
            Node.call( thisButton );
            var content = options.content; // convenience variable
            var upCenter = new Vector2( options.xContentOffset, options.yContentOffset );
        
            // Hook up the input listener
            this.addInputListener( new ButtonListener( buttonModel ) );
        
            // Use the user-specified radius if present, otherwise calculate the
            // radius based on the content and the margin.
            var buttonRadius = options.radius || Math.max( content.width + options.minXMargin * 2, content.height + options.minYMargin * 2 ) / 2;
        
            // Create the basic button shape.
            var button = new Circle( buttonRadius,
              {
                fill: options.baseColor,
                lineWidth: options.lineWidth
              } );
            this.addChild( button );
        
            // Hook up the strategy that will control the basic button appearance.
            options.buttonAppearanceStrategy( button, interactionStateProperty, options );
        
            // Add the content to the button.
            if ( content ) {
              content.center = upCenter;
              thisButton.addChild( content );
            }
        
            // Hook up the strategy that will control the content appearance.
            options.contentAppearanceStrategy( content, interactionStateProperty );
        
            // Control the pointer state based on the interaction state.
            interactionStateProperty.link( function( state ) {
              thisButton.cursor = state === 'disabled' || state === 'disabled-pressed' ? null : 'pointer';
            } );
        
            // Expand the touch area.
            this.touchArea = Shape.circle( 0, 0, buttonRadius + options.touchExpansion );
        
            // Set pickable such that sub-nodes are pruned from hit testing.
            this.pickable = null;
        
            // Mutate with the options after the layout is complete so that
            // width-dependent fields like centerX will work.
            thisButton.mutate( options );
          }
        
          /**
           * Strategy for making a button look 3D-ish by using gradients that create
           * the appearance of highlighted and shaded edges.
           *
           * @param {Node} button
           * @param {Property} interactionStateProperty
           * @param {Object} options
           * @constructor
           */
          RoundButtonView.threeDAppearanceStrategy = function( button, interactionStateProperty, options ) {
        
            // Set up variables needed to create the various gradient fills and otherwise mod the appearance
            var buttonRadius = button.width / 2;
            var baseColor = Color.toColor( options.baseColor );
            var disabledBaseColor = Color.toColor( options.disabledBaseColor );
            var transparentBaseColor = new Color( baseColor.getRed(), baseColor.getGreen(), baseColor.getBlue(), 0 );
            var transparentDisabledBaseColor = new Color( disabledBaseColor.getRed(), disabledBaseColor.getGreen(), disabledBaseColor.getBlue(), 0 );
            var disabledStroke = options.stroke ? disabledBaseColor.colorUtilsDarker( 0.4 ) : null;
        
            // Create the overlay that is used to add shading.
            var overlayForShadowGradient = new Circle( buttonRadius,
              {
                fill: options.baseColor,
                stroke: options.stroke,
                lineWidth: options.lineWidth
              } );
            button.addChild( overlayForShadowGradient );
        
            // The multiplier below can be varied in order to tweak the highlight appearance.
            var innerGradientRadius = buttonRadius - HIGHLIGHT_GRADIENT_LENGTH / 2;
            var outerGradientRadius = buttonRadius + HIGHLIGHT_GRADIENT_LENGTH / 2;
            var gradientOffset = HIGHLIGHT_GRADIENT_LENGTH / 2;
        
            // Create the gradient fills used for various button states
            var upFillHighlight = new RadialGradient( gradientOffset, gradientOffset, innerGradientRadius, gradientOffset, gradientOffset, outerGradientRadius )
              .addColorStop( 0, baseColor )
              .addColorStop( 1, baseColor.colorUtilsBrighter( 0.7 ) );
        
            var upFillShadow = new RadialGradient( -gradientOffset, -gradientOffset, innerGradientRadius, -gradientOffset, -gradientOffset, outerGradientRadius )
              .addColorStop( 0, transparentBaseColor )
              .addColorStop( 1, baseColor.colorUtilsDarker( 0.5 ) );
        
            var overFillHighlight = new RadialGradient( gradientOffset, gradientOffset, innerGradientRadius, gradientOffset, gradientOffset, outerGradientRadius )
              .addColorStop( 0, baseColor.colorUtilsBrighter( 0.3 ) )
              .addColorStop( 1, baseColor.colorUtilsBrighter( 0.8 ) );
        
            var overFillShadow = new RadialGradient( -gradientOffset, -gradientOffset, innerGradientRadius, -gradientOffset, -gradientOffset, outerGradientRadius )
              .addColorStop( 0, transparentBaseColor )
              .addColorStop( 1, baseColor.colorUtilsDarker( 0.5 ) );
        
            // Function to create a fill that represents a pressed in round button.
            function createPressedFill( color ) {
              return new RadialGradient( -gradientOffset, -gradientOffset, 0, 0, 0, outerGradientRadius )
                .addColorStop( 0, color.colorUtilsDarker( 0.1 ) )
                .addColorStop( 0.6, color.colorUtilsDarker( 0.2 ) )
                .addColorStop( 0.8, color )
                .addColorStop( 1, color.colorUtilsBrighter( 0.8 ) );
            }
        
            var pressedFill = createPressedFill( baseColor );
        
            var disabledFillHighlight = new RadialGradient( gradientOffset, gradientOffset, innerGradientRadius, gradientOffset, gradientOffset, outerGradientRadius )
              .addColorStop( 0, disabledBaseColor )
              .addColorStop( 1, disabledBaseColor.colorUtilsBrighter( 0.5 ) );
        
            var disabledFillShadow = new RadialGradient( -gradientOffset, -gradientOffset, innerGradientRadius, -gradientOffset, -gradientOffset, outerGradientRadius )
              .addColorStop( 0, transparentDisabledBaseColor )
              .addColorStop( 1, disabledBaseColor.colorUtilsDarker( 0.5 ) );
        
            var disabledPressedFillHighlight = createPressedFill( disabledBaseColor );
        
            // Hook up to the property that will trigger visual appearance changes.
            interactionStateProperty.link( function( state ) {
              switch( state ) {
        
                case 'idle':
                  button.fill = upFillHighlight;
                  overlayForShadowGradient.stroke = options.stroke;
                  overlayForShadowGradient.fill = upFillShadow;
                  break;
        
                case 'over':
                  button.fill = overFillHighlight;
                  overlayForShadowGradient.stroke = options.stroke;
                  overlayForShadowGradient.fill = overFillShadow;
                  break;
        
                case 'pressed':
                  button.fill = pressedFill;
                  overlayForShadowGradient.stroke = options.stroke;
                  overlayForShadowGradient.fill = overFillShadow;
                  break;
        
                case 'disabled':
                  button.fill = disabledFillHighlight;
                  overlayForShadowGradient.stroke = disabledStroke;
                  overlayForShadowGradient.fill = disabledFillShadow;
                  break;
        
                case 'disabled-pressed':
                  button.fill = disabledPressedFillHighlight;
                  overlayForShadowGradient.stroke = disabledStroke;
                  overlayForShadowGradient.fill = disabledFillShadow;
                  break;
              }
            } );
          };
        
          /**
           * Strategy for buttons that look flat, i.e. no shading or highlighting, but
           * that change color on mouseover, press, etc.
           *
           * @param {Node} button
           * @param {Property} interactionStateProperty
           * @param {Object} options
           * @constructor
           */
          RoundButtonView.flatAppearanceStrategy = function( button, interactionStateProperty, options ) {
        
            // Set up variables needed to create the various gradient fills
            var baseColor = Color.toColor( options.baseColor );
            var disabledBaseColor = Color.toColor( options.disabledBaseColor );
            var disabledStroke = null;
            if ( options.stroke ) {
              disabledStroke = disabledBaseColor.colorUtilsDarker( 0.4 );
            }
        
            // Create the fills used for various button states
            var upFill = baseColor;
            var overFill = baseColor.colorUtilsBrighter( 0.4 );
            var downFill = baseColor.colorUtilsDarker( 0.4 );
            var disabledFill = disabledBaseColor;
            var disabledPressedFillVertical = disabledFill;
        
            interactionStateProperty.link( function( state ) {
              switch( state ) {
        
                case 'idle':
                  button.fill = upFill;
                  button.stroke = options.stroke;
                  break;
        
                case 'over':
                  button.fill = overFill;
                  button.stroke = options.stroke;
                  break;
        
                case 'pressed':
                  button.fill = downFill;
                  button.stroke = options.stroke;
                  break;
        
                case 'disabled':
                  button.fill = disabledFill;
                  button.stroke = disabledStroke;
                  break;
        
                case 'disabled-pressed':
                  button.fill = disabledPressedFillVertical;
                  button.stroke = disabledStroke;
                  break;
              }
            } );
          };
        
          /**
           * Basic strategy for controlling content appearance, fades the content by
           * making it transparent when disabled.
           *
           * @param {Node} content
           * @param {Property} interactionStateProperty
           * @constructor
           */
          RoundButtonView.fadeContentWhenDisabled = function( content, interactionStateProperty ) {
            if ( content ) {
              interactionStateProperty.link( function( state ) {
                content.opacity = state === 'disabled' || state === 'disabled-pressed' ? 0.3 : 1;
              } );
            }
          };
        
          return inherit( Node, RoundButtonView, {
            set enabled( value ) {
              assert && assert( typeof value === 'boolean', 'RoundButtonView.enabled must be a boolean value' );
              this.buttonModel.enabled = value;
            },
        
            get enabled() { return this.buttonModel.enabled; }
          } );
        } );
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * A derived property that maps push button model states to the values needed
         * by the button view.
         */
        define( 'SUN/buttons/PushButtonInteractionStateProperty',['require','PHET_CORE/inherit','AXON/DerivedProperty'],function( require ) {
          
        
          // Imports
          var inherit = require( 'PHET_CORE/inherit' );
          var DerivedProperty = require( 'AXON/DerivedProperty' );
        
          function PushButtonInteractionStateProperty( buttonModel ) {
            DerivedProperty.call(
              this,
              [ buttonModel.overProperty, buttonModel.downProperty, buttonModel.enabledProperty ],
              function( over, down, enabled ) {
                return !enabled ? 'disabled' :
                       over && !down ? 'over' :
                       over && down ? 'pressed' :
                       'idle';
              } );
          }
        
          return inherit( DerivedProperty, PushButtonInteractionStateProperty );
        } );
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * An interactive round push button.  This is the file in which the appearance
         * and behavior are brought together.
         *
         * This class inherits from RoundButtonView, which contains all of the
         * code that defines the button's appearance, and adds the button's behavior
         * by hooking up a button model.
         *
         * @author John Blanco
         * @author Sam Reid
         */
        define( 'SUN/buttons/RoundPushButton',['require','PHET_CORE/inherit','SUN/buttons/PushButtonModel','SUN/buttons/RoundButtonView','SUN/buttons/PushButtonInteractionStateProperty'],function( require ) {
          
        
          // modules
          var inherit = require( 'PHET_CORE/inherit' );
          var PushButtonModel = require( 'SUN/buttons/PushButtonModel' );
          var RoundButtonView = require( 'SUN/buttons/RoundButtonView' );
          var PushButtonInteractionStateProperty = require( 'SUN/buttons/PushButtonInteractionStateProperty' );
        
          /**
           * @param {Object} options - All of the general Scenery node options can be
           * used, see Node.js or the Scenery documentation. In addition, the
           * following options are available. Note that there is no automated process
           * to keep these up to date, so keep that in mind when using these (and
           * please fix any errors you notice!).
           *
           * All of these values have defaults, so only specify them when needed.
           *
           *    baseColor:              The color for the main portion of the button, other colors for highlights and shadows will be based off of this
           *    content:                The node to display on the button, can be null for a blank button
           *    disabledBaseColor:      The color for the main portion of the button when disabled, other colors for highlights and shadows will be based of of this
           *    fireOnDown:             Boolean that controls whether the listener function(s) are fired when the button is pressed down instead of when released
           *    listener:               Function that is called when this button is fired
           *    minXMargin:             Minimum margin between the content and the edge in the x (i.e. horizontal) direction
           *    minYMargin:             Minimum margin between the content and the edge in the y (i.e. vertical) direction
           *    radius:                 Radius of the button, not needed unless a fixed radius beyond the size of the content is needed
           *    setContentEnabledLook:  Function that controls how the content appearance changes when the button is disabled
           *    touchExpansion:         Amount added beyond the radius to the touch area
           *    xContentOffset:         Offset from center in the X direction for the content node, sometimes needed for a good visual look
           *    yContentOffset:         Offset from center in the Y direction for the content node, sometimes needed for a good visual look
           *
           * @constructor
           */
          function RoundPushButton( options ) {
            // Safe to pass through options to the PushButtonModel like "fireOnDown".  Other scenery options will be safely ignored.
            this.buttonModel = new PushButtonModel( options );
            RoundButtonView.call( this, this.buttonModel, new PushButtonInteractionStateProperty( this.buttonModel ), options );
          }
        
          return inherit( RoundButtonView, RoundPushButton, {
            addListener: function( listener ) {
              this.buttonModel.addListener( listener );
            },
        
            removeListener: function( listener ) {
              this.buttonModel.removeListener( listener );
            } } );
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Shows one node if the property is true or another node if the property is false.
         * Used to indicate boolean state.
         *
         * @author Sam Reid
         * @author Chris Malley (PixelZoom, Inc.)
         */
        define( 'SUN/ToggleNode',['require','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','PHET_CORE/inherit'],function( require ) {
          
        
          var Node = require( 'SCENERY/nodes/Node' );
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
          var inherit = require( 'PHET_CORE/inherit' );
        
          /**
           * @param {Node} trueNode
           * @param {Node} falseNode
           * @param {Property} booleanProperty
           * @constructor
           */
          function ToggleNode( trueNode, falseNode, booleanProperty, options ) {
        
            options = _.extend( { // defaults
        
              //Wrap the nodes so that visibility flags won't be toggled on the passed-in nodes directly (in case they appear elsewhere in the DAG)
              //Or opt-out if you know the nodes don't appear elsewhere and want to opt out of the increased tree depth and associated performance costs
              wrapChildren: true
            }, options );
        
            var thisNode = this;
            Node.call( thisNode );
            var background = Rectangle.bounds( trueNode.bounds.union( falseNode.bounds ), { visible: false } );
            this.addChild( background );
        
            var targetTrueNode = options.wrapChildren ? new Node( {children: [trueNode]} ) : trueNode;
            var targetFalseNode = options.wrapChildren ? new Node( {children: [falseNode]} ) : falseNode;
        
            this.addChild( targetFalseNode );
            this.addChild( targetTrueNode );
        
            booleanProperty.link( function( value ) {
              targetTrueNode.setVisible( value );
              targetFalseNode.setVisible( !value );
            } );
            if ( options ) {
              this.mutate( options );
            }
          }
        
          return inherit( Node, ToggleNode );
        } );
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * A big round Go/Pause button that appears when the user has attached any nonzero number of pullers to the rope
         * which can be used to start/pause the animation.
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/tugofwar/view/GoPauseButton',['require','SCENERY/nodes/Text','PHET_CORE/inherit','string!FORCES_AND_MOTION_BASICS/go','string!FORCES_AND_MOTION_BASICS/pause','SCENERY_PHET/PhetFont','SUN/buttons/RoundPushButton','SUN/ToggleNode','SCENERY/nodes/Rectangle'],function( require ) {
          
        
          var Text = require( 'SCENERY/nodes/Text' );
          var inherit = require( 'PHET_CORE/inherit' );
          var goString = require( 'string!FORCES_AND_MOTION_BASICS/go' );
          var pauseString = require( 'string!FORCES_AND_MOTION_BASICS/pause' );
          var PhetFont = require( 'SCENERY_PHET/PhetFont' );
          var RoundPushButton = require( 'SUN/buttons/RoundPushButton' );
          var ToggleNode = require( 'SUN/ToggleNode' );
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
        
          //Given nodes that have possibly different sizes, wrap the specified node in a parent empty Rectangle node so the bounds will match up
          //If the node is already the largest, don't wrap it.
          //Centers all the nodes in the parent wrappers
          //TODO: Would be good to factor this out or provide better library support
          function wrap( node, padX, padY, nodes ) {
            var maxWidth = -1;
            var maxHeight = -1;
            nodes.forEach( function( n ) {
              if ( n.width > maxWidth ) {
                maxWidth = n.width;
              }
              if ( n.height > maxHeight ) {
                maxHeight = n.height;
              }
            } );
            maxWidth += padX;
            maxHeight += padY;
            node.centerX = maxWidth / 2;
            node.centerY = maxHeight / 2;
            return new Rectangle( 0, 0, maxWidth, maxHeight, {children: [node]} );
          }
        
          /**
           * Create a GoPauseButton that appears below the candy cart when a puller has been attached to the rope.
           * @param {TugOfWarModel} model the TugOfWarModel
           * @param {Number} layoutWidth the layout width for centering the button
           * @constructor
           */
          function GoPauseButton( model, layoutWidth ) {
            var goPauseButton = this;
        
            var padX = 15;
            var padY = 10;
            var goText = new Text( goString, {font: new PhetFont( 42 )} );
            var pauseText = new Text( pauseString, {font: new PhetFont( 30 )} );
        
            var goButton = new RoundPushButton( {content: wrap( goText, padX, padY, [goText, pauseText] ), baseColor: '#94b830', listener: function() {model.running = true;}} );//green
            var pauseButton = new RoundPushButton( {content: wrap( pauseText, padX, padY, [goText, pauseText] ), baseColor: '#df1a22', listener: function() {model.running = false;}} );//red
        
            var showGoButtonProperty = model.toDerivedProperty( ['running', 'state', 'numberPullersAttached'], function( running, state, numberPullersAttached ) {
              return !running;
            } );
            ToggleNode.call( this, goButton, pauseButton, showGoButtonProperty, {top: 400} );
        
            //Show the go/pause button if any pullers are attached or if the cart got started moving, and if it hasn't already finished a match, see #61
            model.multilink( [ 'running', 'state', 'numberPullersAttached' ], function() {
              goPauseButton.visible = model.state !== 'completed' && ( model.numberPullersAttached > 0 || model.running );
            } );
        
            this.centerX = layoutWidth / 2;
        
            //Add an accessibility peer to the Go/Pause button to enable keyboard access and screen reading
            //TODO: The peer should not be in the DOM if the button is invisible
            this.addPeer( '<input type="button" aria-label="Go/Pause">', {
              click: function() {
                model.running = !model.running;
              },
        
              //Visit this button after the user has added some pullers to the rope
              //TODO: Would benefit from a more natural traversal order
              tabIndex: 2
            } );
          }
        
          return inherit( ToggleNode, GoPauseButton );
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * A linear gradient that can be passed into the 'fill' or 'stroke' parameters.
         *
         * SVG gradients, see http://www.w3.org/TR/SVG/pservers.html
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/util/LinearGradient',['require','SCENERY/scenery','PHET_CORE/inherit','DOT/Vector2','SCENERY/util/Gradient'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          
          var inherit = require( 'PHET_CORE/inherit' );
          var Vector2 = require( 'DOT/Vector2' );
          var Gradient = require( 'SCENERY/util/Gradient' );
        
          // TODO: add the ability to specify the color-stops inline. possibly [ [0,color1], [0.5,color2], [1,color3] ]
          scenery.LinearGradient = function LinearGradient( x0, y0, x1, y1 ) {
            assert && assert( isFinite( x0 ) && isFinite( y0 ) && isFinite( x1 ) && isFinite( y1 ) );
            var usesVectors = y1 === undefined;
            if ( usesVectors ) {
              assert && assert( ( x0 instanceof Vector2 ) && ( y0 instanceof Vector2 ), 'If less than 4 parameters are given, the first two parameters must be Vector2' );
            }
            this.start = usesVectors ? x0 : new Vector2( x0, y0 );
            this.end = usesVectors ? y0 : new Vector2( x1, y1 );
            
            // use the global scratch canvas instead of creating a new Canvas
            Gradient.call( this, scenery.scratchContext.createLinearGradient( x0, y0, x1, y1 ) );
          };
          var LinearGradient = scenery.LinearGradient;
          
          inherit( Gradient, LinearGradient, {
            
            isLinearGradient: true,
            
            // seems we need the defs: http://stackoverflow.com/questions/7614209/linear-gradients-in-svg-without-defs
            // SVG: spreadMethod 'pad' 'reflect' 'repeat' - find Canvas usage
            getSVGDefinition: function( id ) {
              /* Approximate example of what we are creating:
              <linearGradient id="grad2" x1="0" y1="0" x2="100" y2="0" gradientUnits="userSpaceOnUse">
                <stop offset="0" style="stop-color:rgb(255,255,0);stop-opacity:1" />
                <stop offset="0.5" style="stop-color:rgba(255,255,0,0);stop-opacity:0" />
                <stop offset="1" style="stop-color:rgb(255,0,0);stop-opacity:1" />
              </linearGradient>
              */
              var definition = document.createElementNS( scenery.svgns, 'linearGradient' );
              definition.setAttribute( 'id', id );
              definition.setAttribute( 'gradientUnits', 'userSpaceOnUse' ); // so we don't depend on the bounds of the object being drawn with the gradient
              definition.setAttribute( 'x1', this.start.x );
              definition.setAttribute( 'y1', this.start.y );
              definition.setAttribute( 'x2', this.end.x );
              definition.setAttribute( 'y2', this.end.y );
              if ( this.transformMatrix ) {
                definition.setAttribute( 'gradientTransform', this.transformMatrix.getSVGTransform() );
              }
              
              _.each( this.stops, function( stop ) {
                var stopElement = document.createElementNS( scenery.svgns, 'stop' );
                stopElement.setAttribute( 'offset', stop.ratio );
                stopElement.setAttribute( 'style', 'stop-color: ' + stop.color.withAlpha( 1 ).toCSS() + '; stop-opacity: ' + stop.color.a.toFixed( 20 ) + ';' );
                definition.appendChild( stopElement );
              } );
              
              return definition;
            },
            
            toString: function() {
              var result = 'new scenery.LinearGradient( ' + this.start.x + ', ' + this.start.y + ', ' + this.end.x + ', ' + this.end.y + ' )';
              
              _.each( this.stops, function( stop ) {
                result += '.addColorStop( ' + stop.ratio + ', \'' + stop.color.toString() + '\' )';
              } );
              
              return result;
            }
          } );
          
          return LinearGradient;
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Visual representation of a rectangular button.
         *
         * @author John Blanco
         * @author Sam Reid
         */
        define( 'SUN/buttons/RectangularButtonView',['require','SUN/buttons/ButtonListener','SCENERY/util/Color','PHET_CORE/inherit','SCENERY/util/LinearGradient','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','KITE/Shape'],function( require ) {
          
        
          // modules
          var ButtonListener = require( 'SUN/buttons/ButtonListener' );
          var Color = require( 'SCENERY/util/Color' );
          var inherit = require( 'PHET_CORE/inherit' );
          var LinearGradient = require( 'SCENERY/util/LinearGradient' );
          var Node = require( 'SCENERY/nodes/Node' );
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
          var Shape = require( 'KITE/Shape' );
        
          // constants
          var VERTICAL_HIGHLIGHT_GRADIENT_LENGTH = 7; // In screen coords, which are roughly pixels.
          var HORIZONTAL_HIGHLIGHT_GRADIENT_LENGTH = 7; // In screen coords, which are roughly pixels.
          var SHADE_GRADIENT_LENGTH = 3; // In screen coords, which are roughly pixels.
          var DEFAULT_COLOR = new Color( 153, 206, 255 );
        
          /**
           * @param {ButtonModel} buttonModel - Model that defines the button's behavior.
           * @param {Property} interactionStateProperty - A property that is used to drive the visual appearance of the button.
           * @param {Object} options
           * @constructor
           */
          function RectangularButtonView( buttonModel, interactionStateProperty, options ) {
            this.buttonModel = buttonModel; // @protected
            var thisButton = this;
        
            options = _.extend( {
              // Default values.
              content: null,
              minWidth: 1,
              minHeight: 1,
              cursor: 'pointer',
              cornerRadius: 4,
              baseColor: DEFAULT_COLOR,
              disabledBaseColor: new Color( 220, 220, 220 ),
              xMargin: 8, // should be visibly greater than yMargin, see issue #109
              yMargin: 5,
              fireOnDown: false,
              xTouchExpansion: 5,
              yTouchExpansion: 5,
              stroke: DEFAULT_COLOR.colorUtilsDarker( 0.4 ),
              lineWidth: 0.5, // Only meaningful if stroke is non-null
        
              // Strategy for controlling the button's appearance, excluding any
              // content.  This can be a stock strategy from this file or custom.  To
              // create a custom one, model it off of the stock strategies defined in
              // this file.
              buttonAppearanceStrategy: RectangularButtonView.threeDAppearanceStrategy,
        
              // Strategy for controlling the appearance of the button's content based
              // on the button's state.  This can be a stock strategy from this file,
              // or custom.  To create a custom one, model it off of the stock
              // version(s) defined in this file.
              contentAppearanceStrategy: RectangularButtonView.fadeContentWhenDisabled
            }, options );
        
            Node.call( thisButton );
        
            // Hook up the input listener
            this.addInputListener( new ButtonListener( buttonModel ) );
        
            // Figure out the size of the button.
            var content = options.content;
            var buttonWidth = Math.max( content ? content.width + options.xMargin * 2 : 0, options.minWidth );
            var buttonHeight = Math.max( content ? content.height + options.yMargin * 2 : 0, options.minHeight );
        
            // Create the basic button shape.
            var button = new Rectangle( 0, 0, buttonWidth, buttonHeight, options.cornerRadius, options.cornerRadius,
              {
                fill: options.baseColor,
                lineWidth: options.lineWidth
              } );
            this.addChild( button );
        
            // Hook up the strategy that will control the basic button appearance.
            options.buttonAppearanceStrategy( button, interactionStateProperty, options );
        
            // Add the content to the button.
            if ( content ) {
              content.center = button.center;
              thisButton.addChild( content );
            }
        
            // Hook up the strategy that will control the content appearance.
            options.contentAppearanceStrategy( content, interactionStateProperty );
        
            // Control the pointer state based on the interaction state.
            interactionStateProperty.link( function( state ) {
              thisButton.cursor = state === 'disabled' || state === 'disabled-pressed' ? null : 'pointer';
            } );
        
            // Add explicit mouse and touch areas so that the child nodes can all be non-pickable.
            this.mouseArea = Shape.rectangle( 0, 0, buttonWidth, buttonHeight );
            this.touchArea = Shape.rectangle( -options.xTouchExpansion, -options.yTouchExpansion, buttonWidth + options.xTouchExpansion * 2, buttonHeight + options.yTouchExpansion * 2 );
        
            // Mutate with the options after the layout is complete so that width-
            // dependent fields like centerX will work.
            thisButton.mutate( options );
          }
        
          /**
           * Strategy for making a button look 3D-ish by using gradients that create
           * the appearance of highlighted and shaded edges.
           *
           * @param {Node} button
           * @param {Property} interactionStateProperty
           * @param {Object} options
           * @constructor
           */
          RectangularButtonView.threeDAppearanceStrategy = function( button, interactionStateProperty, options ) {
        
            // Set up variables needed to create the various gradient fills
            var buttonWidth = button.width;
            var buttonHeight = button.height;
            var verticalHighlightStop = Math.min( VERTICAL_HIGHLIGHT_GRADIENT_LENGTH / buttonHeight, 1 );
            var verticalShadowStop = Math.max( 1 - SHADE_GRADIENT_LENGTH / buttonHeight, 0 );
            var horizontalHighlightStop = Math.min( HORIZONTAL_HIGHLIGHT_GRADIENT_LENGTH / buttonWidth, 1 );
            var horizontalShadowStop = Math.max( 1 - SHADE_GRADIENT_LENGTH / buttonWidth, 0 );
            var baseColor = Color.toColor( options.baseColor );
            var disabledBaseColor = Color.toColor( options.disabledBaseColor );
            var transparentBaseColor = new Color( baseColor.getRed(), baseColor.getGreen(), baseColor.getBlue(), 0 );
            var transparentDisabledBaseColor = new Color( disabledBaseColor.getRed(), disabledBaseColor.getGreen(), disabledBaseColor.getBlue(), 0 );
            var disabledStroke = null;
            if ( options.stroke ) {
              disabledStroke = disabledBaseColor.colorUtilsDarker( 0.4 );
            }
            var transparentWhite = new Color( 256, 256, 256, 0.7 );
        
            // Create the gradient fills used for various button states
            var upFillVertical = new LinearGradient( 0, 0, 0, buttonHeight )
              .addColorStop( 0, baseColor.colorUtilsBrighter( 0.7 ) )
              .addColorStop( verticalHighlightStop, baseColor )
              .addColorStop( verticalShadowStop, baseColor )
              .addColorStop( 1, baseColor.colorUtilsDarker( 0.5 ) );
        
            var upFillHorizontal = new LinearGradient( 0, 0, buttonWidth, 0 )
              .addColorStop( 0, transparentWhite )
              .addColorStop( horizontalHighlightStop, transparentBaseColor )
              .addColorStop( horizontalShadowStop, transparentBaseColor )
              .addColorStop( 1, baseColor.colorUtilsDarker( 0.5 ) );
        
            var overFillVertical = new LinearGradient( 0, 0, 0, buttonHeight )
              .addColorStop( 0, baseColor.colorUtilsBrighter( 0.7 ) )
              .addColorStop( verticalHighlightStop, baseColor.colorUtilsBrighter( 0.5 ) )
              .addColorStop( verticalShadowStop, baseColor.colorUtilsBrighter( 0.5 ) )
              .addColorStop( 1, baseColor.colorUtilsDarker( 0.5 ) );
        
            var overFillHorizontal = new LinearGradient( 0, 0, buttonWidth, 0 )
              .addColorStop( 0, transparentWhite )
              .addColorStop( horizontalHighlightStop / 2, new Color( 256, 256, 256, 0 ) )
              .addColorStop( horizontalShadowStop, transparentBaseColor )
              .addColorStop( 1, baseColor.colorUtilsDarker( 0.3 ) );
        
            var downFill = new LinearGradient( 0, 0, 0, buttonHeight )
              .addColorStop( 0, baseColor.colorUtilsBrighter( 0.7 ) )
              .addColorStop( verticalHighlightStop * 0.67, baseColor.colorUtilsDarker( 0.3 ) )
              .addColorStop( verticalShadowStop, baseColor.colorUtilsBrighter( 0.2 ) )
              .addColorStop( 1, baseColor.colorUtilsDarker( 0.5 ) );
        
            var disabledFillVertical = new LinearGradient( 0, 0, 0, buttonHeight )
              .addColorStop( 0, disabledBaseColor.colorUtilsBrighter( 0.7 ) )
              .addColorStop( verticalHighlightStop, disabledBaseColor.colorUtilsBrighter( 0.5 ) )
              .addColorStop( verticalShadowStop, disabledBaseColor.colorUtilsBrighter( 0.5 ) )
              .addColorStop( 1, disabledBaseColor.colorUtilsDarker( 0.5 ) );
        
            var disabledFillHorizontal = new LinearGradient( 0, 0, buttonWidth, 0 )
              .addColorStop( 0, disabledBaseColor.colorUtilsBrighter( 0.7 ) )
              .addColorStop( horizontalHighlightStop, transparentDisabledBaseColor )
              .addColorStop( horizontalShadowStop, transparentDisabledBaseColor )
              .addColorStop( 1, disabledBaseColor.colorUtilsDarker( 0.5 ) );
        
            var disabledPressedFillVertical = new LinearGradient( 0, 0, 0, buttonHeight )
              .addColorStop( 0, disabledBaseColor.colorUtilsBrighter( 0.7 ) )
              .addColorStop( verticalHighlightStop * 0.67, disabledBaseColor.colorUtilsDarker( 0.3 ) )
              .addColorStop( verticalShadowStop, disabledBaseColor.colorUtilsBrighter( 0.2 ) )
              .addColorStop( 1, disabledBaseColor.colorUtilsDarker( 0.5 ) );
        
            // Create the overlay that is used to add horizontal shading.
            var overlayForHorizGradient = new Rectangle( 0, 0, buttonWidth, buttonHeight, options.cornerRadius, options.cornerRadius,
              {
                fill: options.baseColor,
                stroke: options.stroke,
                lineWidth: options.lineWidth
              } );
            button.addChild( overlayForHorizGradient );
        
            interactionStateProperty.link( function( state ) {
              switch( state ) {
        
                case 'idle':
                  button.fill = upFillVertical;
                  overlayForHorizGradient.stroke = options.stroke;
                  overlayForHorizGradient.fill = upFillHorizontal;
                  break;
        
                case 'over':
                  button.fill = overFillVertical;
                  overlayForHorizGradient.stroke = options.stroke;
                  overlayForHorizGradient.fill = overFillHorizontal;
                  break;
        
                case 'pressed':
                  button.fill = downFill;
                  overlayForHorizGradient.stroke = options.stroke;
                  overlayForHorizGradient.fill = overFillHorizontal;
                  break;
        
                case 'disabled':
                  button.fill = disabledFillVertical;
                  button.stroke = disabledStroke;
                  overlayForHorizGradient.stroke = disabledStroke;
                  overlayForHorizGradient.fill = disabledFillHorizontal;
                  break;
        
                case 'disabled-pressed':
                  button.fill = disabledPressedFillVertical;
                  button.stroke = disabledStroke;
                  overlayForHorizGradient.stroke = disabledStroke;
                  overlayForHorizGradient.fill = disabledFillHorizontal;
                  break;
              }
            } );
          };
        
          /**
           * Strategy for buttons that look flat, i.e. no shading or highlighting, but
           * that change color on mouseover, press, etc.
           *
           * @param {Node} button
           * @param {Property} interactionStateProperty
           * @param {Object} options
           * @constructor
           */
          RectangularButtonView.flatAppearanceStrategy = function( button, interactionStateProperty, options ) {
        
            // Set up variables needed to create the various gradient fills
            var baseColor = Color.toColor( options.baseColor );
            var disabledBaseColor = Color.toColor( options.disabledBaseColor );
            var disabledStroke = null;
            if ( options.stroke ) {
              disabledStroke = disabledBaseColor.colorUtilsDarker( 0.4 );
            }
        
            // Create the fills used for various button states
            var upFill = baseColor;
            var overFill = baseColor.colorUtilsBrighter( 0.4 );
            var downFill = baseColor.colorUtilsDarker( 0.4 );
            var disabledFill = disabledBaseColor;
            var disabledPressedFillVertical = disabledFill;
        
            interactionStateProperty.link( function( state ) {
              switch( state ) {
        
                case 'idle':
                  button.fill = upFill;
                  button.stroke = options.stroke;
                  break;
        
                case 'over':
                  button.fill = overFill;
                  button.stroke = options.stroke;
                  break;
        
                case 'pressed':
                  button.fill = downFill;
                  button.stroke = options.stroke;
                  break;
        
                case 'disabled':
                  button.fill = disabledFill;
                  button.stroke = disabledStroke;
                  break;
        
                case 'disabled-pressed':
                  button.fill = disabledPressedFillVertical;
                  button.stroke = disabledStroke;
                  break;
              }
            } );
          };
        
          /**
           * Basic strategy for controlling content appearance, fades the content by
           * making it transparent when disabled.
           *
           * @param {Node} content
           * @param {Property} interactionStateProperty
           * @constructor
           */
          RectangularButtonView.fadeContentWhenDisabled = function( content, interactionStateProperty ) {
            if ( content ) {
              interactionStateProperty.link( function( state ) {
                content.opacity = state === 'disabled' || state === 'disabled-pressed' ? 0.3 : 1;
              } );
            }
          };
        
          return inherit( Node, RectangularButtonView,
            {
              set enabled( value ) {
                assert && assert( typeof value === 'boolean', 'RectangularButtonView.enabled must be a boolean value' );
                this.buttonModel.enabled = value;
              },
        
              get enabled() { return this.buttonModel.enabled; }
            } );
        } );
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * A rectangular push button.  This is the file in which the appearance and
         * behavior are brought together.
         *
         * This class inherits from RectangularButtonView, which contains all of the
         * code that defines the button's appearance, and adds the button's behavior
         * by hooking up a button model.
         *
         * @author John Blanco
         */
        define( 'SUN/buttons/RectangularPushButton',['require','PHET_CORE/inherit','SUN/buttons/RectangularButtonView','SUN/buttons/PushButtonInteractionStateProperty','SUN/buttons/PushButtonModel'],function( require ) {
          
        
          // modules
          var inherit = require( 'PHET_CORE/inherit' );
          var RectangularButtonView = require( 'SUN/buttons/RectangularButtonView' );
          var PushButtonInteractionStateProperty = require( 'SUN/buttons/PushButtonInteractionStateProperty' );
          var PushButtonModel = require( 'SUN/buttons/PushButtonModel' );
        
          /**
           * @param {Object} options - All of the general Scenery node options can be
           * used, see Node.js or the Scenery documentation. In addition, the
           * following options are available. Note that there is no automated process
           * to keep these up to date, so keep that in mind when using these (and
           * please fix any errors you notice!).
           *
           * All of these values have defaults, so only specify them when needed.
           *
           *    buttonAppearanceStrategy:   Object that controls how the button's appearance changes as the user interacts with it
           *    baseColor:                  The color for the main portion of the button, other colors for highlights and shadows will be based off of this
           *    content:                    The node to display on the button, can be null for a blank button
           *    contentAppearanceStrategy:  Object that controls how the content node's appearance changes as the user interacts with the button
           *    cornerRadius:               Just like the usual option for a rectangular shape
           *    disabledBaseColor:          The color for the main portion of the button when disabled, other colors for highlights and shadows will be based of of this
           *    fireOnDown:                 Boolean that controls whether the listener function(s) are fired when the button is pressed down instead of when released
           *    listener:                   Function that is called when this button is fired
           *    minHeight:                  Minimum height for the button, not needed unless a fixed height beyond that of the content is desired
           *    minWidth:                   Minimum width for the button, not needed unless a fixed width beyond that of the content is desired
           *    xMargin:                    Margin between the content and the edge in the x (i.e. horizontal) direction
           *    yMargin:                    Margin between the content and the edge in the y (i.e. vertical) direction
           *    xTouchExpansion:            Amount of space beyond the left and right edges where the button will sense touch events
           *    yTouchExpansion:            Amount of space beyond the top and bottom edges where the button will sense touch events
           *
           * @constructor
           */
          function RectangularPushButton( options ) {
            // Safe to pass through options to the PushButtonModel like "fireOnDown".  Other scenery options will be safely ignored.
            var buttonModel = new PushButtonModel( options );
            RectangularButtonView.call( this, buttonModel, new PushButtonInteractionStateProperty( buttonModel ), options );
          }
        
          return inherit( RectangularButtonView, RectangularPushButton, {
            addListener: function( listener ) {
              this.buttonModel.addListener( listener );
            },
        
            removeListener: function( listener ) {
              this.buttonModel.removeListener( listener );
            }
          } );
        } );
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Push button with text on a rectangle.
         *
         * @author John Blanco
         */
        define( 'SUN/buttons/TextPushButton',['require','PHET_CORE/inherit','SUN/buttons/RectangularPushButton','SCENERY/nodes/Text','SCENERY_PHET/PhetFont'],function( require ) {
          
        
          // modules
          var inherit = require( 'PHET_CORE/inherit' );
          var RectangularPushButton = require( 'SUN/buttons/RectangularPushButton' );
          var Text = require( 'SCENERY/nodes/Text' );
          var PhetFont = require( 'SCENERY_PHET/PhetFont' );
        
          // constants
          var DEFAULT_FONT = new PhetFont( 20 );
        
          function TextPushButton( text, options ) {
        
            options = _.extend( {
              font: DEFAULT_FONT,
              textFill: 'black'
            }, options );
        
            var textNode = new Text( text, { font: options.font, fill: options.textFill } );
            RectangularPushButton.call( this, _.extend( { content: textNode }, options ) );
          }
        
          return inherit( RectangularPushButton, TextPushButton );
        } );
        
        
        define("string!FORCES_AND_MOTION_BASICS/return",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/return");});
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Shows a button that allows the user to "return" the cart after a match has completed.
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/tugofwar/view/ReturnButton',['require','SCENERY/nodes/Node','PHET_CORE/inherit','SUN/buttons/TextPushButton','SCENERY_PHET/PhetFont','string!FORCES_AND_MOTION_BASICS/return'],function( require ) {
          
        
          var Node = require( 'SCENERY/nodes/Node' );
          var inherit = require( 'PHET_CORE/inherit' );
          var TextPushButton = require( 'SUN/buttons/TextPushButton' );
          var PhetFont = require( 'SCENERY_PHET/PhetFont' );
          var returnString = require( 'string!FORCES_AND_MOTION_BASICS/return' );
        
          /**
           * @param {TugOfWarModel} model
           * @param options
           * @constructor
           */
          function ReturnButton( model, options ) {
            Node.call( this, {} );
        
            var button = new TextPushButton( returnString, {
              listener: model.returnCart.bind( model ),
              font: new PhetFont( { size: 16, weight: 'bold' } ),
              baseColor: 'rgb( 254, 192, 0 )'
            } );
            this.addChild( button );
            this.mutate( options );
        
            model.startedProperty.linkAttribute( this, 'visible' );
          }
        
          return inherit( Node, ReturnButton );
        } );
        
        
        define("string!FORCES_AND_MOTION_BASICS/blueWins",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/blueWins");});
        
        
        define("string!FORCES_AND_MOTION_BASICS/redWins",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/redWins");});
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Node that shows the waving flag when the tug of war game is complete.
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/tugofwar/view/FlagNode',['require','SCENERY/nodes/Node','SCENERY/nodes/Text','SCENERY/nodes/Path','KITE/Shape','PHET_CORE/inherit','string!FORCES_AND_MOTION_BASICS/blueWins','string!FORCES_AND_MOTION_BASICS/redWins','SCENERY_PHET/PhetFont'],function( require ) {
          
        
          var Node = require( 'SCENERY/nodes/Node' );
          var Text = require( 'SCENERY/nodes/Text' );
          var Path = require( 'SCENERY/nodes/Path' );
          var Shape = require( 'KITE/Shape' );
          var inherit = require( 'PHET_CORE/inherit' );
          var blueWinsString = require( 'string!FORCES_AND_MOTION_BASICS/blueWins' );
          var redWinsString = require( 'string!FORCES_AND_MOTION_BASICS/redWins' );
          var PhetFont = require( 'SCENERY_PHET/PhetFont' );
        
          /**
        
           * Constructor for FlagNode
           *
           * @param {MotionModel} model the model for the entire 'motion', 'friction' or 'acceleration' screen
           * @param {Number} centerX center for layout
           * @param {Number} top top for layout
           * @constructor
           */
          function FlagNode( model, centerX, top ) {
            var flagNode = this;
            this.model = model;
            Node.call( this );
        
            var text = new Text( model.cart.x < 0 ? blueWinsString : redWinsString, {font: new PhetFont( 32 ), fill: 'white'} );
            this.path = new Path( null, {fill: model.cart.x < 0 ? 'blue' : 'red', stroke: 'black', lineWidth: 2, centerX: 0, centerY: 0} );
            this.addChild( this.path );
        
            //Shrink the text to fit on the flag if necessary
            if ( text.width > 220 ) {
              text.scale( 220 / text.width );
            }
            this.addChild( text );
        
            var update = this.updateFlagShape.bind( this );
        
            //Do it once, to remove as a listener since flag node gets recreated when another game won
            model.once( 'reset-all', function() {
              flagNode.detach();
              model.timeProperty.unlink( update );
            } );
            model.once( 'cart-returned', function() {
              flagNode.detach();
              model.timeProperty.unlink( update );
            } );
        
            //When the clock ticks, wave the flag
            model.timeProperty.link( update );
            text.centerX = this.path.centerX;
            text.centerY = this.path.centerY;
            this.centerX = centerX;
            this.top = top;
          }
        
          return inherit( Node, FlagNode, {
        
            //Update the flag shape, copied from the Java version
            updateFlagShape: function() {
              var shape = new Shape();
              var maxX = 220;
              var maxY = 75;
              var dy = ( 7 * Math.sin( this.model.time * 6 ) );
              var dx = ( 2 * Math.sin( this.model.time * 5 ) ) + 10;
              shape.moveTo( 0, 0 );
              shape.cubicCurveTo( maxX / 3 + dx, 25 + dy, 2 * maxX / 3 + dx, -25 - dy, maxX + dx, dy / 2 );
              shape.lineTo( maxX + dx, maxY + dy / 2 );
              shape.cubicCurveTo( 2 * maxX / 3 + dx, -25 + maxY - dy, maxX / 3 + dx, 25 + maxY + dy, 0, maxY );
              shape.lineTo( 0, 0 );
              shape.close();
              this.path.shape = shape;
            }} );
        } );
        //  Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * AbstractBox is the parent for VBox and HBox, which arrange child nodes.
         * See https://github.com/phetsims/scenery/issues/116
         *
         * @author Sam Reid
         */
        
        define( 'SCENERY/nodes/AbstractBox',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Node'],function( require ) {
          
        
          var inherit = require( 'PHET_CORE/inherit' );
          var scenery = require( 'SCENERY/scenery' );
          var Node = require( 'SCENERY/nodes/Node' );
        
          /**
           * Main constructor for AbstractBox.
           *
           * @param {object} options Same as Node.constructor.options with the following additions:
           *
           * spacing: can be a number or a function.  If a number, then it will be the spacing between each object.
           *              If a function, then the function will have the signature function(a,b){} which returns the spacing between adjacent pairs of items.
           * align:   How to line up the items, defaults to 'center'.
           *
           * @param {string} type 'vertical' or 'horizontal'
           * @param {function} layoutFunction the function to layout out the nodes (different for HBox and VBox)
           *
           * @constructor
           */
          scenery.AbstractBox = function AbstractBox( type, layoutFunction, options ) {
            assert && assert( type === 'vertical' || type === 'horizontal' );
        
            this.type = type;
            this.layoutFunction = layoutFunction;
            this.boundsListener = this.updateLayout.bind( this );
        
            // ensure we have a parameter object
            this.options = _.extend( {
              // defaults
              spacing: function() { return 0; },
              align: 'center',
        
              //By default, update the layout when children are added/removed/resized, see #116
              resize: true
            }, options );
        
            if ( typeof this.options.spacing === 'number' ) {
              var spacingConstant = this.options.spacing;
              this.options.spacing = function() { return spacingConstant; };
            }
        
            Node.call( this );
        
            //See HBox.js
            this.inited = false;
            this.mutate( this.options );
            this.inited = true;
          };
          var AbstractBox = scenery.AbstractBox;
        
          inherit( Node, AbstractBox, {
            updateLayout: function() {
              if ( !this.updatingLayout ) {
                //Bounds of children are changed in updateLayout, we don't want to stackoverflow so bail if already updating layout
                this.updatingLayout = true;
                this.layoutFunction.call( this );
                this.updatingLayout = false;
              }
            }
          } );
        
          //Override the child mutators to updateLayout
          //Have to listen to the child bounds individually because there are a number of possible ways to change the child
          //bounds without changing the overall bounds.
          var overrides = ['insertChild', 'removeChildWithIndex'];
          overrides.forEach( function( override ) {
        
            //Support up to two args for overrides
            AbstractBox.prototype[override] = function( arg1, arg2 ) {
        
              //Remove event listeners from any nodes (will be added back later if the node was not removed)
              var abstractBox = this;
              if ( this.options.resize ) {
                this.children.forEach( function( child ) {
                  if ( child.containsEventListener( 'bounds', abstractBox.boundsListener ) ) {
                    child.removeEventListener( 'bounds', abstractBox.boundsListener );
                  }
                } );
              }
        
              //Super call
              Node.prototype[override].call( this, arg1, arg2 );
        
              //Update the layout if it should be dynamic
              if ( this.options.resize || !this.inited ) {
                this.updateLayout();
              }
        
              //Add event listeners for any current children (if it should be dynamic)
              if ( this.options.resize ) {
                this.children.forEach( function( child ) {
                  if ( !child.containsEventListener( 'bounds', abstractBox.boundsListener ) ) {
                    child.addEventListener( 'bounds', abstractBox.boundsListener );
                  }
                } );
              }
            };
          } );
        
          return AbstractBox;
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * VBox arranges the child nodes vertically, and they can be centered, left or right justified.
         * Vertical spacing can be set as a constant or a function which depends on the adjacent nodes.
         *
         * See a dynamic test in scenery\tests\test-vbox.html
         *
         * @author Sam Reid
         */
        
        define( 'SCENERY/nodes/HBox',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/AbstractBox'],function( require ) {
          
        
          var inherit = require( 'PHET_CORE/inherit' );
          var scenery = require( 'SCENERY/scenery' );
          var AbstractBox = require( 'SCENERY/nodes/AbstractBox' );
        
          /**
           *
           * @param options Same as Node.constructor.options with the following additions:
           *
           * spacing: can be a number or a function.  If a number, then it will be the vertical spacing between each object.
           *              If a function, then the function will have the signature function(top,bottom){} which returns the spacing between adjacent pairs of items.
           * align:   How to line up the items horizontally.  One of 'center', 'top' or 'bottom'.  Defaults to 'center'.
           *
           * @constructor
           */
          scenery.HBox = function VBox( options ) {
            AbstractBox.call( this, 'horizontal', function() {
              var minY = _.min( _.map( this.children, function( child ) {return child.top;} ) );
              var maxY = _.max( _.map( this.children, function( child ) {return child.top + child.height;} ) );
              var centerY = (maxY + minY) / 2;
        
              //Start at x=0 in the coordinate frame of this node.  Not possible to set this through the spacing option, instead just set it with the {x:number} option.
              var x = 0;
              for ( var i = 0; i < this.children.length; i++ ) {
                var child = this.children[i];
                child.left = x;
        
                //Set the position horizontally
                if ( this.options.align === 'top' ) {
                  child.top = minY;
                }
                else if ( this.options.align === 'bottom' ) {
                  child.bottom = maxY;
                }
                else {//default to center
                  child.centerY = centerY;
                }
        
                //Move to the next vertical position.
                x += child.width + this.options.spacing( child, this.children[i + 1] );
              }
            }, options );
          };
        
          return inherit( AbstractBox, scenery.HBox );
        } );
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Reset All shape (arrow)
         *
         * @author John Blanco
         */
        define( 'SCENERY_PHET/ResetAllShape',['require','PHET_CORE/inherit','KITE/Shape'],function( require ) {
          
        
          // modules
          var inherit = require( 'PHET_CORE/inherit' );
          var Shape = require( 'KITE/Shape' );
        
          /**
           * @param {Number} Radius of the center of the reset arrow
           * @constructor
           */
          function ResetAllShape( radius ) {
            Shape.call( this );
        
            // Create the curved arrow shape, starting at the inside of the non-
            // pointed end.  The parameters immediately below can be adjusted in order
            // to tweak the appearance of the arrow.
            var innerRadius = radius * 0.4;
            var outerRadius = radius * 0.625;
            var headWidth = 2.25 * ( outerRadius - innerRadius );
            var startAngle = -Math.PI * 0.35;
            var endToNeckAngularSpan = -2 * Math.PI * 0.85;
            var arrowHeadAngularSpan = -Math.PI * 0.18;
            //---- End of tweak params ----
            this.moveTo( innerRadius * Math.cos( startAngle ), innerRadius * Math.sin( startAngle ) ); // Inner edge of end.
            this.lineTo( outerRadius * Math.cos( startAngle ), outerRadius * Math.sin( startAngle ) );
            var neckAngle = startAngle + endToNeckAngularSpan;
            this.arc( 0, 0, outerRadius, startAngle, neckAngle, true ); // Outer curve.
            var headWidthExtrusion = ( headWidth - ( outerRadius - innerRadius ) ) / 2;
            this.lineTo(
                ( outerRadius + headWidthExtrusion ) * Math.cos( neckAngle ),
                ( outerRadius + headWidthExtrusion ) * Math.sin( neckAngle ) );
            var pointRadius = ( outerRadius + innerRadius ) * 0.55; // Tweaked a little from center for better look.
            this.lineTo( // Tip of arrowhead.
                pointRadius * Math.cos( neckAngle + arrowHeadAngularSpan ),
                pointRadius * Math.sin( neckAngle + arrowHeadAngularSpan ) );
            this.lineTo( ( innerRadius - headWidthExtrusion ) * Math.cos( neckAngle ), ( innerRadius - headWidthExtrusion ) * Math.sin( neckAngle ) );
            this.lineTo( innerRadius * Math.cos( neckAngle ), innerRadius * Math.sin( neckAngle ) );
            this.arc( 0, 0, innerRadius, neckAngle, startAngle ); // Inner curve.
            this.close();
          }
        
          return inherit( Shape, ResetAllShape );
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Reset All button.  This version is drawn in code using shapes, gradients,
         * and such, and does not use any image files.
         *
         * @author John Blanco
         */
        define( 'SCENERY_PHET/ResetAllButton',['require','SCENERY/util/Color','PHET_CORE/inherit','SCENERY/nodes/Path','SUN/buttons/RoundPushButton','SCENERY_PHET/ResetAllShape'],function( require ) {
          
        
          // modules
          var Color = require( 'SCENERY/util/Color' );
          var inherit = require( 'PHET_CORE/inherit' );
          var Path = require( 'SCENERY/nodes/Path' );
          var RoundPushButton = require( 'SUN/buttons/RoundPushButton' );
          var ResetAllShape = require( 'SCENERY_PHET/ResetAllShape' );
        
          // Constants
          var DEFAULT_RADIUS = 24; // Derived from images initially used for reset button.
        
          /**
           * @param {Object} options
           * @constructor
           */
          function ResetAllButton( options ) {
            var buttonRadius = options && options.radius ? options.radius : DEFAULT_RADIUS;
            options = _.extend( {
              // Default values
              radius: DEFAULT_RADIUS,
              minXMargin: buttonRadius * 0.2,
        
              // Default orange color scheme, standard for PhET reset buttons
              baseColor: new Color( 247, 151, 34 ),
        
              // The arrow shape doesn't look right when perfectly centered, account
              // for that here, and see docs in RoundButtonView.  The multiplier
              // values were empirically determined.
              xContentOffset: buttonRadius * 0.03,
              yContentOffset: buttonRadius * ( -0.0125 )
            }, options );
        
            var icon = new Path( new ResetAllShape( options.radius ), { fill: 'white' } );
        
            RoundPushButton.call( this, _.extend( { content: icon }, options ) );
          }
        
          return inherit( RoundPushButton, ResetAllButton );
        } );
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Provides access to font-awesome glyphs as scenery nodes.
         *
         * @author Sam Reid
         */
        define( 'SUN/FontAwesomeNode',['require','SCENERY/nodes/Path','KITE/Shape','DOT/Matrix3','PHET_CORE/inherit'],function( require ) {
          
        
          var Path = require( 'SCENERY/nodes/Path' );
          var Shape = require( 'KITE/Shape' );
          var Matrix3 = require( 'DOT/Matrix3' );
          var inherit = require( 'PHET_CORE/inherit' );
        
          // Generated using chipper.FontAwesomeToScenery
          var icons = {
            fullscreen: "M1283 995l-355 -355l355 -355l144 144q29 31 70 14q39 -17 39 -59v-448q0 -26 -19 -45t-45 -19h-448q-42 0 -59 40q-17 39 14 69l144 144l-355 355l-355 -355l144 -144q31 -30 14 -69q-17 -40 -59 -40h-448q-26 0 -45 19t-19 45v448q0 42 40 59q39 17 69 -14l144 -144 l355 355l-355 355l-144 -144q-19 -19 -45 -19q-12 0 -24 5q-40 17 -40 59v448q0 26 19 45t45 19h448q42 0 59 -40q17 -39 -14 -69l-144 -144l355 -355l355 355l-144 144q-31 30 -14 69q17 40 59 40h448q26 0 45 -19t19 -45v-448q0 -42 -39 -59q-13 -5 -25 -5q-26 0 -45 19z",
            reorder: "M1536 192v-128q0 -26 -19 -45t-45 -19h-1408q-26 0 -45 19t-19 45v128q0 26 19 45t45 19h1408q26 0 45 -19t19 -45zM1536 704v-128q0 -26 -19 -45t-45 -19h-1408q-26 0 -45 19t-19 45v128q0 26 19 45t45 19h1408q26 0 45 -19t19 -45zM1536 1216v-128q0 -26 -19 -45 t-45 -19h-1408q-26 0 -45 19t-19 45v128q0 26 19 45t45 19h1408q26 0 45 -19t19 -45z",
            home: "M1408 544v-480q0 -26 -19 -45t-45 -19h-384v384h-256v-384h-384q-26 0 -45 19t-19 45v480q0 1 0.5 3t0.5 3l575 474l575 -474q1 -2 1 -6zM1631 613l-62 -74q-8 -9 -21 -11h-3q-13 0 -21 7l-692 577l-692 -577q-12 -8 -24 -7q-13 2 -21 11l-62 74q-8 10 -7 23.5t11 21.5 l719 599q32 26 76 26t76 -26l244 -204v195q0 14 9 23t23 9h192q14 0 23 -9t9 -23v-408l219 -182q10 -8 11 -21.5t-7 -23.5z",
            volume_off: "M768 1184v-1088q0 -26 -19 -45t-45 -19t-45 19l-333 333h-262q-26 0 -45 19t-19 45v384q0 26 19 45t45 19h262l333 333q19 19 45 19t45 -19t19 -45z",
            volume_up: "M768 1184v-1088q0 -26 -19 -45t-45 -19t-45 19l-333 333h-262q-26 0 -45 19t-19 45v384q0 26 19 45t45 19h262l333 333q19 19 45 19t45 -19t19 -45zM1152 640q0 -76 -42.5 -141.5t-112.5 -93.5q-10 -5 -25 -5q-26 0 -45 18.5t-19 45.5q0 21 12 35.5t29 25t34 23t29 35.5 t12 57t-12 57t-29 35.5t-34 23t-29 25t-12 35.5q0 27 19 45.5t45 18.5q15 0 25 -5q70 -27 112.5 -93t42.5 -142zM1408 640q0 -153 -85 -282.5t-225 -188.5q-13 -5 -25 -5q-27 0 -46 19t-19 45q0 39 39 59q56 29 76 44q74 54 115.5 135.5t41.5 173.5t-41.5 173.5 t-115.5 135.5q-20 15 -76 44q-39 20 -39 59q0 26 19 45t45 19q13 0 26 -5q140 -59 225 -188.5t85 -282.5zM1664 640q0 -230 -127 -422.5t-338 -283.5q-13 -5 -26 -5q-26 0 -45 19t-19 45q0 36 39 59q7 4 22.5 10.5t22.5 10.5q46 25 82 51q123 91 192 227t69 289t-69 289 t-192 227q-36 26 -82 51q-7 4 -22.5 10.5t-22.5 10.5q-39 23 -39 59q0 26 19 45t45 19q13 0 26 -5q211 -91 338 -283.5t127 -422.5z",
            check: "M1408 606v-318q0 -119 -84.5 -203.5t-203.5 -84.5h-832q-119 0 -203.5 84.5t-84.5 203.5v832q0 119 84.5 203.5t203.5 84.5h832q63 0 117 -25q15 -7 18 -23q3 -17 -9 -29l-49 -49q-10 -10 -23 -10q-3 0 -9 2q-23 6 -45 6h-832q-66 0 -113 -47t-47 -113v-832 q0 -66 47 -113t113 -47h832q66 0 113 47t47 113v254q0 13 9 22l64 64q10 10 23 10q6 0 12 -3q20 -8 20 -29zM1639 1095l-814 -814q-24 -24 -57 -24t-57 24l-430 430q-24 24 -24 57t24 57l110 110q24 24 57 24t57 -24l263 -263l647 647q24 24 57 24t57 -24l110 -110 q24 -24 24 -57t-24 -57z",
            check_empty: "M1120 1280h-832q-66 0 -113 -47t-47 -113v-832q0 -66 47 -113t113 -47h832q66 0 113 47t47 113v832q0 66 -47 113t-113 47zM1408 1120v-832q0 -119 -84.5 -203.5t-203.5 -84.5h-832q-119 0 -203.5 84.5t-84.5 203.5v832q0 119 84.5 203.5t203.5 84.5h832 q119 0 203.5 -84.5t84.5 -203.5z",
            undo: "M1536 640q0 -156 -61 -298t-164 -245t-245 -164t-298 -61q-179 0 -336.5 76t-266 213t-147.5 312q-3 14 7 27q9 12 25 12h199q23 0 30 -23q50 -162 185 -261.5t304 -99.5q104 0 198.5 40.5t163.5 109.5t109.5 163.5t40.5 198.5t-40.5 198.5t-109.5 163.5t-163.5 109.5 t-198.5 40.5q-98 0 -188 -35.5t-160 -101.5l137 -138q31 -30 14 -69q-17 -40 -59 -40h-448q-26 0 -45 19t-19 45v448q0 42 40 59q39 17 69 -14l130 -129q107 101 244.5 156.5t284.5 55.5q156 0 298 -61t245 -164t164 -245t61 -298z",
            cut: "M960 640q26 0 45 -19t19 -45t-19 -45t-45 -19t-45 19t-19 45t19 45t45 19zM1260 576l507 -398q28 -20 25 -56q-5 -35 -35 -51l-128 -64q-13 -7 -29 -7q-17 0 -31 8l-690 387l-110 -66q-8 -4 -12 -5q14 -49 10 -97q-7 -77 -56 -147.5t-132 -123.5q-132 -84 -277 -84 q-136 0 -222 78q-90 84 -79 207q7 76 56 147t131 124q132 84 278 84q83 0 151 -31q9 13 22 22l122 73l-122 73q-13 9 -22 22q-68 -31 -151 -31q-146 0 -278 84q-82 53 -131 124t-56 147q-5 59 15.5 113t63.5 93q85 79 222 79q145 0 277 -84q83 -52 132 -123t56 -148 q4 -48 -10 -97q4 -1 12 -5l110 -66l690 387q14 8 31 8q16 0 29 -7l128 -64q30 -16 35 -51q3 -36 -25 -56zM579 836q46 42 21 108t-106 117q-92 59 -192 59q-74 0 -113 -36q-46 -42 -21 -108t106 -117q92 -59 192 -59q74 0 113 36zM494 91q81 51 106 117t-21 108 q-39 36 -113 36q-100 0 -192 -59q-81 -51 -106 -117t21 -108q39 -36 113 -36q100 0 192 59zM672 704l96 -58v11q0 36 33 56l14 8l-79 47l-26 -26q-3 -3 -10 -11t-12 -12q-2 -2 -4 -3.5t-3 -2.5zM896 480l96 -32l736 576l-128 64l-768 -431v-113l-160 -96l9 -8q2 -2 7 -6 q4 -4 11 -12t11 -12l26 -26zM1600 64l128 64l-520 408l-177 -138q-2 -3 -13 -7z",
            trash: "M512 800v-576q0 -14 -9 -23t-23 -9h-64q-14 0 -23 9t-9 23v576q0 14 9 23t23 9h64q14 0 23 -9t9 -23zM768 800v-576q0 -14 -9 -23t-23 -9h-64q-14 0 -23 9t-9 23v576q0 14 9 23t23 9h64q14 0 23 -9t9 -23zM1024 800v-576q0 -14 -9 -23t-23 -9h-64q-14 0 -23 9t-9 23v576 q0 14 9 23t23 9h64q14 0 23 -9t9 -23zM1152 76v948h-896v-948q0 -22 7 -40.5t14.5 -27t10.5 -8.5h832q3 0 10.5 8.5t14.5 27t7 40.5zM480 1152h448l-48 117q-7 9 -17 11h-317q-10 -2 -17 -11zM1408 1120v-64q0 -14 -9 -23t-23 -9h-96v-948q0 -83 -47 -143.5t-113 -60.5h-832 q-66 0 -113 58.5t-47 141.5v952h-96q-14 0 -23 9t-9 23v64q0 14 9 23t23 9h309l70 167q15 37 54 63t79 26h320q40 0 79 -26t54 -63l70 -167h309q14 0 23 -9t9 -23z",
            ban_circle: "M1280 640q0 139 -71 260l-701 -701q121 -71 260 -71q104 0 198.5 40.5t163.5 109.5t109.5 163.5t40.5 198.5zM327 380l701 701q-121 71 -260 71q-104 0 -198.5 -40.5t-163.5 -109.5t-109.5 -163.5t-40.5 -198.5q0 -139 71 -260zM1536 640q0 -209 -103 -385.5 t-279.5 -279.5t-385.5 -103t-385.5 103t-279.5 279.5t-103 385.5t103 385.5t279.5 279.5t385.5 103t385.5 -103t279.5 -279.5t103 -385.5z",
            times_circle: "M1149 414q0 26 -19 45l-181 181l181 181q19 19 19 45q0 27 -19 46l-90 90q-19 19 -46 19q-26 0 -45 -19l-181 -181l-181 181q-19 19 -45 19q-27 0 -46 -19l-90 -90q-19 -19 -19 -46q0 -26 19 -45l181 -181l-181 -181q-19 -19 -19 -45q0 -27 19 -46l90 -90q19 -19 46 -19 q26 0 45 19l181 181l181 -181q19 -19 45 -19q27 0 46 19l90 90q19 19 19 46zM1536 640q0 -209 -103 -385.5t-279.5 -279.5t-385.5 -103t-385.5 103t-279.5 279.5t-103 385.5t103 385.5t279.5 279.5t385.5 103t385.5 -103t279.5 -279.5t103 -385.5z"
          };
          
          // stripped the box out of the 'check'
          icons.check_without_box = 'M1639 1095l-814 -814q-24 -24 -57 -24t-57 24l-430 430q-24 24 -24 57t24 57l110 110q24 24 57 24t57 -24l263 -263l647 647q24 24 57 24t57 -24l110 -110 q24 -24 24 -57t-24 -57z';
        
          function FontAwesomeNode( iconName, options ) {
        
            // default values
            options = _.extend( {
              fill: "#000",
              //Font awesome nodes are expensive to pick (and have a lot of holes in them which you may wish to pick anyways, such as the door of the 'home' icon, so don't pick by default
              pickable: false
            }, options );
        
            // add internal values required by supertype constructor
            options = _.extend( options, {
              matrix: Matrix3.createFromPool( 0.025, 0, 0, 0, -0.025, 0, 0, 0, 1 )
            } );
        
            Path.call( this, new Shape( icons[iconName] ), options );
          }
        
          inherit( Path, FontAwesomeNode );
        
          return FontAwesomeNode;
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * A derived property the maps sticky toggle button model states to the values
         * needed by the button view.
         */
        define( 'SUN/buttons/ToggleButtonInteractionState',['require','PHET_CORE/inherit','AXON/DerivedProperty'],function( require ) {
          
        
          // Imports
          var inherit = require( 'PHET_CORE/inherit' );
          var DerivedProperty = require( 'AXON/DerivedProperty' );
        
          function ToggleButtonInteractionState( buttonModel ) {
            DerivedProperty.call(
              this,
              [ buttonModel.overProperty, buttonModel.downProperty, buttonModel.enabledProperty],
              function( over, down, enabled ) {
                return !enabled ? 'disabled' :
                       over && !(down ) ? 'over' :
                       down ? 'pressed' :
                       'idle';
              } );
          }
        
          return inherit( DerivedProperty, ToggleButtonInteractionState );
        } );
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Model for a toggle button that changes value on each "up" event when the button is released.
         *
         * @author Sam Reid
         * @author John Blanco
         */
        define( 'SUN/buttons/ToggleButtonModel',['require','PHET_CORE/inherit','SUN/buttons/ButtonModel'],function( require ) {
          
        
          // modules
          var inherit = require( 'PHET_CORE/inherit' );
          var ButtonModel = require( 'SUN/buttons/ButtonModel' );
        
          /**
           * @param valueA {Object} one possible value for the toggle
           * @param valueB {Object} the other value for the toggle
           * @param valueProperty {Property<Object>} axon property that can be either valueA or valueB.
           *        (Would have preferred to call this `property` but it would clash with the property function name.)
           * @constructor
           */
          function ToggleButtonModel( valueA, valueB, valueProperty ) {
            var thisModel = this;
        
            this.valueA = valueA;
            this.valueB = valueB;
            this.valueProperty = valueProperty;
        
            ButtonModel.call( this );
        
            // Behaves like a push button (with fireOnDown:false), but toggles its state when the button is released.
            this.property( 'down' ).link( function( down ) {
              if ( thisModel.enabled && thisModel.over ) {
                if ( !down ) {
                  thisModel.toggle();
                }
              }
            } );
          }
        
          return inherit( ButtonModel, ToggleButtonModel, {
            toggle: function() {
              assert && assert( this.valueProperty.value === this.valueA || this.valueProperty.value === this.valueB );
              if ( this.valueProperty.value === this.valueA ) {
                this.valueProperty.value = this.valueB;
              }
              else {
                this.valueProperty.value = this.valueA;
              }
            }
          } );
        } );
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * A rectangular toggle button that switches the value of a property that can take on valueA or valueB.
         *
         * @author John Blanco
         * @author Sam Reid
         */
        define( 'SUN/buttons/RectangularToggleButton',['require','PHET_CORE/inherit','SUN/buttons/RectangularButtonView','SUN/buttons/ToggleButtonInteractionState','SUN/buttons/ToggleButtonModel'],function( require ) {
          
        
          // modules
          var inherit = require( 'PHET_CORE/inherit' );
          var RectangularButtonView = require( 'SUN/buttons/RectangularButtonView' );
          var ToggleButtonInteractionState = require( 'SUN/buttons/ToggleButtonInteractionState' );
          var ToggleButtonModel = require( 'SUN/buttons/ToggleButtonModel' );
        
          /**
           * @param valueA {Object} one possible value for the toggle
           * @param valueB {Object} the other value for the toggle
           * @param property {Property<Object>} axon property that can be either valueA or valueB.
           * @param {*} options
           * @constructor
           */
          function RectangularToggleButton( valueA, valueB, property, options ) {
            var buttonModel = new ToggleButtonModel( valueA, valueB, property );
            RectangularButtonView.call( this, buttonModel, new ToggleButtonInteractionState( buttonModel ), options );
          }
        
          return inherit( RectangularButtonView, RectangularToggleButton );
        } );
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * This toggle button uses a boolean property and a trueNode and falseNode to display its content.
         */
        define( 'SUN/buttons/BooleanRectangularToggleButton',['require','PHET_CORE/inherit','SUN/buttons/RectangularToggleButton','SUN/ToggleNode'],function( require ) {
          
        
          // modules
          var inherit = require( 'PHET_CORE/inherit' );
          var RectangularToggleButton = require( 'SUN/buttons/RectangularToggleButton' );
          var ToggleNode = require( 'SUN/ToggleNode' );
        
          /**
           * @param trueNode
           * @param falseNode
           * @param booleanProperty
           * @param options
           * @constructor
           */
          function BooleanRectangularToggleButton( trueNode, falseNode, booleanProperty, options ) {
            RectangularToggleButton.call( this, false, true, booleanProperty, _.extend( { content: new ToggleNode( trueNode, falseNode, booleanProperty ) }, options ) );
          }
        
          return inherit( RectangularToggleButton, BooleanRectangularToggleButton );
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Button for toggling sound on and off.
         *
         * @author John Blanco
         * @author Chris Malley (PixelZoom, Inc.)
         * @author Sam Reid
         */
        define( 'SCENERY_PHET/SoundToggleButton',['require','SCENERY/util/Color','SUN/FontAwesomeNode','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Path','KITE/Shape','SUN/buttons/BooleanRectangularToggleButton'],function( require ) {
          
        
          // modules
          var Color = require( 'SCENERY/util/Color' );
          var FontAwesomeNode = require( 'SUN/FontAwesomeNode' );
          var inherit = require( 'PHET_CORE/inherit' );
          var Node = require( 'SCENERY/nodes/Node' );
          var Path = require( 'SCENERY/nodes/Path' );
          var Shape = require( 'KITE/Shape' );
          var BooleanRectangularToggleButtonWithContent = require( 'SUN/buttons/BooleanRectangularToggleButton' );
        
          // Constants
          var WIDTH = 45;
          var HEIGHT = 45;
          var MARGIN = 4;
          var X_WIDTH = WIDTH * 0.25; // Empirically determined.
        
          function SoundToggleButton( property, options ) {
            var soundOffNode = new Node();
            var soundOnNode = new FontAwesomeNode( 'volume_up' );
            var contentScale = ( WIDTH - ( 2 * MARGIN ) ) / soundOnNode.width;
            soundOnNode.scale( contentScale );
            soundOffNode.addChild( new FontAwesomeNode( 'volume_off', { scale: contentScale } ) );
            var soundOffX = new Path( new Shape().moveTo( 0, 0 ).lineTo( X_WIDTH, X_WIDTH ).moveTo( 0, X_WIDTH ).lineTo( X_WIDTH, 0 ),
              {
                stroke: 'black',
                lineWidth: 3,
                left: soundOffNode.width + 5,
                centerY: soundOffNode.centerY
              } );
            soundOffNode.addChild( soundOffX );
        
            BooleanRectangularToggleButtonWithContent.call( this, soundOnNode, soundOffNode, property, _.extend(
              {
                baseColor: new Color( 242, 233, 22 ),//Color match with the yellow in the PhET logo
                minWidth: WIDTH,
                minHeight: HEIGHT,
                xMargin: MARGIN,
                yMargin: MARGIN
              }, options ) );
          }
        
          return inherit( BooleanRectangularToggleButtonWithContent, SoundToggleButton );
        } );
        
        define("string!FORCES_AND_MOTION_BASICS/sumOfForces",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/sumOfForces");});
        
        
        define("string!FORCES_AND_MOTION_BASICS/values",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/values");});
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Basic button handling.
         *
         * Uses 4 states:
         * up: mouse not over, not pressed
         * over: mouse over, not pressed
         * down: mouse over, pressed
         * out: mouse not over, pressed
         *
         * TODO: offscreen handling
         * TODO: fix enter/exit edge cases for moving nodes or add/remove child, and when touches are created
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/input/ButtonListener',['require','SCENERY/scenery','SCENERY/util/Trail','PHET_CORE/inherit','SCENERY/input/DownUpListener'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          require( 'SCENERY/util/Trail' );
          var inherit = require( 'PHET_CORE/inherit' );
          
          var DownUpListener = require( 'SCENERY/input/DownUpListener' );
          
          /**
           * Options for the ButtonListener:
           *
           * mouseButton: 0
           * fireOnDown: false // default is to fire on 'up' after 'down', but passing fireOnDown: true will fire on 'down' instead
           * up: null          // Called on an 'up' state change, as up( event, oldState )
           * over: null        // Called on an 'over' state change, as over( event, oldState )
           * down: null        // Called on an 'down' state change, as down( event, oldState )
           * out: null         // Called on an 'out' state change, as out( event, oldState )
           * fire: null        // Called on a state change to/from 'down' (depending on fireOnDown), as fire( event ). Called after the triggering up/over/down event.
           */
          scenery.ButtonListener = function ButtonListener( options ) {
        
            this.buttonState = 'up'; // public: 'up', 'over', 'down' or 'out'
            
            this._overCount = 0; // how many pointers are over us (track a count, so we can handle multiple pointers gracefully)
            
            this._buttonOptions = options; // store the options object so we can call the callbacks
            
            var buttonListener = this;
            DownUpListener.call( this, {
        
              mouseButton: options.mouseButton || 0, // forward the mouse button, default to 0 (LMB)
              
              down: function( event, trail ) {
                buttonListener.setButtonState( event, 'down' );
              },
              
              up: function( event, trail ) {
                buttonListener.setButtonState( event, buttonListener._overCount > 0 ? 'over' : 'up' );
              }
            } );
          };
        
          var ButtonListener = scenery.ButtonListener;
          
          inherit( DownUpListener, ButtonListener, {
        
            setButtonState: function( event, state ) {
              if ( state !== this.buttonState ) {
                sceneryEventLog && sceneryEventLog( 'ButtonListener state change to ' + state + ' from ' + this.buttonState + ' for ' + ( this.downTrail ? this.downTrail.toString() : this.downTrail ) );
                var oldState = this.buttonState;
                
                this.buttonState = state;
                
                if ( this._buttonOptions[state] ) {
                  this._buttonOptions[state]( event, oldState );
                }
                
                if ( this._buttonOptions.fire &&
                     this._overCount > 0 &&
                     ( this._buttonOptions.fireOnDown ? ( state === 'down' ) : ( oldState === 'down' ) ) ) {
                  this._buttonOptions.fire( event );
                }
              }
            },
            
            enter: function( event ) {
              sceneryEventLog && sceneryEventLog( 'ButtonListener enter for ' + ( this.downTrail ? this.downTrail.toString() : this.downTrail ) );
              this._overCount++;
              if ( this._overCount === 1 ) {
                this.setButtonState( event, this.isDown ? 'down' : 'over' );
              }
            },
        
            exit: function( event ) {
              sceneryEventLog && sceneryEventLog( 'ButtonListener exit for ' + ( this.downTrail ? this.downTrail.toString() : this.downTrail ) );
              assert && assert( this._overCount > 0, 'Exit events not matched by an enter' );
              this._overCount--;
              if ( this._overCount === 0 ) {
                this.setButtonState( event, this.isDown ? 'out' : 'up' );
              }
            }
          } );
        
          //TODO delete this after work is completed on sun.Button and scenery.ButtonListener
          ButtonListener.TEST_LISTENER = new ButtonListener( {
        
            up: function( event, oldState ) {
              console.log( "ButtonListener.up oldState=" + oldState );
            },
        
            over: function( event, oldState ) {
              console.log( "ButtonListener.over oldState=" + oldState );
            },
        
            down: function( event, oldState ) {
              console.log( "ButtonListener.down oldState=" + oldState );
            },
        
            out: function( event, oldState ) {
              console.log( "ButtonListener.out oldState=" + oldState );
            },
        
            fire: function( event ) {
              console.log( "ButtonListener.fire" );
            }
          } );
        
          return ButtonListener;
        } );
        
        
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Check box.
         *
         * @author Chris Malley (PixelZoom, Inc.)
         */
        define( 'SUN/CheckBox',['require','SCENERY/input/ButtonListener','SUN/FontAwesomeNode','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','SCENERY/nodes/Text'],function( require ) {
          
        
          // modules
          var ButtonListener = require( 'SCENERY/input/ButtonListener' );
          var FontAwesomeNode = require( 'SUN/FontAwesomeNode' );
          var inherit = require( 'PHET_CORE/inherit' );
          var Node = require( 'SCENERY/nodes/Node' );
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
          var Text = require( 'SCENERY/nodes/Text' );
        
          /**
           * @param {Node} content
           * @param {Property<Boolean>} property
           * @constructor
           * @param options
           */
          function CheckBox( content, property, options ) {
            var checkBox = this;
            options = _.extend( {
              spacing: 5,
              boxWidth: 21,
              cursor: 'pointer',
              checkBoxColor: 'black',
              checkBoxColorDisabled: 'gray'
            }, options );
        
            var thisNode = this;
            Node.call( this );
        
            // save this stuff for use in prototype functions
            thisNode.options = options; // @private
            thisNode.content = content; // @private
            thisNode._enabled = true; // @private
        
            // Make the background white.  Until we are creating our own shapes, just
            // put a white rectangle behind the font awesome check box icons.
            var whiteBackground = new Rectangle( 0, -options.boxWidth, options.boxWidth * 0.95, options.boxWidth * 0.95,
              options.boxWidth * 0.2, options.boxWidth * 0.2, {fill: 'white'} );
        
            thisNode.uncheckedNode = new FontAwesomeNode( 'check_empty', { fill: options.checkBoxColor } ); // @private
            var iconScale = options.boxWidth / thisNode.uncheckedNode.width;
            thisNode.uncheckedNode.scale( iconScale );
            thisNode.checkedNode = new FontAwesomeNode( 'check', { scale: iconScale, fill: options.checkBoxColor } ); // @private
        
            thisNode.addChild( whiteBackground );
            thisNode.addChild( thisNode.checkedNode );
            thisNode.addChild( thisNode.uncheckedNode );
            thisNode.addChild( content );
        
            content.left = thisNode.checkedNode.right + options.spacing;
            content.centerY = thisNode.checkedNode.centerY;
        
            // put a rectangle on top of everything to prevent dead zones when clicking
            thisNode.addChild( new Rectangle( thisNode.left, thisNode.top, thisNode.width, thisNode.height ) );
        
            content.pickable = false; // since there's a pickable rectangle on top of content
        
            // interactivity
            thisNode.addInputListener( new ButtonListener( {
              fire: function() {
                if ( thisNode._enabled ) {
                  property.value = !property.value;
                }
              }
            } ) );
        
            // sync with property
            property.link( function( checked ) {
              thisNode.checkedNode.visible = checked;
              thisNode.uncheckedNode.visible = !checked;
            } );
        
            //Add accessibility
            thisNode.addPeer( '<input type="checkbox">', {click: function() {property.value = !property.value;}, label: options.label} );
            property.link( function( value ) {
              _.each( checkBox.instances, function( instance ) {
        
                //Make sure accessibility is enabled, then apply the change to the peer
                _.each( instance.peers, function( peer ) {
                  peer.element.setAttribute( 'checked', value );
                } );
              } );
            } );
        
            // Apply additional options
            thisNode.mutate( options );
          }
        
          return inherit( Node, CheckBox, {
        
            // prototype properties
        
            get enabled() { return this._enabled; },
        
            set enabled( value ) {
        
              this._enabled = value;
              this.pickable = value;
        
              // set the color of the check box icons
              this.checkedNode.fill = value ? this.options.checkBoxColor : this.options.checkBoxColorDisabled;
              this.uncheckedNode.fill = this.checkedNode.fill;
        
              // enable/disable the content, if it supports it
              if ( this.content.setEnabled ) {
                this.content.setEnabled( value );
              }
            }
        
          }, {
        
            // static properties
        
            /**
             * Factory method, creates a check box with a text label and optional icon.
             * @param {String} text
             * @param {*} textOptions options that apply to the text, same as scenery.Text
             * @param {Property<Boolean>} property
             * @returns {CheckBox}
             */
            createTextCheckBox: function( text, textOptions, property, checkBoxOptions ) {
        
              textOptions = _.extend( {
                fill: 'black',
                fillDisabled: 'rgb(220,220,220)'
              }, textOptions );
        
              checkBoxOptions = _.extend( {
                icon: null,  // an optional node, added to the right of the text
                iconSpacing: 15
              }, checkBoxOptions );
        
              var content = new Node();
        
              // text
              var textNode = new Text( text, textOptions );
              content.addChild( textNode );
        
              // options icon
              if ( checkBoxOptions.icon ) {
                content.addChild( checkBoxOptions.icon );
                //TODO support different layouts of text and image?
                checkBoxOptions.icon.left = textNode.right + checkBoxOptions.iconSpacing;
                checkBoxOptions.icon.centerY = textNode.centerY;
              }
        
              content.setEnabled = function( enabled ) {
                textNode.fill = enabled ? textOptions.fill : textOptions.fillDisabled;
        
                // if the check box has an icon...
                if ( checkBoxOptions.icon ) {
                  if ( checkBoxOptions.icon.setEnabled ) {
                    // use setEnabled if provided by icon
                    checkBoxOptions.icon.setEnabled( enabled );
                  }
                  else {
                    // fallback to using opacity
                    checkBoxOptions.icon.opacity = enabled ? 1 : 0.3;
                  }
                }
              };
        
              return new CheckBox( content, property, checkBoxOptions );
            }
          } );
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * VBox arranges the child nodes vertically, and they can be centered, left or right justified.
         * Vertical spacing can be set as a constant or a function which depends on the adjacent nodes.
         *
         * See a dynamic test in scenery\tests\test-vbox.html
         *
         * @author Sam Reid
         */
        
        define( 'SCENERY/nodes/VBox',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/AbstractBox'],function( require ) {
          
        
          var inherit = require( 'PHET_CORE/inherit' );
          var scenery = require( 'SCENERY/scenery' );
          var AbstractBox = require( 'SCENERY/nodes/AbstractBox' );
        
          /**
           *
           * @param options Same as Node.constructor.options with the following additions:
           *
           * spacing: can be a number or a function.  If a number, then it will be the vertical spacing between each object.
           *              If a function, then the function will have the signature function(top,bottom){} which returns the spacing between adjacent pairs of items.
           * align:   How to line up the items horizontally.  One of 'center', 'left' or 'right'.  Defaults to 'center'.
           *
           * @constructor
           */
          scenery.VBox = function VBox( options ) {
            AbstractBox.call( this, 'vertical', function() {
              var minX = _.min( _.map( this.children, function( child ) {return child.left;} ) );
              var maxX = _.max( _.map( this.children, function( child ) {return child.left + child.width;} ) );
              var centerX = (maxX + minX) / 2;
        
              //Start at y=0 in the coordinate frame of this node.  Not possible to set this through the spacing option, instead just set it with the {y:number} option.
              var y = 0;
              for ( var i = 0; i < this.children.length; i++ ) {
                var child = this.children[i];
                child.top = y;
        
                //Set the position horizontally
                if ( this.options.align === 'left' ) {
                  child.left = minX;
                }
                else if ( this.options.align === 'right' ) {
                  child.right = maxX;
                }
                else {//default to center
                  child.centerX = centerX;
                }
        
                //Move to the next vertical position.
                y += child.height + this.options.spacing( child, this.children[i + 1] );
              }
            }, options );
          };
        
          return inherit( AbstractBox, scenery.VBox );
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * A vertical group of check boxes.
         *
         * @author Sam Reid
         */
        //TODO: not ready for use in simulations, it will need further development & discussion first.
        define( 'SUN/VerticalCheckBoxGroup',['require','SCENERY/nodes/Path','SUN/CheckBox','SCENERY/nodes/VBox','SCENERY/nodes/HBox','SCENERY/nodes/Rectangle','KITE/Shape','PHET_CORE/inherit'],function( require ) {
          
        
          var Path = require( 'SCENERY/nodes/Path' );
          var CheckBox = require( 'SUN/CheckBox' );
          var VBox = require( 'SCENERY/nodes/VBox' );
          var HBox = require( 'SCENERY/nodes/HBox' );
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
          var Shape = require( 'KITE/Shape' );
          var inherit = require( 'PHET_CORE/inherit' );
        
          /**
           * Main constructor.
           *
           * @param items  an array of {content, property, indent}
           * @param options
           * @constructor
           */
          function VerticalCheckBoxGroup( items, options ) {
        
            options = _.extend( {
              spacing: 10, // vertical spacing
              padding: 8, //TODO what is this? It looks like it's added to the right of the check box. Shouldn't this be an x-margin, added to left and right?
              checkBoxColor: 'black',
              align: 'left',
              boxWidth: 21
            }, options );
        
            // compute max width of the items
            var maxWidth = 0;
            for ( var i = 0; i < items.length; i++ ) {
              maxWidth = Math.max( maxWidth, items[i].content.width );
            }
        
            // process each item
            var children = [];
            for ( i = 0; i < items.length; i++ ) {
              var offset = items[i].indent || 0;
              //Attach each item to an invisible strut to make the widths match.
              var content = new Path( Shape.rect( 0, 0, maxWidth + options.padding - offset, 0 ), { children: [items[i].content] } );
              var checkBox = new CheckBox( content, items[i].property, {label: items[i].label, checkBoxColor: options.checkBoxColor, boxWidth: options.boxWidth} );
              checkBox.mouseArea = checkBox.touchArea = Shape.bounds( checkBox.bounds.dilatedXY( 5, options.spacing / 2 ) );
              if ( items[i].indent ) {
                children.push( new HBox( {children: [ new Rectangle( 0, 0, items[i].indent, 1 ), checkBox ]} ) );
              }
              else {
                children.push( new HBox( {children: [checkBox]} ) );
              }
            }
        
            options.children = children; //TODO bad form, if options.children was already set, then this will blow it away
            VBox.call( this, options );
          }
        
          return inherit( VBox, VerticalCheckBoxGroup );
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Control panel around a content node.
         * Dynamically adjusts its size to fit its contents.
         *
         * @author Sam Reid
         * @author Chris Malley (PixelZoom, Inc.)
         */
        define( 'SUN/Panel',['require','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Rectangle'],function( require ) {
          
        
          // modules
          var inherit = require( 'PHET_CORE/inherit' );
          var Node = require( 'SCENERY/nodes/Node' );
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
        
          /**
           * @param {Node} content
           * @param {object} options
           * @constructor
           */
          function Panel( content, options ) {
        
            var thisNode = this;
        
            // default options
            options = _.extend( {
              fill: 'white',
              stroke: 'black',
              lineWidth: 1, // width of the background border
              xMargin: 5,
              yMargin: 5,
              cornerRadius: 10, // radius of the rounded corners on the background
              resize: true, // dynamically resize when content bounds change
              backgroundPickable: false
            }, options );
        
            Node.call( thisNode );
        
            // correct size will be set by updateBackground
            var background = new Rectangle( 0, 0, 1, 1, {stroke: options.stroke, lineWidth: options.lineWidth, fill: options.fill, pickable: options.backgroundPickable, lineDash: options.lineDash} );
            this.background = background;
            this.addChild( background );
            this.addChild( content );
        
            // Adjust the background size to match the content.
            var updateBackground = function() {
              background.setRect( 0, 0, content.width + ( 2 * options.xMargin ), content.height + ( 2 * options.yMargin ), options.cornerRadius, options.cornerRadius );
        
              // Prevent oscillation and stack overflow due to numerical imprecision, see https://github.com/phetsims/sun/issues/110
              if ( background.center.distanceSquared( content.center ) > 1E-6 ) {
                content.center = background.center;
              }
            };
            if ( options.resize ) {
              content.addEventListener( 'bounds', function() {
                updateBackground();
              } );
            }
            updateBackground();
        
            // Apply options after the layout is done, so that options that use the bounds will work properly.
            this.mutate( options );
          }
        
          inherit( Node, Panel, {
        
            //Setters for the background rectangle stroke
            set stroke( s ) { this.background.stroke = s; },
        
            //Getter for the background rectangle stroke
            get stroke() {return this.background.stroke;}
          } );
        
          return Panel;
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Control panel with options to show sum of forces and values, and also buttons below the control panel for reset all and sound.
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/tugofwar/view/TugOfWarControlPanel',['require','SCENERY/nodes/HBox','SCENERY/nodes/Node','SCENERY/nodes/Text','SCENERY_PHET/ResetAllButton','SCENERY_PHET/SoundToggleButton','PHET_CORE/inherit','string!FORCES_AND_MOTION_BASICS/sumOfForces','string!FORCES_AND_MOTION_BASICS/values','SUN/VerticalCheckBoxGroup','SUN/Panel','SCENERY_PHET/PhetFont'],function( require ) {
          
        
          var HBox = require( 'SCENERY/nodes/HBox' );
          var Node = require( 'SCENERY/nodes/Node' );
          var Text = require( 'SCENERY/nodes/Text' );
          var ResetAllButton = require( 'SCENERY_PHET/ResetAllButton' );
          var SoundToggleButton = require( 'SCENERY_PHET/SoundToggleButton' );
          var inherit = require( 'PHET_CORE/inherit' );
          var sumOfForcesString = require( 'string!FORCES_AND_MOTION_BASICS/sumOfForces' );
          var valuesString = require( 'string!FORCES_AND_MOTION_BASICS/values' );
          var VerticalCheckBoxGroup = require( 'SUN/VerticalCheckBoxGroup' );
          var Panel = require( 'SUN/Panel' );
          var PhetFont = require( 'SCENERY_PHET/PhetFont' );
        
          /**
           * Create the TugOfWarControlPanel.
           * @param {TugOfWarModel} model the model for this control panel
           * @param {Object} options
           * @constructor
           */
          function TugOfWarControlPanel( model, options ) {
            options = _.extend( {}, options );
            Node.call( this, options );
        
            var fontOptions = {font: new PhetFont( 18 )};
            var controlPanel = new VerticalCheckBoxGroup( [
              {content: new Text( sumOfForcesString, fontOptions ), property: model.showSumOfForcesProperty, label: sumOfForcesString},
              {content: new Text( valuesString, fontOptions ), property: model.showValuesProperty, label: valuesString}
            ] );
            this.addChild( new Panel( controlPanel, {xMargin: 10, yMargin: 10, fill: '#e3e980'} ) );
        
            //Create sound and reset buttons, and size them to be the same height.  They appear below the top panel
            var resetButton = new ResetAllButton( { listener: model.reset.bind( model ), scale: 1.13 } );
            var soundButton = new SoundToggleButton( model.volumeOnProperty, { padX: 19, padY: 19 } );
            this.addChild( new HBox( {spacing: 5, children: [ resetButton, soundButton ]} ).mutate( {centerX: controlPanel.centerX, top: controlPanel.bottom + 15} ) );
          }
        
          return inherit( Node, TugOfWarControlPanel );
        } );
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        //This function was taken from chipper/grunt/Gruntfile.js.  It is for converting a resource (like an image or audio file) to base64
        define( '../../chipper/requirejs-plugins/loadFileAsDataURI',[],function() {
        
          return function( filename ) {
            var mimeType = {
              'png': 'image/png',
              'svg': 'image/svg+xml',
              'jpg': 'image/jpeg',
              'gif': 'image/gif',
              'cur': 'image/x-icon', // cursor files (used in build-a-molecule). x-win-bitmap gives off warnings in Chrome
              'mp3': 'audio/mpeg',
              'm4a': 'audio/mp4',
              'ogg': 'audio/ogg',
              'oga': 'audio/ogg',
              'bma': 'audio/webm', // webma is the full extension
              'wav': 'audio/wav'
            }[filename.slice( -3 )];
        
            //TODO: use asserts at build time
            if ( !mimeType ) {
              throw new Error( 'Unknown mime type for filename: ' + filename );
            }
        
            var base64 = 'data:' + mimeType + ';base64,' + Buffer( fs.readFileSync( filename ) ).toString( 'base64' );
            return base64;
          };
        } );
        define('image',{load: function(id){throw new Error("Dynamic load not allowed: " + id);}});
        
        define("image!FORCES_AND_MOTION_BASICS/grass.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/rope.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/cart.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * The view portion of a Screen.
         * Specifies the layout strategy.
         * TODO: should extend this to be compatible with the Sim.js framework.
         *
         * @author Sam Reid
         */
        define( 'JOIST/ScreenView',['require','SCENERY/nodes/Node','PHET_CORE/inherit','DOT/Bounds2'],function( require ) {
          
        
          var Node = require( 'SCENERY/nodes/Node' );
          var inherit = require( 'PHET_CORE/inherit' );
          var Bounds2 = require( 'DOT/Bounds2' );
        
          //Default to width and height for iPad2, iPad3, iPad4 running Safari with default tabs and decorations
          //Simulations can change this to provide their own sizes or aspect ratios
          //TODO: the code that uses these bounds needs to account for the minX and minY values if they are overriden in subclasses
          //See https://github.com/phetsims/joist/issues/126
          var DEFAULT_LAYOUT_BOUNDS = new Bounds2( 0, 0, 768, 504 );
        
          function ScreenView( options ) {
        
            options = _.extend( {
               layoutBounds: DEFAULT_LAYOUT_BOUNDS.copy()
            }, options );
            this.layoutBounds = options.layoutBounds;
        
            Node.call( this, _.extend( {
              layerSplit: true // so we're not in the same layer as the navbar, etc.
            }, options ) );
          }
        
          inherit( Node, ScreenView, {
        
              //Get the scale to use for laying out the sim components and the navigation bar, so its size will track with the sim size
              getLayoutScale: function( width, height ) {
                return Math.min( width / this.layoutBounds.width, height / this.layoutBounds.height );
              },
        
              //Default layout function uses the layoutWidth and layoutHeight to scale the content (based on whichever is more limiting: width or height)
              //and centers the content in the screen vertically and horizontally
              //This function can be replaced by subclasses that wish to perform their own custom layout.
              layout: function( width, height ) {
                this.resetTransform();
        
                var scale = this.getLayoutScale( width, height );
                this.setScaleMagnitude( scale );
        
                //center vertically
                if ( scale === width / this.layoutBounds.width ) {
                  this.translate( 0, (height - this.layoutBounds.height * scale) / 2 / scale );
                }
        
                //center horizontally
                else if ( scale === height / this.layoutBounds.height ) {
                  this.translate( (width - this.layoutBounds.width * scale) / 2 / scale, 0 );
                }
              }
            },
        
            //statics
            {
              DEFAULT_LAYOUT_BOUNDS: DEFAULT_LAYOUT_BOUNDS,
        
              //The bounds are actually wider now.  See #126
              UPDATED_LAYOUT_BOUNDS: new Bounds2( 0, 0, 834, 504 )
            }
          );
        
          return ScreenView;
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * An arrow shape, either single or double headed.
         *
         * @author John Blanco
         * @author Chris Malley
         */
        define( 'SCENERY_PHET/ArrowShape',['require','PHET_CORE/inherit','KITE/Shape','DOT/Vector2'],function( require ) {
          
        
          // modules
          var inherit = require( 'PHET_CORE/inherit' );
          var Shape = require( 'KITE/Shape' );
          var Vector2 = require( 'DOT/Vector2' );
        
          function ArrowShape( tailX, tailY, tipX, tipY, options ) {
        
            options = _.extend( {
              tailWidth: 5,
              headWidth: 10,
              headHeight: 10,
              doubleHead: false
            }, options );
        
            var thisShape = this;
            Shape.call( thisShape );
        
            if ( tipX !== tailX || tipY !== tailY ) {
        
              var vector = new Vector2( tipX - tailX, tipY - tailY );
              var xHatUnit = vector.normalized();
              var yHatUnit = xHatUnit.rotated( Math.PI / 2 );
              var length = vector.magnitude();
        
              // limit head height
              options.headHeight = Math.min( options.headHeight, options.doubleHead ? 0.35 * length : 0.99 * length );
        
              // Set up a coordinate frame that goes from the tail of the arrow to the tip.
              var getPoint = function( xHat, yHat ) {
                var x = xHatUnit.x * xHat + yHatUnit.x * yHat + tailX;
                var y = xHatUnit.y * xHat + yHatUnit.y * yHat + tailY;
                return new Vector2( x, y );
              };
        
              // Compute points for single- or double-headed arrow
              var points = [];
              if ( options.doubleHead ) {
                points.push( getPoint( 0, 0 ) );
                points.push( getPoint( options.headHeight, options.headWidth / 2 ) );
                points.push( getPoint( options.headHeight, options.tailWidth / 2 ) );
              }
              else {
                points.push( getPoint( 0, options.tailWidth / 2 ) );
              }
              points.push( getPoint( length - options.headHeight, options.tailWidth / 2 ) );
              points.push( getPoint( length - options.headHeight, options.headWidth / 2 ) );
              points.push( getPoint( length, 0 ) );
              points.push( getPoint( length - options.headHeight, -options.headWidth / 2 ) );
              points.push( getPoint( length - options.headHeight, -options.tailWidth / 2 ) );
              if ( options.doubleHead ) {
                points.push( getPoint( options.headHeight, -options.tailWidth / 2 ) );
                points.push( getPoint( options.headHeight, -options.headWidth / 2 ) );
              }
              else {
                points.push( getPoint( 0, -options.tailWidth / 2 ) );
              }
        
              // Describe the shape
              thisShape.moveTo( points[0].x, points[0].y );
              var tail = _.tail( points );
              _.each( tail, function( element ) {
                thisShape.lineTo( element.x, element.y );
              } );
              thisShape.close();
            }
          }
        
          return inherit( Shape, ArrowShape );
        } );
        
        
        define("string!FORCES_AND_MOTION_BASICS/forceReadout.pattern",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/forceReadout.pattern");});
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Collection of utility functions related to Strings.
         */
        define( 'PHETCOMMON/util/StringUtils',[],function() {
          
        
          function StringUtils() {
          }
        
          /**
           * http://mobzish.blogspot.com/2008/10/simple-messageformat-for-javascript.html
           * Similar to Java's MessageFormat, supports simple substitution, simple substitution only.
           * The full MessageFormat specification allows conditional formatting, for example to support pluralisation.
           * <p>
           * Eg, StringUtils.format( '{0} + {1}', 2, 3 ) -> '2 + 3'
           *
           * @param {String} pattern pattern string, with N placeholders, where N is an integer
           * @return {String}
           */
          StringUtils.format = function( pattern ) {
            var args = arguments;
            return pattern.replace( /{(\d)}/g, function( r, n ) { return args[+n + 1];} );
          };
        
          return StringUtils;
        } );
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Arrow that displays a numerical value inside the arrow (if there is room) or above the arrow.
         * Used for force arrows in Forces and Motion: Basics
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/common/view/ReadoutArrow',['require','SCENERY/nodes/Path','SCENERY/nodes/Text','SCENERY/nodes/Node','SCENERY_PHET/ArrowShape','PHET_CORE/inherit','SCENERY_PHET/PhetFont','string!FORCES_AND_MOTION_BASICS/forceReadout.pattern','PHETCOMMON/util/StringUtils'],function( require ) {
          
        
          var Path = require( 'SCENERY/nodes/Path' );
          var Text = require( 'SCENERY/nodes/Text' );
          var Node = require( 'SCENERY/nodes/Node' );
          var ArrowShape = require( 'SCENERY_PHET/ArrowShape' );
          var inherit = require( 'PHET_CORE/inherit' );
          var PhetFont = require( 'SCENERY_PHET/PhetFont' );
          var forceReadoutPattern = require( 'string!FORCES_AND_MOTION_BASICS/forceReadout.pattern' );
          var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
        
          /**
           * Main constructor for ReadoutArrow, a scenery.Node that shows arrows with readouts.
           *
           * @param label the text to show for the arrow
           * @param fill the color of the arrow
           * @param tailX {Number} the location of the tail in X
           * @param tailY {Number} the location of the tail in Y
           * @param valueProperty {Property<Number>} the property for the value to display
           * @param showValuesProperty {Property<Boolean>} whether or not to display the values
           * @param options 'labelPosition' where the label text should be {side|top}
           * @constructor
           */
          function ReadoutArrow( label, fill, tailX, tailY, valueProperty, showValuesProperty, options ) {
            var readoutArrow = this;
        
            //Store fields
            this.options = _.extend( {labelPosition: 'top', arrowScale: 1}, options );
            this.showValuesProperty = showValuesProperty;
            this.tailX = tailX;
            this.tailY = tailY;
        
            //Call the super class.  Render in svg to make the text crisper on retina display.
            Node.call( this, {pickable: false} );
        
            //Create and add the children
            this.arrowNode = new Path( null, _.extend( {fill: fill, stroke: '#000000', lineWidth: 1}, options ) );
            var fontOptions = {font: new PhetFont( { size: 16, weight: 'bold' } )};
            this.valueNode = new Text( '110N', fontOptions );
            this.labelNode = new Text( label, fontOptions );
            this.addChild( this.arrowNode );
            this.addChild( this.valueNode );
            this.addChild( this.labelNode );
        
            //Update when the value changes
            valueProperty.link( function( value ) {
              readoutArrow.value = value;
              readoutArrow.valueNode.text = StringUtils.format( forceReadoutPattern, Math.abs( Math.round( value ) ).toFixed( 0 ) );
              readoutArrow.update();
            } );
        
            //Update when the numeric readout visibility is toggled
            showValuesProperty.link( this.update.bind( this ) );
          }
        
          return inherit( Node, ReadoutArrow, {
        
            //Sets the arrow dash, which changes when the simulation starts playing
            setArrowDash: function( lineDash ) { this.arrowNode.lineDash = lineDash; },
        
            //On the motion screens, when the 'Friction' label overlaps the force vector it should be displaced vertically
            set labelPosition( position ) {
              if ( this.options.labelPosition !== position ) {
                this.options.labelPosition = position;
                this.update();
              }
            },
        
            //Get the label position
            get labelPosition() { return this.options.labelPosition; },
        
            //Update the arrow graphics and text labels
            update: function() {
              var value = this.value * this.options.arrowScale;
        
              //Don't show it if it is too small
              var hidden = Math.abs( value ) < 1E-6;
              this.hidden = hidden;
              this.arrowNode.visible = !hidden;
              this.valueNode.visible = !hidden && this.showValuesProperty.value;
              this.labelNode.visible = !hidden;
        
              //Only change the node if visible, for performance
              if ( !hidden ) {
                var tailX = this.tailX;
                var tailY = this.tailY;
                var tailWidth = 25;
                var headWidth = 50;
        
                //For short arrows, the head height should be half of the arrow length.  See https://github.com/phetsims/scenery-phet/issues/30
                var headHeight = Math.min( Math.abs( value ) / 2, 40 );
                this.arrowNode.shape = new ArrowShape( tailX, tailY, tailX + value, tailY,
                  { tailWidth: tailWidth, headWidth: headWidth, headHeight: headHeight } );
        
                //Position the value and label if the label position is on the side
                if ( this.options.labelPosition === 'side' ) {
                  if ( value > 0 ) {
                    this.labelNode.left = this.arrowNode.right + 5;
                  }
                  else {
                    this.labelNode.right = this.arrowNode.left - 5;
                  }
                  this.labelNode.centerY = this.arrowNode.centerY;
        
                  this.valueNode.center = this.arrowNode.center;
        
                  if ( this.valueNode.width + 5 > this.arrowNode.width ) {
                    this.valueNode.top = this.labelNode.bottom;
                    this.valueNode.centerX = this.labelNode.centerX;
                  }
                }
                else {
                  this.valueNode.center = this.arrowNode.center;
                  this.labelNode.centerX = this.arrowNode.centerX;
        
                  //Position the value and label if the label position is on the bottom
                  if ( this.options.labelPosition === 'bottom' ) {
                    this.labelNode.top = isFinite( this.arrowNode.centerY ) ? this.arrowNode.centerY + headHeight / 2 + this.labelNode.height + 5 : 0;
                    if ( this.valueNode.width + 5 > this.arrowNode.width ) {
                      this.valueNode.bottom = this.labelNode.top;
                    }
                  }
        
                  //Position the value and label if the label position is on the top
                  else {
                    this.labelNode.bottom = isFinite( this.arrowNode.centerY ) ? this.arrowNode.centerY - headHeight / 2 - this.labelNode.height + 12 : 0;
                    if ( this.valueNode.width + 5 > this.arrowNode.width ) {
                      this.valueNode.top = this.labelNode.bottom;
                    }
                  }
                }
              }
            }
          } );
        } );
        
        
        define("string!FORCES_AND_MOTION_BASICS/leftForce",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/leftForce");});
        
        
        define("string!FORCES_AND_MOTION_BASICS/rightForce",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/rightForce");});
        
        
        define("string!FORCES_AND_MOTION_BASICS/sumOfForcesEqualsZero",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/sumOfForcesEqualsZero");});
        
        /**
         * A version of the base-64-binary library that has been wrapped in a define
         * statement for compatibility with requirejs.  See
         * https://github.com/danguer/blog-examples/blob/master/js/base64-binary.js
         *
         * TODO: I (jblanco) don't think that this is licensed such that PhET can just
         * use it.  Its use is temporary while exploring ways to handle the audio.
         */
        
        /*
         Copyright (c) 2011, Daniel Guerrero
         All rights reserved.
        
         Redistribution and use in source and binary forms, with or without
         modification, are permitted provided that the following conditions are met:
         * Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
         * Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
         documentation and/or other materials provided with the distribution.
        
         THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
         ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
         WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
         DISCLAIMED. IN NO EVENT SHALL DANIEL GUERRERO BE LIABLE FOR ANY
         DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
         (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
         LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
         ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
         (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
         SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
         */
        
        /**
         * Uses the new array typed in javascript to binary base64 encode/decode
         * at the moment just decodes a binary base64 encoded
         * into either an ArrayBuffer (decodeArrayBuffer)
         * or into an Uint8Array (decode)
         *
         * References:
         * https://developer.mozilla.org/en/JavaScript_typed_arrays/ArrayBuffer
         * https://developer.mozilla.org/en/JavaScript_typed_arrays/Uint8Array
         */
        
        define( 'SHERPA/base64binary',['require'],function( require ) {
          
          var base64Binary = {
            _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        
            /* will return a  Uint8Array type */
            decodeArrayBuffer: function( input ) {
              var bytes = (input.length / 4) * 3;
              var ab = new ArrayBuffer( bytes );
              this.decode( input, ab );
        
              return ab;
            },
        
            decode: function( input, arrayBuffer ) {
              //get last chars to see if are valid
              var lkey1 = this._keyStr.indexOf( input.charAt( input.length - 1 ) );
              var lkey2 = this._keyStr.indexOf( input.charAt( input.length - 2 ) );
        
              var bytes = (input.length / 4) * 3;
              if ( lkey1 == 64 ) {
                bytes--;
              } //padding chars, so skip
              if ( lkey2 == 64 ) {
                bytes--;
              } //padding chars, so skip
        
              var uarray;
              var chr1, chr2, chr3;
              var enc1, enc2, enc3, enc4;
              var i = 0;
              var j = 0;
        
              if ( arrayBuffer ) {
                uarray = new Uint8Array( arrayBuffer );
              }
              else {
                uarray = new Uint8Array( bytes );
              }
        
              input = input.replace( /[^A-Za-z0-9\+\/\=]/g, "" );
        
              for ( i = 0; i < bytes; i += 3 ) {
                //get the 3 octects in 4 ascii chars
                enc1 = this._keyStr.indexOf( input.charAt( j++ ) );
                enc2 = this._keyStr.indexOf( input.charAt( j++ ) );
                enc3 = this._keyStr.indexOf( input.charAt( j++ ) );
                enc4 = this._keyStr.indexOf( input.charAt( j++ ) );
        
                chr1 = (enc1 << 2) | (enc2 >> 4);
                chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                chr3 = ((enc3 & 3) << 6) | enc4;
        
                uarray[i] = chr1;
                if ( enc3 != 64 ) {
                  uarray[i + 1] = chr2;
                }
                if ( enc4 != 64 ) {
                  uarray[i + 2] = chr3;
                }
              }
        
              return uarray;
            }
          };
        
          return base64Binary;
        
        } );
        
        define('audio',{load: function(id){throw new Error("Dynamic load not allowed: " + id);}});
        
        define("audio!VIBE/empty.mp3", function(){ return [{base64:'data:audio/mpeg;base64,//s0wAAAAAABLgAAACAAACXAAAAE//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////s0wD2AAAABLgAAACAAACXAAAAE//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AAAAAAAAAAAAAAAAAAAAAAAAA//s0wHsAAAABLgAAACAAACXAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//s0wLiAAAABLgAAACAAACXAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//s0wPYADQABLgAAACAAACXAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//s0wP+AD2ABLgAAACAAACXAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'}
        ];});
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Type for loading and playing sounds, works on multiple platforms and
         * supports embedded base64 data.  This uses Web Audio when available,
         * primarily because the webkit platforms were failing with cross-domain
         * errors when attempting to load audio data from embedded data URIs.  This
         * was occurring in mid-September 2013.  Simplification may be possible if the
         * cross-domain issue goes away at some point in the future.
         */
        define( 'VIBE/Sound',['require','SHERPA/base64binary','PHET_CORE/platform','audio!VIBE/empty.mp3','AXON/Property'],function( require ) {
          
        
          // modules
          var base64Binary = require( 'SHERPA/base64binary' );
          var platform = require( 'PHET_CORE/platform' );
          var empty = require( 'audio!VIBE/empty.mp3' );
          var Property = require( 'AXON/Property' );
        
          // Global property that allows all audio to be turned on/off, see #11
          var audioEnabledProperty = new Property( true );
        
          // Set up a single audio context that will be used by all sounds when
          // using Web Audio API.
          var audioContext;
          if ( 'AudioContext' in window ) {
            /*global AudioContext*/ // Disable jshint warning.
            audioContext = new AudioContext();
          }
          else if ( 'webkitAudioContext' in window ) {
            /*global webkitAudioContext*/
            /*jshint newcap:false*/ // Disable jshint warning.
            audioContext = new webkitAudioContext();
          }
        
          /**
           * @param {Array} soundInfoArray An array of 'soundInfo' objects.  Each
           * soundInfo object includes *either* a url that points to the sound to be
           * played *or* a base64-encoded version of the sound data.  The array is
           * generally used to hold multiple formats for a given sound (e.g. mp3 and
           * ogg).
           * @constructor
           */
          function Sound( soundInfoArray ) {
        
            var self = this;
        
            // For backward compatibility with earlier versions, support the case
            // where a single soundInfo object is passed in.
            var localSoundInfoArray = soundInfoArray;
            if ( !( soundInfoArray instanceof Array ) ) {
              localSoundInfoArray = new Array( soundInfoArray );
            }
            // Parameter checking.
            localSoundInfoArray.forEach( function( soundInfo ) {
              if ( typeof( soundInfo ) !== 'object' || ( typeof( soundInfo.base64 ) === 'undefined' && typeof( soundInfo.url ) === 'undefined' ) ) {
                throw new Error( 'Error with soundInfo object: Does not contain a necessary value.' );
              }
            } );
        
            this.sound = document.createElement( 'audio' );
            var supportedFormatFound = false;
            var soundInfo = null;
            for ( var i = 0; i < localSoundInfoArray.length && !supportedFormatFound; i++ ) {
        
              soundInfo = localSoundInfoArray[ i ];
        
              // Identify the audio format.
              var audioFormat;
              if ( soundInfo.url ) {
                audioFormat = 'audio/' + soundInfo.url.slice( soundInfo.url.lastIndexOf( '.' ) + 1 );
              }
              else {
                audioFormat = soundInfo.base64.slice( soundInfo.base64.indexOf( ':' ) + 1, soundInfo.base64.indexOf( ';' ) );
              }
        
              // Determine whether this audio format is supported.
              if ( this.sound.canPlayType( audioFormat ) ) {
                // This one is supported, so fall out of the loop to the next section.
                supportedFormatFound = true;
              }
              else {
                if ( i === localSoundInfoArray.length - 1 ) {
                  console.log( 'Warning: No supported audio formats found, sound will not be played.' );
                }
              }
            }
        
            // Load the sound.
            if ( supportedFormatFound ) {
              if ( audioContext ) {
                var arrayBuff;
        
                if ( soundInfo.base64 ) {
                  // We're working with base64 data, so we need to decode it.
                  // The regular expression removes the mime header
                  var soundData = ( soundInfo.base64 ? soundInfo.base64 : this.sound.getAttribute( 'src' )).replace( new RegExp( '^.*,' ), '' );
                  arrayBuff = base64Binary.decodeArrayBuffer( soundData );
                  audioContext.decodeAudioData( arrayBuff,
                    function( audioData ) {
                      self.audioBuffer = audioData;
                    },
                    function() {
                      console.log( "Error: Unable to decode audio data." );
                    } );
                }
                else {
                  // Load sound via URL.
                  var request = new XMLHttpRequest();
                  request.open( 'GET', soundInfo.url, true );
                  request.responseType = 'arraybuffer';
                  request.onload = function() {
                    // Decode the audio data asynchronously
                    audioContext.decodeAudioData( request.response,
                      function( audioData ) {
                        self.audioBuffer = audioData;
                      },
                      function() { console.log( "Error loading and decoding sound, sound name: " + soundInfo.url ); }
                    );
                  };
                  request.onerror = function() {
                    console.log( "Error occurred on attempt to load sound data." );
                  };
                  request.send();
                }
              }
              else {
                // Web Audio API is not available, so insert the sound into the DOM and
                // use HTML5 audio.
                this.sound.setAttribute( 'src', soundInfo.base64 ? soundInfo.base64 : soundInfo.url );
                this.sound.load();
              }
            }
          }
        
          /**
           * Plays the sound using the Web Audio API if available or HTML5 audio if not.
           */
          Sound.prototype.play = function() {
            if ( !Sound.audioEnabledProperty.get() ) {
              return;
            }
            if ( audioContext ) {
              // Use the Web Audio API.
              this.soundSource = audioContext.createBufferSource();
              this.soundSource.buffer = this.audioBuffer;
              this.soundSource.connect( audioContext.destination );
        
              if ( 'AudioContext' in window ) {
                this.soundSource.start( 0 );
              }
              else if ( 'webkitAudioContext' in window ) {
                this.soundSource.noteOn( 0 );
              }
            }
            else {
              // Use the HTML5 API.
              this.sound.play();
            }
          };
        
          /**
           * Stop the sound if it is currently playing.
           */
          Sound.prototype.stop = function() {
            if ( 'AudioContext' in window ) {
              // TODO: TBD
            }
            else if ( 'webkitAudioContext' in window ) {
              // TODO: TBD
            }
            else {
              this.sound.pause();
              this.sound.currentTime = 0;
            }
          };
        
          // Workaround for iOS+Safari: In this situation, we must play an audio file
          // from a thread initiated by a user event such as touchstart before any
          // sounds will play. This is impossible with scenery, since all scenery
          // events are batched and dispatched from the animation loop.
          // See http://stackoverflow.com/questions/12517000/no-sound-on-ios-6-web-audio-api
          // Note: This requires the user to touch the screen before audio can be played
          if ( platform.mobileSafari ) {
        
            var silence = new Sound( empty );
            var playSilence = function() {
              silence.play();
              window.removeEventListener( 'touchstart', playSilence, false );
            };
            window.addEventListener( 'touchstart', playSilence, false );
          }
        
          Sound.audioEnabledProperty = audioEnabledProperty;
        
          return Sound;
        } );
        
        define("image!FORCES_AND_MOTION_BASICS/pull_figure_BLUE_0.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEYAAADDCAYAAAA/U2fvAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoyNjUzMTBBQjI5OUYxMUUzOTI5MEJBRjhGMzFDNzBGQyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoyNjUzMTBBQzI5OUYxMUUzOTI5MEJBRjhGMzFDNzBGQyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkQzREU3MjYwMjk5RTExRTM5MjkwQkFGOEYzMUM3MEZDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjI2NTMxMEFBMjk5RjExRTM5MjkwQkFGOEYzMUM3MEZDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+nH4/swAALfJJREFUeNrsfQuM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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pull_figure_BLUE_3.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJkAAACICAYAAAD01kmEAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoyNjUzMTBBRjI5OUYxMUUzOTI5MEJBRjhGMzFDNzBGQyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoyNjUzMTBCMDI5OUYxMUUzOTI5MEJBRjhGMzFDNzBGQyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjI2NTMxMEFEMjk5RjExRTM5MjkwQkFGOEYzMUM3MEZDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjI2NTMxMEFFMjk5RjExRTM5MjkwQkFGOEYzMUM3MEZDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+rDOg+AAALJtJREFUeNrsnXtw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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pull_figure_lrg_BLUE_0.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFYAAADpCAYAAAC+ysBXAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4OTg0Q0JGRDI5OUUxMUUzOTI5MEJBRjhGMzFDNzBGQyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4OTg0Q0JGRTI5OUUxMUUzOTI5MEJBRjhGMzFDNzBGQyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg5ODRDQkZCMjk5RTExRTM5MjkwQkFGOEYzMUM3MEZDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjg5ODRDQkZDMjk5RTExRTM5MjkwQkFGOEYzMUM3MEZDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Lzgn3AAAOINJREFUeNrsfWuQ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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pull_figure_lrg_BLUE_3.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pull_figure_small_BLUE_0.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD0AAACNCAYAAAAEqHKcAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4OTI5Q0I4RTI5OUYxMUUzOTI5MEJBRjhGMzFDNzBGQyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4OTI5Q0I4RjI5OUYxMUUzOTI5MEJBRjhGMzFDNzBGQyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg5MjlDQjhDMjk5RjExRTM5MjkwQkFGOEYzMUM3MEZDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjg5MjlDQjhEMjk5RjExRTM5MjkwQkFGOEYzMUM3MEZDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+aqgwDAAAHJdJREFUeNrsXWuM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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pull_figure_small_BLUE_3.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFsAAAB1CAYAAAAhkJ3fAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4OTI5Q0I4QTI5OUYxMUUzOTI5MEJBRjhGMzFDNzBGQyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4OTI5Q0I4QjI5OUYxMUUzOTI5MEJBRjhGMzFDNzBGQyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg5MjlDQjg4Mjk5RjExRTM5MjkwQkFGOEYzMUM3MEZDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjg5MjlDQjg5Mjk5RjExRTM5MjkwQkFGOEYzMUM3MEZDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+5Kbf7QAAHJ5JREFUeNrsnXls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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pull_figure_RED_0.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pull_figure_RED_3.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pull_figure_lrg_RED_0.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pull_figure_lrg_RED_3.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAACgCAYAAAClika/AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAALLJJREFUeNrsnWtsZMl130/dR7/4as6MZh+a3eVCK1tPqAXZhmRpvRzJSpAYsbiO4AR2gCXjOEq+RDuAkQ/Jh9n5EsCOkNkBAgSKDQ/nQwwjUbJcKUpkOMlwpchRgtjLlQxFtuWoldmd5w7ZbLKf996qnFNVt7v69u1mN8nZYZNVg5q67Hff/vW//+fUi4EtthxyEULIljEGNwEWQNXFlJtuYC0/rtpDKcyeflsOCWJiKYPVu/fhDz/L33zzV0Sj8axotxdAAz6kVLCuYX31cdVaoG15qDDnsJm6/6lP/Wr05pu/AWH4hAhDgHYbRL0OotUa5+HKeM9LTwKsWqBteRiqPLv1y7/88+F3v/syHp9DnwEQRSCCAFChQdRqsu6l0nQtxxrh/RFoCAhsxlY+zPn6OK/JsR+LLfuFufalLz1570Mf+v3we9/7CnjeOawArgvg+6p1HAXyEJjpGgK4jSA3qeIxtS3GFtoA1/+H675kFdqWBw7z/U9/+hNRufz7LJt9QsLbewMQzSaI7W3gm5upQNMlEcGM8EYa6uRxqG8TMLb682G4YoG25YFkMO6eO/d5wfnvsEJhDoEGaTPMgnaD37sHvFLpg5lrSGNrESaOe6DuvW71cyNAbYG2Zaxy0/OWWT5/1ZmexjBwClgm0wWalBl9M791Syq0WQhSboI7BOqeY0Otsa78ahCsWqBtORyYAV5CeC8yAplqLgeM/DICR0Egv38fxM7OwEAvCejIx92/K1g/+oV2uzzoNXr2Y7JlRJivYrMsLQSl48g3cy4tSJzN6ICM8HFTiQcAuudxv3IXA/U6zluFtuXgMJuFgCa4OdfSiNqIis3RU0eOA2EYQrtehxCVe0RY97Qc8TFC/fw/bTbXrELbsh+Yl/tglqY46oI8MwNidhY4Ah0izBFCHCDMLVTygIA+JMthHF+EAT2KVqFt2Qvmq+m/7eibCwUQZ84AR6A5BoeclBkVm2BuVyrQ3NyEEME/RMthZkPO/4t6fd0qtC2jwlzC5nLychF75GJRwiwQZrIYUQwiAtxqNqG5vQ0BHu8H1hEV/QVsLNDHpQRqBFtJV7PQyLUNH6B8wKcgZS6aIMv8McIrCObTpyXMHL10FMOGFoNAbty9K71zB77DtxzULlrLMfkQE2AvglKnhT1uTkCvCQZXMmI8uGV6DuBiD8gxYGgzQCuzQM8sISObgarcQovRIJuBf48L6DgqbgSHT//b3d2yBXpyQb44zv3k0CEm21Wsl3Lh3mDfVM/1I44tT4JI6jw3JwNACTN5ZrIYOzvQRM9MCn0Y/ngvRTce4/lXd3fXrOWYLJjpp/UV8+d/z8Jir6urA8vYLu/m4BIevzxTl+OPUwvC8iLBPAhETqPoajUIGw0IKItBbRgOhXdflmPYY+hjruyWBXqCYH7pAKocwww8bh24iO3ntoqwMl9JnyXSYuyFYRARyBHai1CIkZX2MCyHqc6RtEJCvVcbFE4MzP2dGeOA3A+zal0o4fHrt0/DyqP3ewfRf89xii305gPGUXRhRZj3q7oj2YwB8HNZFcgEdJpftkAfTb9MFmNxn/ai22qguduFOmQEiQTm6g9PwXMrW/CG47lrrwVhGZ+7xA8xE5FqHfYBv9Agc6bCVBqsmsUvlW+BnohydVSYh9mLGGCzKgVkEAjd4i/A+TzANyPn8vnpwtrXw+jC+SA8tM6P/VgO8z5cW4sYZA9fdxbbjG7dlOyNBfro2Yyl/doLarkJs6sAN1TZhBkrg/NZtBptBzYdtvT1jL/4vojD7Bj+eBTVHQd+bqixkG+TABZy9m3WbIWcbrVh89CT7JkNexEDzQ2LYfhkeRwlQA7i4xhofdmbeKff5T5U8fhZVOhFrIdpOUZJw0WGGsf+OJMAOKsvI3X2UZ1/s9F62ir00YT58l4wDwz6DGWOQTbtRSi6APfCrNo2/j3LBPycE8Fa5MFrngcfQZX2SaUPofNjrzRcMtBzNMAdePH15xwHCtkMZF0XvHYb3FYL7Ya4AtZDH0mYCeQXRwr6nBSYEz45VmUJcA/MXZDb6nl74H4vYvURxuE7woV/5/vwS9R1DYfQ+ZECf5SwFnGgFwOcgW5b8DMwOz0N+UwGfBrhR8NVm82yEGLVAn30YF6EQaPZ9sopu+gusUpVxn+mvTBBTtqLYIBKU/txVOlb+AR/hor4J6iGPzFmF/ZewKcGej2WQrfaahSyWZibm5NtBl+jw5vA2wEIzi/8w3ZYsUAfLZhLOj03Xk6ZQM54wLM+XoaQCPS7QVtDTDDH0PaD2wXaVGoNtb7Np1ClK3j8TYR6GsGag/E7P9L8sVRkJjqBnm/aihR1zqH1mZuZ1TAD+BwfpdGkTp3V5Xa4NuQHzZaHlGu+DsmRcnvllD0HRD4HopAH7rsQRYEcFBQ0Wwio6Mle9ILce1kPyDqNR3/HVoSA/i8o+XOo0D+nIRm18yPcI9CLQU6qcsdm0PV4/5nZWZiemYEMfrF8jt66Xodoc3Ptbzdbzw87t1ahH16uuTRWTtn3QMxOg5iZRnXOIMwRBDUObQzg2olUXJq9aCfgbqdYjhhuhv8+iM/5pyirf4qAvZcGIcHoPX88AbKTknIz88kZkVBqx4UZrHkKTsMIYa6BqO6suSMsY2CBfufV+SUz1zxSTpnsRXEOxHwReKGANgMfZ2cHWvhht7EOsxftxGXDQDb/nsZ2Hl/DDVTHOYSsQIP4R/DHZsYiDvRicGNLYfpkE+TO34JDodWCTBiA22iA02qt/kIQ2YVmjiDMSx3fPEJOWf6dRWU+NQ/i9Bng+YIK/NptaG3el+OP2zTiLRH0tVPgbhvq3d4D7rZ+LFpisYxgeaTSmYycqZJmM5Jd096AjEVsKcxOkhj4DCRajA/QalQcIS781YivjnqOrUK/s0Hg1ZFyyjqfLNAnS1U+8y7guYIM/OQ6cKhazVpNTUJN+GLym1MICa0VV8cgrIo/+Mnb9MKdrtIqZ42P5brQDAK4ic81jwFaMtAT+Bxq3rfs7EgFOBn8meBmjfvFl9PfXiTWMWJY+XQkyuOcZwv0OxcEXkVWiiPnlD0GnAbSnzoDUVbZDOmTW01oVKsSaPxlhhkkbzbAn2iyBljb+Ik2fIAa1h1UubP4BD/Cb8hb+FGn2wsNeV8HDH0p8HuHgSjDK1vo2bdIWWmpgpQevewAVU765F6bgUGicZ2vgsYyvv0Li1zsa51oC/Q7URhcFaTQew3tjDtHqOanQMzNo82YkiDLRQvRUwb3N2H67ha8ux7C6UClweg+BPJOToG86zKoClW3Ba3qiY+HwDTwSZIqPQhkBbvyw56LUFMQSoP7Gdtwc37J2QPkbALgpM1QqtwH8qXnuFg9yKm2QD/ggnC8hFAsDR2n7BogE1h+Fvj0DIipaQzAVIbBq+7C2fJbMLu1C65e3IVuH+B9m0hEPdMPMo3NoBTcNra7QKsZ9YPc7uSThbqOKZDpMpfywQgc08vcUkH//mo+663gd+cyXrc4KFMxzCf7nRYqrhBr+BauIcjrh6Mdtjw4mGnqE1qN1JyyocyROZAIAY6mEOb509JyFLZ2oHjjDhQq3TXj6MsQoBS1vC7IO6DArWqAtxNthE+UTViOOFNBACuQlUKDhjAnK/lZXrndbJEFWMB64Vt6lNuvT+UWUYlfILDxsRcG+WQTZFTmDXzZ6wjya5/Zp62wQD+E0nJlEHhdkG8eZ5xyBtV5ZhZmka4ztyvgt9o9IIeuArlBIJPNAKXE2/jAVQPgigF0Bduz1HWcEvQFhiqT7nvxgCANdF63X26292Tlt7L+YkZ74yTMHojyL4a8/KDPuwX6AZSmJ4PA15GlhdHHKTOZQcgxHx7dCSHXCns6XULtk0mRZcDHtL3oQOz0qrIGmVraAOVRMIePapgNe+Fo+GKQc1zBnMfLC9j+ZjuYCFash34ABRm6noS5xyunjIhjKI+P1zkqc7MH5EiDbGYudmKP3GMrnF5V1vnlPBNwGl9I01Rlw16ITlCn7EWsyrIi1ARzYe9drCzQx7WgFSDPXOJ72AtzRNyZhoCzjS40Zuai6adnLnp9stNjM5o6UDstFdfpKrIKUqUqRyn2Ioa5kICZUoIW6BNYallYRiuxPOo4ZQ+penqXQz7qPkZf5sJRtqIq0gO+igaa2rrKHMA8uuFpTik3R3awmKm4QOeOTYhJmfPcgFlDHAM9JcSGBfqEld08lCijkfTK0YD5fKTKjxiqLDMXFPD5vZmLKqQpshn4ObCr5tfBnAaZhn02HBfqCHObiW5OGfRot0TQZ9oLE2Z6nBmyLYe406sFegLKTgGKyNYrarxyIqfcO8sa6Nf7KSRwOhAdnxwMyFxUtZVIB1kpNpVpRHWa0+RWDlP4BLc9H2qkzIa9cERSlbswFxKKTHUGbz8jH1t2gLxqgT5JQaAjlXmhL6ecUGUfyXrPDocM789c1HXmYnuEzAWBTJAWCGSEeEZ2e3M5zb/sI8wO68kpZ9OCPp4Oc6zK07qiOpc/cMDtii3QE1Qqs7CMAC+ZQV9gBH3x39NtAQs1Lq2BBNnvZi6kT04N+Jye9Nu2HmCUR1DnCTyEeE5WgRA78BcZT9qMYEhOOS2DUdADmgjkGOaCrvjyLkzS52Hz0AcoW0VUZQavo9UoJnPK5izrYkvA0wjzwMwFjJa5oDzxjFCqTBDPRVwq6l+gKt/yXNXjB6rLelhOuYBfgtgvT8nH64I8pWteWY21RwCen6TPxCr0AQrai8sS5iGzrOcR5qcaXAZ7VGs6c7EDablk0ycroGuJzMUswlikijCTKn8nl+2oshjFXiSCvmmtyjHIpMrUEZNFq4Hf0ZVJ+0yONNBCjR1YiH/d2SFG2/9tVmYlimgXStQ9jT/Rc+hLS0IPvO/kg/VUqfi5zRUvfwywSEFewfjBM2eLZFGiH29zSuepHj4M/mh8cqzIg7uqu5mLWVAeeVZbC4KZOkJ+kMnADa3KkVwma3x7MW2ockGrsoa5gs/9PF5WmTSg2RGEOHWVeqG8Z6XlwFrdg2uPNPv310grP8zBAkGJSlpCvp7Dlv5eiMEUvc/dfxlLv66vZepkurT/iMwwOPC+dgQcI7WaBypr0Rk85OyZuShIe9EN+EiR57Etez78OXrlmpw9onLKXVUenlOeSgR9U4ZXzunqK5hphbANmMDCjhjMy6BWEepZ3JuyBgGeZYQZGqhyBMi2Dy9/bKs/YKm6Um2XENznUHEXZRc0DIYX2IDL9zpmQ74EuvXxtVZyGtyekXCGP05kLvI6czGrQaY6jzDfd12pyhWZwRgtp1xIwJymyrmuKtPP9Qae4hVvQmE+UkCLlC3EBM02xsCpjWe5iT+9dYx2KE9bxbqFL30LnPVf2YzOk6rT/RHiF3j/Jjp9wCXVd9ht0i4XibMnhtyeAsNvT3twy+lPxVWMzEUOtHpqiIvaXmw5LiqyD9sa5DinnE3kk3ODevl41ycPsBdyzDJ+99bx7TzvTqDNOHJACwXh650LaIZxIQ/h9BS0PQfq7TrstmqwwyL5wW4SzKhyBPWZNmx8vhaUkm9mlOP9/D3qiTOv/37GgX9f8Dv+OFblOHNBHSMzvDdzsY3ngHLKVSOn3JnuZNqLAb18Zk55ZoC9yOggimaKuGo2+sSXoxIUdvbDExjohMUihPNz0PIdaDAO1WoTKvhBbXGpyrApVBaAgP4/nlP6kBOivxQD4d0L7oNcNsp9yE7QCp/JzEWxJ+CjBRIZWgsP/hztRYOBHn+xd065YHjmKR30JVU5n1BlX6nyBmUynAm2GEcOaB0ELqo0GAY6U3loF2egmdEwN3ZgE9X5Pn6qW8JVVkM4nXEMpHbrngefaAcPDMhR7jPsdv/Z9xBoF3ZSMheksm1U47dQjes9A4m645TJV2fx9mRLSI0H2Yu4y3o6ocpJexGrsnNMVPmoKXRJZzDQXjBooU9utGtQi/BnN2jAZrMJmwjzpla4rThHq9Neu9i+gar2NARjwXYQuMe573fyWXjD86WvPs26VsFhDjTx16ja6U0UnYFEQ8cpD8kpm0Ffmr0wVZkdI1U+UkCHet8PmcFwONTCBuzuNqCCHy5Zi9grJ1W5Kj0oA5/WhUAZu/WAwRz3ssB14G4uA7vYvjeegConpVJKTy3iYk6DGjZOedQu66kBquyrD5ry+KTKL8MxLg8d6LqrUnLUqgwG7wC8ZQCdVGXylVNoSd6F7Rn88G8fMpD7thwIcEB5Yt/rWQBxr8mpcU45bwR9MnvBoUeR8xriQkpO2fTKCXvxMsHMJjyDMTFZjh9Ow9aOB8VkBmOYKs8hADRP7jGg9a/bsJXw0AexHuNe5qDi5jGA9TO+3G110Lpxyfl844xTTsspp3VZGzllshdrtGgLO/i+31ahxyn3MrBaAfYiZTBGVeUYZqr/KQyhPsI3ddxU3jCI1bbBar3mD+QzKMwutEZYWsucZR0a9iKbZi8OkFPWQd86nLByJBT6q6ec4j3hvI4QLwxSZQ9VuWioctzeCMKNP2i0FmCcrYPHLNyocnFCRl3cCCMSk0F6pvCPc16+MyDJXPCwf5b1/nPKsyn2IpFTXtc55RMH8pECmso/K2ZK94FdR1UuJlW5gDCfMRQ5BnoeYPVnqjU5Iuyvqc4ZApvaOej2GBZhQO8hKE9pRvt0vI0APhdSt7mG2DxZjgbZ1zBnXVptnja2wf+iXLoqGyBHw+xFMg23x0CibNdeSJD9EwzykQOayvJcfmFTOFe3gS0mVfnRBNCoVpc+VK09kDzqs2pw1GXzMsdQZRqjkcU2SyDjseuqMdARAh1yL2WduG5OORvnlPfosk5OgzJBzhsg41NfyliQjybQcfnpmZlFVOUXzoJYfBxVN4YYVXr9FMCrKLlr76/WHmig86zeN9BUZc9UZVcBLUfWyQH91DoQhVmVwTCCPhiSUy6kzOsblFPOd9NwEuScBXkygH6ny41ubyVZk+f0xaUvMyh+myl7EVuMGGTPjTfoYXq7B1VD7uLlXmdpLVdDnN2jy3rYNKhCN+Ar49OuFCzIFugBIBPENO56OXldvOLRKtY/TqgyMAPiZCuhduQ+JdmUnHJBjDY51bQXCHIFn/YC2o5Vi6wFOg3kkvbIi2nXm8t3Uf0K0vQDX1mOELrgBilQq3mFDGEFOQR0vzllbS8I5Cv4PXq5cAI6RQ6jeCcQZgokLw66PglzhDT9De2fvyu3d+hXZ3PtjVBDTaPlaNbJI5ynLq9FOeW07EXcQYIfzCrWS1MnqFPEKvT4PvmVQao8CGZavjb01JiT/4hB34ZwemE2oKZJspE+pi0kaIHxUwj0R8MAFsJo4DQos8safwhWKeCbtSBboPeAuX+jyzFgjjtLviZceANrvGtrqOGOIN4hqguzTPfpWhQc/kqzBR8Lw7RpUBVaMoAUuWhBtkCPAPTrhwFzW4+W+xp34bsIdazKYUKVhT6xBLIrW7VnH9WPI9B/v9EkiNexbqBPfu2xCVqZyAL98GGm4O/Fw4K5pecAfp178D0J9WBV7oGZQQdqF8TL/71au2Dxs0DvJy13/bBhbunjbwgPvs8dCbSpygpmoYHug5naynq1Nm/xs1mOccvVkWH20Db4CKfP1BrNtOcfVwPz02CmAfqfZBHk8XH+Jyr1CKqsrpMDRHjRomeBHledl8FYqGYgzEhdlPOB5zIg8r78Oww5BLRLaxDIzeHTYI4hf0bupMpl9sPVG7UPgpnR1g74eIJz65kt0GOXL+4JM209PJ0HmJnCWgDwPRAIXFSvQ0jqjAHcMJhbej/sRxDYDzAOf4mXEciOAbKeMRKDLB8fhHjVomc99DjqTMr8o6EwZxDe2WkQp+aAT+XRP+vOEgSusbMDdayNRgNaCPYwmJudYwZ3UYDvsYGqLGEWQpS/GUZPW/SsQo9TlvaEGRVZzCPM0wXlmXVvXwttRrPZhGarPRbMLb19Gq3b3GDKekAMMe38GgmEmdQZLlnsLNDjlo8M88wcPbMo5LBmujAja61WE+rVKtRrNWiS3RgD5pa0JUJOy6JRdoysRRQpZaZFcGgTHyHWvyUOtpe1LScT6IXB2QwHOFUXg7mgDSEqKgV+zWYDGuidG/UmtBDE/cBM4zeaZDVovAaoTEkr0kALQYOLnrfIWaD3U0qpMMs8s4CIhRC1mxBGIbRJmVGNm+02qnIk884HhVmOoKM5gLQSFGdQB7F2E2DlW3bEnAV6n6U4sNPE4QhyAEFDwUu5ZpqtPUo2Y2SYOyvtCzm5cZqxN15UCm2LBXr8smcPIKXkRDSwB/DQYNbbR8xO0E6sk16c4/imEOKN/XZnHzbMp/D4lLUaFuhxC0K5gPUy1td9vdf2UYCZFsU5fUwXRrSW48GAvAxqXuCi+aYOA+aGULtVNfR92f5glpNbLWoW6GEQp24sRIX2Y2HOwWCON5WoMdAroBLADB4XITwTRFD2XAgcNhLMGBSW32OBtkDvATKN0+iMWCP8ZAcJQtzW+2bvB2bqEHm/E8AutrcEba3myIVhMkxtH1Fljlz76JfqTVinpXLx8mEw0wucsoP3LdAjg8yUIscQyw3gse7qjdsJ9FFhpiEXn8G/Aibk9hFy5jVTm/nQIjF0oup427ddB7bx8X+t2YY/8D25SOQgmGktOh/gisXMAt0J9EDN0F7uyWIwpcgxyE1PbfdGINOaeOR763ijd7PRU3Pn2214lHG479EKp2obCLmWBq2voVW6RvbDceAOQr0bhPA3sX4VjwfBnAdYt7O2LdBDQabF0QNSY1eBXMe6A12Qd0S3pYURTzGxt2dGdf5wK5J7cOfwTgVXyCUICGpS6BzCTCpNweEu2o57rgt3wgiexss+E3H4keiHmSbAuhO28bsF+vBBXtS2YikZ6El/bIBM2wzvaIiraBFiiHdBVdpp6sfChU87gbQew7IZj0VCziTx0ERnI1oeV8gVT/Mx1LQCEt6Wdkqh+9xHVb6NSv12FMFP4HVNFfz1wIzfjZc9m647mUDr1BuBXBoU6DW1tajpjd/jbYZ39LK7XZCxkt8VTHrer0UZ+KwbDM0zxwsqugh0JkSr4Au0HbFKKx8d2w7qJqc9BO96qNQI9JN4/U/S4xgwZxBkq84nEGgN8kVIjI4bFOh1rIVhK2KIqSWA60IFb01Q8N0DB1xU3Z9ywoGdJoHeUpZU2o+07fCEXpKLoGZoO9SCiw1K58ng0EWVjmAL/fOCgjiGuUx7ZVu0ThDQaSCPEuj1KbJU4xhkJmFr6KW65MLiQAulR8BCDtsIo5NxUnsAKWtBhcW2IySg1ULrhdhHd2yHeo5NHRzeQ6Af1+rs6r2yme3qPhlAa4982bQW4wR6fSBrW9EwACXzQPbgXYLDWbQE78bg7Qlsn+ACQgzgvpnPVPC2RbM7+y8dt/MayXaQSst16BwFdAx1b06awV3aui1k8ssyo5XZwnwCgNZZi8tmsNcJ9AxFHiXQ6wWZdTbqAWkPuFxL7hEN8pMI8BMI22MqA1HJtKOVP8yxDbz9VYR50Ryb8X20EB/A+zHDdkwZ2Y4440G2wwfVc6iCQ1RrDCrP4nv0VFxogT7OQLfVap+yQyStR6+RCPR2jP1VBgV6Tb3xO02dcuTm7xxOI8iPIpDnAgQZj88JtZXFaRnUyYzDJdp8Eqpyv6zzf2dmZglhvowwL9DYjD/yNdBGcFjwY4U2d5pSKr2rc9J38YtwF78459T19IV92WL18Ap7gCCTraCFXkqHHejROnI0q3oGQT6DMD1OIEtrocDSGwrR+spySVpnSOfGZ2enFxsgXjgX8cV/VWssxIFpA2W4ghTfQhV+C38tqCv8NlYKMu/TLl147OFreH8YwM822/AJ/AItqLXqPmqxOmZAt/WmOw8q0JtDkN9FIBPEVFGR3w20PoYMzsoI1TVaJNwZ8+d/y1jUkV7zDkruvSyDtxDimxrqu1jf1rvckgc/J0L4aQT6WXwdH1LP/zSzvYPHw3LoMRdXEeSldyrQowwD9dJNA6xnAK74BxsMdC0GGu0zZCK9LTFL+GgzJ82U7aCewydV6o7slc1BT7pCNx1YQOv5SuhAaXCgR61zaIHeKVRC9LfXEORV/xBUcUt9Ibdi20HvYRttx20PVVq4ynYAqTSTKl3R+etnohA+gSr9SXydz6jXZBeSmWSFrnpQajG4jiAXBwV6/RmLMQI9DXIc6M2ptZWvTB/y0Ez03ZUttTHPcpyTzuic9FSs0p0BS3gdU69/qzcnvYDCXnJtt/dkAn03B5QluI4gFw8j0CuiU04L9M4ibAjwKoJ0ZebBelQa7rlMBw7XtsPISXcGLJHt0Om7HXzP9xDoO92cNE08sEBPItC1LLyCdqN4GD16aYHeGYQ3rzaZXJt+B3K8qNIbWwrGkhywRDlpUulMipcWasBSs9MVHsL9SI68W7I+egKB3jjNXrojoHSQQO+M6PpjM9CbRTXGAOva6YezyeQVnXJUtiNS+wuqrvDenLTPVG/jtsM6Oekn0HYECLVvZ6tMFtAYJH1xR8ChBXqoxhsI8jUEZvVdD7HHDVV6dUuPNekMWOIpPYeM6QFL9L4dZTsQ7C21wMznwAI9WUC/KZziQQO9s0JsFBFiBHntiE0mpRTeRaZthxyw5KYPWMpo27EpgXbgbR5RFmYJ73bBtV3hkwP0Fmcbd8EpjRPoPRZGlbNcrJ8W4lWyEz9zdDshqAtbbtDZGSedER2g86kDlnROGt/rU0IUC8pLr1rM3rlyoDx0nTHxb3I+/G/Phf+HH2Yy0CNFpgwBLVz4vnYge9M+CPD0qQnpSdtSPnpZznhBQ1xF43zHZ3IS7S3h9uWkadb4e6IQPq5z0u9FCzVtu8Lf0bLvlZPwQ16knOyvNdrwz1sNuOzU4B+4TfgFtwWfcdvwjMOBoXLddDw5zDKkeXnqCZcm6Pxcib/1ZDtkThqEmkTLYpXWM8OZ2t6tk5OWmRwoBQP2ebHliAHdI/NCzfaYZxzO6NXrKY/BNAykXKTaofr7I5NycuZV+k7mkx3dFS5ns0DCdjCQPpre9048iRa/wBX1npctZpMB9GKsXub+fI5xWexnaEPKiCmoYfIU60oMdGcSLeictK7KSyub1TYn0YIc3/KCxWwCFZp1YBZ9UHNQAWKkbrM4SSdoXgV1lZ7gkNa0g7RJtOq9xpNo7+LxLn6BW0O2ZbblKAKtFYwZCu0kgCaFDvXxBJa1WKX9HtsRT6IFNYlWbuMmOpNoKYW3pVR6yaJ29IGumEBLHz3AdgipzkqhJxToK/EvUWcSLeicdJ/tUHn3TSM4bKpOFluOONAbZsqDJQLBrocWHYWOgRaTZzvova7HtiOeRDsFaTlp9b7jSbQUHKLtKO3abMfkWQ6HpftooTMcIYsXqp3Ici1W6Y7tYIngkCmouwOWVFf4plLpRYvbBAE9yD/HQEesazsmEWodHJZ7JtGKQZNoVU66Im2HK4PDhrUdRx7o8uBMRwJo1s1Dc5h8lXZ7gkNILOyoctKuzHDoAUvKdliFPspAmxNBOwGhMHPS2k+TzRDHBmga31ExByzFOenCgJw0DVi6jRVtR/GGTd9NkOWIoWbCsCAiYTkmG+h5ldm5Eqt0ZxItpE2iVffpTKKlQNECfeSB3kj66DTbQSXSQWEEE63QHZU2c9JT2kd3Vv1nQtoOyknXO8GhA9sT1O1/UoGu9Cl0AuoYd64DpUkHOlbpnkm0oCfR9gxYQuCZ6iGNByxtWYWeDMsBenBSp2OFpWQ58Cj20Hzyz5tSaT09K8dF/4AlEMaAJTWJtsKYDQwfcDnoJNnXsC6yvsyGkMFgrNyx5YiOh+WIlzu4gF/iq+NMor3jhLAdieXZbidLWdcKs7PEjwTQ0JPpoDWYWb+XpsL1WI4J7v5OQk3zDr+ItqPUWdhxyCTaip5EW4/41dn0H7k4JilrodhgD2eCsAU6LSh0UoLC6BgBrQup9HWf7z2JtqZz0g0EmwvR8+tllJKuSwbk6xp0gnzdrj/9DmQ50oLCtDHRIWPHwnIYKr2O7/vlziRa6HaH54ycNHnpQOekv4eRYjUDUPPVClO0bBptEMoHDwsg302LX76ClTa1fR3rVaGmhtkg85AVumfEnRrPIXo7VgzLESs0HK+BOpfwfS+h7VgYZRLtnSx1tHAgVc/QQCeusiXUUpc65bfdOMgW3R7YFBVf1ipeMRR8Q1uVsgX6gFkOBoOqkP/LQf5aoY8T0BQg3hewglBep+BwylwkPWUn2tsI9Q2sGVTmjEfXKQWnNoacFF+CrlODEnLe7YlNQF7UKr5ofBzlhE3ZsEDvJyiEZC6aVJr1zCs8Zh5altMC1u8IuIQqfVEFh7070eaMnWjfxrNCs8ZpwrAvVI8iHWeoMyYJOTcgN9Tc1aA7RroUeiFf0HXJUPE1DfjacfbhBwV6oycgHDDIP/bQ5pjo41YeCeGlGy48l4tgMbkTbdbYiZZU+qZwZTpPQp1o6Xa+HuCUwZMoK9OQi4SSm5AbdiX+HIygs6gtClXy3/S5XdNwly3QXd9cEQmFHjTQ35xXyOHYluczEVyfckWpx0sbO9ES1LdlfppJcH29CZEPqk2FPL6OaUV3dJuA3NdWxTdUvMePdyGPffhlobIo146Lch+G5ahoBRhgO47NvMI9yxMtqPxZBs5jIHh9CkQpn5hES0rdQJgDPCuehFlB6xlAp0PeD3sq5H4X8Niu+IaKe+lBJ3WMLWq4V4G69SdYtQ8DaPr5WkwblOQkLQfAcVdo+MkdqPzxaTi/w9l1DAxLBWMnWvrCb8rl0RgGfApkj45lKzTkQl5mAt17nIS8C3sP5OTH3S78gyB3dfDpcCjiXV7Eu77IFdiUvSmfVIVWkbdQgWD6RFllOcJu6u7Ylo/dh8r52dyFxxm//iTjci/EXUrbCdbJNTt6AUuaCEAgx5C7GnCl3GwI5P2wZ1LaOOj0BwSdGdG1Kl7Xriwj6MtNBBuvvpCPJseKHAbQb1A03QkKWZxWEj2pu85EWVq7QsCxL9ertfXPzk6t3hHOcvx2pxDueHCW/MXSSwy3RBdyV0PuMgW2q2HuqLj23p7oAu1Bug9PhbyTWcG/Ha3sSci7Kr6MkC/d9+HC6eZkLDp5GECXAdLnFPatzSEVmqzHCSAayx9Wayu/OF14AyG9HDA92pAxPclBgNpzSHQBp3Oklx+GzuwfpeSehlwq+qiQG348Yyh6xvgCdCwJGJD3Bp1FbK/+MAfPPVOBlRMDdDLT0Wc5WHe0XQQnp3x1t/7yr+eza3g+LuLpWWoyVsQKbdoaOp7FIyEX8msumIZdCwAfAHlSydMgN4NNLyXozCRsSyZpV7Qf12nE5W+fAvjkplg51kDTiDABxiTZAem75LzCk1R+u9GiL/3Kb7nuhYDBUsTY5wIMpHcdp0i7hdVpRF4P5GpChDcAcjqPQbwjgj7vbh/kQqXuDMiViqdkVhLevDd12BNsLn/lFLv2+c1w/TgrdJzpKHUmydJ4DgNsiCfKakVqndCxv/84iii4WtUVfhfPWd1xSgj0R5oOo6V3F6uOI7fEa3QgZ3rqmoLc1XYthjy2K6EGXCgXo62Kur3LFNhuT2YlaVXYSJB7KsV3/IHG81JKT90J3fndVei2HQIpy9+lLzbnG52Tg+XLDluoMmcB1Xqx5jhPIdh0XMK2SENPCfIAFORcQ851NiNW8TheiYNOMSDoHOTH98isHOlU3mEB/YbpodOX1dVd36TSQliaB5QvcIHARGWlgt1o45LvFRHqElqWRfTgT2FdwHOJx6Ag179+kQ46Pe1FuireVfLYj8MQP56WPsQvSPn3tuurJwHo9b5RdszobtV5aK7z0KHlduxyMQgr+qe+5+f+N7J+CYEuEeB4Xp9DsBeotpga3ZjMrGRGzKyYkKvYSKr/+lE/T2MDrQeVx0MWe67oU+i0eYVYf9ZOLTq08qVW0NllwCx/L59FqBXcARMLbQX1U3j+F6YFFJ/ivCT0etZt/LDIzjT0LykFnE29HR/taOYzNZM9K8S1iQdaxMMQMTKXEA+wCx3/LOIJsqJ/bQ6m1uaw5cGX31GZlfKAz/R6HFhW0RTfKOANMRi9IVx4izZEwk+S5kG2dM8vZTmmOS+/stuYXIVG8BYY5U5dd1lk8fvp403DEESziV9r1TUSoy20JUsqdP8QUjml36rzQyxCDSFdpM+r7sq92uEWrRsiaEcvR+7otYm1qnczo1GDU1zQtnyXJuH9pQJ9pwDL2xwuQy5XhCK6i0JBTaGqbmNtEc8S4ngeXNzOtftBTg5Qwp++ssXqocFMVvEyHdNcxrcR5pseDWeNYWYIM4NtUNtXFxiXQ18fjaL1f91orU4k0H9yGpZuC7gKmSy4p04BK0wpaNst9FYNiDxUZ491FDpOEwk8EW1PaKvRvxNWbDnqDnvDovXQCk22LQb44WxmEGaMEGmvRVLne1jv036L+Df55hzCTF3ftHX1uSC6MClvsA9ofGOXyQQ7PgLN8OoggqjVgla1AlET1Vm6qu6iizHM1L6FN/+giDprc5g9hvG8wgZjdv/rh1deiLRvvoXq3IGZdu6i9ayx0lbXcvgp3vhMFMHTQXjpn4TRxsQCjYHBghwN1woBtrbRXkQQBgFwwSXMXCfqeQJqroElgovylv1LGbSBrf/LZttajodjN5aQ1YVdhPk2+WbW65u3tG+Og8A5zuE9QbiGML80Se+zD+j/K5z1ENgib3MQaDO4iGF1O9D2ggw9l/8AI+W/7rT7egrpuAnsgkXroQH9XEMHgTdpzWrR3daZYN4WagwJ+WYKAheCcAPtxsqkvc8+oMvCXUEP9TrGfcU0YE27QUpteul4dfPfFVk47wTmyLuyC2Ll2zu7dv22h1SaLpTezvYGgfdkRkNZjTgIpJWeHouijfmIn/+CEBM3RCE1K/xTMzNFD8RlfO/L5m5WSQsBKX+bD5oDUUa1v/aNau0li9TDLTem4PqbWbb4Y1pGgbtwU+ebKbNRxeOczGgAnEWYH4mi819qBRM53mZoN8dnZqcoF73kCvicD2Kxm2cWnS0o4mlEdEwtKvtGm7H1kMFr/2G3YQPAI1L+1yl2/S1wFm8gvLLzRCt0BaurV02d5nz1ld3GyiS/z7H67f5RLlPyBBQ7MyOE6E6jB1H5YsStpTiiZe2U+xJCfDGG+a62G2QV80yU8bO88I2d+sQLkO2IPiHlt+e9IoL8yk3hLt6ROWfpm8vom6/gr+3qf63WjsWQXgv0CSt/a7awUAFnYUew8h/t7JTtGbHFliNc/r8AAwBxbfMu+AsyIgAAAABJRU5ErkJggg==';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pull_figure_small_RED_0.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pull_figure_small_RED_3.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("audio!FORCES_AND_MOTION_BASICS/golf-clap", function(){ return [{base64:'data:audio/mpeg;base64,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sZ8wp5OocaJJhmiXEuKQLmQQmZhFtJMRBSF7LgaZuHycxwmOeaMVbIzvIclc4rPQHBYOA480Bwj0uzD9HIGzOk0AdRVZaVQDARisI2IWP9IJSEIWAJwEdHEEFsE0NoQsOhtdvGBwL+gyCF2DATJ/BqCWIYqNDDAziZmXPon5jmg/yP/7cMDZABWpFxmHveuLD6MdPPe9dPCABYi7HkT3MKTSFQUwlQHyd9JM1t6kiG2gSLoTAcByV3yOvOTD+TkQa5BsDwxD9vW4bo4xJZ5ncafibn7sbki7HzdiQVlKEUHZVO/bDG0feGmcQ4wBdEOP/NSlYd74cgNnbO1cPS09pDySuX08bjF6G4f7rsQiRERVVKBvkwHGX7Jd3ROy+JI7VpQtJdFCP9uREVz9o0lMuGIsBSq5SrRwYvFRh6qZljXkSD5IfSbSOmmLJTCpAqWWJUhSJhQjDBO2oTqJqKvVk7wNwtvEC+zv7U2ZuSuvOerY36UNpMdRrdhsNnC/s24yuClgvpJIJK0qgN5DJylJyr3pyrmGhzWhKqCIqSgkBUo0hS1r6sKj6ap4TybVSEzQiNHkDYqGF1zAfiL/+3DAsgAWfRk3J78Lod4jKjj3pXQTxEf6LmpLFG4ZVoTBEQygGcgZJkxMQ425iUtgsnj5Nwcji5sldmqqpyxthy8kqYaTP6dUXYixIlQNrmTJ921wBJJ/BVi0jiVg4mE5mZtcnrEvEUuj9BFAmpqyJqSqi5QjHZoREbURnjoZjBQ2ZRFh5QNKx9NMk0SKyFSfZRBVQ6moXYaRKiIbFY7NCVZ5Y2XBlpDJCQkohDWEyqyrOFSahUqRI1BUTKkq1iI/mxlfQwXYJlU1CZUSmyKbTZSSRSorpnErORMl2UqSX2tgj0ZOiqJxXbc+atM0jXJYG6fZadFYpnC9iFMPIqGornDcDJ0PInCcdrLtMpimXGH+mzLTcS06hpfqnRVHkpHay8CUrDyKSAdrG4Eo9EETyovprSUvF9Os//twwK4ADsUZR4elK6HnIubs9KV1vTcZgbv3zXN61tzc+es03E8tgvEef+kJgJr6RYCkQmZ//////////////////////////////////////////////////////P/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7cMDIABaZHwunsYugAAAlwAAABP//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+3DA/4AkgAEuAAAAIAAAJcAAAAT/////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//twwP+AJIABLgAAACAAACXAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=='},
        {base64:'data:audio/ogg;base64,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pDQIOeYcpQQh5pyjVDkGoYSWKuYghJJa55yElmLsHISSWowlpdZirLWUlFqMtRYAAFDgAAAQYIOmxOIAhYasBACiAAAQYxBiDEKDjFKMQWgMUoo5CJFSjDknJVKKMeekZI45JyGljDnnoJQUQiglpZZCCKWklFoBAAAFDgAAATZoSiwOUGjIigAgCgAAMAYxhhhD0DEpnZTIQSYlk9A4Byl1lDJKpcQSY0apxFZijKBzlEJKGaUSY2kxo1RiDLEUAAB24AAAdmAhFBqyEgDIAwBAjFGKMeecMwgx5ZxzzhmEFHPOOecUY4w555xzijHGnHPOOeacc85BCCFzzjnnIITQOecchBBC6JxzDkIIIXTOOQchhBA655yDEEIIBQAAFTgAAATYKLI5wUhQoSErAYA8AADAGKWcg1BKoxRjEEpJqVGKMQilpFQ5B6GUlFqrnINQSkqtdRBKSam1GDsIpaTUWoyllJRijDHXUEpLLcZYc2otxhhzzTmlFmOtNedcAADuggMA2IGNIpsTjAQVGrISAMgDAEAQUooxxhhDCjHGmGPOIaQUY4wx5xRjjDnmnHNKMcaYc845xphzzjnnHGOMOeecc44x5pxzzjnHnHPOOeecY84555xzzjHnnHPOOecEAAAVOAAABNgosjnBSFChISsBgHAAAIAI6DjnnHPOOTcOYq211lprrTVyUGuttdZaa62p1lprrbXWWmtNtdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWgCQb4UDgP+DjTOsJJ0VjgYXGrISAAgHAACMYcxB56CDDkLDlHMQQgghhBAapiCUEkIppaSUQSclpVJSSimlzEEpKZWSUkqpdVJSai2l1lqLrZOSUksppdZaix2EVFJqrbXYYusgpJRSa621GGMoJbXWWosxxhhDKSm11lqMMdZYSmmptRhjjDHGUlJKrcUYY4wxlpRai63FGGOMtaTUWmwxxhpjjQUAcDc4AEAk2DjDStJZ4WhwoSErAYCQAAAEIcacc8456ByEECnFmHPOOQchhBAipRhzzjnnIIQQQsaYc85BCCGEEELIGHPOOQghhBBCCJ1zzkEIIYQQQgih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'}
        ];});
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Main class for the entire view of the Tug of War model, including cart, pullers, background, controls & audio sounds (when tug of war game complete).
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/tugofwar/view/TugOfWarView',['require','FORCES_AND_MOTION_BASICS/tugofwar/view/PullerNode','KITE/Shape','SCENERY/nodes/Path','SCENERY/nodes/Text','SCENERY/nodes/Rectangle','SCENERY/nodes/Image','SCENERY/nodes/Node','FORCES_AND_MOTION_BASICS/tugofwar/view/KnotHighlightNode','FORCES_AND_MOTION_BASICS/tugofwar/view/GoPauseButton','FORCES_AND_MOTION_BASICS/tugofwar/view/ReturnButton','SCENERY/util/LinearGradient','FORCES_AND_MOTION_BASICS/tugofwar/view/FlagNode','FORCES_AND_MOTION_BASICS/tugofwar/view/TugOfWarControlPanel','PHET_CORE/inherit','image!FORCES_AND_MOTION_BASICS/grass.png','image!FORCES_AND_MOTION_BASICS/rope.png','image!FORCES_AND_MOTION_BASICS/cart.png','JOIST/ScreenView','DOT/Bounds2','FORCES_AND_MOTION_BASICS/common/view/ReadoutArrow','AXON/Property','SCENERY_PHET/PhetFont','string!FORCES_AND_MOTION_BASICS/sumOfForces','string!FORCES_AND_MOTION_BASICS/leftForce','string!FORCES_AND_MOTION_BASICS/rightForce','string!FORCES_AND_MOTION_BASICS/sumOfForcesEqualsZero','VIBE/Sound','image!FORCES_AND_MOTION_BASICS/pull_figure_BLUE_0.png','image!FORCES_AND_MOTION_BASICS/pull_figure_BLUE_3.png','image!FORCES_AND_MOTION_BASICS/pull_figure_lrg_BLUE_0.png','image!FORCES_AND_MOTION_BASICS/pull_figure_lrg_BLUE_3.png','image!FORCES_AND_MOTION_BASICS/pull_figure_small_BLUE_0.png','image!FORCES_AND_MOTION_BASICS/pull_figure_small_BLUE_3.png','image!FORCES_AND_MOTION_BASICS/pull_figure_RED_0.png','image!FORCES_AND_MOTION_BASICS/pull_figure_RED_3.png','image!FORCES_AND_MOTION_BASICS/pull_figure_lrg_RED_0.png','image!FORCES_AND_MOTION_BASICS/pull_figure_lrg_RED_3.png','image!FORCES_AND_MOTION_BASICS/pull_figure_small_RED_0.png','image!FORCES_AND_MOTION_BASICS/pull_figure_small_RED_3.png','audio!FORCES_AND_MOTION_BASICS/golf-clap'],function( require ) {
          
        
          var PullerNode = require( 'FORCES_AND_MOTION_BASICS/tugofwar/view/PullerNode' );
          var Shape = require( 'KITE/Shape' );
          var Path = require( 'SCENERY/nodes/Path' );
          var Text = require( 'SCENERY/nodes/Text' );
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
          var Image = require( 'SCENERY/nodes/Image' );
          var Node = require( 'SCENERY/nodes/Node' );
          var KnotHighlightNode = require( 'FORCES_AND_MOTION_BASICS/tugofwar/view/KnotHighlightNode' );
          var GoPauseButton = require( 'FORCES_AND_MOTION_BASICS/tugofwar/view/GoPauseButton' );
          var ReturnButton = require( 'FORCES_AND_MOTION_BASICS/tugofwar/view/ReturnButton' );
          var LinearGradient = require( 'SCENERY/util/LinearGradient' );
          var FlagNode = require( 'FORCES_AND_MOTION_BASICS/tugofwar/view/FlagNode' );
          var TugOfWarControlPanel = require( 'FORCES_AND_MOTION_BASICS/tugofwar/view/TugOfWarControlPanel' );
          var inherit = require( 'PHET_CORE/inherit' );
          var grassImage = require( 'image!FORCES_AND_MOTION_BASICS/grass.png' );
          var ropeImage = require( 'image!FORCES_AND_MOTION_BASICS/rope.png' );
          var cartImage = require( 'image!FORCES_AND_MOTION_BASICS/cart.png' );
          var ScreenView = require( 'JOIST/ScreenView' );
          var Bounds2 = require( 'DOT/Bounds2' );
          var ReadoutArrow = require( 'FORCES_AND_MOTION_BASICS/common/view/ReadoutArrow' );
          var Property = require( 'AXON/Property' );
          var PhetFont = require( 'SCENERY_PHET/PhetFont' );
          var sumOfForcesString = require( 'string!FORCES_AND_MOTION_BASICS/sumOfForces' );
          var leftForceString = require( 'string!FORCES_AND_MOTION_BASICS/leftForce' );
          var rightForceString = require( 'string!FORCES_AND_MOTION_BASICS/rightForce' );
          var sumOfForcesEqualsZeroString = require( 'string!FORCES_AND_MOTION_BASICS/sumOfForcesEqualsZero' );
          var Sound = require( 'VIBE/Sound' );
          var pullFigureBlue0Image = require( 'image!FORCES_AND_MOTION_BASICS/pull_figure_BLUE_0.png' );
          var pullFigureBlue3Image = require( 'image!FORCES_AND_MOTION_BASICS/pull_figure_BLUE_3.png' );
          var pullFigureLargeBlue0Image = require( 'image!FORCES_AND_MOTION_BASICS/pull_figure_lrg_BLUE_0.png' );
          var pullFigureLargeBlue3Image = require( 'image!FORCES_AND_MOTION_BASICS/pull_figure_lrg_BLUE_3.png' );
          var pullFigureSmallBlue0Image = require( 'image!FORCES_AND_MOTION_BASICS/pull_figure_small_BLUE_0.png' );
          var pullFigureSmallBlue3Image = require( 'image!FORCES_AND_MOTION_BASICS/pull_figure_small_BLUE_3.png' );
          var pullFigureRed0Image = require( 'image!FORCES_AND_MOTION_BASICS/pull_figure_RED_0.png' );
          var pullFigureRed3Image = require( 'image!FORCES_AND_MOTION_BASICS/pull_figure_RED_3.png' );
          var pullFigureLargeRed0Image = require( 'image!FORCES_AND_MOTION_BASICS/pull_figure_lrg_RED_0.png' );
          var pullFigureLargeRed3Image = require( 'image!FORCES_AND_MOTION_BASICS/pull_figure_lrg_RED_3.png' );
          var pullFigureSmallRed0Image = require( 'image!FORCES_AND_MOTION_BASICS/pull_figure_small_RED_0.png' );
          var pullFigureSmallRed3Image = require( 'image!FORCES_AND_MOTION_BASICS/pull_figure_small_RED_3.png' );
          var golfClapSound = require( 'audio!FORCES_AND_MOTION_BASICS/golf-clap' );
        
          //The aspect ratio that this sim was coded for differs by 7% than the one we eventually decided upon.
          //aspect ratio of this screen: 981/604=1.62
          //aspect ratio for default: 768/504=1.52
          //TODO: Rewrite the sim layout to use the standard bounds (lower priority)
          var LAYOUT_BOUNDS = new Bounds2( 0, 0, 981, 604 );
        
          /**
           * @param {TugOfWarModel} model
           * @constructor
           */
          function TugOfWarView( model ) {
        
            ScreenView.call( this, {renderer: 'svg', layoutBounds: LAYOUT_BOUNDS} );
        
            //Fit to the window and render the initial scene
            var width = this.layoutBounds.width;
            var height = this.layoutBounds.height;
        
            var tugOfWarView = this;
            this.model = model;
        
            //Create the sky and ground.  Allow the sky and ground to go off the screen in case the window is larger than the sim aspect ratio
            var skyHeight = 376;
            var grassY = 368;
            var groundHeight = height - skyHeight;
            this.addChild( new Rectangle( -width, -skyHeight, width * 3, skyHeight * 2, {fill: new LinearGradient( 0, 0, 0, skyHeight ).addColorStop( 0, '#02ace4' ).addColorStop( 1, '#cfecfc' )} ) );
            this.addChild( new Rectangle( -width, skyHeight, width * 3, groundHeight * 3, { fill: '#c59a5b'} ) );
        
            //Show the grass.
            this.addChild( new Image( grassImage, {x: 13, y: grassY} ) );
            this.addChild( new Image( grassImage, {x: 13 - grassImage.width, y: grassY} ) );
            this.addChild( new Image( grassImage, {x: 13 + grassImage.width, y: grassY} ) );
        
            this.cartNode = new Image( cartImage, {y: 221} );
        
            //Black caret below the cart
            this.addChild( new Path( new Shape().moveTo( -10, 10 ).lineTo( 0, 0 ).lineTo( 10, 10 ), { stroke: '#000000', lineWidth: 3, x: this.layoutBounds.width / 2, y: grassY + 10} ) );
        
            //Add toolbox backgrounds for the pullers
            var toolboxHeight = 216;
            this.addChild( new Rectangle( 25, this.layoutBounds.height - toolboxHeight - 4, 324, toolboxHeight, 10, 10, {fill: '#e7e8e9', stroke: '#000000', lineWidth: 1} ) );
            this.addChild( new Rectangle( 630, this.layoutBounds.height - toolboxHeight - 4, 324, toolboxHeight, 10, 10, { fill: '#e7e8e9', stroke: '#000000', lineWidth: 1} ) );
        
            //Split into another canvas to speed up rendering
            this.addChild( new Node( {layerSplit: true} ) );
        
            //Create the arrow nodes
            var opacity = 0.8;
            this.sumArrow = new ReadoutArrow( sumOfForcesString, '#7dc673', this.layoutBounds.width / 2, 100, this.model.netForceProperty, this.model.showValuesProperty, {lineDash: [ 10, 5 ], labelPosition: 'top', opacity: opacity} );
            this.leftArrow = new ReadoutArrow( leftForceString, '#bf8b63', this.layoutBounds.width / 2, 200, this.model.leftForceProperty, this.model.showValuesProperty, {lineDash: [ 10, 5], labelPosition: 'side', opacity: opacity} );
            this.rightArrow = new ReadoutArrow( rightForceString, '#bf8b63', this.layoutBounds.width / 2, 200, this.model.rightForceProperty, this.model.showValuesProperty, {lineDash: [ 10, 5], labelPosition: 'side', opacity: opacity} );
        
            //Arrows should be dotted when the sim is paused, but solid after pressing 'go'
            this.model.runningProperty.link( function( running ) {
              [tugOfWarView.sumArrow, tugOfWarView.leftArrow, tugOfWarView.rightArrow].forEach( function( arrow ) {
                arrow.setArrowDash( running ? null : [ 10, 5 ] );
              } );
            } );
        
            this.model.showSumOfForcesProperty.linkAttribute( this.sumArrow, 'visible' );
        
            this.ropeNode = new Image( ropeImage, {x: 51, y: 273 } );
        
            model.knots.forEach( function( knot ) { tugOfWarView.addChild( new KnotHighlightNode( knot ) ); } );
        
            this.addChild( this.ropeNode );
        
            this.model.cart.xProperty.link( function( x ) {
              tugOfWarView.cartNode.x = x + 412;
              tugOfWarView.ropeNode.x = x + 51;
            } );
        
            this.addChild( this.cartNode );
        
            //Add the go button, but only if there is a puller attached
            var goPauseButton = new GoPauseButton( this.model, this.layoutBounds.width );
            var goPauseButtonContainer = new Node( {children: [goPauseButton]} );
            this.addChild( goPauseButtonContainer );
        
            //Return button
            this.addChild( new ReturnButton( model, {centerX: this.layoutBounds.centerX, top: goPauseButton.bottom + 5} ) );
        
            //Lookup a puller image given a puller instance and whether they are leaning or not.
            var getPullerImage = function( puller, leaning ) {
              var type = puller.type;
              var size = puller.size;
        
              //todo: compress with more ternary?
              return type === 'blue' && size === 'large' && !leaning ? pullFigureLargeBlue0Image :
                     type === 'blue' && size === 'large' && leaning ? pullFigureLargeBlue3Image :
                     type === 'blue' && size === 'medium' && !leaning ? pullFigureBlue0Image :
                     type === 'blue' && size === 'medium' && leaning ? pullFigureBlue3Image :
                     type === 'blue' && size === 'small' && !leaning ? pullFigureSmallBlue0Image :
                     type === 'blue' && size === 'small' && leaning ? pullFigureSmallBlue3Image :
                     type === 'red' && size === 'large' && !leaning ? pullFigureLargeRed0Image :
                     type === 'red' && size === 'large' && leaning ? pullFigureLargeRed3Image :
                     type === 'red' && size === 'medium' && !leaning ? pullFigureRed0Image :
                     type === 'red' && size === 'medium' && leaning ? pullFigureRed3Image :
                     type === 'red' && size === 'small' && !leaning ? pullFigureSmallRed0Image :
                     type === 'red' && size === 'small' && leaning ? pullFigureSmallRed3Image :
                     null;
            };
        
            var pullerLayer = new Node();
            this.addChild( pullerLayer );
            this.model.pullers.forEach( function( puller ) {
              pullerLayer.addChild( new PullerNode( puller, tugOfWarView.model, getPullerImage( puller, false ), getPullerImage( puller, true ) ) );
            } );
        
            //Add the arrow nodes after the pullers so they will appear in the front in z-ordering
            this.addChild( this.leftArrow );
            this.addChild( this.rightArrow );
            this.addChild( this.sumArrow );
        
            //Show the control panel
            this.addChild( new TugOfWarControlPanel( this.model ).mutate( {right: 981 - 5, top: 5} ) );
        
            //Show the flag node when pulling is complete
            var showFlagNode = function() { tugOfWarView.addChild( new FlagNode( model, tugOfWarView.layoutBounds.width / 2, 10 ) ); };
            model.stateProperty.link( function( state ) { if ( state === 'completed' ) { showFlagNode(); } } );
        
            //Accessibility for reading out the total force
            var textProperty = new Property( '' );
            model.numberPullersAttachedProperty.link( function() {
              textProperty.value = 'Left force: ' + Math.abs( model.getLeftForce() ) + ' Newtons, ' +
                                   'Right force: ' + Math.abs( model.getRightForce() ) + ' Newtons, ' +
                                   'Net Force: ' + Math.abs( model.getNetForce() ) + ' Newtons ' +
                                   (model.getNetForce() === 0 ? '' : model.getNetForce() > 0 ? 'to the right' : 'to the left');
            } );
            this.addLiveRegion( textProperty );
        
            var golfClap = new Sound( golfClapSound );
        
            //Play audio golf clap when game completed
            model.stateProperty.link( function( state ) {
              if ( state === 'completed' && model.volumeOn ) {
                golfClap.play();
              }
            } );
        
            //Show 'Sum of Forces = 0' when showForces is selected but the force is zero
            this.sumOfForcesText = new Text( sumOfForcesEqualsZeroString, {font: new PhetFont( { size: 16, weight: 'bold' } ), centerX: width / 2, y: 53} );
            model.multilink( ['netForce', 'showSumOfForces'], function( netForce, showSumOfForces ) {tugOfWarView.sumOfForcesText.visible = !netForce && showSumOfForces;} );
            this.addChild( this.sumOfForcesText );
          }
        
          return inherit( ScreenView, TugOfWarView );
        } );
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * The model for an item that can be dragged out of the toolbox and put into the play area to be pushed.
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/motion/model/Item',['require','DOT/Vector2','AXON/PropertySet','PHET_CORE/inherit','DOT/Util'],function( require ) {
          
        
          var Vector2 = require( 'DOT/Vector2' );
          var PropertySet = require( 'AXON/PropertySet' );
          var inherit = require( 'PHET_CORE/inherit' );
          var Util = require( 'DOT/Util' );
        
          function Item( context, name, image, mass, x, y, imageScale, pusherInset, sittingImage, holdingImage, mystery ) {
            var item = this;
        
            this.name = name;
        
            //Non-observable properties
            this.initialX = x;
            this.initialY = y;
            this.image = image;
            this.mass = mass;
            this.pusherInset = pusherInset;
            this.sittingImage = sittingImage;
            this.holdingImage = holdingImage;
            this.context = context;
            this.mystery = mystery;
        
            //Observable properties
            PropertySet.call( this, {position: new Vector2( x, y ), pusherInset: pusherInset || 0, dragging: false, direction: 'left', animating: {enabled: false, x: 0, y: 0, end: null, destination: 'home'},
              //Flag for whether the item is on the skateboard
              onBoard: false,
        
              //How much to increase/shrink the original image.  Could all be set to 1.0 if images pre-scaled in an external program
              imageScale: imageScale || 1.0,
        
              //How much the object grows or shrinks when interacting with it
              interactionScale: 1.0
            } );
        
            this.context.directionProperty.link( function( direction ) {
        
              //only change directions if on the board, and always choose one of left/right, and only for people
              if ( item.onBoard && direction !== 'none' && sittingImage ) {
                item.direction = direction;
              }
            } );
          }
        
          return inherit( PropertySet, Item, {
            get: function() {
              var parent = PropertySet.prototype.get.call( this );
              parent.image = this.image;
              parent.mystery = this.mystery;
              parent.name = this.name;
              return parent;
            },
        
            //For unknown reasons, the trash can is not centered when drawn, so we make up for it with a workaround here
            get centeringOffset() { return this.image === 'trash-can.png' ? 5 : 0; },
        
            //Return true if the arms should be up (for a human)
            armsUp: function() { return this.context.draggingItems().length > 0 || this.context.isItemStackedAbove( this ); },
        
            //Animate the item to the specified location
            animateTo: function( x, y, destination ) {
              this.animating = {enabled: true, x: x, y: y, destination: destination};
            },
        
            //Animate the item to its original location
            animateHome: function() {
        
              //Make the characters face their original direction so that they won't be displaced within the toolbox, see #16
              this.direction = 'left';
              this.animateTo( this.initialX, this.initialY, 'home' );
            },
        
            //Cancel an animation when the user clicks on an item
            cancelAnimation: function() {
              if ( this.animating.enabled ) {
                if ( this.dragging ) {
                  this.interactionScale = 1.3;
                }
                else {
                  if ( this.animating.destination === 'home' ) {
                    this.interactionScale = 1.0;
                  }
                }
                this.animating = {enabled: false, x: 0, y: 0, end: null, destination: 'home'};
              }
            },
        
            //Step the item in time, making it grow or shrink (if necessary), or animate to its destination
            step: function( dt ) {
              if ( this.dragging ) {
                this.interactionScale = Math.min( this.interactionScale + 9 * dt, 1.3 );
              }
              else if ( this.animating.destination === 'home' ) {
                this.interactionScale = Math.max( this.interactionScale - 9 * dt, 1.0 );
              }
        
              if ( this.animating.enabled ) {
                var destination = new Vector2( this.animating.x, this.animating.y );
        
                //Make sure not to blend outside of 0..1 or it could cause overshooting and oscillation
                var blendAmount = Util.clamp( 15 * dt, 0.1, 0.9 );
                this.position = this.position.blend( destination, blendAmount );
                if ( this.position.distance( destination ) < 1 && this.interactionScale === 1.3 ) {
        
                  //Snap to exact final destination, see #59
                  this.position = destination;
                  if ( this.animating.end ) {
                    this.animating.end();
                  }
                  this.animating = {enabled: false, x: 0, y: 0, end: null};
                }
              }
            }
          } );
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * An observable array of items.
         * <p>
         * Because the array is observable, we must be careful about the possibility of concurrent-modification errors.
         * Any time we iterate over the array, we must iterate over a copy, because callback may be modifying the array.
         *
         * @author Sam Reid
         * @author Chris Malley
         */
        define( 'AXON/ObservableArray',['require','AXON/Property','AXON/axon'],function( require ) {
          
        
          // modules
          var Property = require( 'AXON/Property' );
          var axon = require( 'AXON/axon' );
        
          axon.ObservableArray = function ObservableArray( array, options ) {
        
            this._options = _.extend( {
              allowDuplicates: false // are duplicate items allowed in the array?
            }, options );
        
            this._array = array || []; // internal, do not access directly
            this._addedListeners = []; // listeners called when an item is added
            this._removedListeners = []; // listeners called when an item is removed
        
            this.lengthProperty = new Property( this._array.length ); // observe this, but don't set it
        
            //Store the initial array, if any, for resetting, see #4
            this.initialArray = array ? array.slice() : [];
          };
        
          axon.ObservableArray.prototype = {
        
            //Restore the array back to its initial state
            //Note: if an item is in the current array and original array, it is removed and added back
            //This may or may not change in the future, see #4
            reset: function() {
              for ( var i = 0; i < this._array.length; i++ ) {
                this._fireItemRemoved( this._array[i] );
              }
              this._array = this.initialArray.slice();
              for ( i = 0; i < this._array.length; i++ ) {
                this._fireItemAdded( this._array[i] );
              }
            },
        
            get length() { return this._array.length; },
        
            /**
             * Adds a listener that will be notified when an item is added to the list.
             * @param listener function( item, observableArray )
             */
            addItemAddedListener: function( listener ) {
              assert && assert( this._addedListeners.indexOf( listener ) === -1 ); // listener is not already registered
              this._addedListeners.push( listener );
            },
        
            /**
             * Removes a listener that was added via addItemAddedListener.
             * @param listener
             */
            removeItemAddedListener: function( listener ) {
              var index = this._addedListeners.indexOf( listener );
              assert && assert( index !== -1 ); // listener is registered
              this._addedListeners.splice( index, 1 );
            },
        
            /**
             * Adds a listener that will be notified when an item is removed from the list.
             * @param listener function( item, observableArray )
             */
            addItemRemovedListener: function( listener ) {
              assert && assert( this._removedListeners.indexOf( listener ) === -1 ); // listener is not already registered
              this._removedListeners.push( listener );
            },
        
            /**
             * Removes a listener that was added via addItemRemovedListener.
             * @param listener
             */
            removeItemRemovedListener: function( listener ) {
              var index = this._removedListeners.indexOf( listener );
              assert && assert( index !== -1 ); // listener is registered
              this._removedListeners.splice( index, 1 );
            },
        
            /**
             * Convenience function for adding both types of listeners in one shot.
             * @param itemAddedListener
             * @param itemRemovedListener
             */
            addListeners: function( itemAddedListener, itemRemovedListener ) {
              this.addItemAddedListener( itemAddedListener );
              this.addItemRemovedListener( itemRemovedListener );
            },
        
            // Internal: called when an item is added.
            _fireItemAdded: function( item ) {
              var copy = this._addedListeners.slice( 0 ); // operate on a copy, firing could result in the listeners changing
              for ( var i = 0; i < copy.length; i++ ) {
                copy[i]( item, this );
              }
            },
        
            // Internal: called when an item is removed.
            _fireItemRemoved: function( item ) {
              var copy = this._removedListeners.slice( 0 ); // operate on a copy, firing could result in the listeners changing
              for ( var i = 0; i < copy.length; i++ ) {
                copy[i]( item, this );
              }
            },
        
            /**
             * Adds an item to the end of the array.
             * This is a convenience function, and is the same as push.
             * @param item
             */
            add: function( item ) {
              this.push( item );
            },
        
            /**
             * Add items to the end of the array.
             * This is a convenience function, and is the same as push.
             * @param {Array} items
             */
            addAll: function( items ) {
              this._array.push.apply( this._array, items );
            },
        
            /**
             * Removes the first occurrence of an item from the array.
             * If duplicates are allowed (see options.allowDuplicates) you may need to call this multiple
             * times to totally purge item from the array.
             * @param item
             */
            remove: function( item ) {
              var index = this._array.indexOf( item );
              if ( index !== -1 ) {
                this._array.splice( index, 1 );
                this.lengthProperty.set( this._array.length );
                this._fireItemRemoved( item );
              }
            },
        
            /**
             * Removes the first occurrence of each item in the specified array.
             * @param list {Array} a list of items to remove
             * @see ObservableArray.remove
             */
            removeAll: function( list ) {
              for ( var i = 0; i < list.length; i++ ) {
                var item = list[i];
                this.remove( item );
              }
            },
        
            /**
             * Pushes an item onto the end of the array.
             * @param item
             * @throws Error if duplicates are not allowed (see options.allowDuplicates) and item is already in the array
             */
            push: function( item ) {
              if ( !this._options.allowDuplicates && this.contains( item ) ) {
                throw new Error( 'duplicates are not allowed' );
              }
              this._array.push( item );
              this.lengthProperty.set( this._array.length );
              this._fireItemAdded( item );
            },
        
            /**
             * Removes an item from the end of the array and returns it.
             * @returns {*}
             */
            pop: function() {
              var item = this._array.pop();
              if ( item !== undefined ) {
                this.lengthProperty.set( this._array.length );
                this._fireItemRemoved( item );
              }
              return item;
            },
        
            /**
             * Removes an item from the beginning of the array and returns it.
             * @returns {*}
             */
            shift: function() {
              var item = this._array.shift();
              if ( item !== undefined ) {
                this.lengthProperty.set( this._array.length );
                this._fireItemRemoved( item );
              }
              return item;
            },
        
            /**
             * Does the array contain the specified item?
             * @param item
             * @returns {boolean}
             */
            contains: function( item ) {
              return this.indexOf( item ) !== -1;
            },
        
            /**
             * Gets an item at the specified index.
             * @param index
             * @returns {*} the item, or undefined if there is no item at the specified index
             */
            get: function( index ) {
              return this._array[index];
            },
        
            /**
             * Gets the index of a specified item.
             * @param item
             * @returns {*} -1 if item is not in the array
             */
            indexOf: function( item ) {
              return this._array.indexOf( item );
            },
        
            /**
             * Removes all items from the array.
             */
            clear: function() {
              var copy = this._array.slice( 0 );
              for ( var i = 0; i < copy.length; i++ ) {
                this.remove( copy[i] );
              }
            },
        
            /**
             * Applies a callback function to each item in the array
             * @param callback function(item)
             */
            forEach: function( callback ) {
              this._array.slice().forEach( callback ); // do this on a copy of the array, in case callbacks involve array modification
            },
        
            /**
             * Maps the values in this ObservableArray using the specified function, and returns a new ObservableArray for chaining.
             * @param mapFunction
             * @returns {axon.ObservableArray}
             */
            map: function( mapFunction ) {
              return new axon.ObservableArray( this._array.map( mapFunction ) );
            },
        
            /**
             * Starting with the initial value, combine values from this ObservableArray to come up with a composite result.
             * Same as foldLeft.  In underscore this is called _.reduce aka _.foldl or _.inject
             * @param value
             * @param combiner
             * @returns {*}
             */
            reduce: function( value, combiner ) {
              for ( var i = 0; i < this._array.length; i++ ) {
                value = combiner( value, this._array[i] );
              }
              return value;
            },
        
            /**
             * Return the underlying array
             * @returns {*|Array}
             */
            getArray: function() {
              return this._array;
            }
          };
        
          return axon.ObservableArray;
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Constants just used for the motion screens
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/motion/MotionConstants',[],function() {
          
        
          return {
        
            //The scale mapping between model units (meters) and stage coordinates, How much to translate model coordinates into view pixels for translating the background ground
            POSITION_SCALE: 40,
        
            //Coefficient of friction (Friction is unitless and not bounded between 0 and 1)
            MAX_FRICTION: 0.5,
        
            //Maximum speed in meters/second before the pusher falls down
            MAX_SPEED: 20
          };
        } );
        
        define("image!FORCES_AND_MOTION_BASICS/water-bucket.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/fridge.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/crate.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/girl-standing.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAADECAYAAADOIzJBAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAABNGSURBVHja7F0JVBvnnf9LgATikLjBgBnA4APbjK/EtE5REh+Jna1p13bTeBNw43Vjv21NkrZ5TbobkrfJbrpvbdJmt9ukSXHfpu3G2Vc7teOkm8YiTkviEx/44JTNYQ4LJCTELe33H2lkCTSj0cEl5v/eMNLMaOb7ff/7/33fILFarTAXSBLg+ynJpiYbnZseq5aFhlBUqpJyd+HA0CjoTYOa+tZevdE8rCGHcLs404FuTUuIKl04P744NyMW6AXJXv1YZxiAupYeuNLcrT9f13mEHKoINGh/gZbkUwnl6wrSKW/BcZF5cASqa9vgL5dbNbd1/eXkUNV0Ai1IjlVUPrYhn87LiJs0vfrzOS18fLr5CBHtMvL15lQDLXlgZWbllsIcUISHTboRQQ6/+3+1KNII9pCv9wnx8vpfP7Fpafmme7MhLDQEpoLwOasWpoRHyEOLr2p1aNiOTipQZaT81/u+sbKUzk2G6aDseSogakJfI2CHRsaOThbQg6Wblz2Vn5U4rb4wXhkBC+fH0Zcau70GKwRoCRHXf12zKHVGOH4iWQzYU5davRJjT0Az1y1PP7K5MCd8JkU5CDY+JoK+2NilJ1+/9BtoanzkkSe3FCyaKsPjDWUkxWB09VDzbQMGGJ2erpfyiezX1+Wqp8KF+Ero4qgU5RF76OkTR5Uk4vk9AarypyE1DZ3Q3G5gen+yXE9SrEL1RW37oKcIioujZRvvyaL8bUhzRz/o+gY4zx/4n9N+g8XIbG3+PAwVM70GSrhZ6m9ohxFNxvwFvNf0DYwxAb2/tF29CA1UOd81oe50czw3MebEtAqJRCi8osh20MWGLtj5rb+Dn71zi7MjsjPSoaW7j/GP/hDaEeIdSo9XN5ZzxcShbiytCzcR5EMbH4GH7lvDfG+53Q2tHd1uH2gw9cPVettzsvNWQn4uBdlUNlTX9Tiu6ejqgjCphRHp3Tu/Da/95zvQ2mW06Vx4DMREKbglwGSG1TnRbjuGxN/w+aXWckP/0C4hQX0msWTaR76ywNHrp26Y4Y0Xy2aEla2+cBU++fMHnPnu4ZPX4dPzNyl3XB2vo8WF+WmOL+RH8NyenTPGnRSuWOLgvjtCrhIq9WiMctNji53FIj6ZgoxU7vjWYOxnehk3/Dwl2Ux4DG8svGZxaqknHVUSI6N2iMmVNvha0SbOm773YRUcOXURJCFhQFEUfPBlAxTlpzp0mYtQxw+fsLm89JRE2LG5yLvAPiGF/LVwnl88P546c+321vFxsDNH1QULku4aDf0Qb6Mv3DLAxcu1UFVVBYcOHYLsBbmgucRfBPjo1Bl46pVfwbmmbmjsGQFJUh7s/sfXvQKav4CClq4+7tIHwUBcTTGf6LqURRKYnuMmlUoFBoPB8V2v17sYDeTcePrk9FXmd9g5R48ehYqKCvhWyR6ordcKB5qbyaun6Gpy0lTcQLE86XwiJYk/wc6KsUJRURGUlJTA/v37GaAr7fnqkgWZDvF0pugI17gZRV6r1RKXEukFUApau4281yzNSsTQtcitjjrrpxBC3UIr+DERR7D0wqNb1jgMlzLafcPLHt8KPzzwG9i6dSsDsudONyiHu8jvFvugp8ArvvAxFDvHvyzQzLgY15Szpa3Fc6pEgO3esdmtNXabKZAOePPFvYyoovNfsmk5Z6fwPjctg/zlF9/seSp1U7t+guhS48M6g6HH98SYNP7J7Q/zih9Kgy8gGdUgeooFbz4i6RvtnL6xQNXpidEuF6ao5F4ZCXfhGutOAk2eLC9jczJiGQM7wRiNT7DRAr93wrciOVrdwh3fs0UzZI/fA1pdICrTSdwfb/qWzngQtYuOrsxLVruLMj692OhzqFb74dvMZ9z7KqKe9ZQ/o0lLiKLb7pg8llIgPU7GOHlf9ZTPAvtL6P4w6eD19VHhtAtHYyLlbqsJhUvT4A8fn+SNkFCPf3X4BGSkJDoMhVKAX0Rx3nTfasYw+So1f/38BPAVCHDIslZ75y7QyPAwzqelqyxMXMsVk7INzVj+VSgrKwONRsPbQAwsysvL4cGVuT6DZIOSyt/18AKNj2ESFGx4VainG2Lu99sTJ5ge5MpkDj6/lxHxv3l4Azz73AugVqvdAsSQ7/q5v8B/vbCbNysSqhp8mQxrZ1CCHYk3SbatbLLNVfY4Ut0Ov3u93GMDkPufnLkKa76qBpqmmRCv8UYtdN6sh2d2bfMboDM9/+9vQWFOKG+7n/2PT7HRL4UKuSFasPvyY5kbv/rs33sMDVkxr75wAdamJcL21evJt/UBN0iddwygS1Bw1pzsLlPFWt2C9KRoz+acRE7p0WYGrDcGI5AcdKanX/0FGHrbmeIab+CQHkuzQFUKubBqPAv2iR+8OmUVBXdxNHZ2hEUHJQ8tg/qWXt7roxUyz36UC+wDy1Tw5HOv+BUi+kL4vKd+8m9MZ6PrY8uvfDQ0PEY5gJqHRrxLk4hOlGzMhdfe+AUceOf9KeEiPgefV1w4b0JdGUuyXIVwdvqPIKvLR5hFnG0wwk/+odQvv8gF8G0SjHxW/QVsXJPBWThHkDiTBWvFGOOy3EY69tcGOF7dKPEbKGvGsTSqUKXDbpKe+QsYffJnp2ug4/YtWJ2X4NUgFQ5s4SgBJt8YAwQUqHPPHvroMizPXwpScuuM1CTG8mK1j8v6skk4hoRNLa1gNuogKyWS4Yw/Q5YIGA0V6jACDQ2kqKHuYkj20+e+y3zHoYvWjjtwXPMl9PWb3YeYyQmQRjri8W9sgANvHoJNBdkBaQtyE0PAg++duRvrGvqH9KxjDSQhJ3FbSwurCXX0mPVv/bGxxsnh08pIudt2ccW4CI4NIBh3mBgN9a29NqBXmror3/pjDeNYjeZhPKHxFVxmWnIpGjtffhsaJqs5X9d5v5BQl4gjzcVMd0xjgOpNQ0+TBwSEiySrUPsK1BuDDNwj3G6PS2GO0JwBGiiri+kKTTwIbTZr6T5Tv1fVd1vVsJ/0erP6xb1SZkr4hWvWGrkM9De0Vv2lOmANFNoONJxez+X1ZXYnO8taXbRaQtMLQU0vkoB6tQSoNAlo26yw79V02Pf4HqYKIIT+96PP4NTpd+E3/zwIqhj3TcL7atvJvt22b7hl1Q6PgPbwn6zYCex20V+gBWQr/goNxWvyJXTxA1JQr+H+qb7PChXvWqHtzgpQKDLh3oKJ7qWN+NjrTdcgUnYevvngIO/9PAYH161Qc8PK7E+esR4hEoCcr7QbLY9AkR1lO7dIitevlVDF90s4e5uPWE5MqNCRFBglYTIIn/mjgxY94bZjjq+7JykTY+HIvkel6rKdvoGbKbTjB2MIFl2dYQIKIp4Xjr8RQs9mgM6czXp4DLn6+nj3sv+V7wUHSCYXJcaRMK50gh+9ZxmU+WMUZiJtKJQyo2rOQDO//bCUgiAjdHvo410ma9gPBhURP89gc5msMVnmfjoJ7c3yPCeObt8ooYM1zqXmSSgHUFkYUMEKNCvNiaML5kuCFiiKr9QpUHfrcIPF8rJAaXcWt+K/LXMj8Q6aCGkeD1BMtcbTyCiAhRzGM7NJqDEU5ARac8MRVdxlP7laKrGlPOyZQAMeG5tc0aXtEYTggoTV6Zh36+El/OekoZMiLSxQlRB9tA1gSF2aK5F4u5yLGwbTYeSPxMOvKo96byTZ4phGsny0nEpLKf3mxnWMP23p6Ibnd33u2isSV+1kPlms47jlOz8k5P4hkjHu/pHcLZ3AVt+AYtG3ShYWqn7mO9sYoDge6Sn2xbMWGGP0NpBkdSPgEqcDWJpBY+mNV3Apd9ZpWzXgNH+O6+EWqwQ1085l5/OB0S5Pza/4kZQpvv2pOo8ZrbOJPboDC9kTsbaQvWWM2SyWETh9pWlCXVeLw3huxzedkNpEePIIOxKfYeUAje6ifK8EjINLmCk92DgrgrMScGOjZBsBy+gws42NDMDPCeDx7kXLTj+dTmIlI5AaMR5oDdeUU4tViLhJBNhWobIbWMUfD9SA68vcUYhUqBnx3/FLJiEUmdD8zju+j426WLkZtlp6AtDTl65rgzEnnQC0S6efG0BZg9TS0R30QPVokHLS7wQ90Cp2VW+wA4VOXa9+TgA1GPtr5gTQYye/mBtAmZKRqX9OANXUBplB4uSoKnpuiO7FYBtZE6fIBRNd1XbUzFqgmjNWWCJwSvvlhvaaWc1RJc8LZFgy9g9Ct96knbVAcU6gkImV1252MF6EC2gBjkDNbKC2l094otO1zbhTcQFVUfOCw72YBvSz2+p26+cLuk4u74Ci1RJ16GwFKnTic3JCB+gMs5ijvX2eLe7V5nZmtHtomFtHZzxFKjwbomsMUAmsWCyhuYBSwRDUt3X1OmZ2cwKdyUG9LSryzNGhEdsLM3A0f9aKrpB3PZgHbXPcVdGS2QkUFwqkp/CvHe/rH4DsjEGbeM4L3LqXKSW9EezLNLkHoq42tTEz38peG4P2btDMTqB9nkfarhGghz6wqsG+Vo0LqH7r98dq0CyjItMLbYt3psvwMPuztv3lpjjCoRjbq4RWcC/XbGjp0IPTgjyPrc/NzbPGxceDyWiEZdk9ECoxQU6a7dU5zhOuhM7FH78OBvVNb3+rVmNbFIxao5jvnX22d27Hx8WDTC6DOLKXy+WO350/fw7SY+Xw/HcfhYyUhAlD+yUv/ExbdfZqllCgyhUrV+lXrlw10XQPDUFPj475PExCD539syeSyWQQTzqOpaioaIiO9s1pYxuuXbkIRXQOPPm3GyE6MtwBlNr0lAs+T0CLNm95RJOaOrNzNp3uDrRp6+HRjffCtg2FUFvfDDt+WAEmk8mBb9YG9c4UH5/AbCfOaeHE5xdgaVYqRBEpIUAd1wRVcSyToiBz8SqobtBBZiZTT8oUCpRCnZpttHTpMtYOUIKBokgEA4kF7NlOdpUTJroRCgU1my2xYKApySmUKLoi0JlDcXFxtCCgUunsXk+qVKpUgoDGKJWijopAZ5IvlcsE6WjBbIxznUmhiBSkoyrnBFkUXRHo9FNUVBSjgp6A0ljPmc1kr0WpPOqor0UrUXRFoJOlo4xE0rxAnQNif8hoNM5sHXUOiH0lLDDX19cFv+hiJT81NVXU0akglcr2D3ukQgJiXwnHZKabYmNj+TnqHBD7SjpGdGfGuE1Axl5wkGd4eCL3TNNocQUDbW5q0uh7ba9GHxgcgI7btzUcl6oP/Hiv2jHUzozXWpm11juOH4OvFamnOVVTqHmB6vW995NN0M12bGbRsO8XsS0qT5kBFldmHzyeVKs7E4xRQHWUi/IyEiF6uBP6jCbo6O0HmSwMbnX1gVVqeyzrY22j4MIGs5xH2p2jL+exUCSzuV9POrqm165+kwr0vYof29+HMArW0RGwOF4bMAg///0n8Mb7xxiRL6SXaLJVS4CdTnOzQwcWImxxijCIiYpg1ADnKKBKRJJ7bVqbSe43DE+8dKgSbC8j9fgq2uke8WZmjeBLI575zjYHUHxfCvMCCXYCBgFnYeYmkP3oENNZ1lFmspQWPPwTZDFNE4GKQEWgIlARqAhUBCoCFYGKQEWgIlARqAhUBCoCFYGKQEWgIlARqAhUBCoCFYGKQEWgItAgpWlf403Jw/9wreosvFzn9K5QdhYP+dvb1QMyvfsXpj6WkFx+1mQsrRs0Z00LUIPJzKyctw3Pj0Ftw00w9BntcxHGoLuuFfS6PlimiDz5oDJOvV6uBOjhmMESFg2QyD0TPClMRtXdNuO/7uUd4vfndRklpKGlMomUWkUvorq1t2FEqYRV27fBucPvw8LEJHik/J/gWPnLsK7s+0DTNHy6fjMkO62lebOjDR5LTIGoEN9fam8aG4N9Tdcre0ZHdwWao0VpMnlFaVIqXRht/y9kyI2YeGhbsgj2lJfDm7XXIWbRQlCr1XBW9zSoVCrQarUuIFnyByT7+3uiYoo/0vfsCpQxylSGhJwsS83Q/DJn0V2QLlJmE7FRIqbsZ71ezwAd6XOdF9g0OOAWuC+0KioGJ2hu9RcoIjpIFF/7y5zF6vWqOM4LkYtIfddvQFhMNAOya2SYEVs85kyXzSZYG6UMCFDs9LjQ0GJ/gJbQiijt2zmLy7zVJQRdU1MD2fIIt+cDyVEkFF9fdDRzvkxe+XhSqtqdiHJR/D2rGXBZ4RFuuRzudG2kNLD/VQPFl+gpiu9RoRzd//XYBO1PqVyvQLLkLK6602chNMamqyNOc3cv95tgWWRUQIEuUzD3UwsRXSUam3+Zn1OxJyXNa2vYOTwMFEWBua0d+onJV9kXWSjSbDOwB9raXfTT3rCAEbZ3XbSS9gS0IC9cUYPGxteeRi4iUAQUwYJrJ5/nTQSKvs9ft+KO4kLD+Dm6OEJR+fL8bCpQD2eBmtvapzSc5Gs/Ai15IjGV9hdkHDFESLozZx3H0J+igdJoNC46ORncFJK9UIE2DPFrVjssLV/oFmjiu2fA0jTW6DiD6yR6i0ap+viHjKWtNhrgt90dzPFm4kcDTT2jIxq+oL6EWNpKLq5iA8dHNM7UODhQEyaR6MeoTEgnPvPw4cPjHzb+e5U92ipzk7LR6TK5z+ttSLqm6RoZecnduf8XYACE1RwjEbtR1QAAAABJRU5ErkJggg==';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/man-standing.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/girl-sitting.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/man-sitting.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/girl-holding.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/man-holding.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAACiCAYAAAB21CJRAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAABmySURBVHja7F0JVBRXur6gIFtDQaM0bhSyuEuro8a40GKimcTE1vhi1EyATGLyTN4B9Eyc9ybvoZmZk8mbE9F5meQlkwxgjtG8LLTLzAnZaIy7iUJEQRRp0iigdNMoIuLCu39R1RbY0LV3NfCfU6eru2u93/2/f7l/3fJB0giBFz29ED1tND4uJiludLTz/0pLLaqsrkVLFjxAfffzG0zGjtSRzP8fmb42XbE3L+NxHbCvsbdrmD11QrKWCO31ILrICEOoJohav3qtFX3w6T/T8WoeUqF0dHSgwRIch8QgnExdtogYFT0UtVpLeOw6EdkGj0CF3/+AVs+OdvH/w8Ytf/+M83XM+8Xkk5tXzySkbaYwVFoxNuP4qbNwY6n0j7vpdQdemqmNOmUz/ZuiIgWIxtfWrSEAvFbrRUEHuNpy/b7f9pU1o537irZyPUZUZHi21ABCB/vL9gIHBhCAKcBLOq3lBTRY21hgAmNk02zEBjQDL6V42SoXiD5iDzBj8tiTb6bP1fe2zX7LbVRbd4VaB5oCimI+JybEoKTIduq/0kZ/9ENZpeObQydMDY1N0AgWrlq4/rkV1UsmhUkCHDDDt4dPWKpr6x0srWNo3sKiawe9zv6NpL/DUkzvC/+ZaTCT6P+yaMAdPO5TFjol5s2YrHe30Wz9BORHVnahKCdVNSK0Ze9px76iIya6wUx8LwK0UAyA0Hm+xMAdPnkGWMFCN6yDbmQ2gAyIJL2wgYP1EpaPwN6G2S6Zpalwr0vp9W1igBQLon5iPFxnU68b+Tkqu3wPGqVH//ORybFjz7cAWD7dSwXTuX58fBpokPb2Rd7AFX5/3JVzZGE1fneKNvTg2CGWZrH3K6F/N3Q7Vi7rPHp6Pd0zIGI6bLU2cd7hQ7MFg/ch9Lyt3235tSNl/Ydizp+5+fU/5ISEhKAzjhZUWtqMfFpt6NF501FsQFOP4IGzZK2/wsXTdSebaTvYXUu7tFE3oB0srTV2++0k/RmrJIgEH290Y+6BEuwkLMPgWZAEMnPmrIw5c+Y6vzPrXxV+id796hja+NyyLtr5u48OU5TZi7CpsidQ2JLNAXgTSwsdrE+jixDNTB8jl7aZDiVAvE+q28KphhocTCDbtZsoMESDWlpa0O3rDoQBNEsFINy0wbDAZQMvWvwItXzx+Weosfo8eunheFcAOlxQJenqe/wILfXl/EVbZxwZoUH19msoJNAftdxovxdf4t9B4D823bugXVfi6LaPgQbSpBiI//v1edR8NxA9OCcWPf3Sqy63SV60JDNlfSaiL06UaLXajAdZWuhKlj+5AlVV6dG/v7MVHS05w24sh5sGvU8YADuBu0l9hgQOoX5bPCMRFR6v7AIeG2BYB2EBzj73MjoMMdAL+9oglFngzmcYJLItLTcHEwbTycu6lzI2ogULUtDo0aN7zoTodMhmt407V1n5Hv7aJubEKQsfyktONgS42y4iIgKR8Ylo3949zE+wD4G1htq3/fadTrWOj6ZA8ffr7NcRoUGUBoJ22a/dcALg7zeI+m3jqmQKNB8fH9TQ1ELtC9sxAtsxx14wNQ5ZLzuc3wFUZh3LOFBe+pPROh3dPnCNNTSw9a7ub9OmTchXLIiVdVdJ7FwgcC64yBNPLCW6UYwQScP2kLMmxcXFU/YSGp4RAACAgQZ9cv4kah20DX4H8OCz5Hwd/myhtmEoFbaD//ILT6CqS3YnrTKaytAvo6XwX0PTtS60C/8zx6NtoZFFo3qW1woORwxeivCS05N9FgsiunPnDp88G9WgMSSZKuacY8bELZ3jhkrvv9B2ivIY7WIEGvfz/WUUGPA7aGRSXDTV+J3a6e8EHTpB6uJp1DEAYF1ECLVPcIC/cztmW1jmTIqhjg//MwLUGzdc6/yfvR+IJnCIgwUWk4+GNs7sCUjRGRs4+I4du3KidDrOO4DD8c47b8cKDHAJbOua1q17hfMO4Fg98/RyJ2jQ8HHDI1BpVR31GwAzZxJJgQzrXfbF21ddslEN373Bmf1BAChGu6BTnL9od3YathaygWbsJmNTmWsBLWd5tnpW4gGx4kkzk7GRAkQSN2g1OBFcpaG+Hq1Z83SWwHxi5nvvf5ADGs1VIOQoLfrCqTkA4PW2dkrjgC7hdwaw7kCJFQCaDTDz219NRygKhuuB62BAhO/gOLGAN6Ouo0MWWjMBSIdUIKKJkyad3LbtbT2ffTIyXik5XVY2VYlz/fmN19HGR8cgNQpoXeHxc3QnukkBCraWWT9YVuNwEa8yHu0yANFXigvBYOSDdvGR5PkGPYsiOGs9vR8vKkXNtUitAvT5/oZlmFITKEqn/AbMFPA7sAVmBiYRYGKFH0XsbJCvRNdiOnjwAK8dIBhH98bnOCswvR9nOYSva+7kGKRmAQoH0Daumo9+/9zD1MI4RCwaTmNRqpleN0oJoqV4v5mXlwohycKHHuYVasD2XEMZp/05cYzyAnsTsItAafCpJg0FbzgqXMP2pgnW527JQgwxlDp92nSSB6Ua6O0lp9K1b32B3txZTH0KtWsp6z9AT/xuu6QdATQUtBMcr84MkT9ieapLGe/eV8LOw5tSIW0G6TOOabbUB3nGhkClj8xMcA827Qm6CgW4eqDM/gfLLJJrJTg4cGzae2a00UA7N5KCKIhSH5j9ICdKhe34UmlVeSnVAO4k5+XHKPqCTyECcR4kBoC2YV1qgWMySQp2qCI5nQql1JSUhQRttCVLs92jUivnng4gcgHcdSMnoC3rHqMcEqnjzM7YMQS9bHzAmVSgKXUzHWpIC6IQSk1K0qNRo0ZnSJ1mAyqFxhUjQF8QlKtBIGPEUDfWRujQYXLYREGUCrJq1WqmfMFlmk0/dSrvhDlQqSvq4euwQHJcLWHIx6+tRHv++Cyj7c2y0KlQSoXYL4Yks3v427iYZ2zYqUYNou6DGb1gUnJqktfTH5bPJgqlVJCVTz1tcKWNQLV88qSUFladR/E6jaibgFymWrTQlVbKDaIgSgVtxIDldPuZfPzxJ/im5lDV+fNU6krqxlKryAGiIEpl2Ua2p2rkPW6I5Txookh7CCEDa0hIVUIPQFtkBVEopYI2jhgxwmkbx40fn8FnnJIRDbouSYANQIJ3CmCqCVA6uWCWG0RBlAqyZs2vSNo26p94fCkpKDS4YpXkJgBIiM8ghuw+WOxJ2XOovEQJTRRMqSxPlXeazenUiKRSNQsk6q2Xm7fJbhPFUCrIY48uMQgZsZDSqVGjQPLh429LQAvzlAJRMKWCHeQ7YuG0F6UlvDURHAWhyW8lBewz1sJ0RbxTsZQKQAihUiosEODUgNMiNr3GjEmyi6ekplEcuwKAJYqCKIZShVApdBhd4C3e+8HgK1S0/effv+5SP8rFS4QOsPatArT6D7vQgVMW2QB8c2fxVtTDI+c+clMA38ImBnQh8SGUQka3nXU7kt+TvYFSw4NlNc4CYldligAyVHzDJ1OjynzKIXBNmCVgxGKTq/+lemafC6XqucZ7QKV8akrZAjb4Uk2VhUoS8ASSqXOBhak1ZarC2dusSJ50XwmiXE7M+/uOOfYdrshCbiZ9kB1EmlJz+NSlChGgUugweHUrpsXM5KTY7A1PzSOEpM5gH0azhGi1FMH8lk8PlNBOjFvn0FeBa7Ls3buHk5cKRb4wvihEgrENnTZtOsSXUO6+tbi0emrqnz41AR15i4BztDn/W0fWX/+xGQM4lQuAithEWjhVbf/5v/+EfvPqb8X1YkzHn+zaaTl27CjzbJ+B1IVnr1wwxeDq2Qe1gIfjP6BO6glqxGMaFckqwDmI2+cnoJzi3XfeFg0iW6s/+b9d5hqLBZwCM4CpDQ1KNejHpMGIvxqyOuB1FpVcsBwrt+bzBc8TIEKJRcH7f/vQ2FujAyXOERgf9iTbt+ehf+zbm2ez2ZgpVaiankmxUanTE0foQTuVAhScFbB3R8utjsOnfzbZrrYKmi3EYyBCw2FKze2JUt/BWijUK3XbeFjLv/jiM7Q9Pw96O3vWJ5LW0OSpCcMNIyJDSQgXXIUWQoQJR+AxuLPWKyVl1Q3ACMVigfMkiL1Sqpwgsj3Yj3fucGDN7Mn2bMp5+bFsaHTmCanuT0p1PkDq3wUodt0qe5/Oh0+pR9xka2elQUTh4eEFn35WYHTljEADLxJSSyMezDx0b1hn03dbns925/6zpbPMPqTXlB5eZAXRV0kQm5qa8l2l4YBiAUilBBIPWVkbiB07dmU/m5pWrdVqYcoRA5d9IX5kL2oopPJV+Hwm7Prf54FBnhQaFihVSYFzPvtsGvZiP0979dXfFuEYNRviSplGNPTQWXQ6XQfiOXOHWuJEtuSadu9Lc5XgBm0ELxUaVkhZhhQCg8qF/9yDfJpr0eJp4j3XN3fuRxVX2s0wRgrmoqGhHr249nnJ5k9V3CYyPRL3+pO92T9IZENjehJM8Gihirz0YCHSjw7lVU3unMyhPRg9uGDxfWHTv6xYZsKmZZk3gwgFUNVvv/0u6a4RIcYDjV2+fIWgoSmphGKIvZ+j+LBb1MMtPYUf4KkWnqhBLf7Deu2AOTlvgVMVLhWIgzzRKI2NjaUVFeUGMjaWgMmCXIm/vz+aMWMmBd5HGMzrGNS4+HiPgAiTKM2Zn4LaAyLRri8PoetXm7rQLAxf7fy+CrVrJ6Llz7xATcrUW6e7e/dugLnoO5j7tELstcFkRD7IcwLGPfOxJY9nrF61hnBHm+DVAr3BaAjfinCpBa7lK9NOFD90SI+U6U4eWmgAm5guhSb6IM8Lib22bAxmmjvaZDIv8Al05UmKZWw3M/7J13a/8cYfLd9+83VsXwHR6fDEkGQOPJPhLuiHYB3sJWik3OOUXBwgIR0r+79eA40WOiGTakFkxIAdn9wXXniRdDe2CFoA2gBACh2HlDILxLVjQTwMpZX4+sG5cfRFEBlJmzZtes6GDb9xay8htgQ7JYTW5PBke+pYoK2ggetefgXVY9Dxuuh4Ue0g8nJ+1BSSuIp1GU1lhx5SxIveACJv5wcaC+gKvEWlEuruOhZzXTDgzb52KeJFbwLR6fwQBJGzdu1Lbp0fNdlLJrnf/TrABGBKBU009ScQnc4PPJCambVe7w4gNaTw3MSLMK6Z1R9BdDo/M2fOyv718y+QvSUA1GYvpYwX+wKIvJwf0EjQTNBeT9tLNlOImMC3z4DIBhMGeTPdadvh3Fx0oKIcLVq92uP2EjqWmKGpvgai05MNDw/PWbVqjbGnoHvQe39DvqU/oTzbZXR1xi/Q8md+5VF7ufKpJ6EaL10oiIP6IIiOtra2T44fP1ZcvN9MBgYEkN1HP3z8/JDvjyeQPigYTbTZ0Q77FVRefobKtsDoidJy6qefkNVqfU/Ivp4exejibQYHBy8dNiyK4rbm5maH3W5jSvssIo9txM5PzsqnV3VJ4/mt+7fOnjxyJLr9Hxs9ai/B6dqen+cjVBM9DSIBFXCTpyQZEhISu3mU19C5ykpUUVGe19rayvm9Sb15ss40XlgY8tvQ+RaduykGdGfFk11iN0jjKRlf0iAKyqN6GkR9ZGRk0S8fXUL0RmHt7e3owPf7HdXVF9KR+KJbypNdOy85Y81lO1WsdOfFF9DdpCkejS8hGbBhfabb1wn1BOJgT2ng0KHDCh755aOEOxsE/6csfIg4XXaq4MiRw2ITxtDTN2EA4ZOavepuouvaGdBEpeJL+pF4wUzj6wkEAwMDczGAJB8nYuKkyWh+sgHqQ9MkCkcoe4gvpseNADQYGVm86BHqiS3QTjmkvoECscSbQDTOmTvPKMQLBLspEZDUS6M6ErmVeQCdwvuwwMuFoSQlC51VCeLIUaNyYmJIwfsDkFgrOVdsu9VEHgKODoAJ9AeaCTazP4KYNmWKnhR7kAcemI1iY8fAuwWFHotyOzsShM1MDCHIv2KaBU8Whr2ETPPiwiYKlsEKa2F2dLQ0s0zMnTefsNvtBTik5PWqouKxkwnaMKMOrfCZp8BegufKPBwLlCvU+WlrazN7iyYax40bT0p1MLCp2LaCRm0SpIWjRkpyHQAaDPaC80PFe3ihJpHvi3QaEaFNFWMLXQloNbaP2YjfO6cIMVTam/MDnizYTTk9WU/SKRE9fLhRjgNPmzYd1VqtuTxotVMTtfJM4gcgwsJHG4uLzSXeoInG7mk1GWg1k1emY+QIWW+Yp21sVj2ImEqXarXyTW4AtIq91WzE7bm/ZCHhhZpFERDlolK2zJxFvcEmm5MWatUzHyqdOFA9nRqlCit6py8N2MdMDrEjibSqm5nYoXYQk6OjhyvSEpBfDQoKcqeNZEdE35qZWHYQo6J0BqVGy+E8OBZNcxtyqEgTvYJOI4cOVbQSCbQxICAwx6UrP3YyqVJlUjWdGpSwh921ccKECYYetJEC8W5ivGrQkyK7IzuIWg9QF20bM5AXiK2x0axqEAMDA5PAa1RaWLaRRP1AZAVx6LBhHmtEjp6qx8VqtTpUDWKkNtJj5dWgjSNGjgRtJNQM4oULVaVqBtEQotF4tIEgOY5c5FThUesBOuUmpCfsIVvg/LGxYzLk8AilELq8w6JqEJUOL1zJ+AkTubw93JPhhXpBjIjQJqmhoaAjhYURXbRRbdVqqgUxDLecWm4ySa/Xs4P/+CGBqrguKVJusoIYFBxsUAuIUBZCB/9Ug12/ckVNiqTeEGOIv3rePwHhxujRMcbks6eo7w0N9aq4LrGlinKDaIhQ2ZjduPETgN5hcNoRPyRAFR6q2FJF2TXR33+IqkCEHG5UlI6i1BDfQaqp3la1JmrVN3qOY8ZYfXlbKxkyqG89IC2jJqrvnUwJiWPRN1ebSaDTvhRmyAIijF6o8WahY5WHh6G+JrKAqNNFqzbpHB0Xhw60XEU+lecGQOxN7ty9o1oQIWY81t42oInuRKMJ1av5ps9gSr1ecXYARG8J9F3JxImTUUlrywCIvQih9puG8KcloO94qHKAqNdJUCxcV1cnL5CjRg1ootxy7py8Ngue0hrQRJlFI3NVAFBqQ0PDAIg90alGI82kPTabTdabr62t9WgiPESj0asVREKK2hoYBYEpweSm1EMuXsqpoINFqBVESQRGQerrLslOqaU/lSJvF9WCCA18U2ZNVAOlqhLEyMjIGGk00R/ZZbaJaqBUVYKo0YSS0hn+EEU03tsp1VfNF9d+s12R8wClDoAoo5bYFKBUqE096MWUqmoQlQgzQGB46ofjxwZAlCUYxvGm3dY4QKlKgxgeHm6Qkk6vKeT+a0JDvbYCzhcNiJNSCwu/HABRDlEiVmTi0lqrdQBEuZwbm0JA+vr6SlZaPwAiS6DUw25XBkQYzPbGMUbVgwg0p5Qmemv2xgvoNFL20Qy2XPbCgWKv8E6xJpqVOpc2MlIxStVFUa8v0vcLELGUyF04xUi0gnaRfgcVoToQZXqQplgpSoXrrygv79d0SoINk0EcFy9eVMxtvH37tlcNFEsOolwX2tBQb1YiGe6NoYY3pd121ylEqTA05U0gDvYiEM21VqsjJoZU5DGByw2XZTkuJNmBqqGTQHYoKCgotbW11dxfQEQ1NRYzvLZPiXO1tl6nXhnECLw0ms+7LmD+uJbrLajJbke3bt1G9iY7un3rFuU4gd8AiYWRo0ZTs3pUVJSn9xsQb9y4sRvHjEYl5gOY2jm5n1OOHj3Ka38ooIbx0GGdsSDM+OhyOwIL7UtY+gWIWEznzlXmarWzFT+xXPPU0d68KBC9bTzRUXfpkgn1IaFZxdBfvFNK7HbbbqUS4kolF7CE9WkQ6Rob9vxnptOnT/UlZYQ5WfWqArG9/abEx6MCfHbQ5rhYW5vXl0AUO1GF1CCalSinwHFVPnZw+gyIYudK99ZCKfOFC1UWNCBeDSIUNW1rabnWJ0CgJ7zX9zsQseSdOPFj3wCx86Fcoj+CSDk4So1sDNCpfA7O5tNlp/o9iJKn3agyCglpzk1ZhuXMmTPmiZMmG/xVPouVl4F4yQcvBrxalGqMRz4d95S94cpNdLNbGBnbbULGaG0wCvDvvKy/fPaD+XJT64LeztfWdgO00dA9YT0AokjRRQRnvPLk/Y0aP4zfcYaFByMMottwo79ro9Q2Edxk45jhhCRjfoH+gzm53Vgbs/qzbRSjiSQNWjKmRH24ZohBpw3BdBiCKVKa2X2HhgdxHWsrqagoz0tITEzz9PuphAgd7zqUABEAM2CqTI4kggyjo0IJKQFzJfSxwb7mcfBUs44dPWpMWfgQ4XUgXqNALJEDROo9Epog/+QYXZhx7KgIAhqV0AQodnPQSeD811rb8zhs7qiuvrAZe7M5anjRGM9QSdRbalyBaAgJ9M+YEjfUOJ6MlFXTuAjuQGTZBc6vBdp6+NCBpUseX+pVTk5zc3OJVCASwQF+BY/MGmOYmhilmhsMDfI38Nm+qakp/cD3+096C62CPcQh2W5JvFNs54qyVs5QFYAgAUN4+14WTKtZ3jJUVWOhfDazFCBuWjo3Qc8E2X1A8vYXm7fW1FhUf6Fnz1aYkcjX71EgzhgXneFp29eT2JpvCEUi69DBA3lqrseB2BbT/2Ypgn1DIvY81XqjV6+3C1Yn7PWlmwo+z1MjtULnOnLkcJ5YKmUcG315TSOqs8v3FFDt5WuWSqs9n/mOvd+kmROijbFuXmTTdvM2qq5z7BZ5+nRMrbutP/+cO3PWLMLTyQAYOgMNPHHix63AFlIc0wcvOUiCp1XdSL6LgL0Icau3XCBFb6Xj3rTo6OFLAwICPAYidrpK6PaQ5Imdjo4O9P8CDAChQgHWH+UU4wAAAABJRU5ErkJggg==';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/trash-can.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/mystery-object-01.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Model for the Motion, Friction and Acceleration screens
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/motion/model/MotionModel',['require','FORCES_AND_MOTION_BASICS/motion/model/Item','AXON/PropertySet','AXON/ObservableArray','PHET_CORE/inherit','FORCES_AND_MOTION_BASICS/motion/MotionConstants','DOT/Vector2','image!FORCES_AND_MOTION_BASICS/water-bucket.png','image!FORCES_AND_MOTION_BASICS/fridge.png','image!FORCES_AND_MOTION_BASICS/crate.png','image!FORCES_AND_MOTION_BASICS/girl-standing.png','image!FORCES_AND_MOTION_BASICS/man-standing.png','image!FORCES_AND_MOTION_BASICS/girl-sitting.png','image!FORCES_AND_MOTION_BASICS/man-sitting.png','image!FORCES_AND_MOTION_BASICS/girl-holding.png','image!FORCES_AND_MOTION_BASICS/man-holding.png','image!FORCES_AND_MOTION_BASICS/trash-can.png','image!FORCES_AND_MOTION_BASICS/mystery-object-01.png'],function( require ) {
          
        
          var Item = require( 'FORCES_AND_MOTION_BASICS/motion/model/Item' );
          var PropertySet = require( 'AXON/PropertySet' );
          var ObservableArray = require( 'AXON/ObservableArray' );
          var inherit = require( 'PHET_CORE/inherit' );
          var MotionConstants = require( 'FORCES_AND_MOTION_BASICS/motion/MotionConstants' );
          var Vector2 = require( 'DOT/Vector2' );
          var waterBucketImage = require( 'image!FORCES_AND_MOTION_BASICS/water-bucket.png' );
          var fridgeImage = require( 'image!FORCES_AND_MOTION_BASICS/fridge.png' );
          var crateImage = require( 'image!FORCES_AND_MOTION_BASICS/crate.png' );
          var girlStandingImage = require( 'image!FORCES_AND_MOTION_BASICS/girl-standing.png' );
          var manStandingImage = require( 'image!FORCES_AND_MOTION_BASICS/man-standing.png' );
          var girlSittingImage = require( 'image!FORCES_AND_MOTION_BASICS/girl-sitting.png' );
          var manSittingImage = require( 'image!FORCES_AND_MOTION_BASICS/man-sitting.png' );
          var girlHoldingImage = require( 'image!FORCES_AND_MOTION_BASICS/girl-holding.png' );
          var manHoldingImage = require( 'image!FORCES_AND_MOTION_BASICS/man-holding.png' );
          var trashCanImage = require( 'image!FORCES_AND_MOTION_BASICS/trash-can.png' );
          var mysteryObjectImage = require( 'image!FORCES_AND_MOTION_BASICS/mystery-object-01.png' );
        
          /**
           * Constructor for the motion model
           * @param {String} screen String that indicates which of the 3 screens this model represents
           * @constructor
           */
          function MotionModel( screen ) {
            //Motion models must be constructed with a screen, which indicates 'motion'|'friction'|'acceleration'
            assert && assert( screen );
            var motionModel = this;
        
            //Constants
            this.screen = screen;
            this.skateboard = screen === 'motion';
            this.accelerometer = screen === 'acceleration';
            this.friction = screen === 'motion' ? 0 : MotionConstants.MAX_FRICTION / 2;
            this.stack = new ObservableArray();
        
            //Observable values, all values are in MKS units (meters, kg, sec, Newtons, etc.)
            PropertySet.call( this, {
              appliedForce: 0,
              frictionForce: 0,
              friction: this.friction,
        
              sumOfForces: 0,
        
              position: 0,
              speed: 0,
        
              //Velocity is a 1-d vector, where the direction (right or left) is indicated by the sign
              velocity: 0,
              acceleration: 0,
              pusherPosition: -4, //Start to the left of the box by this many meters
              showForce: true,
              showValues: false,
              showSumOfForces: false,
              showSpeed: false,
              showMasses: false,
              showAcceleration: false,
        
              //Keep track of whether the speed is classified as: 'RIGHT_SPEED_EXCEEDED', 'LEFT_SPEED_EXCEEDED' or 'WITHIN_ALLOWED_RANGE'
              //so that the Applied Force can be stopped if the speed goes out of range
              speedClassification: 'WITHIN_ALLOWED_RANGE',
              previousSpeedClassification: 'WITHIN_ALLOWED_RANGE',
              movingRight: true,
              direction: 'none',
              timeSinceFallen: 10,
              fallen: false,
              fallenDirection: 'left',
              time: 0,
        
              //stack.length is already a property, but mirror it here to easily multilink with it, see usage in MotionView.js
              //TODO: Perhaps a DerivedProperty would be more suitable instead of duplicating/synchronizing this value
              stackSize: 1
            } );
        
            //Zero out the applied force when the last object is removed.  Necessary to remove the force applied with the slider tweaker buttons.  See #37
            this.stack.lengthProperty.link( function( length ) { if ( length === 0 ) { motionModel.appliedForce = 0; } } );
        
            this.stack.lengthProperty.linkAttribute( this, 'stackSize' );
        
            var bucket = new Item( this, 'bucket', waterBucketImage, 100, 845, 547 + -39, 0.78 );
            bucket.bucket = true;
            var fridge = new Item( this, 'fridge', fridgeImage, 200, 25, 439, 0.8, 4 );
            var crate1 = new Item( this, 'crate1', crateImage, 50, 126, 495, 0.5 );
            var crate2 = new Item( this, 'crate2', crateImage, 50, 218, 495, 0.5 );
            var girl = new Item( this, 'girl', girlStandingImage, 40, 684, 471, 0.6, 4, girlSittingImage, girlHoldingImage );
            var man = new Item( this, 'man', manStandingImage, 80, 747, 421, 0.6, 12, manSittingImage, manHoldingImage );
            this.items = this.accelerometer ?
                         [ fridge, crate1, crate2, girl, man, bucket ] :
                         [ fridge, crate1, crate2, girl, man,
                           new Item( this, 'trash', trashCanImage, 100, 816, 502, 0.7, 11 ),
                           new Item( this, 'mystery', mysteryObjectImage, 50, 888, 543, 1.1, undefined, undefined, undefined, true )
                         ];
        
            this.appliedForceProperty.link( function( appliedForce ) {
              motionModel.direction = appliedForce > 0 ? 'right' :
                                      appliedForce < 0 ? 'left' :
                                      'none';
            } );
        
            //Applied force should drop to zero if max speed reached
            this.speedClassificationProperty.link( function( speedClassification ) {
              if ( speedClassification !== 'WITHIN_ALLOWED_RANGE' ) {
                motionModel.appliedForce = 0;
              }
            } );
          }
        
          return inherit( PropertySet, MotionModel, {
        
            draggingItems: function() {
              var draggingItems = [];
              for ( var i = 0; i < this.items.length; i++ ) {
                var item = this.items[i];
                if ( item.dragging ) {
                  draggingItems.push( item );
                }
              }
              return draggingItems;
            },
        
            //Upper items should fall if an item removed from beneath
            //Uses the view to get item dimensions.
            spliceStack: function( index ) {
              var item = this.stack.get( index );
              this.stack.remove( item );
              if ( this.stack.length > 0 ) {
                var sumHeight = 0;
                for ( var i = 0; i < this.stack.length; i++ ) {
                  var size = this.view.getSize( this.stack.get( i ) );
                  sumHeight += size.height;
                  this.stack.get( i ).animateTo( this.view.layoutBounds.width / 2 - size.width / 2 + this.stack.get( i ).centeringOffset, (this.skateboard ? 335 : 360) - sumHeight, 'stack' );//TODO: factor out this code for layout, which is duplicated in MotionTab.topOfStack
                }
              }
        
              //If the stack is emptied, stop the motion
              if ( this.stack.length === 0 ) {
                this.velocity = 0;
                this.acceleration = 0;
              }
              return item;
            },
        
            //When a 4th item is placed on the stack, move the bottom item home and have the stack fall
            spliceStackBottom: function() {
              var bottom = this.spliceStack( 0 );
              bottom.onBoard = false;
              bottom.animateHome();
            },
        
            //Determine whether a value is positive, negative or zero for the physics computations
            getSign: function( value ) { return value > 0 ? 1 : value < 0 ? -1 : 0; },
        
            //Returns the friction force on an object given the applied force
            getFrictionForce: function( appliedForce ) {
              var g = 10.0;
              var sum = function( a, b ) {return a + b;};
              var toMass = function( item ) {return item.mass;};
              var mass = this.stack.map( toMass ).reduce( 0, sum );
              var frictionForceMagnitude = Math.abs( this.friction * mass * g );
        
              //Friction force only applies above this velocity
              var velocityThreshold = 1E-12;
        
              //Object is motionless, friction should oppose the applied force
              if ( Math.abs( this.velocity ) <= velocityThreshold ) {
        
                //the friction is higher than the applied force, so don't allow the friction force to be higher than the applied force
                return frictionForceMagnitude >= Math.abs( appliedForce ) ? -appliedForce :
        
                  //Oppose the applied force
                       -this.getSign( this.appliedForce ) * frictionForceMagnitude;
              }
        
              //Object is moving, so friction should oppose the velocity
              else {
                return -this.getSign( this.velocity ) * frictionForceMagnitude;
              }
            },
        
            //Compute the mass of the entire stack, for purposes of momentum computation
            getStackMass: function() { return this.stack.reduce( 0, function( sum, item ) { return sum + item.mass; } ); },
        
            //Determine whether a value is positive, negative or zero, to determine whether the object changed directions.
            sign: function( value ) {
              return value < 0 ? 'negative' :
                     value > 0 ? 'positive' :
                     'zero';
            },
        
            //Determine whether a velocity value changed direction
            changedDirection: function( a, b ) {
              return this.sign( a ) === 'negative' && this.sign( b ) === 'positive' ||
                     this.sign( b ) === 'negative' && this.sign( a ) === 'positive';
            },
        
            //Update the physics
            step: function( dt ) {
        
              //There are more than 2x as many frames on html as we were getting on Java, so have to decrease the dt to compensate
              dt = dt / 2.3;
              this.time = this.time + dt;
        
              //Computes the new forces and sets them to the corresponding properties
              //The first part of stepInTime is to compute and set the forces.  But this is factored out because the forces must also be updated
              //When the user changes the friction force or mass while the sim is paused.
              this.frictionForce = this.getFrictionForce( this.appliedForce );
              this.sumOfForces = this.frictionForce + this.appliedForce;
        
              var mass = this.getStackMass();
              this.acceleration = mass !== 0 ? this.sumOfForces / mass : 0.0;
        
              var newVelocity = this.velocity + this.acceleration * dt;
        
              //friction force should not be able to make the object move backwards
              //Also make sure velocity goes exactly to zero when the pusher is pushing so that the friction force will be correctly computed
              //Without this logic, it was causing flickering arrows because the velocity was flipping sign and the friction force was flipping direction
              if ( this.changedDirection( newVelocity, this.velocity ) ) {
                newVelocity = 0.0;
              }
        
              //Cap at strobe speed.  This is necessary so that a reverse applied force will take effect immediately, without these lines of code the pusher will stutter.
              if ( newVelocity > MotionConstants.MAX_SPEED ) { newVelocity = MotionConstants.MAX_SPEED; }
              if ( newVelocity < -MotionConstants.MAX_SPEED ) { newVelocity = -MotionConstants.MAX_SPEED; }
        
              this.velocity = newVelocity;
              this.position = this.position + this.velocity * dt;
              if ( this.appliedForce !== 0 ) {
                this.pusherPosition = this.position + 2 * (this.appliedForce > 0 ? -1 : 1);
              }
              this.speed = Math.abs( this.velocity );
              this.speedClassification = this.velocity >= MotionConstants.MAX_SPEED ? 'RIGHT_SPEED_EXCEEDED' :
                                         this.velocity <= -MotionConstants.MAX_SPEED ? 'LEFT_SPEED_EXCEEDED' :
                                         'WITHIN_ALLOWED_RANGE';
        
              if ( this.speedClassification !== 'WITHIN_ALLOWED_RANGE' ) {
                this.timeSinceFallen = 0;
                this.fallenDirection = this.speedClassification === 'RIGHT_SPEED_EXCEEDED' ? 'right' : 'left';
                this.fallen = true;
              }
              else {
                this.timeSinceFallen = this.timeSinceFallen + dt;
        
                //Stand up after 1 second
                if ( this.timeSinceFallen > 1 ) {
                  this.fallen = false;
                }
              }
        
              //Stand up if applying a force in the opposite direction that you fell
              if ( this.fallen && this.fallenDirection === 'left' && this.appliedForce > 0 ) {
                this.fallen = false;
              }
              if ( this.fallen && this.fallenDirection === 'right' && this.appliedForce < 0 ) {
                this.fallen = false;
              }
        
              if ( this.previousSpeedClassification !== 'WITHIN_ALLOWED_RANGE' ) {
                this.speedClassification = this.previousSpeedClassification;
              }
        
              for ( var i = 0; i < this.items.length; i++ ) {
                this.items[i].step( dt );
              }
        
              //Don't show the pusher as fallen while applying a force, see https://github.com/phetsims/forces-and-motion-basics/issues/66
              if ( this.appliedForce !== 0 ) {
                this.fallen = false;
              }
        
              this.trigger( 'stepped' );
            },
        
            //Determine whether an item is in the stack.
            isInStack: function( item ) { return this.stack.contains( item ); },
        
            //Determine whether an item is stacked above another item, so that the arms can be raised for humans
            isItemStackedAbove: function( item ) { return this.isInStack( item ) && this.stack.indexOf( item ) < this.stack.length - 1;},
        
            //Reset the model
            reset: function() {
              PropertySet.prototype.reset.call( this );
              for ( var i = 0; i < this.items.length; i++ ) {
                this.items[i].reset();
              }
              this.stack.clear();
        
              //Move the initial crate to the play area, since it resets to the toolbox, not its initial location.
              this.viewInitialized( this.view );
            },
        
            /**
             * After the view is constructed, move one of the blocks to the top of the stack.
             * It would be better if more of this could be done in the model constructor, but it would be difficult with the way things are currently set up.
             * @param view
             */
            viewInitialized: function( view ) {
              this.view = view;
              var item = this.items[1];
              item.onBoard = true;
              var itemNode = view.itemNodes[1];
              item.animating = {enabled: false, x: 0, y: 0, end: null};
              item.interactionScale = 1.3;
              item.position = new Vector2( view.layoutBounds.width / 2 - itemNode.width / 2, view.topOfStack - itemNode.height );
              this.stack.add( item );
            },
        
            /**
             * Get the state of the simulation, for persistence.
             * @return {{properties: *, stack: Array}}
             */
            getState: function() {
              var motionModel = this;
              return {
                properties: this.get(),
                stack: motionModel.stack.getArray().map( function( item ) {return item.get();} )
              };
            }
          } );
        } );
        
        define("string!FORCES_AND_MOTION_BASICS/massDisplay.pattern",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/massDisplay.pattern");});
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Shows the draggable node for any of the items in the Motion, Friction and Acceleration screens.
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/motion/view/ItemNode',['require','SCENERY/nodes/Image','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','SCENERY/nodes/Text','SCENERY/input/SimpleDragHandler','PHET_CORE/inherit','SCENERY_PHET/PhetFont','DOT/Matrix3','string!FORCES_AND_MOTION_BASICS/massDisplay.pattern','PHETCOMMON/util/StringUtils','PHET_CORE/platform'],function( require ) {
          
        
          var Image = require( 'SCENERY/nodes/Image' );
          var Node = require( 'SCENERY/nodes/Node' );
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
          var Text = require( 'SCENERY/nodes/Text' );
          var SimpleDragHandler = require( 'SCENERY/input/SimpleDragHandler' );
          var inherit = require( 'PHET_CORE/inherit' );
          var PhetFont = require( 'SCENERY_PHET/PhetFont' );
          var Matrix3 = require( 'DOT/Matrix3' );
          var massDisplayPattern = require( 'string!FORCES_AND_MOTION_BASICS/massDisplay.pattern' );
          var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
          var platform = require( 'PHET_CORE/platform' );
        
          //Workaround for https://github.com/phetsims/scenery/issues/108
          var IDENTITY = Matrix3.scaling( 1, 1 );
        
          /**
           * Constructor for ItemNode
           * @param {MotionModel} model the entire model for the containing screen
           * @param {MotionView} motionView the entire view for the containing screen
           * @param {Item} item the corresponding to this ItemNode
           * @param {Image} normalImage the scenery.Image to show for this node
           * @param {Image} sittingImage optional image for when the person is sitting down
           * @param {Image} holdingImage optional image for when the person is holding an object
           * @param {Property} showMassesProperty property for whether the mass value should be shown
           * @constructor
           */
          function ItemNode( model, motionView, item, normalImage, sittingImage, holdingImage, showMassesProperty ) {
            var itemNode = this;
            this.item = item;
            Node.call( this, {x: item.position.x, y: item.position.y, scale: item.imageScale, cursor: 'pointer', rendererOptions: { cssTransform: true } } );
        
            //Work around issue where the images are getting corrupted in Firefox, see #38
            if ( platform.firefox ) {
              this.renderer = 'canvas';
            }
        
            //Create the node for the main graphic
            var normalImageNode = new Image( normalImage );
        
            //When the model changes, update the image location as well as which image is shown
            var updateImage = function() {
              if ( (typeof holdingImage !== 'undefined') && (item.armsUp() && item.onBoard) ) {
                normalImageNode.image = holdingImage;
              }
              else if ( item.onBoard && typeof sittingImage !== 'undefined' ) {
                normalImageNode.image = sittingImage;
              }
              else {
                normalImageNode.image = normalImage;
              }
              if ( itemNode.labelNode ) {
                itemNode.labelNode.bottom = normalImageNode.height - 2;
                itemNode.labelNode.centerX = normalImageNode.width / 2;
              }
            };
        
            for ( var i = 0; i < model.items.length; i++ ) {
              model.items[i].draggingProperty.link( updateImage );
            }
        
            model.stack.lengthProperty.link( updateImage );
        
            //When the user drags the object
            var dragHandler = new SimpleDragHandler( {
              translate: function( options ) {
                item.position = options.position;//es5 setter
              },
        
              //When picking up an object, remove it from the stack.
              start: function() {
        
                //Move it to front (z-order)
                itemNode.moveToFront();
                item.dragging = true;
                var index = model.stack.indexOf( item );
                if ( index >= 0 ) {
                  model.spliceStack( index );
                }
                item.onBoard = false;
        
                //Don't allow the user to translate the object while it is animating
                item.cancelAnimation();
              },
        
              //End the drag
              end: function() {
                item.dragging = false;
                //If the user drops it above the ground, move to the top of the stack on the skateboard, otherwise go back to the original position.
                if ( item.position.y < 350 ) {
                  item.onBoard = true;
                  item.animateTo( motionView.layoutBounds.width / 2 - itemNode.width / 2 + item.centeringOffset, motionView.topOfStack - itemNode.height, 'stack' );
                  model.stack.add( item );
                  if ( model.stack.length > 3 ) {
                    model.spliceStackBottom();
                  }
                }
                else {
                  item.animateHome();
                }
              }
            } );
            this.addInputListener( dragHandler );
        
            //Label for the mass (if it is shown)
            var massLabel = new Text( item.mystery ? '?' : StringUtils.format( massDisplayPattern, item.mass ), {font: new PhetFont( { size: 15, weight: 'bold' } )} );
            var roundRect = new Rectangle( 0, 0, massLabel.width + 10, massLabel.height + 10, 10, 10, {fill: 'white', stroke: 'gray'} ).mutate( {centerX: massLabel.centerX, centerY: massLabel.centerY} );
            var labelNode = new Node( {children: [roundRect, massLabel ], scale: 1.0 / item.imageScale} );
            this.labelNode = labelNode;
        
            //Update the position of the item
            item.positionProperty.link( function( position ) { itemNode.setTranslation( position ); } );
        
            //When the object is scaled or change direction, update the image part
            item.multilink( ['interactionScale', 'direction'], function( interactionScale, direction ) {
              var scale = item.imageScale * interactionScale;
              itemNode.setScaleMagnitude( scale );
        
              normalImageNode.setMatrix( IDENTITY );
              if ( direction === 'right' ) {
                normalImageNode.scale( -1, 1 );
        
                //TODO: I'm not sure why there is an extra 16 pixels in this direction, but it seems necessary to center the images
                normalImageNode.translate( -itemNode.width * scale + 16, 0 );
              }
            } );
            item.onBoardProperty.link( updateImage );
        
            itemNode.addChild( normalImageNode );
            itemNode.addChild( labelNode );
        
            showMassesProperty.link( function( showMasses ) { labelNode.visible = showMasses; } );
          }
        
          return inherit( Node, ItemNode );
        } );
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * This scenery.Node shows the interactive water bucket.  The user can drag it from the toolbox to the play area, and the water sloshes based on the acceleration.
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/motion/view/WaterBucketNode',['require','SCENERY/nodes/Path','KITE/Shape','DOT/Vector2','PHET_CORE/inherit','FORCES_AND_MOTION_BASICS/motion/view/ItemNode','DOT/Util'],function( require ) {
          
        
          var Path = require( 'SCENERY/nodes/Path' );
          var Shape = require( 'KITE/Shape' );
          var Vector2 = require( 'DOT/Vector2' );
          var inherit = require( 'PHET_CORE/inherit' );
          var ItemNode = require( 'FORCES_AND_MOTION_BASICS/motion/view/ItemNode' );
          var linear = require( 'DOT/Util' ).linear;
        
          /**
           * WaterBucketNode constructor
           *
           * @param {MotionModel} model the model for the entire 'motion', 'friction' or 'acceleration' screen
           * @param {MotionView} motionView the view for the entire 'motion', 'friction' or 'acceleration' screen
           * @param {Item} item the model for the item itself
           * @param {Image} image image to be shown when in the toolbox or being dragged
           * @param {Image} imageSitting image to be shown if it is a sitting person
           * @param {Image} imageHolding image to be shown if it is a sitting person holding their arms in the air
           * @param {Property} showMassesProperty boolean property of whether the masses should be shown
           * @constructor
           */
          function WaterBucketNode( model, motionView, item, image, imageSitting, imageHolding, showMassesProperty ) {
            this.item = item;
            ItemNode.call( this, model, motionView, item, image, imageSitting, imageHolding, showMassesProperty );
            var water = new Path( Shape.lineSegment( new Vector2( 0, 0 ), new Vector2( 0, 18 ) ), { stroke: 'black', fill: 'rgb(9, 125, 159)', lineWidth: 1} );
            this.addChild( water );
            water.moveToBack();
        
            //Keep track of the history to show a momentum-based "sloshing" effect
            var history = [];
        
            //Metrics based on original image size of 98 pixels wide.
            var padX = 4.5;
            var padY = 9;
            var s = image.width / 98.0;
        
            var leftLineX = function( x ) {return linear( 0, 1, ( 1 + padX ) * s, ( 10 + padX ) * s, x );};
            var leftLineY = function( x ) {return linear( 0, 1, ( 9 - padY ) * s, ( 102 - padY ) * s, x );};
        
            var rightLineX = function( x ) {return linear( 1, 0, ( 87 - padX ) * s, ( 96 - padX ) * s, x );};
            var rightLineY = function( x ) {return linear( 1, 0, ( 102 - padY ) * s, ( 9 - padY ) * s, x );};
        
            var min = 0.5; //Water level when acceleration = 0
        
            //When the model steps in time, update the water shape
            //The delta value is the critical value in determining the water shape.
            //Compute it separately as a guard against reshaping the water bucket node when the shape hasn't really changed
            var deltaProperty = model.toDerivedProperty( ['time'], function() {
              var acceleration = model.acceleration;
              history.push( acceleration );
              while ( history.length > 7 ) {
                history.shift();//remove front item
              }
        
              var sum = 0.0;
              history.forEach( function( item ) { sum = sum + item; } );
              var composite = sum / history.length;
        
              return model.isInStack( item ) ? -composite / 50 : 0;
            } );
        
            //When the shape has really changed, update the water node
            deltaProperty.link( function( delta ) {
        
              var path = new Shape();
              path.moveTo( leftLineX( min + delta ), leftLineY( min + delta ) );
              path.lineTo( leftLineX( 1 ), leftLineY( 1 ) );
              path.lineTo( rightLineX( 1 ), rightLineY( 1 ) );
              path.lineTo( rightLineX( min - delta ), rightLineY( min - delta ) );
              path.close();
        
              water.shape = path;
            } );
          }
        
          return inherit( ItemNode, WaterBucketNode );
        } );
        
        define("image!FORCES_AND_MOTION_BASICS/pusher_straight_on.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pusher_fall_down.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pusher_0.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pusher_1.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pusher_2.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pusher_3.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pusher_4.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pusher_5.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pusher_6.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pusher_7.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pusher_8.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pusher_9.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pusher_10.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pusher_11.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pusher_12.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pusher_13.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/pusher_14.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Shows the draggable pusher, which applies force to the objects in the center of the screen and falls down if he exceeds the maximum velocity.
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/motion/view/PusherNode',['require','SCENERY/nodes/Image','SCENERY/nodes/Node','SCENERY/input/SimpleDragHandler','PHET_CORE/inherit','image!FORCES_AND_MOTION_BASICS/pusher_straight_on.png','image!FORCES_AND_MOTION_BASICS/pusher_fall_down.png','image!FORCES_AND_MOTION_BASICS/pusher_0.png','image!FORCES_AND_MOTION_BASICS/pusher_1.png','image!FORCES_AND_MOTION_BASICS/pusher_2.png','image!FORCES_AND_MOTION_BASICS/pusher_3.png','image!FORCES_AND_MOTION_BASICS/pusher_4.png','image!FORCES_AND_MOTION_BASICS/pusher_5.png','image!FORCES_AND_MOTION_BASICS/pusher_6.png','image!FORCES_AND_MOTION_BASICS/pusher_7.png','image!FORCES_AND_MOTION_BASICS/pusher_8.png','image!FORCES_AND_MOTION_BASICS/pusher_9.png','image!FORCES_AND_MOTION_BASICS/pusher_10.png','image!FORCES_AND_MOTION_BASICS/pusher_11.png','image!FORCES_AND_MOTION_BASICS/pusher_12.png','image!FORCES_AND_MOTION_BASICS/pusher_13.png','image!FORCES_AND_MOTION_BASICS/pusher_14.png','FORCES_AND_MOTION_BASICS/motion/MotionConstants','DOT/Vector2'],function( require ) {
          
        
          var Image = require( 'SCENERY/nodes/Image' );
          var Node = require( 'SCENERY/nodes/Node' );
          var SimpleDragHandler = require( 'SCENERY/input/SimpleDragHandler' );
          var inherit = require( 'PHET_CORE/inherit' );
          var pusherStraightImage = require( 'image!FORCES_AND_MOTION_BASICS/pusher_straight_on.png' );
          var pusherFallDownImage = require( 'image!FORCES_AND_MOTION_BASICS/pusher_fall_down.png' );
          var pusherImage0 = require( 'image!FORCES_AND_MOTION_BASICS/pusher_0.png' );
          var pusherImage1 = require( 'image!FORCES_AND_MOTION_BASICS/pusher_1.png' );
          var pusherImage2 = require( 'image!FORCES_AND_MOTION_BASICS/pusher_2.png' );
          var pusherImage3 = require( 'image!FORCES_AND_MOTION_BASICS/pusher_3.png' );
          var pusherImage4 = require( 'image!FORCES_AND_MOTION_BASICS/pusher_4.png' );
          var pusherImage5 = require( 'image!FORCES_AND_MOTION_BASICS/pusher_5.png' );
          var pusherImage6 = require( 'image!FORCES_AND_MOTION_BASICS/pusher_6.png' );
          var pusherImage7 = require( 'image!FORCES_AND_MOTION_BASICS/pusher_7.png' );
          var pusherImage8 = require( 'image!FORCES_AND_MOTION_BASICS/pusher_8.png' );
          var pusherImage9 = require( 'image!FORCES_AND_MOTION_BASICS/pusher_9.png' );
          var pusherImage10 = require( 'image!FORCES_AND_MOTION_BASICS/pusher_10.png' );
          var pusherImage11 = require( 'image!FORCES_AND_MOTION_BASICS/pusher_11.png' );
          var pusherImage12 = require( 'image!FORCES_AND_MOTION_BASICS/pusher_12.png' );
          var pusherImage13 = require( 'image!FORCES_AND_MOTION_BASICS/pusher_13.png' );
          var pusherImage14 = require( 'image!FORCES_AND_MOTION_BASICS/pusher_14.png' );
          var MotionConstants = require( 'FORCES_AND_MOTION_BASICS/motion/MotionConstants' );
          var Vector2 = require( 'DOT/Vector2' );
        
          /**
           * Constructor for PusherNode
           *
           * @param {MotionModel} model the model for the entire 'motion', 'friction' or 'acceleration' screen
           * @param layoutWidth width for the layout for purposes of centering the character when pushing
           * @constructor
           */
          function PusherNode( model, layoutWidth ) {
            var pusherNode = this;
            var scale = 0.85;
        
            //Create all the images up front, add as children and toggle their visible for performance and reduced garbage collection
            var pushingRightNodes = [];
            var pushingLeftNodes = [];
            var children = [];
            var standingUp = new Image( pusherStraightImage, {visible: true, pickable: true, scale: scale} );
            var fallLeft = new Image( pusherFallDownImage, {visible: false, pickable: false, scale: scale} );
            var fallRight = new Image( pusherFallDownImage, {visible: false, pickable: false, scale: new Vector2( -scale, scale )} );
            var visibleNode = standingUp;
        
            children.push( standingUp );
            children.push( fallLeft );
            children.push( fallRight );
            for ( var i = 0; i <= 14; i++ ) {
              var image = i === 0 ? pusherImage0 :
                          i === 1 ? pusherImage1 :
                          i === 2 ? pusherImage2 :
                          i === 3 ? pusherImage3 :
                          i === 4 ? pusherImage4 :
                          i === 5 ? pusherImage5 :
                          i === 6 ? pusherImage6 :
                          i === 7 ? pusherImage7 :
                          i === 8 ? pusherImage8 :
                          i === 9 ? pusherImage9 :
                          i === 10 ? pusherImage10 :
                          i === 11 ? pusherImage11 :
                          i === 12 ? pusherImage12 :
                          i === 13 ? pusherImage13 :
                          i === 14 ? pusherImage14 :
                          null;
              var rightImage = new Image( image, {visible: false, pickable: false, scale: scale} );
              var leftImage = new Image( image, {visible: false, pickable: false, scale: new Vector2( -scale, scale )} );
              pushingRightNodes.push( rightImage );
              pushingLeftNodes.push( leftImage );
              children.push( rightImage );
              children.push( leftImage );
            }
        
            function setVisibleNode( node ) {
              if ( node !== visibleNode ) {
                visibleNode.visible = false;
                visibleNode.pickable = false;
                node.visible = true;
                node.pickable = true;
                visibleNode = node;
              }
            }
        
            Node.call( this, {children: children} );
        
            //Update the position when the pusher is not applying force (fallen or standing)
            function updateZeroForcePosition() {
              var pusherY = 362 - visibleNode.height;
              var x = layoutWidth / 2 + (model.pusherPosition - model.position) * MotionConstants.POSITION_SCALE;
        
              //To save processor time, don't update the image if it is too far offscreen
              if ( x > -2000 && x < 2000 ) {
                visibleNode.translate( x - visibleNode.getCenterX(), pusherY - visibleNode.y, true );
              }
            }
        
            function updateAppliedForcePosition() {
              assert && assert( model.stack.length > 0 );
              var pusherY = 362 - visibleNode.height;
              var delta = model.stack.get( 0 ).view.width / 2 - model.stack.get( 0 ).pusherInset;
              if ( model.appliedForce > 0 ) {
                visibleNode.setTranslation( (layoutWidth / 2 - visibleNode.width - delta), pusherY );
              }
              else {
                visibleNode.setTranslation( (layoutWidth / 2 + visibleNode.width + delta), pusherY );
              }
            }
        
            //Choose the rightImage
            model.multilink( ['appliedForce', 'fallen'], function( appliedForce, fallen ) {
              if ( fallen ) {
                setVisibleNode( model.fallenDirection === 'left' ? fallLeft : fallRight );
                updateZeroForcePosition();
              }
              else if ( appliedForce === 0 ) {
                setVisibleNode( standingUp );
                updateZeroForcePosition();
              }
              else {
                var index = Math.min( 14, Math.round( Math.abs( (appliedForce / 500 * 14) ) ) );
                if ( appliedForce > 0 ) {
                  setVisibleNode( pushingRightNodes[index] );
                }
                else {
                  setVisibleNode( pushingLeftNodes[index] );
                }
                updateAppliedForcePosition();
              }
            } );
        
            //Update the rightImage and position when the model changes
            model.multilink( ['position', 'pusherPosition'], function() {
              if ( model.appliedForce === 0 || model.fallen ) {
                updateZeroForcePosition();
              }
            } );
        
            var listener = new SimpleDragHandler( {
              allowTouchSnag: true,
              translate: function( options ) {
                var newAppliedForce = model.appliedForce + options.delta.x;
                var clampedAppliedForce = Math.max( -500, Math.min( 500, newAppliedForce ) );
        
                //Only apply a force if the pusher is not fallen, see #48
                if ( !model.fallen ) {
                  model.appliedForce = clampedAppliedForce;
                }
              },
        
              start: function() {},
              end: function() { model.appliedForce = 0; }
            } );
            this.addInputListener( listener );
        
            //Make it so you cannot drag the pusher until one ItemNode is in the play area
            model.stack.lengthProperty.link( function( length ) {
              pusherNode.cursor = length === 0 ? 'default' : 'pointer';
              if ( length === 0 ) {
                pusherNode.removeInputListener( listener );
              }
              else {
                pusherNode.addInputListener( listener );
              }
            } );
          }
        
          return inherit( Node, PusherNode );
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * A rounded slider knob that shows with grip 'dots' to indicate that it is grabbable.  Based on artwork by Noah Podolefsky.
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/common/view/SliderKnob',['require','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','SCENERY/nodes/Circle','PHET_CORE/inherit','SCENERY/util/LinearGradient'],function( require ) {
          
        
          var Node = require( 'SCENERY/nodes/Node' );
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
          var Circle = require( 'SCENERY/nodes/Circle' );
          var inherit = require( 'PHET_CORE/inherit' );
          var LinearGradient = require( 'SCENERY/util/LinearGradient' );
        
          function SliderKnob( options ) {
        
            options = _.extend( { enabled: true }, options );
            this.enabled = options.enabled;
        
            Node.call( this );
        
            //Add the rounded rectangle background
            var scale = 0.8;
            var width = 20 * scale;
            var height = 50 * scale;
            var gradient = new LinearGradient( 0, 0, width, 0 ).addColorStop( 0, '#2FB0E4' ).addColorStop( 0.5, '#B8E4FB' ).addColorStop( 1, '#2FB0E4' );
            this.addChild( new Rectangle( 0, 0, width, height, 10 * scale, 10 * scale, {fill: this.enabled ? gradient : 'gray', stroke: this.enabled ? 'black' : 'gray', lineWidth: 2} ) );
        
            //add a grid of grip dots
            var dx = width / 5;
            var dy = height / 6;
            this.addGripDot( width / 2 - dx, height / 2 - dy );
            this.addGripDot( width / 2 + dx, height / 2 - dy );
            this.addGripDot( width / 2 - dx, height / 2 );
            this.addGripDot( width / 2 + dx, height / 2 );
            this.addGripDot( width / 2 - dx, height / 2 + dy );
            this.addGripDot( width / 2 + dx, height / 2 + dy );
        
            //Make sure the slider knob is perfectly centered on the tick marks.  Not sure why this workaround is necessary, but it seems to perfectly center the knob.
            this.translate( 1, 0 );
          }
        
          return inherit( Node, SliderKnob, {
            addGripDot: function( x, y ) {
              var radius = 1.8;
              var stroke = new LinearGradient( -radius, -radius, radius * 2, radius * 2 ).
                addColorStop( 0, 'black' ).addColorStop( 0.5, '#56889F' ).addColorStop( 1, 'white' );
              this.addChild( new Circle( radius, {x: x, y: y, fill: this.enabled ? '#56889F' : 'gray', stroke: this.enabled ? stroke : 'gray', lineWidth: 1} ) );
            }
          } );
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Horizontal slider for the friction/applied force.
         * Not generalizable enough to be reused elsewhere, but has custom behaviors like being half grayed out when acceleration is maxed
         * out in one direction.
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/motion/view/HSlider',['require','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','SCENERY/nodes/Text','SCENERY/nodes/Path','KITE/Shape','SCENERY/input/SimpleDragHandler','DOT/Vector2','PHET_CORE/inherit','DOT/Util','AXON/Property','FORCES_AND_MOTION_BASICS/common/view/SliderKnob','SCENERY_PHET/PhetFont'],function( require ) {
          
        
          var Node = require( 'SCENERY/nodes/Node' );
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
          var Text = require( 'SCENERY/nodes/Text' );
          var Path = require( 'SCENERY/nodes/Path' );
          var Shape = require( 'KITE/Shape' );
          var SimpleDragHandler = require( 'SCENERY/input/SimpleDragHandler' );
          var Vector2 = require( 'DOT/Vector2' );
          var inherit = require( 'PHET_CORE/inherit' );
          var linear = require( 'DOT/Util' ).linear;
          var Property = require( 'AXON/Property' );
          var SliderKnob = require( 'FORCES_AND_MOTION_BASICS/common/view/SliderKnob' );
          var PhetFont = require( 'SCENERY_PHET/PhetFont' );
        
          /**
           * Constructor for HSlider
           * @param {Number} min
           * @param {Number} max
           * @param {Number} width
           * @param {Property<Number>} property the numeric value for the slider
           * @param {Property<Number>} speedClassificationProperty
           * @param {Property<Boolean>} disableLeftProperty
           * @param {Property<Boolean>} disableRightProperty
           * @param {Object} options
           * @constructor
           */
          function HSlider( min, max, width, property, speedClassificationProperty, disableLeftProperty, disableRightProperty, options ) {
            var slider = this;
            this.enabledProperty = new Property( true );
            this.options = _.extend( {zeroOnRelease: false}, options || {} );
        
            speedClassificationProperty.link( function( speedClassification ) {
              if ( speedClassification !== 'WITHIN_ALLOWED_RANGE' ) {
        
                //The speed could have been exceeded by another means than the HSlider (such as dragging the character or pushing the tweaker arrow buttons)
                //So only end the drag if it originated here
                if ( dragHandler.dragging ) {
                  dragHandler.endDrag();//drop the mouse
                }
              }
            } );
            this.min = min;
            this.max = max;
            this.sliderWidth = width;
            this.trackHeight = 6;
        
            Node.call( this, this.options );
        
            this.ticksLayer = new Node( {pickable: false} );
            this.addChild( this.ticksLayer );
        
            //The track
            var track = new Rectangle( 0, 0, width, this.trackHeight, {stroke: 'black', lineWidth: 1, fill: 'white'} );
            this.addChild( track );
            this.enabledProperty.link( function( enabled ) {
              track.stroke = enabled ? 'black' : 'gray';
              track.fill = enabled ? 'white' : 'gray';
            } );
        
            //Gray out left side or right side if the maximum speed has been reached in that direction
            if ( disableLeftProperty && disableRightProperty ) {
              //Bars to show either side of the slider disabled when max is reached in that direction
              var rightDisableBar = new Rectangle( width / 2, 0, width / 2, this.trackHeight, {stroke: 'gray', lineWidth: 1, fill: 'gray'} );
              this.addChild( rightDisableBar );
              disableRightProperty.linkAttribute( rightDisableBar, 'visible' );
        
              var leftDisableBar = new Rectangle( 0, 0, width / 2, this.trackHeight, {stroke: 'gray', lineWidth: 1, fill: 'gray'} );
              this.addChild( leftDisableBar );
              disableLeftProperty.linkAttribute( leftDisableBar, 'visible' );
            }
        
            //Lookup the new item and append to the scenery
            var enabledKnob = new SliderKnob();
            var disabledKnob = new SliderKnob( {enabled: false} );
            var knob = new Node( {children: [ enabledKnob]} );
        
            knob.y = -knob.height / 2 + 4;
        
            //Increase the hit region
            var hitRegionExpansion = 20;
            knob.touchArea = new Shape.rectangle( knob.bounds.minX - hitRegionExpansion, knob.bounds.minY - hitRegionExpansion, knob.bounds.width + hitRegionExpansion * 2, knob.bounds.height + hitRegionExpansion * 2 );
        
            //Wire up the drag listener.
            //Code for keeping the mouse centered on the same point copied from Beer's Law Lab: ConcentrationSlider.js -> ThumbDragHandler, see #21
            var clickXOffset; // x-offset between initial click and thumb's origin
            var dragNode = knob;
            var dragHandler = new SimpleDragHandler( {
                allowTouchSnag: true,
                start: function( event ) {
                  clickXOffset = dragNode.globalToParentPoint( event.pointer.point ).x - event.currentTarget.x;
                },
                drag: function( event ) {
                  var localValue = dragNode.globalToParentPoint( event.pointer.point ).x - clickXOffset;
        
                  var x = Math.min( Math.max( localValue, -knob.width / 2 ), width - knob.width / 2 ) + knob.width / 2;
                  var result = linear( 0, width, min, max, x );
        
                  //Don't drag into the gray part of the slider if speed exceeded
                  if ( disableRightProperty && disableRightProperty.value ) {
                    result = Math.min( 0, result );
                  }
                  if ( disableLeftProperty && disableLeftProperty.value ) {
                    result = Math.max( 0, result );
                  }
                  property.value = result;
                },
                end: function() {
                  if ( slider.options.zeroOnRelease ) {
                    property.value = 0;
                  }
                }}
            );
            knob.addInputListener( dragHandler );
            this.addChild( knob );
        
            //Show the knob as enabled or disabled
            this.enabledProperty.link( function( enabled ) {
              knob.children = [enabled ? enabledKnob : disabledKnob];
              knob.cursor = enabled ? 'pointer' : 'default';
              if ( enabled ) {
                knob.addInputListener( dragHandler );
              }
              else {
                knob.removeInputListener( dragHandler );
              }
            } );
        
            //Link to the property value so that when the model value changes the knob will change location.
            property.link( function( value ) { knob.x = linear( min, max, 0, width, value ) - knob.width / 2; } );
        
            //Update layout and settings for Node
            this.mutate( options );
          }
        
          return inherit( Node, HSlider, {
        
            //Add ticks at regular intervals in 8 divisions
            addNormalTicks: function() {
        
              //Constants and functions for creating the ticks
              var slider = this;
              var numDivisions = 10; //e.g. divide the ruler into 1/8ths
              var numTicks = numDivisions + 1; //ticks on the end
              var isMajor = function( tickIndex ) { return tickIndex % 5 === 0; };
              var hasLabel = function( tickIndex ) { return tickIndex % 5 === 0; };
        
              //Generate each of the ticks and add to the parent
              _.range( numTicks ).forEach( function( i ) {
        
                var x1 = linear( slider.min, slider.max, 0, slider.sliderWidth, i / (numTicks - 1) * (slider.max - slider.min) + slider.min );
                var tick = new Path( Shape.lineSegment( new Vector2( x1, 0 ), new Vector2( x1, isMajor( i ) ? -30 : -22 ) ), {pickable: false, stroke: 'black', lineWidth: 1} );
                slider.enabledProperty.link( function( enabled ) {tick.stroke = enabled ? 'black' : 'gray';} );
                slider.ticksLayer.addChild( tick );
                if ( hasLabel( i ) ) {
                  var label = new Text( linear( 0, 1, slider.min, slider.max, i / (numTicks - 1) ).toFixed( 0 ), {pickable: false, centerX: tick.centerX, bottom: tick.top, font: new PhetFont( 16 )} );
                  slider.enabledProperty.link( function( enabled ) {label.fill = enabled ? 'black' : 'gray';} );
                  slider.ticksLayer.addChild( label );
                }
              } );
        
              //Return this for chaining
              return this;
            },
        
            //Add the tick for the specified value, so that the node will be centered on the location specified and just at the edge of the track.
            addTick: function( value, tickAndLabelNode ) {
              tickAndLabelNode.centerX = linear( 0, 1, 0, this.sliderWidth, value );
              tickAndLabelNode.bottom = 0;
              this.ticksLayer.addChild( tickAndLabelNode );
              return this;
            },
        
            //Set the entire slider to be enabled or disabled
            set enabled( value ) { this.enabledProperty.set( value ); },
        
            //Determine whether the slider is enabled or not
            get enabled() { return this.enabledProperty.get(); }
          } );
        } );
        
        
        define("string!FORCES_AND_MOTION_BASICS/appliedForce",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/appliedForce");});
        
        
        define("string!FORCES_AND_MOTION_BASICS/newtons",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/newtons");});
        
        
        define("string!FORCES_AND_MOTION_BASICS/speed",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/speed");});
        
        
        define("string!FORCES_AND_MOTION_BASICS/frictionForce",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/frictionForce");});
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * The gauge node is a scenery node that represents a circular gauge that
         * depicts some dynamic value.  This was originally ported from the
         * speedometer node in forces-and-motion-basics.
         *
         * @author Sam Reid
         * @author John Blanco
         */
        define( 'SCENERY_PHET/GaugeNode',['require','SCENERY/nodes/Circle','SCENERY/nodes/Node','SCENERY/nodes/Text','SCENERY/nodes/Path','KITE/Shape','DOT/Matrix3','PHET_CORE/inherit','DOT/Util','SCENERY_PHET/PhetFont','AXON/Property'],function( require ) {
          
        
          var Circle = require( 'SCENERY/nodes/Circle' );
          var Node = require( 'SCENERY/nodes/Node' );
          var Text = require( 'SCENERY/nodes/Text' );
          var Path = require( 'SCENERY/nodes/Path' );
          var Shape = require( 'KITE/Shape' );
          var Matrix3 = require( 'DOT/Matrix3' );
          var inherit = require( 'PHET_CORE/inherit' );
          var linear = require( 'DOT/Util' ).linear;
          var PhetFont = require( 'SCENERY_PHET/PhetFont' );
          var Property = require( 'AXON/Property' );
        
          /**
           * Constructor
           * @param {Property} valueProperty Property<Number> which is portrayed
           * @param {Object} options typical Node layout and display options
           * @param label {String} label to display (scaled to fit if necessary)
           * @param range {Object} contains min and max values that define the range
           * @constructor
           */
          function GaugeNode( valueProperty, label, range, options ) {
        
            Node.call( this );
        
            options = _.extend( {
              // Defaults
              radius: 67,
              backgroundFill: 'white',
              backgroundStroke: 'rgb( 85, 85, 85 )',
              backgroundLineWidth: 2,
              anglePerTick: Math.PI * 2 / 4 / 8,
        
              //8 ticks goes to 9 o'clock (on the left side), and two more ticks appear below that mark.
              //The ticks are duplicated for the right side, and one tick appears in the middle at the top
              numTicks: ( 8 + 2 ) * 2 + 1,
        
              //Optional property to pass in--if the client provides a updateEnabledProperty then the needle will only be updated when changed and visible (or made visible)
              updateEnabledProperty: new Property( true )
            }, options );
            this.addChild( new Circle( options.radius, {
              fill: options.backgroundFill,
              stroke: options.backgroundStroke,
              lineWidth: options.backgroundLineWidth
            } ) );
        
            var foregroundNode = new Node( { pickable: false } );
            this.addChild( foregroundNode );
        
            var needle = new Path( Shape.lineSegment( 0, 0, options.radius, 0 ), { stroke: 'red', lineWidth: 3} );
            foregroundNode.addChild( needle );
        
            this.label = new Text( label, {font: new PhetFont( 20 )} ).mutate( {centerX: 0, centerY: -options.radius / 3} );
            foregroundNode.addChild( this.label );
        
            var pin = new Circle( 2, {fill: 'black'} );
            foregroundNode.addChild( pin );
        
            var totalAngle = (options.numTicks - 1) * options.anglePerTick;
            var startAngle = -1 / 2 * Math.PI - totalAngle / 2;
            var endAngle = startAngle + totalAngle;
        
            //Update when the velocity changes, but only if the gauge is visible
            var updateNeedle = function() {
              if ( options.updateEnabledProperty.get() ) {
                if ( typeof( valueProperty.get() ) === 'number' ) {
                  needle.visible = true;
                  var needleAngle = linear( range.min, range.max, startAngle, endAngle, Math.abs( valueProperty.get() ) );
                  needle.setMatrix( Matrix3.rotation2( needleAngle ) );
                }
                else {
                  // Hide the needle if there is no value number value to portray.
                  needle.visible = false;
                }
              }
            };
            valueProperty.link( updateNeedle );
        
            //When the gauge is made visible, update the needle
            options.updateEnabledProperty.link( function( visible ) {
              if ( visible ) {
                updateNeedle();
              }
            } );
        
            //Add the tick marks
            for ( var i = 0; i < options.numTicks; i++ ) {
              var tickAngle = i * options.anglePerTick + startAngle;
              var tickLength = i % 2 === 0 ? 10 : 5;
              var lineWidth = i % 2 === 0 ? 2 : 1;
              var tick = new Path( Shape.lineSegment( (options.radius - tickLength) * Math.cos( tickAngle ),
                (options.radius - tickLength) * Math.sin( tickAngle ),
                options.radius * Math.cos( tickAngle ),
                options.radius * Math.sin( tickAngle ) ),
                { stroke: 'gray', lineWidth: lineWidth } );
              foregroundNode.addChild( tick );
            }
        
            this.mutate( options );
          }
        
          return inherit( Node, GaugeNode );
        } );
        
        define("string!FORCES_AND_MOTION_BASICS/acceleration",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/acceleration");});
        
        
        define("string!FORCES_AND_MOTION_BASICS/force",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/force");});
        
        
        define("string!FORCES_AND_MOTION_BASICS/forces",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/forces");});
        
        
        define("string!FORCES_AND_MOTION_BASICS/masses",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/masses");});
        
        
        define("string!FORCES_AND_MOTION_BASICS/friction",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/friction");});
        
        
        define("string!FORCES_AND_MOTION_BASICS/lots",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/lots");});
        
        
        define("string!FORCES_AND_MOTION_BASICS/none",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/none");});
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        //TODO: Consolidate with MutableArrowNode, see #34
        /**
         * A single- or double-headed arrow. This is a convenience class, most of the
         * work is done in ArrowShape.
         *
         * @author John Blanco
         * @author Chris Malley
         */
        define( 'SCENERY_PHET/ArrowNode',['require','SCENERY_PHET/ArrowShape','PHET_CORE/inherit','SCENERY/nodes/Path'],function( require ) {
          
        
          // Imports
          var ArrowShape = require( 'SCENERY_PHET/ArrowShape' );
          var inherit = require( 'PHET_CORE/inherit' );
          var Path = require( 'SCENERY/nodes/Path' );
        
          /**
           * @param {number} tailX
           * @param {number} tailY
           * @param {number} tipX
           * @param {number} tipY
           * @param {Object} options
           * @constructor
           */
          function ArrowNode( tailX, tailY, tipX, tipY, options ) {
        
            // default options
            options = _.extend( {
              headHeight: 10,
              headWidth: 10,
              tailWidth: 5,
              doubleHead: false, // true puts heads on both ends of the arrow, false puts a head at the tip
              fill: 'black',
              stroke: 'black',
              lineWidth: 1
            }, options );
        
            // things you're likely to mess up, add more as needed
            assert && assert( options.headWidth > options.tailWidth );
        
            Path.call( this, new ArrowShape( tailX, tailY, tipX, tipY, options ), options );
            this.options = options;
          }
        
          return inherit( Path, ArrowNode, {
        
            //Set the tail and tip locations to update the arrow shape.  Matches API in MutableArrowNode so they can easily be swapped
            setTailAndTip: function( tailX, tailY, tipX, tipY ) {
              this.shape = new ArrowShape( tailX, tailY, tipX, tipY, this.options );
            }
          } );
        } );
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * In the 'Acceleration' screen, this horizontal indicator shows the amount of acceleration (like a moving bubble).
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/motion/view/AccelerometerNode',['require','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','SCENERY/nodes/Path','KITE/Shape','PHET_CORE/inherit','SCENERY/util/LinearGradient'],function( require ) {
          
        
          var Node = require( 'SCENERY/nodes/Node' );
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
          var Path = require( 'SCENERY/nodes/Path' );
          var Shape = require( 'KITE/Shape' );
          var inherit = require( 'PHET_CORE/inherit' );
          var LinearGradient = require( 'SCENERY/util/LinearGradient' );
        
          //Constructor for the AccelerometerNode
          function AccelerometerNode( accelerationProperty, options ) {
            options = options || {};
            this.ticks = [];
            Node.call( this );
            var height = 15;
            var barWidth = 170;
            var barSideInset = 7;
            var gradient = new LinearGradient( 0, 4, 0, height ).addColorStop( 0, 'white' ).addColorStop( 1, 'rgb( 207, 208, 210 )' );
            var background = new Rectangle( 0 - barSideInset, 0, barWidth + barSideInset * 2, height, 10, 10, { fill: gradient} );
        
            this.addChild( background );
        
            //Tweaked to get 10m/s/s to line up with 1st tick.
            var scale = 4.22;
        
            //The bar that gets bigger or smaller based on the acceleration.
            var bar = new Rectangle( barWidth / 2, 0, 25, height, {fill: new LinearGradient( 0, 5, 0, height ).addColorStop( 0, 'rgb(218,140,180)' ).addColorStop( 1, 'rgb(130,80,100)' )} );
            accelerationProperty.link( function( acceleration ) {
              var scaled = acceleration * scale;
              if ( acceleration > 0 ) {
                bar.setRect( barWidth / 2, 0, scaled, height );
              }
              else {
                var scaledValue = Math.abs( scaled );
                bar.setRect( barWidth / 2 - scaledValue, 0, scaledValue, height );
              }
            } );
            this.addChild( bar );
        
            //Show the knob, which just covers the edge of the bar
            var knobThickness = 1;
            var knob = new Rectangle( barWidth / 2, 0, knobThickness, height, {fill: new LinearGradient( 0, 5, 0, height ).addColorStop( 0, 'rgb(248,194,216)' ).addColorStop( 1, 'rgb(154,105,127)' )} );
            accelerationProperty.link( function( acceleration ) {
              var scaled = acceleration * scale;
              knob.setRect( barWidth / 2 + scaled - knobThickness / 2, 0, knobThickness, height );
            } );
            this.addChild( knob );
        
            //Outline
            this.addChild( new Rectangle( 0 - barSideInset, 0, barWidth + barSideInset * 2, height, 10, 10, {stroke: 'black'} ) );
        
            //Tick marks
            var majorTickInset = 6;
            var minorTickInset = 7;
            var line = Shape.lineSegment;
            this.addTick( new Path( line( 0, majorTickInset, 0, height - majorTickInset ), { stroke: 'black'} ) );
            this.addTick( new Path( line( barWidth / 4, minorTickInset, barWidth / 4, height - minorTickInset ), { stroke: 'black' } ) );
            this.addTick( new Path( line( barWidth / 2, majorTickInset, barWidth / 2, height - majorTickInset ), { stroke: 'black' } ) );
            this.addTick( new Path( line( 3 * barWidth / 4, minorTickInset, 3 * barWidth / 4, height - minorTickInset ), {stroke: 'black' } ) );
            this.addTick( new Path( line( barWidth, majorTickInset, barWidth, height - majorTickInset ), { stroke: 'black' } ) );
        
            this.mutate( options );
          }
        
          return inherit( Node, AccelerometerNode, {
            addTick: function( child ) {
              this.addChild( child );
              this.ticks.push( child );
            }
          } );
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Scenery node that shows the control panel for the Motion, Friction and Acceleration screens.
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/motion/view/MotionControlPanel',['require','SCENERY/nodes/Node','SCENERY/nodes/Path','SCENERY/nodes/Text','SCENERY/nodes/VBox','SCENERY/nodes/HBox','KITE/Shape','DOT/Vector2','FORCES_AND_MOTION_BASICS/motion/view/HSlider','string!FORCES_AND_MOTION_BASICS/speed','string!FORCES_AND_MOTION_BASICS/acceleration','string!FORCES_AND_MOTION_BASICS/force','string!FORCES_AND_MOTION_BASICS/forces','string!FORCES_AND_MOTION_BASICS/sumOfForces','string!FORCES_AND_MOTION_BASICS/values','string!FORCES_AND_MOTION_BASICS/masses','string!FORCES_AND_MOTION_BASICS/friction','string!FORCES_AND_MOTION_BASICS/lots','string!FORCES_AND_MOTION_BASICS/none','AXON/Property','SUN/Panel','PHET_CORE/inherit','SUN/VerticalCheckBoxGroup','FORCES_AND_MOTION_BASICS/motion/MotionConstants','SCENERY_PHET/ArrowNode','SCENERY_PHET/GaugeNode','FORCES_AND_MOTION_BASICS/motion/view/AccelerometerNode','SCENERY/nodes/Rectangle','SCENERY_PHET/PhetFont'],function( require ) {
          
        
          var Node = require( 'SCENERY/nodes/Node' );
          var Path = require( 'SCENERY/nodes/Path' );
          var Text = require( 'SCENERY/nodes/Text' );
          var VBox = require( 'SCENERY/nodes/VBox' );
          var HBox = require( 'SCENERY/nodes/HBox' );
          var Shape = require( 'KITE/Shape' );
          var Vector2 = require( 'DOT/Vector2' );
          var HSlider = require( 'FORCES_AND_MOTION_BASICS/motion/view/HSlider' );
          var speedString = require( 'string!FORCES_AND_MOTION_BASICS/speed' );
          var accelerationString = require( 'string!FORCES_AND_MOTION_BASICS/acceleration' );
          var forceString = require( 'string!FORCES_AND_MOTION_BASICS/force' );
          var forcesString = require( 'string!FORCES_AND_MOTION_BASICS/forces' );
          var sumOfForcesString = require( 'string!FORCES_AND_MOTION_BASICS/sumOfForces' );
          var valuesString = require( 'string!FORCES_AND_MOTION_BASICS/values' );
          var massesString = require( 'string!FORCES_AND_MOTION_BASICS/masses' );
          var frictionString = require( 'string!FORCES_AND_MOTION_BASICS/friction' );
          var lotsString = require( 'string!FORCES_AND_MOTION_BASICS/lots' );
          var noneString = require( 'string!FORCES_AND_MOTION_BASICS/none' );
          var Property = require( 'AXON/Property' );
          var Panel = require( 'SUN/Panel' );
          var inherit = require( 'PHET_CORE/inherit' );
          var VerticalCheckBoxGroup = require( 'SUN/VerticalCheckBoxGroup' );
          var MotionConstants = require( 'FORCES_AND_MOTION_BASICS/motion/MotionConstants' );
          var ArrowNode = require( 'SCENERY_PHET/ArrowNode' );
          var GaugeNode = require( 'SCENERY_PHET/GaugeNode' );
          var AccelerometerNode = require( 'FORCES_AND_MOTION_BASICS/motion/view/AccelerometerNode' );
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
          var PhetFont = require( 'SCENERY_PHET/PhetFont' );
        
          /**
           * Main constructor for MotionControlPanel
           *
           * @param {MotionModel} model the model for the entire 'motion', 'friction' or 'acceleration' screen
           * @constructor
           */
          function MotionControlPanel( model ) {
            Node.call( this, {} );
        
            var fontSize = 18;
        
            var toElement = function( text, propertyName, options ) {
              options = _.extend( {indent: 0}, options );
              var textNode = new Text( text, {font: new PhetFont( fontSize )} );
              return {
                //TODO: Why is this immense spacing necessary here?
                content: options.icon ? new HBox( {spacing: 10, children: [  textNode, options.icon]} ) : textNode,
                property: model.property( propertyName ),
                indent: options.indent
              };
            };
        
            //Icon for the forces in the control panel
            var arrowIcon = function() {return new ArrowNode( 0, 0, 40, 0, {headHeight: 20, headWidth: 20, tailWidth: 10, fill: '#e66e23', stroke: 'black'} );};
            var speedometerIcon = function() { return new GaugeNode( model.velocityProperty, speedString, {min: 0, max: MotionConstants.MAX_SPEED}, {scale: 0.2} );};
            var accelerometerIcon = function() { return new AccelerometerNode( model.accelerationProperty ).mutate( {scale: 0.3} ); };
        
            //Workarounds because VBox centering not working properly
            var spacer = function( width, height ) { return new Rectangle( 0, 0, width, height, {visible: false} ); };
        
            var createFrictionSlider = function() {
              var createTick = function( label, visible ) {
                var path = new Path( Shape.lineSegment( new Vector2( 0, 0 ), new Vector2( 0, -18 ) ), { stroke: 'black', lineWidth: 1} );
                var text = new Text( label, {font: new PhetFont( 15 )} );
                model.stack.lengthProperty.link( function( length ) {
                  var enabled = length > 0;
                  path.fill = enabled ? 'black' : 'gray';
                  text.fill = enabled ? 'black' : 'gray';
                } );
                return new VBox( {children: [ text, path ], pickable: false, visible: visible} );
              };
        
              //Create the friction slider and its labels.
              // Add invisible symmetric ticks + labels so the slider will be perfectly centered.  A better way to do this would be just to line things up based on the track of the slider,
              // but this makes it work with VBox/HBox
              var frictionSlider = new HSlider( 0, MotionConstants.MAX_FRICTION, 150, model.frictionProperty, new Property( 'WITHIN_ALLOWED_RANGE' ), null, null, {zeroOnRelease: false} ).
                addTick( 0, createTick( noneString, true ) ).addTick( 1, createTick( lotsString, true ) ).
                addTick( 0, createTick( lotsString, false ) ).addTick( 1, createTick( noneString, false ) );
              var frictionLabel = new Text( frictionString, new PhetFont( { size: fontSize, weight: 'bold' } ) );
        
              return new VBox( {spacing: -8, children: [frictionLabel , frictionSlider]} );
            };
        
            var indent = 24;
            var controlPanel = new VBox( {
              align: 'center',
              children: model.screen === 'motion' ?
                        [ new VerticalCheckBoxGroup(
                          [
                            toElement( forceString, 'showForce', {icon: arrowIcon()} ),
                            toElement( valuesString, 'showValues', {indent: indent} ),
                            toElement( massesString, 'showMasses' ),
                            toElement( speedString, 'showSpeed', {icon: speedometerIcon()} )
                          ], {fill: '#e3e980'} )] :
                        model.screen === 'friction' ?
                        [ new VerticalCheckBoxGroup(
                          [
                            toElement( forcesString, 'showForce', {icon: arrowIcon()} ),
                            toElement( sumOfForcesString, 'showSumOfForces', {indent: indent} ),
                            toElement( valuesString, 'showValues', {indent: indent} ),
                            toElement( massesString, 'showMasses' ),
                            toElement( speedString, 'showSpeed', {icon: speedometerIcon()} )
                          ], {fill: '#e3e980'} ), spacer( 12, 12 ), createFrictionSlider()  ] :
                        [ new VerticalCheckBoxGroup(
                          [
                            toElement( forcesString, 'showForce', {icon: arrowIcon()} ),
                            toElement( sumOfForcesString, 'showSumOfForces', {indent: indent} ),
                            toElement( valuesString, 'showValues', {indent: indent} ),
                            toElement( massesString, 'showMasses' ),
                            toElement( speedString, 'showSpeed', {icon: speedometerIcon()} ),
                            toElement( accelerationString, 'showAcceleration', {icon: accelerometerIcon()} )
                          ], {fill: '#e3e980'} ), spacer( 12, 12 ), createFrictionSlider()  ]
            } );
            var panelNode = new Panel( controlPanel, {xMargin: 10, yMargin: 10, fill: '#e3e980'} );
            this.addChild( panelNode.mutate( { left: 981 - panelNode.width - 5, top: 5} ) );
          }
        
          return inherit( Node, MotionControlPanel );
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * A pattern that will deliver a fill or stroke that will repeat an image in both directions (x and y).
         *
         * TODO: future support for repeat-x, repeat-y or no-repeat (needs SVG support)
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/util/Pattern',['require','SCENERY/scenery'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          
          // TODO: support scene or other various content (SVG is flexible, can backport to canvas)
          // TODO: investigate options to support repeat-x, repeat-y or no-repeat in SVG (available repeat options from Canvas)
          scenery.Pattern = function Pattern( image ) {
            this.image = image;
            
            // use the global scratch canvas instead of creating a new Canvas
            this.canvasPattern = scenery.scratchContext.createPattern( image, 'repeat' );
            
            this.transformMatrix = null;
          };
          var Pattern = scenery.Pattern;
          
          Pattern.prototype = {
            constructor: Pattern,
            
            isPattern: true,
            
            setTransformMatrix: function( transformMatrix ) {
              this.transformMatrix = transformMatrix;
              return this;
            },
            
            getCanvasStyle: function() {
              return this.canvasPattern;
            },
            
            getSVGDefinition: function( id ) {
              var definition = document.createElementNS( scenery.svgns, 'pattern' );
              definition.setAttribute( 'id', id );
              definition.setAttribute( 'patternUnits', 'userSpaceOnUse' ); // so we don't depend on the bounds of the object being drawn with the gradient
              definition.setAttribute( 'patternContentUnits', 'userSpaceOnUse' ); // TODO: is this needed?
              definition.setAttribute( 'x', 0 );
              definition.setAttribute( 'y', 0 );
              definition.setAttribute( 'width', this.image.width );
              definition.setAttribute( 'height', this.image.height );
              if ( this.transformMatrix ) {
                definition.setAttribute( 'patternTransform', this.transformMatrix.getSVGTransform() );
              }
              
              definition.appendChild( scenery.Image.createSVGImage( this.image.src, this.image.width, this.image.height ) );
              
              return definition;
            },
            
            toString: function() {
              return 'new scenery.Pattern( $( \'<img src="' + this.image.src + '"/>\' )[0] )';
            }
          };
          
          return Pattern;
        } );
        
        
        define("image!FORCES_AND_MOTION_BASICS/mountains.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/brick-tile.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAhCAIAAACdh/i6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3QMPFBgyLFQNogAABExJREFUaN7tWkGu40QQfe9NhzASsERCYjvLWSDN1xyAC8wGbjEbLsKGA7CeDRcAaS4wEhJLJNgxI9gTSP53sajqdjt2EjtfP+Mg9/+K4rYdv65+9aqq23zx9FMs7eGbFhNcpqXNZrdY4QKNP3739WKFSzD6kbhY4RKGXq/Tg3gKudlsyXYWzezD9Wrcze/Jux8SM796/ll7ZL0vdRs82ww/Y7PZfvPyy/rc4/Xq2+9/skO/eej3j3deD+a03d2OuvTkOLttu7sjBWtPi9ze3pnZaUOcYdzzbr8g5tRYdNkp9OY9JxDbKjGTgqwDAOXuCeDOHzaeg9b7vDbM6ebzTyRCkEBSBEUSYukECXmnXyOAw5q0XvGH139lyJ3LygBuzZ5+/NEE6QRIUBDJDLLFDEqgSFSdGbMIzgNzWq3oBxJJk0QaRTEPgCaRncODZc76g5YP7A6sPkqcEO8kI0kxT3PAy8MwUqXTr6Fmhzm54RlzKcBIivRj0kj6NQhSy8x44Km1mvnNe244vpk5KTJiBmIENMQfJQZmJ5IzaG6YpbCwhWLI5QNUOy3hfTCJ/Wk/li65E4Ur8XgsGkyYGEbzbwYEbdHSFhAcswQJYIzFTe2Pfe+YU8bHdipoCkq4IBrhZ6fkt7Y/OHIyNRTTbxRdcCEyCNJiloPMmJU5ToVAzwFzChbAA6DCyjkeZlJHGJyY/2vgsBk14Ai8JWAEcwOPXOkqzOhgDgGZGWYSoGQKxYg+Zu7ke7ifTp4MCM6w9p+wEVWfwYpvxY+EUbNvRQxx7mSVK5gBmjxazglzKqEZzKIcWUeY3VVmgsy1UwzWy7BjVRJiDLi4ocKCPutWpRN9zC3HZ4XZee42NXnoDsaYk3qq97VyB3W4MSKwmIG0Eus8VCuczHmaxTd4YLwSzEmOM7thlXVkgea5azzheMMp6jCfwreCAn5X5Y+WlSOS5V6mNF/MiW214ihVKhROdr190B3X8+82zA4zUBDMi76cIbcFFFqbGrqYPd8PxswVc/I0I6fqKrkdadQ9Nros6qAx7IjEKGTBSqyThDaC5wF4CU5cG2aWeQjvg6IgnBqyexGCh52yR6M6wwFLNIvKAy67IQvFVXk9mFPU4znriFT6aM16rhvqIDViQYCEEapWjowUszNGhClZR47yCumYL2Zf6zDPTzzjQ8WL+7Fjf8zcx2plaHKkKDkDJGW+eMCwvIJhuQoxX+VAaOOsMRNMv/6xcaKjfJZpnI75kQ4XsFk9Bbzb/NsZTBTPKAtGYFmjcDOWNUwor0d0MJcb5oo5/fb271G7ElNzJEBkzYmQvwYi//xne+ae0KSdlDlhTgerTLv3JilVQ4g1KVZBhr1nHe8cPHslmNPNsyeTNtZGtu12B6J+E2p319x88WTsg8Z3Nt1xzhUz37x6iaU9fFvevbtQSz//8nsOsDN/ZYlN0/S25q4GM188W17bXaTjf9T+A+moDV+1pfKDAAAAAElFTkSuQmCC';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/cloud1.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/icicle.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * This class shows all of the moving background, including the mountains, clouds and brick tile on the ground.
         *
         * Performance notes:
         * Using .boundsInaccurate = true; seems to save about 1 ms during rendering on the iPad3
         *
         * @author Sam Reid
         */
        define( 'FORCES_AND_MOTION_BASICS/motion/view/MovingBackgroundNode',['require','SCENERY/nodes/Rectangle','SCENERY/util/Pattern','SCENERY/nodes/Node','SCENERY/nodes/Image','PHET_CORE/inherit','image!FORCES_AND_MOTION_BASICS/mountains.png','image!FORCES_AND_MOTION_BASICS/brick-tile.png','image!FORCES_AND_MOTION_BASICS/cloud1.png','image!FORCES_AND_MOTION_BASICS/icicle.png','DOT/Util','FORCES_AND_MOTION_BASICS/motion/MotionConstants'],function( require ) {
          
        
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
          var Pattern = require( 'SCENERY/util/Pattern' );
          var Node = require( 'SCENERY/nodes/Node' );
          var Image = require( 'SCENERY/nodes/Image' );
          var inherit = require( 'PHET_CORE/inherit' );
          var mountainImage = require( 'image!FORCES_AND_MOTION_BASICS/mountains.png' );
          var brickTileImage = require( 'image!FORCES_AND_MOTION_BASICS/brick-tile.png' );
          var cloudImage = require( 'image!FORCES_AND_MOTION_BASICS/cloud1.png' );
          var icicleImage = require( 'image!FORCES_AND_MOTION_BASICS/icicle.png' );
          var linear = require( 'DOT/Util' ).linear;
          var MotionConstants = require( 'FORCES_AND_MOTION_BASICS/motion/MotionConstants' );
        
          /**
           * Constructor for MovingBackgroundNode
           *
           * @param {MotionModel} model the model for the entire 'motion', 'friction' or 'acceleration' screen
           * @param layoutCenterX the location where the node should be centered horizontally
           * @constructor
           */
          function MovingBackgroundNode( model, layoutCenterX ) {
            var movingBackgroundNode = this;
            this.model = model;
        
            Node.call( this, { pickable: false } );
        
            var L = 900;
        
            //Add a background node at the specified X offset (pixels).  The distanceScale signifies how quickly it will scroll (mountains are far away so have a lower distanceScale)
            var toBackgroundImage = function( offset, image, y, scale ) {
              var node = new Image( image, {scale: scale, x: offset, y: y, rendererOptions: {cssTransform: true}} );
              node.boundsInaccurate = true;
              node.offsetX = offset;
              node.scaleFactor = scale;
              return node;
            };
        
            var stageWidth = L * 2;
        
            var mountainY = 311;
        
            //TODO: It would be good to use cssTransforms here but they are a bit buggy
            var mountainAndCloudLayer = new Node( {x: layoutCenterX,
              children: [
                toBackgroundImage( L / 2, mountainImage, mountainY, 1 ),
                toBackgroundImage( L, mountainImage, mountainY, 1 ),
                toBackgroundImage( -L / 3, mountainImage, mountainY, 1 ),
                toBackgroundImage( 0, cloudImage, 10, 0.7 ),
                toBackgroundImage( L - 100, cloudImage, -30, 0.8 ),
                toBackgroundImage( -L / 3 - 100, cloudImage, 5, 1 )
              ]
            } );
            mountainAndCloudLayer.boundsInaccurate = true;
            this.addChild( mountainAndCloudLayer );
        
            //Move the background objects
            //TODO: support background objects with scale !== 1
        
            var getLayerUpdater = function( layer, motionScale ) {
              var netDelta = 0;
              var children = layer.children;
              return function( position, oldPosition ) {
                var delta = -(position - oldPosition) * MotionConstants.POSITION_SCALE / motionScale;
                netDelta += delta;
                layer.translate( delta, 0 );
        
                var sign = position > oldPosition ? 1 : -1;
                for ( var i = 0; i < children.length; i++ ) {
                  var child = children[i];
        
        //        console.log( child.offsetX + netDelta );
                  //model moving right
                  if ( sign === 1 ) {
        //            console.log( child.offsetX + netDelta, -800 );
        
                    //TODO: use modulus instead of while loop
                    while ( child.offsetX + netDelta < -L ) {
        //              console.log( 'jump 1' );
                      child.offsetX += stageWidth;
                      child.translate( stageWidth / child.scaleFactor, 0 );
                    }
                  }
        
                  //model moving left
                  else {
        //          console.log( child.offsetX + netDelta, L );
        
                    //TODO: use modulus instead of while loop
                    while ( child.offsetX + netDelta > L ) {
        //              console.log( 'jump 2' );
                      child.offsetX -= stageWidth;
                      child.translate( -stageWidth / child.scaleFactor, 0 );
                    }
                  }
                }
              };
            };
        
            model.positionProperty.link( getLayerUpdater( mountainAndCloudLayer, 10 ) );
        
            var tileWidth = brickTileImage.width;
        
            //Add the ground, offset the pattern so that the it aligns with the brick image
            var tilePattern = new Pattern( brickTileImage );
            var ground = new Rectangle( 0, 0, brickTileImage.width * 14, brickTileImage.height, {fill: tilePattern } );
            var mod = ground.width / 14;
            var centerX = layoutCenterX - ground.width / 2;
        
            //Rendering as a single image instead of a Pattern significantly improves performance on both iPad and Win8/Chrome
            ground.toImage( function( image ) {
              var groundY = mountainY + 50;
              var groundImageNode = new Image( image, {y: groundY, rendererOptions: {cssTransform: true}} );
              groundImageNode.boundsInaccurate = true;
              movingBackgroundNode.addChild( groundImageNode );
              model.positionProperty.link( function( position ) {
                groundImageNode.setTranslation( -position * MotionConstants.POSITION_SCALE % mod + centerX, groundY );
              } );
        
              //Add the gravel and ice.  Do this in the ground callback to keep the z-ordering correct
              if ( !model.skateboard ) {
        
                //Add the gravel
                var gravel = new Rectangle( 0, 0, brickTileImage.width * 14, 4, {y: -2, rendererOptions: {cssTransform: true}} );
                gravel.boundsInaccurate = true;
        
                //Adding the gravel directly to the moving ground makes the performance significantly faster on iPad3
                groundImageNode.addChild( gravel );
        
                //Add the ice
                var iceOverlay = new Rectangle( -400, groundY, brickTileImage.width * 15, brickTileImage.height, {fill: 'rgba(189,227,249,0.87)', rendererOptions: {cssTransform: true}} );
                iceOverlay.boundsInaccurate = true;
                model.addDerivedProperty( 'frictionZero', ['friction'], function( friction ) {return friction === 0;} );
                model.addDerivedProperty( 'frictionNonZero', ['friction'], function( friction ) {return friction !== 0;} );
                movingBackgroundNode.addChild( iceOverlay );
                model.frictionZeroProperty.linkAttribute( iceOverlay, 'visible' );
        
                //make sure gravel gets exactly removed if friction is zero, in case it improves performance.
                model.frictionNonZeroProperty.linkAttribute( gravel, 'visible' );
        
                var iceLayer = new Node( {
                  children: [
                    toBackgroundImage( 0, icicleImage, 0, 0.8 ),
                    toBackgroundImage( 300, icicleImage, 0, 0.8 )
                  ], x: layoutCenterX, y: groundY + ground.height} );
                iceLayer.boundsInaccurate = true;
                model.frictionZeroProperty.linkAttribute( iceLayer, 'visible' );
                movingBackgroundNode.addChild( iceLayer );
        
                //TODO: could prevent updater from firing if ice is not visible
                model.positionProperty.link( getLayerUpdater( iceLayer, 1 ) );
        
                movingBackgroundNode.lastNumSpecks = 0;
        
                var gravelSource = new Node();
        
                var numBlack = 0;
                var numGray = 0;
                var numWhite = 0;
        
                //Create the gravel for nonzero friction.
                model.frictionProperty.link( function( newFriction, oldFriction ) {
        
                  //Discretize the friction so that the new nodes/images are not created at every step
                  newFriction = newFriction * 100;
                  newFriction = Math.round( newFriction / 2 ) * 2;
                  newFriction = newFriction / 100;
        
                  var height = 3;
                  var numSpecks = linear( MotionConstants.MAX_FRICTION * 0.1, MotionConstants.MAX_FRICTION, 0, 400, newFriction );
                  numSpecks = numSpecks < 0 ? 0 : numSpecks;
        
                  var desiredBlack = Math.round( numSpecks / 2 );
                  var desiredGray = Math.round( numSpecks / 2 );
                  var desiredWhite = Math.round( numSpecks / 10 );
        
                  if ( desiredBlack === numBlack && desiredGray === numGray && desiredWhite === numWhite ) {
                    return;
                  }
        
                  while ( numBlack < desiredBlack ) {
                    gravelSource.addChild( new Rectangle( Math.floor( Math.random() * (tileWidth + 1) ), Math.floor( Math.random() * (height + 1) ), 1, 1, {fill: 'black'} ) );
                    numBlack++;
                  }
        
                  while ( numGray < desiredGray ) {
                    gravelSource.addChild( new Rectangle( Math.floor( Math.random() * (tileWidth + 1) ), Math.floor( Math.random() * (height + 1) ), 1, 1, {fill: 'gray'} ) );
                    numGray++;
                  }
        
                  while ( numWhite < desiredWhite ) {
                    gravelSource.addChild( new Rectangle( Math.floor( Math.random() * (tileWidth + 1) ), Math.floor( Math.random() * (height + 1) ), 1, 1, {fill: 'white'} ) );
                    numWhite++;
                  }
        
                  var children;
                  var i;
                  while ( numBlack > desiredBlack ) {
                    children = gravelSource.getChildren();
                    for ( i = children.length - 1; i >= 0; i-- ) {
                      if ( children[i].fill === 'black' ) {
                        gravelSource.removeChildAt( i );
                        break;
                      }
                    }
                    numBlack--;
                  }
        
                  while ( numGray > desiredGray ) {
                    children = gravelSource.getChildren();
                    for ( i = children.length - 1; i >= 0; i-- ) {
                      if ( children[i].fill === 'gray' ) {
                        gravelSource.removeChildAt( i );
                        break;
                      }
                    }
                    numGray--;
                  }
        
                  while ( numWhite > desiredWhite ) {
                    children = gravelSource.getChildren();
                    for ( i = children.length - 1; i >= 0; i-- ) {
                      if ( children[i].fill === 'white' ) {
                        gravelSource.removeChildAt( i );
                        break;
                      }
                    }
                    numWhite--;
                  }
        
                  //TODO: get rid of pattern here, possibly by converting it too to an image?
                  gravelSource.toImage( function( image ) { gravel.fill = new Pattern( image ); }, 0, 0, tileWidth, height );
                } );
              }
            }, 0, 0, ground.width, ground.height );
          }
        
          return inherit( Node, MovingBackgroundNode );
        } );
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * If given an Array, removes all of its elements and returns it. Otherwise, if given a falsy value
         * (null/undefined/etc.), it will create and return a fresh Array.
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'PHET_CORE/cleanArray',['require','PHET_CORE/core'],function( require ) {
          
        
          var core = require( 'PHET_CORE/core' );
        
          core.cleanArray = function cleanArray( arr ) {
            assert && assert( !arr || ( arr instanceof Array ), 'cleanArray either takes an Array' );
        
            if ( arr ) {
              // fastest way to clear an array (http://stackoverflow.com/questions/1232040/how-to-empty-an-array-in-javascript, http://jsperf.com/array-destroy/32)
              // also, better than length=0, since it doesn't create significant garbage collection (like length=0), tested on Chrome 34.
              while ( arr.length ) {
                arr.pop();
              }
              return arr;
            }
            else {
              return [];
            }
          };
        
          return core.cleanArray;
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Timer so that other modules can run timing related code through the simulation's requestAnimationFrame.
         * Note: this is not specific to the running screen, it is global across all screens.
         *
         * @author Sam Reid
         */
        define( 'JOIST/Timer',['require','PHET_CORE/cleanArray'],function( require ) {
          
        
          var cleanArray = require( 'PHET_CORE/cleanArray' );
        
          var listeners = [];
          var listenersDefensiveCopy = []; // separated out to prevent garbage collection issues
          return {
        
            //Trigger a step event, called by Sim.js in the animation loop
            step: function( dt ) {
              var length = listeners.length;
              var i;
        
              // to safely allow listeners to remove themselves while being called (as is explicitly done in setTimeout), we make a copy of the array.
              // we don't use slice(), since that would cause garbage collection issues.
              for ( i = 0; i < length; i++ ) {
                listenersDefensiveCopy[i] = listeners[i];
              }
              for ( i = 0; i < length; i++ ) {
                listenersDefensiveCopy[i]( dt );
              }
              cleanArray( listenersDefensiveCopy );
            },
        
            //Add a listener to be called back once after the specified time (in milliseconds)
            setTimeout: function( listener, timeout ) {
              var elapsed = 0;
              var timer = this;
              var callback = function( dt ) {
                elapsed += dt;
        
                //Convert seconds to ms and see if item has timed out
                if ( elapsed * 1000 >= timeout ) {
                  listener();
                  timer.removeStepListener( callback );
                }
              };
              this.addStepListener( callback );
        
              //Return the callback so it can be removed with removeStepListener
              return callback;
            },
        
            //Clear a scheduled timeout
            clearTimeout: function( timeoutID ) { this.removeStepListener( timeoutID ); },
        
            //Add a listener to be called at specified intervals (in milliseconds)
            setInterval: function( listener, interval ) {
              var elapsed = 0;
              var callback = function( dt ) {
                elapsed += dt;
        
                //Convert seconds to ms and see if item has timed out
                while ( elapsed * 1000 >= interval && listeners.indexOf( callback ) !== -1 ) {
                  listener();
                  elapsed = elapsed - interval / 1000.0; //Save the leftover time so it won't accumulate
                }
              };
              this.addStepListener( callback );
        
              //Return the callback so it can be removed with removeStepListener
              return callback;
            },
        
            //Clear a scheduled interval
            clearInterval: function( intervalID ) { this.removeStepListener( intervalID ); },
        
            //Add a listener to be called back on every animationFrame with a dt value
            addStepListener: function( listener ) { listeners.push( listener ); },
        
            //Remove a step listener from being called back
            removeStepListener: function( listener ) {
              var index = listeners.indexOf( listener );
              assert && assert( index !== -1, 'An attempt was made to remove a non-existent step listener' );
              if ( index !== -1 ) {
                listeners.splice( index, 1 );
              }
            }
          };
        } );
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        //TODO generalize this so that any node can be put on the button
        //TODO This implementation should eventually use sun.buttons.RectangularButton
        /**
         * Button with an arrow that points up, down, left or right.
         * Press and release immediately and the button fires on 'up'.
         * Press and hold for M milliseconds and the button will fire repeatedly every N milliseconds until released.
         *
         * @author Chris Malley (PixelZoom, Inc)
         */
        define( 'SCENERY_PHET/ArrowButton',['require','SCENERY/input/ButtonListener','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Path','SCENERY/nodes/Rectangle','KITE/Shape','JOIST/Timer'],function( require ) {
          
        
          // modules
          var ButtonListener = require( 'SCENERY/input/ButtonListener' );
          var inherit = require( 'PHET_CORE/inherit' );
          var Node = require( 'SCENERY/nodes/Node' );
          var Path = require( 'SCENERY/nodes/Path' );
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
          var Shape = require( 'KITE/Shape' );
          var Timer = require( 'JOIST/Timer' );
        
          /**
           * @param {String} direction 'up'|'down'|'left'|'right'
           * @param callback
           * @param options
           * @constructor
           */
          function ArrowButton( direction, callback, options ) {
        
            var thisButton = this;
        
            var DEFAULT_ARROW_HEIGHT = 20;
            options = _.extend( {
                arrowHeight: DEFAULT_ARROW_HEIGHT, // from tip to base
                arrowWidth: DEFAULT_ARROW_HEIGHT * Math.sqrt( 3 ) / 2, // width of base
                fill: 'white',
                stroke: 'black',
                lineWidth: 1,
                xMargin: 7,
                yMargin: 5,
                cornerRadius: 4,
                enabledFill: 'black',
                disabledFill: 'rgb(175,175,175)',
                enabledStroke: 'black',
                disabledStroke: 'rgb(175,175,175)',
                timerDelay: 400, // start to fire continuously after pressing for this long (milliseconds)
                intervalDelay: 100 // fire continuously at this frequency (milliseconds)
              },
              options );
        
            Node.call( thisButton );
        
            // nodes
            var arrowShape;
            if ( direction === 'up' ) {
              arrowShape = new Shape().moveTo( options.arrowHeight / 2, 0 ).lineTo( options.arrowHeight, options.arrowWidth ).lineTo( 0, options.arrowWidth ).close();
            }
            else if ( direction === 'down' ) {
              arrowShape = new Shape().moveTo( 0, 0 ).lineTo( options.arrowHeight, 0 ).lineTo( options.arrowHeight / 2, options.arrowWidth ).close();
            }
            else if ( direction === 'left' ) {
              arrowShape = new Shape().moveTo( 0, options.arrowHeight / 2 ).lineTo( options.arrowWidth, 0 ).lineTo( options.arrowWidth, options.arrowHeight ).close();
            }
            else if ( direction === 'right' ) {
              arrowShape = new Shape().moveTo( 0, 0 ).lineTo( options.arrowWidth, options.arrowHeight / 2 ).lineTo( 0, options.arrowHeight ).close();
            }
            else {
              throw new Error( "unsupported direction: " + direction );
            }
            var arrowNode = new Path( arrowShape, { fill: options.enabledFill, pickable: false } );
            var background = new Rectangle( 0, 0, arrowNode.width + ( 2 * options.xMargin ), arrowNode.height + ( 2 * options.yMargin ), options.cornerRadius, options.cornerRadius,
              {stroke: options.stroke, lineWidth: options.lineWidth, fill: options.fill, pickable: false } );
        
            // rendering order
            thisButton.addChild( background );
            thisButton.addChild( arrowNode );
        
            // layout
            arrowNode.centerX = background.centerX;
            arrowNode.centerY = background.centerY;
        
            // touch area
            var dx = 0.25 * thisButton.width;
            var dy = 0.25 * thisButton.height;
            thisButton.touchArea = Shape.rectangle( -dx, -dy, thisButton.width + dx + dx, thisButton.height + dy + dy );
        
            // mouse area is constrained to the tight rectangle, so that we can make the children unpickable
            thisButton.mouseArea = Shape.rectangle( 0, 0, thisButton.width, thisButton.height );
        
            // interactivity
            thisButton.cursor = 'pointer';
            var enabled = true;
            var fired = false;
            var timeoutID = null;
            var intervalID = null;
            var cleanupTimer = function() {
              if ( timeoutID ) {
                Timer.clearTimeout( timeoutID );
                timeoutID = null;
              }
              if ( intervalID ) {
                Timer.clearInterval( intervalID );
                intervalID = null;
              }
            };
            thisButton.addInputListener( new ButtonListener( {
        
              over: function() {
                //TODO highlight
              },
        
              down: function() {
                if ( timeoutID === null && intervalID === null ) {
                  fired = false;
                  timeoutID = Timer.setTimeout( function() {
                    timeoutID = null;
                    fired = true;
                    intervalID = Timer.setInterval( function() {
                      if ( enabled ) {
                        callback();
                      }
                    }, options.intervalDelay );
                  }, options.timerDelay );
                }
              },
        
              up: function() {
                cleanupTimer();
              },
        
              fire: function() {
                cleanupTimer();
                if ( !fired && enabled ) {
                  callback();
                }
              }
            } ) );
        
            //TODO consider adding this to the prototype. Would need to convert several local vars to fields, and cleanupTimer gets a little complicated.
            thisButton.setEnabled = function( value ) {
              enabled = value;
              if ( !enabled ) {
                cleanupTimer();
              }
              arrowNode.fill = enabled ? options.enabledFill : options.disabledFill;
              background.stroke = enabled ? options.enabledStroke : options.disabledStroke;
              thisButton.pickable = enabled;
            };
            thisButton.setEnabled( true );
        
            thisButton.mutate( options );
          }
        
          inherit( Node, ArrowButton );
        
          return ArrowButton;
        } );
        
        
        define("image!FORCES_AND_MOTION_BASICS/skateboard.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Main scenery view for the Motion, Friction and Acceleration screens.
         */
        define( 'FORCES_AND_MOTION_BASICS/motion/view/MotionView',['require','FORCES_AND_MOTION_BASICS/motion/MotionConstants','SCENERY_PHET/ResetAllButton','SCENERY/nodes/Rectangle','SCENERY/nodes/Node','SCENERY/nodes/Image','SCENERY/nodes/Text','SCENERY/nodes/VBox','SCENERY/util/LinearGradient','FORCES_AND_MOTION_BASICS/motion/view/ItemNode','FORCES_AND_MOTION_BASICS/motion/view/WaterBucketNode','FORCES_AND_MOTION_BASICS/motion/view/PusherNode','FORCES_AND_MOTION_BASICS/motion/view/HSlider','string!FORCES_AND_MOTION_BASICS/appliedForce','string!FORCES_AND_MOTION_BASICS/newtons','string!FORCES_AND_MOTION_BASICS/speed','string!FORCES_AND_MOTION_BASICS/sumOfForces','string!FORCES_AND_MOTION_BASICS/sumOfForcesEqualsZero','string!FORCES_AND_MOTION_BASICS/frictionForce','SCENERY_PHET/GaugeNode','PHET_CORE/inherit','FORCES_AND_MOTION_BASICS/motion/view/MotionControlPanel','FORCES_AND_MOTION_BASICS/motion/view/MovingBackgroundNode','JOIST/ScreenView','DOT/Bounds2','FORCES_AND_MOTION_BASICS/common/view/ReadoutArrow','SCENERY_PHET/PhetFont','FORCES_AND_MOTION_BASICS/motion/view/AccelerometerNode','AXON/Property','AXON/DerivedProperty','SCENERY_PHET/ArrowButton','image!FORCES_AND_MOTION_BASICS/skateboard.png'],function( require ) {
          
        
          var MotionConstants = require( 'FORCES_AND_MOTION_BASICS/motion/MotionConstants' );
          var ResetAllButton = require( 'SCENERY_PHET/ResetAllButton' );
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
          var Node = require( 'SCENERY/nodes/Node' );
          var Image = require( 'SCENERY/nodes/Image' );
          var Text = require( 'SCENERY/nodes/Text' );
          var VBox = require( 'SCENERY/nodes/VBox' );
          var LinearGradient = require( 'SCENERY/util/LinearGradient' );
          var ItemNode = require( 'FORCES_AND_MOTION_BASICS/motion/view/ItemNode' );
          var WaterBucketNode = require( 'FORCES_AND_MOTION_BASICS/motion/view/WaterBucketNode' );
          var PusherNode = require( 'FORCES_AND_MOTION_BASICS/motion/view/PusherNode' );
          var HSlider = require( 'FORCES_AND_MOTION_BASICS/motion/view/HSlider' );
          var appliedForceString = require( 'string!FORCES_AND_MOTION_BASICS/appliedForce' );
          var newtonsString = require( 'string!FORCES_AND_MOTION_BASICS/newtons' );
          var speedString = require( 'string!FORCES_AND_MOTION_BASICS/speed' );
          var sumOfForcesString = require( 'string!FORCES_AND_MOTION_BASICS/sumOfForces' );
          var sumOfForcesEqualsZeroString = require( 'string!FORCES_AND_MOTION_BASICS/sumOfForcesEqualsZero' );
          var frictionForceString = require( 'string!FORCES_AND_MOTION_BASICS/frictionForce' );
          var GaugeNode = require( 'SCENERY_PHET/GaugeNode' );
          var inherit = require( 'PHET_CORE/inherit' );
          var MotionControlPanel = require( 'FORCES_AND_MOTION_BASICS/motion/view/MotionControlPanel' );
          var MovingBackgroundNode = require( 'FORCES_AND_MOTION_BASICS/motion/view/MovingBackgroundNode' );
          var ScreenView = require( 'JOIST/ScreenView' );
          var Bounds2 = require( 'DOT/Bounds2' );
          var ReadoutArrow = require( 'FORCES_AND_MOTION_BASICS/common/view/ReadoutArrow' );
          var PhetFont = require( 'SCENERY_PHET/PhetFont' );
          var AccelerometerNode = require( 'FORCES_AND_MOTION_BASICS/motion/view/AccelerometerNode' );
          var Property = require( 'AXON/Property' );
          var DerivedProperty = require( 'AXON/DerivedProperty' );
          var ArrowButton = require( 'SCENERY_PHET/ArrowButton' );
          var skateboardImage = require( 'image!FORCES_AND_MOTION_BASICS/skateboard.png' );
        
          //The aspect ratio that this sim was coded for differs by 7% than the one we eventually decided upon.
          //aspect ratio of this screen: 981/604=1.62
          //aspect ratio for default: 768/504=1.52
          //TODO: Rewrite the sim layout to use the standard bounds (lower priority)
          var LAYOUT_BOUNDS = new Bounds2( 0, 0, 981, 604 );
        
          /**
           * Constructor for the MotionView
           * @param {MotionModel} model model for the entire screen
           * @constructor
           */
          function MotionView( model ) {
        
            //Constants and fields
            this.model = model;
        
            //Call super constructor
            ScreenView.call( this, {renderer: 'svg', layoutBounds: LAYOUT_BOUNDS} );
        
            //Variables for this constructor, for convenience
            var motionView = this;
            var width = this.layoutBounds.width;
            var height = this.layoutBounds.height;
        
            //Constants
            var skyHeight = 362;
            var groundHeight = height - skyHeight;
        
            //Create the static background
            var skyGradient = new LinearGradient( 0, 0, 0, skyHeight ).addColorStop( 0, '#02ace4' ).addColorStop( 1, '#cfecfc' );
            this.sky = new Rectangle( -width, -skyHeight, width * 3, skyHeight * 2, {fill: skyGradient, pickable: false} );
        
            this.groundNode = new Rectangle( -width, skyHeight, width * 3, groundHeight * 3, {fill: '#c59a5b', pickable: false} );
            this.addChild( this.sky );
            this.addChild( this.groundNode );
        
            //Create the dynamic (moving) background
            this.addChild( new MovingBackgroundNode( model, this.layoutBounds.width / 2 ).mutate( { layerSplit: true } ) );
        
            //Add toolbox backgrounds for the objects
            var boxHeight = 180;
            this.addChild( new Rectangle( 10, height - boxHeight - 10, 300, boxHeight, 10, 10, {fill: '#e7e8e9', stroke: '#000000', lineWidth: 1, pickable: false} ) );
            this.addChild( new Rectangle( width - 10 - 300, height - boxHeight - 10, 300, boxHeight, 10, 10, { fill: '#e7e8e9', stroke: '#000000', lineWidth: 1, pickable: false} ) );
        
            //Add the pusher
            this.addChild( new PusherNode( model, this.layoutBounds.width ) );
        
            //Add the skateboard if on the 'motion' screen
            if ( model.skateboard ) {
              this.addChild( new Image( skateboardImage, {centerX: width / 2, y: 315 + 12, pickable: false} ) );
            }
        
            //Create the slider
            var disableText = function( node ) { return function( length ) {node.fill = length === 0 ? 'gray' : 'black';}; };
            var disableLeftProperty = new DerivedProperty( [model.fallenProperty, model.fallenDirectionProperty], function( fallen, fallenDirection ) {
              return fallen && fallenDirection === 'left';
            } );
            var disableRightProperty = new DerivedProperty( [model.fallenProperty, model.fallenDirectionProperty], function( fallen, fallenDirection ) {
              return fallen && fallenDirection === 'right';
            } );
            var sliderLabel = new Text( appliedForceString, {font: new PhetFont( 22 ), centerX: width / 2, y: 430} );
            var slider = new HSlider( -500, 500, 300, model.appliedForceProperty, model.speedClassificationProperty, disableLeftProperty, disableRightProperty, {zeroOnRelease: true, centerX: width / 2 + 1, y: 535} ).addNormalTicks();
        
            this.addChild( sliderLabel );
            this.addChild( slider );
        
            //Position the units to the right of the text box.
            var readout = new Text( '???', {font: new PhetFont( 22 ), pickable: false} );
            readout.bottom = slider.top - 15;
            model.appliedForceProperty.link( function( appliedForce ) {
        
              //Must match the other formatters below, see roundedAppliedForceProperty near the creation of the ReadoutArrows
              var numberText = parseInt( Math.round( appliedForce ).toFixed( 0 ), 10 ).toFixed( 0 );
        
              //Prevent -0 from appearing, see https://github.com/phetsims/forces-and-motion-basics/issues/70
              if ( numberText === '-0' ) { numberText = '0'; }
              readout.text = numberText + ' ' + newtonsString; //TODO: i18n message format
              readout.centerX = width / 2;
            } );
        
            //Make 'Newtons Readout' stand out but not look like a text entry field
            this.textPanelNode = new Rectangle( 0, 0, readout.right - readout.left + 50, readout.height + 4, {fill: 'white', stroke: 'lightGray', centerX: width / 2, top: readout.y - readout.height + 2, pickable: false} );
            this.addChild( this.textPanelNode );
            this.addChild( readout );
        
            //Show left arrow button 'tweaker' to change the applied force in increments of 50
            var leftArrowButton = new ArrowButton( 'left', function() {
              model.appliedForce = Math.max( model.appliedForce - 50, -500 );
            }, {rectangleYMargin: 7, rectangleXMargin: 10, right: this.textPanelNode.left - 6, centerY: this.textPanelNode.centerY} );
        
            //Do not allow the user to apply a force that would take the object beyond its maximum velocity
            model.multilink( ['appliedForce', 'speedClassification', 'stackSize'], function( appliedForce, speedClassification, stackSize ) {leftArrowButton.setEnabled( stackSize > 0 && (speedClassification === 'LEFT_SPEED_EXCEEDED' ? false : appliedForce > -500 ) );} );
            this.addChild( leftArrowButton );
        
            //Show right arrow button 'tweaker' to change the applied force in increments of 50
            var rightArrowButton = new ArrowButton( 'right', function() {
              model.appliedForce = Math.min( model.appliedForce + 50, 500 );
            }, {rectangleYMargin: 7, rectangleXMargin: 10, left: this.textPanelNode.right + 6, centerY: this.textPanelNode.centerY} );
        
            //Do not allow the user to apply a force that would take the object beyond its maximum velocity
            model.multilink( ['appliedForce', 'speedClassification', 'stackSize'], function( appliedForce, speedClassification, stackSize ) { rightArrowButton.setEnabled( stackSize > 0 && (speedClassification === 'RIGHT_SPEED_EXCEEDED' ? false : appliedForce < 500 ) ); } );
            this.addChild( rightArrowButton );
        
            model.stack.lengthProperty.link( disableText( sliderLabel ) );
            model.stack.lengthProperty.link( disableText( readout ) );
            model.stack.lengthProperty.link( function( length ) { slider.enabled = length > 0; } );
        
            //Create the speedometer.  Specify the location after construction so we can set the 'top'
            var speedometerNode = new GaugeNode( model.velocityProperty, speedString, {min: 0, max: MotionConstants.MAX_SPEED}, {x: width / 2, top: 2} );
            model.showSpeedProperty.linkAttribute( speedometerNode, 'visible' );
        
            //Move away from the stack if the stack getting too high.  No need to record this in the model since it will always be caused deterministically by the model.
            //Use Tween.JS to smoothly animate
            var itemsCentered = new Property( true );
            model.stack.lengthProperty.link( function() {
        
              //Move both the accelerometer and speedometer if the stack is getting too high, based on the height of items in the stack
              var stackHeightThreshold = 160;
              if ( motionView.stackHeight > stackHeightThreshold && itemsCentered.value ) {
                itemsCentered.value = false;
                new TWEEN.Tween( speedometerNode ).to( { centerX: 300}, 400 ).easing( TWEEN.Easing.Cubic.InOut ).start();
                if ( accelerometerNode ) {
                  new TWEEN.Tween( accelerometerWithTickLabels ).to( { centerX: 300}, 400 ).easing( TWEEN.Easing.Cubic.InOut ).start();
                }
              }
              else if ( motionView.stackHeight <= stackHeightThreshold && !itemsCentered.value ) {
                itemsCentered.value = true;
        
                new TWEEN.Tween( speedometerNode ).to( { x: width / 2}, 400 ).easing( TWEEN.Easing.Cubic.InOut ).start();
                if ( accelerometerNode ) {
                  new TWEEN.Tween( accelerometerWithTickLabels ).to( { centerX: width / 2}, 400 ).easing( TWEEN.Easing.Cubic.InOut ).start();
                }
              }
            } );
            this.addChild( speedometerNode );
        
            //Create and add the control panel
            var controlPanel = new MotionControlPanel( model );
            this.addChild( controlPanel );
        
            //Reset all button goes beneath the control panel
            var resetButton = new ResetAllButton( {
              listener: model.reset.bind( model ),
              scale: 1.13
            } ).mutate( {centerX: controlPanel.centerX, top: controlPanel.bottom + 5} );
            this.addChild( resetButton );
        
            //Add the accelerometer, if on the final screen
            if ( model.accelerometer ) {
        
              var accelerometerNode = new AccelerometerNode( model.accelerationProperty );
              var labelAndAccelerometer = new VBox( {pickable: false, children: [new Text( 'Acceleration', {font: new PhetFont( 18 )} ), accelerometerNode]} );
              var tickLabel = function( label, tick ) {
                return new Text( label, {pickable: false, font: new PhetFont( 16 ), centerX: tick.centerX, top: tick.bottom + 27} );
              };
              var accelerometerWithTickLabels = new Node( {children: [labelAndAccelerometer, tickLabel( '-20', accelerometerNode.ticks[0] ),
                tickLabel( '0', accelerometerNode.ticks[2] ),
                tickLabel( '20', accelerometerNode.ticks[4] )], centerX: width / 2, y: 135, pickable: false} );
              model.showAccelerationProperty.linkAttribute( accelerometerWithTickLabels, 'visible' );
        
              this.addChild( accelerometerWithTickLabels );
            }
        
            //Iterate over the items in the model and create and add nodes for each one
            var itemLayer = new Node();
            this.itemNodes = [];
            for ( var i = 0; i < model.items.length; i++ ) {
              var item = model.items[i];
              var Constructor = item.bucket ? WaterBucketNode : ItemNode;
              var itemNode = new Constructor( model, motionView, item,
                item.image,
                  item.sittingImage || item.image,
                  item.holdingImage || item.image,
                model.showMassesProperty );
              this.itemNodes.push( itemNode );
        
              //Provide a reference from the item model to its view so that view dimensions can be looked up easily
              item.view = itemNode;
              itemLayer.addChild( itemNode );
            }
            this.addChild( itemLayer );
        
            //Add the force arrows & associated readouts in front of the items
            var arrowScale = 0.3;
        
            //Round the forces so that the sum is correct in the display, see https://github.com/phetsims/forces-and-motion-basics/issues/72 and  https://github.com/phetsims/forces-and-motion-basics/issues/74
            var roundedAppliedForceProperty = new DerivedProperty( [model.appliedForceProperty], function( appliedForce ) {return Math.round( appliedForce );} );
            var roundedFrictionForceProperty = new DerivedProperty( [model.frictionForceProperty], function( frictionForce ) { return Math.round( frictionForce ); } );
        
            //Only update the sum force arrow after both friction and applied force changed, so we don't get partial updates, see https://github.com/phetsims/forces-and-motion-basics/issues/83
            var roundedSumProperty = new Property( roundedAppliedForceProperty.get() + roundedFrictionForceProperty.get() );
            model.on( 'stepped', function() { roundedSumProperty.set( roundedAppliedForceProperty.get() + roundedFrictionForceProperty.get() ); } );
        
            this.sumArrow = new ReadoutArrow( sumOfForcesString, '#96c83c', this.layoutBounds.width / 2, 230, roundedSumProperty, model.showValuesProperty, {labelPosition: 'top', arrowScale: arrowScale} );
            model.multilink( ['showForce', 'showSumOfForces'], function( showForce, showSumOfForces ) {
              motionView.sumArrow.visible = showForce && showSumOfForces;
            } );
            this.sumOfForcesText = new Text( sumOfForcesEqualsZeroString, {pickable: false, font: new PhetFont( { size: 16, weight: 'bold' } ), centerX: width / 2, y: 200} );
        
            //If the (rounded) sum of forces arrow is zero, then show the text "Sum of Forces = 0", see #76
            new DerivedProperty( [model.showForceProperty, model.showSumOfForcesProperty, roundedSumProperty], function( showForce, showSumOfForces, sumOfForces ) {
              return showForce && showSumOfForces && sumOfForces === 0;
            } ).linkAttribute( motionView.sumOfForcesText, 'visible' );
            this.appliedForceArrow = new ReadoutArrow( appliedForceString, '#e66e23', this.layoutBounds.width / 2, 280, roundedAppliedForceProperty, model.showValuesProperty, {labelPosition: 'side', arrowScale: arrowScale} );
            this.frictionArrow = new ReadoutArrow( frictionForceString, 'red', this.layoutBounds.width / 2, 280, roundedFrictionForceProperty, model.showValuesProperty, {labelPosition: 'side', arrowScale: arrowScale} );
            this.addChild( this.sumArrow );
            this.addChild( this.appliedForceArrow );
            this.addChild( this.frictionArrow );
            this.addChild( this.sumOfForcesText );
        
            //Whichever arrow is smaller should be in front (in z-ordering)
            var frictionLargerProperty = new DerivedProperty( [roundedAppliedForceProperty, roundedFrictionForceProperty], function( roundedAppliedForce, roundedFrictionForce ) {
              return Math.abs( roundedFrictionForce ) > Math.abs( roundedAppliedForce );
            } );
            frictionLargerProperty.link( function( frictionLarger ) {
              var node = frictionLarger ? motionView.appliedForceArrow : motionView.frictionArrow;
              node.moveToFront();
            } );
        
            //On the motion screens, when the 'Friction' label overlaps the force vector it should be displaced vertically
            model.multilink( ['appliedForce', 'frictionForce'], function( appliedForce, frictionForce ) {
              var sameDirection = (appliedForce < 0 && frictionForce < 0) || (appliedForce > 0 && frictionForce > 0);
              motionView.frictionArrow.labelPosition = sameDirection ? 'bottom' : 'side';
            } );
        
            model.showForceProperty.linkAttribute( this.appliedForceArrow, 'visible' );
            model.showForceProperty.linkAttribute( this.frictionArrow, 'visible' );
        
            //After the view is constructed, move one of the blocks to the top of the stack.
            model.viewInitialized( this );
          }
        
          return inherit( ScreenView, MotionView, {
        
            //Get the height of the objects in the stack (doesn't include skateboard)
            get stackHeight() {
              var sum = 0;
              for ( var i = 0; i < this.model.stack.length; i++ ) {
                sum = sum + this.model.stack.get( i ).view.height;
              }
              return sum;
            },
        
            //Find the top of the stack, so that a new object can be placed on top
            get topOfStack() {
              var n = this.model.skateboard ? 335 : 360;
              return n - this.stackHeight;
            },
        
            //Get the size of an item
            getSize: function( item ) { return {width: item.view.width, height: item.view.height}; }
          } );
        } );
        
        // Copyright 2002-2014, University of Colorado Boulder
        
        /**
         * Basic width and height
         *
         * @author Jonathan Olson <jonathan.olson@colorado.edu>
         */
        
        define( 'DOT/Dimension2',['require','DOT/dot','DOT/Bounds2'],function( require ) {
          
        
          var dot = require( 'DOT/dot' );
          require( 'DOT/Bounds2' );
        
          dot.Dimension2 = function Dimension2( width, height ) {
            this.width = width;
            this.height = height;
          };
          var Dimension2 = dot.Dimension2;
        
          Dimension2.prototype = {
            constructor: Dimension2,
        
            toString: function() {
              return "[" + this.width + "w, " + this.height + "h]";
            },
        
            set: function( dimension ) {
              this.width = dimension.width;
              this.height = dimension.height;
              return this;
            },
        
            setWidth: function( width ) {
              this.width = width;
              return this;
            },
        
            setHeight: function( width ) {
              this.width = width;
              return this;
            },
        
            copy: function( dimension ) {
              if ( dimension ) {
                return dimension.set( this );
              }
              else {
                return new Dimension2( this.width, this.height );
              }
            },
        
            toBounds: function( x, y ) {
              x = x || 0;
              y = y || 0;
              return new dot.Bounds2( x, y, this.width + x, this.height + y );
            },
        
            equals: function( other ) {
              return this.width === other.width && this.height === other.height;
            }
          };
        
          return Dimension2;
        } );
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * A Screen is the largest chunk of a simulation. (Java sims used the term Module, but that term
         * is too overloaded to use with JavaScript and Git.)
         * <p>
         * When creating a Sim, Screens are supplied as the arguments. They can be specified as object literals or through instances of this class.
         * This class may centralize default behavior or state for Screens in the future, but right now it only allows you to create
         * Sims without using named parameter object literals.
         *
         * @author Sam Reid
         */
        define( 'JOIST/Screen',['require','DOT/Dimension2'],function( require ) {
          
        
          var Dimension2 = require( 'DOT/Dimension2' );
        
          /**
           * @param {String} name
           * @param {Node} homeScreenIcon optimal size is 548x373, will be scaled by HomeScreen
           * @param {function} createModel
           * @param {function} createView
           * @param {*} options
           * @constructor
           */
          function Screen( name, homeScreenIcon, createModel, createView, options ) {
        
            options = _.extend( {
              backgroundColor: 'white',
              navigationBarIcon: homeScreenIcon // must be a minimum of 147x100 and have an aspect ratio of 548/373=1.469.  See https://github.com/phetsims/joist/issues/76
            }, options );
        
            this.name = name;
            this.homeScreenIcon = homeScreenIcon;
            this.navigationBarIcon = options.navigationBarIcon;
            this.backgroundColor = options.backgroundColor;
            this.createModel = createModel;
            this.createView = createView;
          }
        
          Screen.HOME_SCREEN_ICON_SIZE = new Dimension2( 548, 373 );
          Screen.NAVBAR_ICON_SIZE = new Dimension2( 147, 100 );
        
          return Screen;
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Base class for push buttons that give visual feedback about their state.
         *
         * @author Chris Malley (PixelZoom, Inc.)
         */
        define( 'SUN/PushButtonDeprecated',['require','SCENERY/input/ButtonListener','PHET_CORE/inherit','SCENERY/nodes/Node','AXON/Property'],function( require ) {
          
        
          // import
          var ButtonListener = require( 'SCENERY/input/ButtonListener' );
          var inherit = require( 'PHET_CORE/inherit' );
          var Node = require( 'SCENERY/nodes/Node' );
          var Property = require( 'AXON/Property' );
        
          /**
           * @param {Node} upNode
           * @param {Node} overNode
           * @param {Node} downNode
           * @param {Node} disabledNode
           * @param {object} options
           * @constructor
           */
          function PushButtonDeprecated( upNode, overNode, downNode, disabledNode, options ) {
        
            options = _.extend( {
                cursor: 'pointer',
                label: 'Button',
                enabled: true,
                listener: null
              },
              options );
        
            var thisButton = this;
            Node.call( thisButton );
        
            // nodes for each state
            thisButton._upNode = upNode;
            thisButton._overNode = overNode;
            thisButton._downNode = downNode;
            thisButton._disabledNode = disabledNode;
        
            thisButton._state = 'up';
            thisButton._enabled = new Property( options.enabled );
            thisButton._listeners = [];
            if ( options.listener ) { thisButton._listeners.push( options.listener ); }
        
            thisButton._stateListeners = [];
        
            thisButton.addChild( upNode );
            thisButton.addChild( overNode );
            thisButton.addChild( downNode );
            thisButton.addChild( disabledNode );
        
            thisButton.addInputListener( new ButtonListener( {
        
              up: function() {
                thisButton._state = 'up';
                thisButton._update();
              },
        
              over: function() {
                thisButton._state = 'over';
                thisButton._update();
              },
        
              down: function() {
                thisButton._state = 'down';
                thisButton._update();
              },
        
              out: function() {
                thisButton._state = 'up'; //NOTE: 'out' state looks the same as 'up'
                thisButton._update();
              },
        
              fire: function() {
                if ( thisButton._enabled.get() ) {
                  thisButton._fire();
                }
              }
            } ) );
        
            // accessibility
            thisButton.addPeer( '<input type="button" aria-label="' + _.escape( options.label ) + '">',
              { click: thisButton._fire.bind( thisButton ) }
            );
        
            thisButton._enabled.link( function( enabled ) {
              thisButton.cursor = enabled ? options.cursor : 'default';
              thisButton._update();
            } );
        
            //Mutate with the options after the layout is complete so that you can use width-dependent fields like centerX, etc.
            thisButton.mutate( options );
          }
        
          return inherit( Node, PushButtonDeprecated, {
        
            // Adds a listener. If already a listener, this is a no-op.
            addListener: function( listener ) {
              if ( this._listeners.indexOf( listener ) === -1 ) {
                this._listeners.push( listener );
              }
            },
        
            // Remove a listener. If not a listener, this is a no-op.
            removeListener: function( listener ) {
              var i = this._listeners.indexOf( listener );
              if ( i !== -1 ) {
                this._listeners.splice( i, 1 );
              }
            },
        
            _fire: function() {
              var copy = this._listeners.slice( 0 );
              copy.forEach( function( listener ) {
                listener();
              } );
            },
        
            // Adds a state listener. If already a listener, this is a no-op.
            addStateListener: function( listener ) {
              if ( this._stateListeners.indexOf( listener ) === -1 ) {
                this._stateListeners.push( listener );
              }
            },
        
            // Remove a listener. If not a listener, this is a no-op.
            removeStateListener: function( listener ) {
              var i = this._stateListeners.indexOf( listener );
              if ( i !== -1 ) {
                this._stateListeners.splice( i, 1 );
              }
            },
        
            _update: function() {
              // use visible instead of add/removeChild to prevent flickering
              var enabled = this._enabled.get();
              this._upNode.visible = ( this._state === 'up' && enabled );
              this._downNode.visible = ( this._state === 'down' && enabled );
              this._overNode.visible = ( this._state === 'over' && enabled );
              this._disabledNode.visible = !enabled;
              for ( var i = 0; i < this._stateListeners.length; i++ ) {
                this._stateListeners[i]( this._state );
              }
            },
        
            set enabled( value ) {
              assert && assert( typeof value === 'boolean', 'PushButton.enabled must be a boolean value' ); // Scenery complains about visible otherwise
              this._enabled.set( value );
            },
        
            get enabled() { return this._enabled.get(); },
        
            getEnabledProperty: function() { return this._enabled; }
          } );
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Highlight node for navigation bar screen buttons, phet button, etc.
         */
        define( 'JOIST/HighlightNode',['require','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','SCENERY/util/LinearGradient','PHET_CORE/inherit'],function( require ) {
          
        
          var Node = require( 'SCENERY/nodes/Node' );
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
          var LinearGradient = require( 'SCENERY/util/LinearGradient' );
          var inherit = require( 'PHET_CORE/inherit' );
        
          function HighlightNode( width, height, options ) {
            options = _.extend( {
              whiteHighlight: true
            }, options );
        
            var outerColor = options.whiteHighlight ? 'black' : 'white';
            var innerColor = options.whiteHighlight ? 'white' : 'black';
            var leftBar = new Rectangle( -0.5, 0, 1, height, 0, 0, {
              fill: new LinearGradient( 0, 0, 0, height ).addColorStop( 0, outerColor ).addColorStop( 0.5, innerColor ).addColorStop( 1, outerColor )
            } );
            var rightBar = new Rectangle( width - 0.5, 0, 1, height, 0, 0, {
              fill: new LinearGradient( 0, 0, 0, height ).addColorStop( 0, outerColor ).addColorStop( 0.5, innerColor ).addColorStop( 1, outerColor )
            } );
        
            options = _.extend( { children: [leftBar, rightBar], pickable: false}, options );
            Node.call( this, options );
          }
        
          return inherit( Node, HighlightNode );
        } );
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        //TODO this should handle wiring up the callback that goes to the home screen, currently done in NavigationBar
        /**
         * The Home button that appears in the navigation bar.
         */
        define( 'JOIST/HomeButton',['require','SUN/FontAwesomeNode','PHET_CORE/inherit','SCENERY/nodes/Node','KITE/Shape','SUN/PushButtonDeprecated','JOIST/HighlightNode'],function( require ) {
          
        
          var FontAwesomeNode = require( 'SUN/FontAwesomeNode' );
          var inherit = require( 'PHET_CORE/inherit' );
          var Node = require( 'SCENERY/nodes/Node' );
          var Shape = require( 'KITE/Shape' );
          var PushButtonDeprecated = require( 'SUN/PushButtonDeprecated' );
          var HighlightNode = require( 'JOIST/HighlightNode' );
        
          function HomeButton( fill, pressedFill, whiteColorScheme, options ) {
        
            var icon = function( fill, highlighted ) {
              var node = new FontAwesomeNode( 'home', { fill: fill, scale: 0.75 } );
              if ( highlighted ) {
                return new Node( {
                  children: [
                    node,
                    new HighlightNode( node.width + 4, node.height, {center: node.center, whiteHighlight: !whiteColorScheme} )
                  ]} );
              }
              else {
                return node;
              }
            };
            PushButtonDeprecated.call( this, icon( fill, false ), icon( fill, true ), icon( pressedFill, true ), icon( fill, false ) );
        
            if ( options ) {
              this.mutate( options );
            }
            this.mouseArea = this.touchArea = Shape.rectangle( this.bounds.minX, this.bounds.minY, this.bounds.width, this.bounds.height );
          }
        
          return inherit( PushButtonDeprecated, HomeButton );
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * A node which always fills the entire screen, no matter what the transform is.
         * Used for showing an overlay on the screen e.g., when a popup dialog is shown.
         * This can fade the background to focus on the dialog/popup as well as intercept mouse events for dismissing the dialog/popup.
         * Note: This is currently implemented using large numbers, it should be rewritten to work in any coordinate frame, possibly using kite.Shape.plane()
         * TODO: Implement using infinite geometry
         *
         * @author Sam Reid
         */
        
        define( 'SCENERY/nodes/Plane',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Rectangle'],function( require ) {
          
        
          var inherit = require( 'PHET_CORE/inherit' );
          var scenery = require( 'SCENERY/scenery' );
        
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
        
          /**
           * @param options Any options for the plane, typically fill/opacity (many others such as scale, translation, rotation should have no effect)
           * @constructor
           */
          scenery.Plane = function Plane( options ) {
            Rectangle.call( this, -2000, -2000, 6000, 6000, options );
          };
          var Plane = scenery.Plane;
        
          return inherit( Rectangle, Plane );
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        //TODO #4: add support for consecutive line breaks, eg 'Hello\n\nWorld'
        //TODO #4: add support for leading (vertical space) between lines
        /**
         * MultiLine plain text, with alignment.
         * The line break character is '\n'.
         * Specify alignment via the 'align' option.
         * Text node options can be specified to style the text.
         * <p>
         * Example: new MultiLineText( 'Hello\nWorld', { align: 'left', font: new PhetFont(20), fill: 'red' } );
         *
         * @author Sam Reid
         * @author Chris Malley (PixelZoom, Inc.)
         */
        define( 'SCENERY_PHET/MultiLineText',['require','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Text','SCENERY/nodes/VBox'],function( require ) {
          
        
          // modules
          var inherit = require( 'PHET_CORE/inherit' );
          var Node = require( 'SCENERY/nodes/Node' );
          var Text = require( 'SCENERY/nodes/Text' );
          var VBox = require( 'SCENERY/nodes/VBox' );
        
          function MultiLineText( text, options ) {
        
            var thisNode = this;
        
            thisNode._options = options = _.extend( {
              align: 'center' // 'center', 'left' or 'right' (as supported by VBox)
            }, options );
        
            Node.call( thisNode );
            thisNode.text = text;
            thisNode.mutate( _.omit( options, 'align' ) ); // mutate after removing options that are specific to this subtype
          }
        
          inherit( Node, MultiLineText, {
              get text() {
                return this._text;
              },
              set text( string ) {
                var thisNode = this;
                thisNode._text = string;
                thisNode.children = [ new VBox( {
                  children: string.split( '\n' ).map( function( line ) {
                    return new Text( line, _.omit( thisNode._options, 'align' ) );
                  } ),
                  align: thisNode._options.align
                } )];
              }
            }
          );
        
          return MultiLineText;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * A line that inherits Path, and allows for optimized drawing,
         * and improved line handling.
         *
         * TODO: add DOM support
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/nodes/Line',['require','PHET_CORE/inherit','SCENERY/scenery','KITE/segments/Line','SCENERY/nodes/Path','KITE/Shape','DOT/Vector2'],function( require ) {
          
          
          var inherit = require( 'PHET_CORE/inherit' );
          var scenery = require( 'SCENERY/scenery' );
          var KiteLine = require( 'KITE/segments/Line' );
          
          var Path = require( 'SCENERY/nodes/Path' );
          var Shape = require( 'KITE/Shape' );
          var Vector2 = require( 'DOT/Vector2' );
          
          /**
           * Currently, all numerical parameters should be finite.
           * x1:         x-position of the start
           * y1:         y-position of the start
           * x2:         x-position of the end
           * y2:         y-position of the end
           *
           * Available constructors:
           * new Line( x1, y1, x2, y2, { ... } )
           * new Line( new Vector2( x1, y1 ), new Vector2( x2, y2 ), { ... } )
           * new Line( { x1: x1, y1: y1, x2: x2, y2: y2,  ... } )
           */
          scenery.Line = function Line( x1, y1, x2, y2, options ) {
            if ( typeof x1 === 'object' ) {
              if ( x1 instanceof Vector2 ) {
                // assumes Line( Vector2, Vector2, options );
                this._x1 = x1.x;
                this._y1 = x1.y;
                this._x2 = y1.x;
                this._y2 = y1.y;
                options = x2 || {};
              } else {
                // assumes Line( { ... } ), init to zero for now
                this._x1 = 0;
                this._y1 = 0;
                this._x2 = 0;
                this._y2 = 0;
                options = x1 || {};
              }
            } else {
              // new Line(  x1, y1, x2, y2, [options] )
              this._x1 = x1;
              this._y1 = y1;
              this._x2 = x2;
              this._y2 = y2;
              
              // ensure we have a parameter object
              options = options || {};
            }
            // fallback for non-canvas or non-svg rendering, and for proper bounds computation
            
            Path.call( this, null, options );
          };
          var Line = scenery.Line;
          
          inherit( Path, Line, {
            setLine: function( x1, y1, x2, y2 ) {
              assert && assert( x1 !== undefined && y1 !== undefined && x2 !== undefined && y2 !== undefined, 'parameters need to be defined' );
              
              this._x1 = x1;
              this._y1 = y1;
              this._x2 = x2;
              this._y2 = y2;
              this.invalidateLine();
            },
            
            setPoint1: function( x1, y1 ) {
              if ( typeof x1 === 'number' ) {
                // setPoint1( x1, y1 );
                this.setLine( x1, y1, this._x2, this._y2 );
              } else {
                // setPoint1( Vector2 )
                this.setLine( x1.x, x1.y, this._x2, this._y2 );
              }
            },
            set p1( point ) { this.setPoint1( point ); },
            get p1() { return new Vector2( this._x1, this._y1 ); },
            
            setPoint2: function( x2, y2 ) {
              if ( typeof x2 === 'number' ) {
                // setPoint2( x2, y2 );
                this.setLine( this._x1, this._y1, x2, y2 );
              } else {
                // setPoint2( Vector2 )
                this.setLine( this._x1, this._y1, x2.x, x2.y );
              }
            },
            set p2( point ) { this.setPoint2( point ); },
            get p2() { return new Vector2( this._x2, this._y2 ); },
            
            createLineShape: function() {
              return Shape.lineSegment( this._x1, this._y1, this._x2, this._y2 );
            },
            
            invalidateLine: function() {
              assert && assert( isFinite( this._x1 ), 'A rectangle needs to have a finite x1 (' + this._x1 + ')' );
              assert && assert( isFinite( this._y1 ), 'A rectangle needs to have a finite y1 (' + this._y1 + ')' );
              assert && assert( isFinite( this._x2 ), 'A rectangle needs to have a finite x2 (' + this._x2 + ')' );
              assert && assert( isFinite( this._y2 ), 'A rectangle needs to have a finite y2 (' + this._y2 + ')' );
              
              // sets our 'cache' to null, so we don't always have to recompute our shape
              this._shape = null;
              
              // should invalidate the path and ensure a redraw
              this.invalidateShape();
            },
            
            containsPointSelf: function( point ) {
              if ( this._strokePickable ) {
                return Path.prototype.containsPointSelf.call( this, point );
              } else {
                return false; // nothing is in a line! (although maybe we should handle edge points properly?)
              }
            },
            
            intersectsBoundsSelf: function( bounds ) {
              // TODO: optimization
              return new KiteLine( this.p1, this.p2 ).intersectsBounds( bounds );
            },
            
            paintCanvas: function( wrapper ) {
              var context = wrapper.context;
              
              context.beginPath();
              context.moveTo( this._x1, this._y1 );
              context.lineTo( this._x2, this._y2 );
              context.closePath();
              
              if ( this._stroke ) {
                this.beforeCanvasStroke( wrapper ); // defined in Strokable
                context.stroke();
                this.afterCanvasStroke( wrapper ); // defined in Strokable
              }
            },
            
            computeShapeBounds: function() {
              return Path.prototype.computeShapeBounds.call( this );
            },
            
            // create a rect instead of a path, hopefully it is faster in implementations
            createSVGFragment: function( svg, defs, group ) {
              return document.createElementNS( scenery.svgns, 'line' );
            },
            
            // optimized for the rect element instead of path
            updateSVGFragment: function( rect ) {
              // see http://www.w3.org/TR/SVG/shapes.html#LineElement
              rect.setAttribute( 'x1', this._x1 );
              rect.setAttribute( 'y1', this._y1 );
              rect.setAttribute( 'x2', this._x2 );
              rect.setAttribute( 'y2', this._y2 );
              
              rect.setAttribute( 'style', this.getSVGFillStyle() + this.getSVGStrokeStyle() );
            },
            
            getBasicConstructor: function( propLines ) {
              return 'new scenery.Line( ' + this._x1 + ', ' + this._y1 + ', ' + this._x1 + ', ' + this._y1 + ', {' + propLines + '} )';
            },
            
            setShape: function( shape ) {
              if ( shape !== null ) {
                throw new Error( 'Cannot set the shape of a scenery.Line to something non-null' );
              } else {
                // probably called from the Path constructor
                this.invalidateShape();
              }
            },
            
            getShape: function() {
              if ( !this._shape ) {
                this._shape = this.createLineShape();
              }
              return this._shape;
            },
            
            hasShape: function() {
              return true;
            }
            
          } );
          
          function addLineProp( capitalizedShort ) {
            var lowerShort = capitalizedShort.toLowerCase();
            
            var getName = 'get' + capitalizedShort;
            var setName = 'set' + capitalizedShort;
            var privateName = '_' + lowerShort;
            
            Line.prototype[getName] = function() {
              return this[privateName];
            };
            
            Line.prototype[setName] = function( value ) {
              if ( this[privateName] !== value ) {
                this[privateName] = value;
                this.invalidateLine();
              }
              return this;
            };
            
            Object.defineProperty( Line.prototype, lowerShort, {
              set: Line.prototype[setName],
              get: Line.prototype[getName]
            } );
          }
          
          addLineProp( 'X1' );
          addLineProp( 'Y1' );
          addLineProp( 'X2' );
          addLineProp( 'Y2' );
          
          // not adding mutators for now
          Line.prototype._mutatorKeys = [ 'p1', 'p2', 'x1', 'y1', 'x2', 'y2' ].concat( Path.prototype._mutatorKeys );
          
          return Line;
        } );
        
        
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * An invisible line used for creating vertical space when laying out panels.
         */
        define( 'SUN/VStrut',['require','PHET_CORE/inherit','SCENERY/nodes/Line'],function( require ) {
          
        
          // Imports
          var inherit = require( 'PHET_CORE/inherit' );
          var Line = require( 'SCENERY/nodes/Line' );
        
          function VStrut( height ) {
            Line.call( this, 0, 0, 0, height );
          }
        
          return inherit( Line, VStrut );
        } );
        
        
        
        define("string!JOIST/credits.developmentTeam",function(){return window.phetStrings.get("JOIST/credits.developmentTeam");});
        
        
        define("string!JOIST/credits.leadDesign",function(){return window.phetStrings.get("JOIST/credits.leadDesign");});
        
        
        define("string!JOIST/credits.softwareDevelopment",function(){return window.phetStrings.get("JOIST/credits.softwareDevelopment");});
        
        
        define("string!JOIST/credits.designTeam",function(){return window.phetStrings.get("JOIST/credits.designTeam");});
        
        
        define("string!JOIST/credits.interviews",function(){return window.phetStrings.get("JOIST/credits.interviews");});
        
        
        define("string!JOIST/credits.graphicArts",function(){return window.phetStrings.get("JOIST/credits.graphicArts");});
        
        
        define("string!JOIST/credits.translation",function(){return window.phetStrings.get("JOIST/credits.translation");});
        
        
        define("string!JOIST/credits.thanks",function(){return window.phetStrings.get("JOIST/credits.thanks");});
        
        
        define("string!JOIST/credits.qualityAssurance",function(){return window.phetStrings.get("JOIST/credits.qualityAssurance");});
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Shows the about dialog.
         *
         * @author Sam Reid
         */
        define( 'JOIST/AboutDialog',['require','SCENERY/nodes/VBox','SCENERY/nodes/Text','PHET_CORE/inherit','SCENERY_PHET/MultiLineText','JOIST/ScreenView','SUN/Panel','SCENERY_PHET/PhetFont','PHETCOMMON/util/StringUtils','SUN/VStrut','string!JOIST/credits.developmentTeam','string!JOIST/credits.leadDesign','string!JOIST/credits.softwareDevelopment','string!JOIST/credits.designTeam','string!JOIST/credits.interviews','string!JOIST/credits.graphicArts','string!JOIST/credits.translation','string!JOIST/credits.thanks','string!JOIST/credits.qualityAssurance'],function( require ) {
          
        
          // modules
          var VBox = require( 'SCENERY/nodes/VBox' );
          var Text = require( 'SCENERY/nodes/Text' );
          var inherit = require( 'PHET_CORE/inherit' );
          var MultiLineText = require( 'SCENERY_PHET/MultiLineText' );
          var ScreenView = require( 'JOIST/ScreenView' );
          var Panel = require( 'SUN/Panel' );
          var PhetFont = require( 'SCENERY_PHET/PhetFont' );
          var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
          var VStrut = require( 'SUN/VStrut' );
        
          // strings
          var developmentTeamString = require( 'string!JOIST/credits.developmentTeam' );
          var leadDesignString = require( 'string!JOIST/credits.leadDesign' );
          var softwareDevelopmentString = require( 'string!JOIST/credits.softwareDevelopment' );
          var designTeamString = require( 'string!JOIST/credits.designTeam' );
          var interviewsString = require( 'string!JOIST/credits.interviews' );
          var graphicArtsString = require( 'string!JOIST/credits.graphicArts' );
          var translationTitleString = require( 'string!JOIST/credits.translation' );
          var thanksTitleString = require( 'string!JOIST/credits.thanks' );
          var qualityAssuranceString = require( 'string!JOIST/credits.qualityAssurance' );
        
          /**
           * @param {Sim} sim
           * @constructor
           */
          function AboutDialog( sim, Brand ) {
            var aboutDialog = this;
        
            //Use view, to help center and scale content
            //Renderer must be specified here because the AboutDialog is added directly to the scene (instead of to some other node that already has svg renderer)
            ScreenView.call( this, {renderer: 'svg'} );
        
            var createLink = function( text, url ) {
              var softwareAgreementLink = new Text( text, {
                font: new PhetFont( 14 ),
                fill: 'rgb(27,0,241)', // blue, like a hyperlink
                cursor: 'pointer'
              } );
              softwareAgreementLink.addInputListener( {
                up: function( evt ) {
                  evt.handle(); // don't close the dialog
                },
                upImmediate: function( event ) {
                  var aboutDialogWindow = window.open( url, '_blank' );
                  aboutDialogWindow.focus();
                }
              } );
              return softwareAgreementLink;
            };
        
            var children = [
              new Text( Brand.name, { font: new PhetFont( 16 ) } ),
              new Text( Brand.copyright, { font: new PhetFont( 12 ) } ),
              new VStrut( 15 ),
              new Text( sim.name, { font: new PhetFont( 28 ) } ),
              new Text( 'version ' + sim.version, { font: new PhetFont( 20 ) } )
            ];
        
            if ( sim.credits ) {
              children.push( new VStrut( 15 ) );
              children.push( createCreditsNode( sim.credits ) );
            }
        
            if ( Brand.links && Brand.links.length ) {
              children.push( new VStrut( 15 ) );
              for ( var i = 0; i < Brand.links.length; i++ ) {
                var link = Brand.links[i];
                children.push( createLink( link.text, link.url ) );
              }
            }
        
            var content = new VBox( { align: 'left', spacing: 5, children: children } );
        
            //Show a gray overlay that will help focus on the about dialog, and prevent clicks on the sim while the dialog is up
            this.addChild( new Panel( content, {centerX: this.layoutBounds.centerX, centerY: this.layoutBounds.centerY, xMargin: 20, yMargin: 20 } ) );
        
            function resize() {
              aboutDialog.layout( $( window ).width(), $( window ).height() );
            }
        
            //Fit to the window and render the initial scene
            $( window ).resize( resize );
            resize();
          }
        
          // Creates node that displays the credits.
          var createCreditsNode = function( credits ) {
            var children = [];
            var titleFont = new PhetFont( { size: 14, weight: 'bold' } );
            var font = new PhetFont( 12 );
            var multiLineTextOptions = { font: font, align: 'left' };
            children.push( new Text( developmentTeamString, { font: titleFont } ) );
        
            if ( credits.leadDesign ) { children.push( new MultiLineText( StringUtils.format( leadDesignString, credits.leadDesign ), multiLineTextOptions ) ); }
            if ( credits.softwareDevelopment ) { children.push( new MultiLineText( StringUtils.format( softwareDevelopmentString, credits.softwareDevelopment ), multiLineTextOptions ) ); }
            if ( credits.designTeam ) { children.push( new MultiLineText( StringUtils.format( designTeamString, credits.designTeam ), multiLineTextOptions ) ); }
            if ( credits.interviews ) { children.push( new MultiLineText( StringUtils.format( interviewsString, credits.interviews ), multiLineTextOptions ) ); }
            if ( credits.graphicArts ) { children.push( new MultiLineText( StringUtils.format( graphicArtsString, credits.graphicArts ), multiLineTextOptions ) ); }
            if ( credits.qualityAssurance ) { children.push( new MultiLineText( StringUtils.format( qualityAssuranceString, credits.qualityAssurance ), multiLineTextOptions ) ); }
            if ( credits.translation ) {
              if ( children.length > 0 ) { children.push( new Text( ' ', font ) ); }
              children.push( new Text( translationTitleString, { font: titleFont } ) );
              children.push( new MultiLineText( credits.translation, multiLineTextOptions ) );
            }
            if ( credits.thanks ) {
              if ( children.length > 0 ) { children.push( new Text( ' ', font ) ); }
              children.push( new Text( thanksTitleString, { font: titleFont } ) );
              children.push( new MultiLineText( credits.thanks, multiLineTextOptions ) );
            }
            return new VBox( { align: 'left', spacing: 1, children: children } );
          };
        
          inherit( ScreenView, AboutDialog );
        
          return AboutDialog;
        } );
        
        define("string!JOIST/showPointers",function(){return window.phetStrings.get("JOIST/showPointers");});
        
        
        define("string!JOIST/done",function(){return window.phetStrings.get("JOIST/done");});
        
        
        define("string!JOIST/title.settings",function(){return window.phetStrings.get("JOIST/title.settings");});
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Shows the about dialog.
         *
         * @author Sam Reid
         */
        define( 'JOIST/SettingsDialog',['require','SCENERY/nodes/VBox','SCENERY/nodes/Text','PHET_CORE/inherit','JOIST/ScreenView','SUN/Panel','SUN/CheckBox','SCENERY_PHET/PhetFont','SUN/buttons/TextPushButton','string!JOIST/showPointers','string!JOIST/done','string!JOIST/title.settings'],function( require ) {
          
        
          var VBox = require( 'SCENERY/nodes/VBox' );
          var Text = require( 'SCENERY/nodes/Text' );
          var inherit = require( 'PHET_CORE/inherit' );
          var ScreenView = require( 'JOIST/ScreenView' );
          var Panel = require( 'SUN/Panel' );
          var CheckBox = require( 'SUN/CheckBox' );
          var PhetFont = require( 'SCENERY_PHET/PhetFont' );
          var TextPushButton = require( 'SUN/buttons/TextPushButton' );
        
          // strings
          var showPointersString = require( 'string!JOIST/showPointers' );
          var doneString = require( 'string!JOIST/done' );
          var settingsString = require( 'string!JOIST/title.settings' );
        
          /**
           * @param {Sim} sim
           * @constructor
           */
          function SettingsDialog( sim ) {
            var settingsDialog = this;
        
            //Use view, to help center and scale content
            ScreenView.call( this, {renderer: 'svg'} );
        
            var content = new VBox( { align: 'center', spacing: 50, children: [
              new Text( settingsString, { font: new PhetFont( 16 ) } ),
              new CheckBox( new Text( showPointersString ), sim.showPointersProperty ),
              new TextPushButton( doneString, {
                listener: function() {
                  settingsDialog.doneListeners.forEach( function( listener ) {
                    listener();
                  } );
                }
              } )
            ]} );
        
            //Show a gray overlay that will help focus on the about dialog, and prevent clicks on the sim while the dialog is up
            this.addChild( new Panel( content, {centerX: this.layoutBounds.centerX, centerY: this.layoutBounds.centerY, xMargin: 20, yMargin: 20 } ) );
        
            function resize() {
              settingsDialog.layout( $( window ).width(), $( window ).height() );
            }
        
            //Fit to the window and render the initial scene
            $( window ).resize( resize );
            resize();
            this.doneListeners = [];
          }
        
          return inherit( ScreenView, SettingsDialog, {
            addDoneListener: function( listener ) {
              this.doneListeners.push( listener );
            }
          } );
        } );
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Utilities for conversion to/from JSON, consolidated here to simplify maintenance.
         * Note: Not all dependencies should be put here, or this file will have too many require statements.  At some point, we will probably have to allow
         * sims to declare some of their own components for replacer/reviver.
         *
         * @author Sam Reid
         */
        define( 'JOIST/SimJSON',['require','DOT/Vector2'],function( require ) {
          
        
          var Vector2 = require( 'DOT/Vector2' );
        
          return {
            replacer: function( key, value ) {
              if ( value instanceof Vector2 ) {
                return {_type: 'Vector2', x: value.x, y: value.y};
              }
              else {
                return value;
              }
            },
        
            reviver: function( k, v ) {
              if ( k === "" ) {
                return v;
              }
              if ( v && v._type && v._type === 'Vector2' ) {
                return new Vector2( v.x, v.y );
              }
              return v;
            }
          };
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * The 'PhET' menu, which appears in the bottom-right of the home screen and the navigation bar, with options like "PhET Website", "Settings", etc.
         *
         * @author Sam Reid
         */
        define( 'JOIST/util/ScreenshotGenerator',['require'],function( require ) {
          
        
          function ScreenshotGenerator() {}
        
          ScreenshotGenerator.prototype.generateScreenshot = function( node, callback ) {
        
            //set all renderers to canvas for capture
            var setToCanvas = function( root ) {
        
              //Skip invisible nodes to speed up
              if ( root.visible ) {
                if ( root.renderer !== null && root.renderer.name !== 'canvas' ) {
                  console.log( root.renderer.name );
                  root.__saveRenderer = root.renderer;
                  root.renderer = 'canvas';
                }
                for ( var i = 0; i < root.children.length; i++ ) {
                  setToCanvas( root.children[i] );
                }
              }
            };
            console.log( 'setting to canvas' );
            setToCanvas( node );
            console.log( 'done setting to canvas' );
            node.toCanvas( function( canvas ) {
              console.log( 'to canvas called back' );
              callback( canvas );
        
              console.log( 'added image, restoring' );
              //set all renderers to canvas for capture
              var restoreRenderers = function( root ) {
                if ( root.visible ) {
                  if ( root.__saveRenderer ) {
                    root.renderer = root.__saveRenderer;
                    delete root.__saveRenderer;
                  }
                  else {
        //                  console.log( 'skipping node: ', typeof root );
                  }
                  for ( var i = 0; i < root.children.length; i++ ) {
                    restoreRenderers( root.children[i] );
                  }
                }
              };
              restoreRenderers( node );
            } );
          };
        
          return ScreenshotGenerator;
        } );
        // Copyright 2002-2014, University of Colorado Boulder
        
        // Returns branding information for the simulations, see https://github.com/phetsims/brand/issues/1
        define( 'BRAND/Brand',[],function() {
          
        
          //TODO: Add your group's information here and it will appear in the About Dialog
          return {
            name: '',//For example: My Company
            copyright: '',//For example: Copyright © 2014, My Company
            links: [
              {text: '', //For example "My Company Support"
                url: ''} //For example, https://www.mycompany.com/support
            ]};
        } );
        
        
        define("string!JOIST/menuItem.about",function(){return window.phetStrings.get("JOIST/menuItem.about");});
        
        
        define("string!JOIST/menuItem.mailInputEventsLog",function(){return window.phetStrings.get("JOIST/menuItem.mailInputEventsLog");});
        
        
        define("string!JOIST/menuItem.outputInputEventsLog",function(){return window.phetStrings.get("JOIST/menuItem.outputInputEventsLog");});
        
        
        define("string!JOIST/menuItem.phetWebsite",function(){return window.phetStrings.get("JOIST/menuItem.phetWebsite");});
        
        
        define("string!JOIST/menuItem.reportAProblem",function(){return window.phetStrings.get("JOIST/menuItem.reportAProblem");});
        
        
        define("string!JOIST/menuItem.settings",function(){return window.phetStrings.get("JOIST/menuItem.settings");});
        
        
        define("string!JOIST/menuItem.submitInputEventsLog",function(){return window.phetStrings.get("JOIST/menuItem.submitInputEventsLog");});
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * The 'PhET' menu, which appears in the bottom-right of the home screen and the navigation bar, with options like "PhET Website", "Settings", etc.
         *
         * @author Sam Reid
         */
        define( 'JOIST/PhetMenu',['require','SCENERY/nodes/Node','KITE/Shape','SCENERY/nodes/Path','SCENERY/nodes/Text','PHET_CORE/inherit','JOIST/AboutDialog','JOIST/SettingsDialog','SCENERY/nodes/Rectangle','SCENERY/input/ButtonListener','SCENERY/nodes/Plane','SCENERY_PHET/PhetFont','JOIST/SimJSON','JOIST/util/ScreenshotGenerator','SCENERY/nodes/Image','BRAND/Brand','string!JOIST/menuItem.about','string!JOIST/menuItem.mailInputEventsLog','string!JOIST/menuItem.outputInputEventsLog','string!JOIST/menuItem.phetWebsite','string!JOIST/menuItem.reportAProblem','string!JOIST/menuItem.settings','string!JOIST/menuItem.submitInputEventsLog'],function( require ) {
          
        
          // modules
          var Node = require( 'SCENERY/nodes/Node' );
          var Shape = require( 'KITE/Shape' );
          var Path = require( 'SCENERY/nodes/Path' );
          var Text = require( 'SCENERY/nodes/Text' );
          var inherit = require( 'PHET_CORE/inherit' );
          var AboutDialog = require( 'JOIST/AboutDialog' );
          var SettingsDialog = require( 'JOIST/SettingsDialog' );
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
          var ButtonListener = require( 'SCENERY/input/ButtonListener' );
          var Plane = require( 'SCENERY/nodes/Plane' );
          var PhetFont = require( 'SCENERY_PHET/PhetFont' );
          var SimJSON = require( 'JOIST/SimJSON' );
          var ScreenshotGenerator = require( 'JOIST/util/ScreenshotGenerator' );
          var Image = require( 'SCENERY/nodes/Image' );
          var Brand = require( 'BRAND/Brand' );
        
          // strings
          var aboutString = require( 'string!JOIST/menuItem.about' );
          var mailInputEventsLogString = require( 'string!JOIST/menuItem.mailInputEventsLog' );
          var outputInputEventsLogString = require( 'string!JOIST/menuItem.outputInputEventsLog' );
          var phetWebsiteString = require( 'string!JOIST/menuItem.phetWebsite' );
          var reportAProblemString = require( 'string!JOIST/menuItem.reportAProblem' );
          var settingsString = require( 'string!JOIST/menuItem.settings' );
          var submitInputEventsLogString = require( 'string!JOIST/menuItem.submitInputEventsLog' );
        
          // constants
          var FONT_SIZE = 18;
          var HIGHLIGHT_COLOR = '#a6d2f4';
        
          // Creates a menu item that highlights and fires.
          var createMenuItem = function( text, width, height, separatorBefore, callback, immediateCallback ) {
        
            var X_MARGIN = 5;
            var Y_MARGIN = 3;
            var CORNER_RADIUS = 5;
        
            var textNode = new Text( text, { font: new PhetFont( FONT_SIZE ) } );
            var highlight = new Rectangle( 0, 0, width + X_MARGIN + X_MARGIN, height + Y_MARGIN + Y_MARGIN, CORNER_RADIUS, CORNER_RADIUS );
        
            var menuItem = new Node( { cursor: 'pointer' } );
            menuItem.addChild( highlight );
            menuItem.addChild( textNode );
        
            textNode.left = highlight.left + X_MARGIN; // text is left aligned
            textNode.centerY = highlight.centerY;
        
            menuItem.addInputListener( {
              enter: function() { highlight.fill = HIGHLIGHT_COLOR; },
              exit: function() { highlight.fill = null; },
              upImmediate: function() { immediateCallback && immediateCallback(); }
            } );
            menuItem.addInputListener( new ButtonListener( {fire: callback } ) );
        
            menuItem.separatorBefore = separatorBefore;
        
            return menuItem;
          };
        
          // Creates a comic-book style bubble.
          var createBubble = function( width, height ) {
        
            var rectangle = new Rectangle( 0, 0, width, height, 8, 8, {fill: 'white', lineWidth: 1, stroke: 'black'} );
        
            var tail = new Shape();
            tail.moveTo( width - 20, height - 2 );
            tail.lineToRelative( 0, 20 );
            tail.lineToRelative( -20, -20 );
            tail.close();
        
            var tailOutline = new Shape();
            tailOutline.moveTo( width - 20, height );
            tailOutline.lineToRelative( 0, 20 - 2 );
            tailOutline.lineToRelative( -18, -18 );
        
            var bubble = new Node();
            bubble.addChild( rectangle );
            bubble.addChild( new Path( tail, {fill: 'white'} ) );
            bubble.addChild( new Path( tailOutline, {stroke: 'black', lineWidth: 1} ) );
        
            return bubble;
          };
        
          //TODO: The popup menu should scale with the size of the screen
          function PhetMenu( sim, options ) {
        
            //Only show certain features for PhET Sims, such as links to our website
            //Note: this string below must stay in sync with the Brand.name or phet features will be dropped
            var isPhETBrand = Brand.name === 'PhET Interactive Simulations';
        
            options = _.extend( {
        
              //For sims that have save/load enabled, show menu items for those.
              showSaveAndLoad: false
            }, options );
        
            var thisMenu = this;
            Node.call( thisMenu, {renderer: 'svg'} );
        
            var showAboutDialog = function( aboutDialog ) {
              var plane = new Plane( {fill: 'black', opacity: 0.3, renderer: 'svg'} );//Renderer must be specified here because the plane is added directly to the scene (instead of to some other node that already has svg renderer)
              sim.addChild( plane );
              sim.addChild( aboutDialog );
              var aboutDialogListener = {up: function() {
                aboutDialog.removeInputListener( aboutDialogListener );
                plane.addInputListener( aboutDialogListener );
                aboutDialog.detach();
                plane.detach();
              }};
              aboutDialog.addInputListener( aboutDialogListener );
              plane.addInputListener( aboutDialogListener );
            };
        
            /*
             * Description of the items in the menu. Each descriptor has these properties:
             * {String} text - the item's text
             * {Boolean} present - whether the item should be added to the menu
             * {Function} callback - called when the item fires
             */
            var itemDescriptors = [
              {
                text: phetWebsiteString,
                present: isPhETBrand,
                callback: function() {
                },
                immediateCallback: function() {
                  var phetWindow = window.open( 'http://phet.colorado.edu', '_blank' );
                  phetWindow.focus();
                } },
              {
                text: outputInputEventsLogString,
                present: !!sim.options.recordInputEventLog,
                callback: function() {
                  // prints the recorded input event log to the console
                  console.log( sim.getRecordedInputEventLogString() );
                }},
              {
                text: submitInputEventsLogString,
                present: !!sim.options.recordInputEventLog,
                callback: function() {
                  // submits a recorded event log to the same-origin server (run scenery/tests/event-logs/server/server.js with Node, from the same directory)
                  sim.submitEventLog();
                }},
              {
                text: mailInputEventsLogString,
                present: !!sim.options.recordInputEventLog,
                callback: function() {
                },
                immediateCallback: function() {
                  // mailto: link including the body to email
                  sim.mailEventLog();
                }},
              {
                text: settingsString,
                present: false,
                callback: function() {
                  var settingsDialog = new SettingsDialog( sim );
                  var plane = new Plane( {fill: 'black', opacity: 0.3, renderer: 'svg'} );
                  sim.addChild( plane );
                  sim.addChild( settingsDialog );
                  settingsDialog.addDoneListener( function() {
                    plane.detach();
                    settingsDialog.detach();
                  } );
                }
              },
              {
                text: reportAProblemString,
                present: isPhETBrand,
                callback: function() {},
                immediateCallback: function() {
                  var url = 'http://phet.colorado.edu/files/troubleshooting/' +
                            '?sim=' + encodeURIComponent( sim.name ) +
                            '&version=' + encodeURIComponent( sim.version ) +
                            '&url=' + encodeURIComponent( window.location.href );
                  var reportWindow = window.open( url, '_blank' );
                  reportWindow.focus();
                } },
              {
        
                //One way to allow the user to "save" the state is with a URL.
                //TODO: This does not preserve other query parameters, it probably should
                text: 'Navigate to Save URL',
                present: options.showSaveAndLoad,
                callback: function() {
                  var state = sim.getState();
        
                  //See http://stackoverflow.com/questions/5817505/is-there-any-method-to-get-url-without-query-string-in-java-script
                  var url = [location.protocol, '//', location.host, location.pathname].join( '' ) + '?state=' + encodeURIComponent( JSON.stringify( state, SimJSON.replacer ) );
                  window.location.href = url;
                }
              },
        
              //Feasibility test for capturing screen shots as images
              {
                text: 'Screen shot',
                present: options.showSaveAndLoad,
                callback: function() {
                  var node = sim.screens[sim.simModel.screenIndex].view;
                  new ScreenshotGenerator().generateScreenshot( node, function( canvas ) {
                    node.addChild( new Image( canvas, {left: 0, top: 0, scale: 0.25} ) );
                  } );
                }
              },
              {
                text: aboutString,
                present: isPhETBrand,
                separatorBefore: true,
                callback: function() { showAboutDialog( new AboutDialog( sim, Brand ) ); }
              },
        
              //About dialog for non-phet sims
              {
                text: aboutString,
                present: !isPhETBrand,
                separatorBefore: false,
                callback: function() {
                  showAboutDialog( new AboutDialog( sim, Brand ) );
                }
              }
            ];
        
            // Menu items have uniform size, so compute the max text dimensions.
            var keepItemDescriptors = _.filter( itemDescriptors, function( itemDescriptor ) {return itemDescriptor.present;} );
            var textNodes = _.map( keepItemDescriptors, function( item ) {return new Text( item.text, {font: new PhetFont( FONT_SIZE )} );} );
            var maxTextWidth = _.max( textNodes, function( node ) {return node.width;} ).width;
            var maxTextHeight = _.max( textNodes, function( node ) {return node.height;} ).height;
        
            // Create the menu items.
            var items = _.map( keepItemDescriptors, function( itemDescriptor ) {
              return createMenuItem( itemDescriptor.text, maxTextWidth, maxTextHeight, itemDescriptor.separatorBefore, itemDescriptor.callback, itemDescriptor.immediateCallback );
            } );
            var separatorWidth = _.max( items, function( item ) {return item.width;} ).width;
            var itemHeight = _.max( items, function( item ) {return item.height;} ).height;
            var content = new Node();
            var y = 0;
            var ySpacing = 2;
            var separator;
            _.each( items, function( item ) {
              if ( item.separatorBefore ) {
                y += ySpacing;
                separator = new Path( Shape.lineSegment( 0, y, separatorWidth, y ), {stroke: 'gray', lineWidth: 1} );
                content.addChild( separator );
                y = y + separator.height + ySpacing;
              }
              item.top = y;
              content.addChild( item );
              y += itemHeight;
            } );
        
            // Create a comic-book-style bubble.
            var X_MARGIN = 5;
            var Y_MARGIN = 5;
            var bubble = createBubble( content.width + X_MARGIN + X_MARGIN, content.height + Y_MARGIN + Y_MARGIN );
        
            thisMenu.addChild( bubble );
            thisMenu.addChild( content );
            content.left = X_MARGIN;
            content.top = Y_MARGIN;
        
            thisMenu.mutate( options );
          }
        
          inherit( Node, PhetMenu );
        
          return PhetMenu;
        } );
        
        
        define("image!BRAND/logo.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!BRAND/logo-on-white.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * The button that pops up the PhET menu.
         */
        define( 'JOIST/PhetButton',['require','SCENERY/nodes/Node','SCENERY/nodes/Image','SUN/FontAwesomeNode','SCENERY/nodes/Plane','PHET_CORE/inherit','JOIST/PhetMenu','KITE/Shape','SCENERY/input/ButtonListener','DOT/Vector2','SUN/PushButtonDeprecated','JOIST/HighlightNode','image!BRAND/logo.png','image!BRAND/logo-on-white.png'],function( require ) {
          
        
          // modules
          var Node = require( 'SCENERY/nodes/Node' );
          var Image = require( 'SCENERY/nodes/Image' );
          var FontAwesomeNode = require( 'SUN/FontAwesomeNode' );
          var Plane = require( 'SCENERY/nodes/Plane' );
          var inherit = require( 'PHET_CORE/inherit' );
          var PhetMenu = require( 'JOIST/PhetMenu' );
          var Shape = require( 'KITE/Shape' );
          var ButtonListener = require( 'SCENERY/input/ButtonListener' );
          var Vector2 = require( 'DOT/Vector2' );
          var PushButtonDeprecated = require( 'SUN/PushButtonDeprecated' );
          var HighlightNode = require( 'JOIST/HighlightNode' );
        
          // images
          var phetLogo = require( 'image!BRAND/logo.png' );
          //Makes the 'h' a bit darker so it will show up better against a white background
          var phetLogoDarker = require( 'image!BRAND/logo-on-white.png' );
        
          //TODO don't pass in navigationBar, position based on this button
          /**
           *
           * @param sim
           * @param whiteColorScheme
           * @param homeScreen flag that indicates whether this button appears in the home screen or navbar, to get the positioning right.  TODO: Get rid of the need for this flag.  See #114
           * @param options Unused in client code.  TODO: Remove
           * @constructor
           */
          function PhetButton( sim, whiteColorScheme, homeScreen, options ) {
        
            var phetButton = this;
            options = _.extend( {
              phetLogo: whiteColorScheme ? phetLogoDarker : phetLogo,
              phetLogoScale: 0.28,
              optionsButtonVerticalMargin: 1.5
            }, options );
        
            var phetLabel = new Image( options.phetLogo, {scale: options.phetLogoScale, pickable: false} );
        
            var optionsButton = new FontAwesomeNode( 'reorder', {
              fill: whiteColorScheme ? '#222' : 'white',
              scale: 0.6,
              left: phetLabel.width + 10,
              bottom: phetLabel.bottom - options.optionsButtonVerticalMargin,
              pickable: false
            } );
        
            var createNode = function( highlighted ) {
              var node = new Node( {children: [phetLabel, optionsButton]} );
        
              if ( highlighted ) {
                node.addChild( new HighlightNode( node.width + 6, node.height + 5, {
                  centerX: node.centerX,
                  centerY: node.centerY + 4,
                  whiteHighlight: !whiteColorScheme
                } ) );
              }
              return node;
            };
        
            //PushButtonDeprecated( upNode, overNode, downNode, disabledNode, options )
            PushButtonDeprecated.call( this, createNode( false ), createNode( true ), createNode( true ), new Node() );
        
            //When the phet button is pressed, show the phet menu
            var phetButtonPressed = function() {
        
              //The PhetMenu can be embedded in different contexts, but the scale should be consistent.  So look up the embedding scale here and factor it out.  See #39
              var ancestor = homeScreen ? phetButton.parents[0] : phetButton.parents[0].parents[0];
              var scale = ancestor.getGlobalToLocalMatrix().getScaleVector().x;
        
              var global = phetButton.parentToGlobalPoint( phetButton.center );
              var local = ancestor.globalToLocalPoint( global );
              var phetMenu = new PhetMenu( sim, {
                showSaveAndLoad: sim.options.showSaveAndLoad,
                scale: scale,
                right: phetButton.globalToParentPoint( new Vector2( phetButton.globalBounds.maxX, 0 ) ).x,
                bottom: local.y} );
        
              var rectangle = new Plane( {fill: 'black', opacity: 0.3, renderer: 'svg'} );
              var detach = function() {
                rectangle.detach();
                phetMenu.detach();
                phetMenu.removeInputListener( popupMenuListener );
                rectangle.removeInputListener( rectangleListener );
              };
              var popupMenuListener = new ButtonListener( {fire: detach} );
              var rectangleListener = {down: detach};
        
              phetMenu.addInputListener( popupMenuListener );
              rectangle.addInputListener( rectangleListener );
        
              ancestor.addChild( rectangle );
              ancestor.addChild( phetMenu );
            };
            this.addListener( phetButtonPressed );
        
            this.addPeer( '<input type="button" aria-label="PhET Menu">', {click: phetButtonPressed, tabIndex: 101} );
        
            // eliminate interactivity gap between label and button
            this.mouseArea = this.touchArea = Shape.bounds( this.bounds );
        
            if ( options ) {
              this.mutate( options );
            }
          }
        
          return inherit( PushButtonDeprecated, PhetButton, {},
        
            //statics
            {
        
              //How much space between the PhetButton and the right side of the screen.
              HORIZONTAL_INSET: 5,
        
              //How much space between the PhetButton and the bottom of the screen
              VERTICAL_INSET: 0
            } );
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Button for a single screen in the navigation bar, shows the text and the navigation bar icon.
         *
         * @author Sam Reid
         */
        define( 'JOIST/NavigationBarScreenButton',['require','SCENERY/nodes/Node','SCENERY/nodes/VBox','SCENERY/nodes/Rectangle','SCENERY/nodes/Text','PHET_CORE/inherit','JOIST/HighlightNode','SUN/PushButtonDeprecated','SUN/ToggleNode'],function( require ) {
          
        
          var Node = require( 'SCENERY/nodes/Node' );
          var VBox = require( 'SCENERY/nodes/VBox' );
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
          var Text = require( 'SCENERY/nodes/Text' );
          var inherit = require( 'PHET_CORE/inherit' );
          var HighlightNode = require( 'JOIST/HighlightNode' );
          var PushButtonDeprecated = require( 'SUN/PushButtonDeprecated' );
          var ToggleNode = require( 'SUN/ToggleNode' );
        
          /**
           * Create a nav bar.  Layout assumes all of the screen widths are the same.
           * @param {Sim} sim
           * @param {Screen} screen
           * @param {Number} navBarHeight
           * @param {Boolean} whiteColorScheme true if the color scheme should be white, false if it should be black
           * @constructor
           */
          function NavigationBarScreenButton( sim, screen, navBarHeight, whiteColorScheme, minWidth ) {
            var icon = new Node( {children: [screen.navigationBarIcon], scale: ( 0.625 * navBarHeight ) / screen.navigationBarIcon.height} );
        
            var createNode = function( selected, highlighted, down ) {
        
              //Color match yellow with the PhET Logo
              var text = new Text( screen.name, { fill: whiteColorScheme ?
                                                        (selected ? 'black' : 'gray') :
                                                        (selected ? '#f2e916' : 'white'), visible: true} );
        
              var box = new VBox( {children: [icon, text], opacity: selected ? 1.0 : down ? 0.65 : 0.5, pickable: false} );
        
              //add an overlay so that the icons can be placed next to each other with an HBox, also sets the toucharea/mousearea
              var overlay = new Rectangle( 0, 0, minWidth, box.height );
              overlay.centerX = box.centerX;
              overlay.y = box.y;
              if ( highlighted ) {
                var highlight = new HighlightNode( overlay.width + 4, overlay.height, {centerX: box.centerX, whiteHighlight: !whiteColorScheme, pickable: false} );
                return new Node( {children: [box, highlight, overlay]} );
              }
              else {
                return new Node( {children: [box, overlay]} );
              }
            };
        
            var selectedNode = new PushButtonDeprecated( createNode( true, false, false ), createNode( true, true, false ), createNode( true, true, true ), createNode( true, false, false ), {} );
            var unselectedNode = new PushButtonDeprecated( createNode( false, false, false ), createNode( false, true, false ), createNode( false, true, true ), createNode( false, false, false ), {} );
            unselectedNode.addListener( function() { sim.simModel.screenIndex = sim.screens.indexOf( screen ); } );
        
            var selected = sim.simModel.screenIndexProperty.valueEquals( sim.screens.indexOf( screen ) );
        
            //We can skip wrapping the children here to improve performance slightly since we are certain they aren't used elsewhere in the scenery DAG
            ToggleNode.call( this, selectedNode, unselectedNode, selected, {wrapChildren: false} );
          }
        
          return inherit( ToggleNode, NavigationBarScreenButton );
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * The navigation bar at the bottom of the screen.
         * For a single-screen sim, it shows the name of the sim at the left and the PhET Logo and options menu at the right.
         * For a multi-screen sim, it shows icons for all of the other screens, with the screen name at the left and the PhET Logo and options menu at the right.
         *
         * @author Sam Reid
         */
        define( 'JOIST/NavigationBar',['require','SCENERY/nodes/Node','SCENERY/nodes/HBox','SCENERY/nodes/Text','JOIST/HomeButton','SCENERY/nodes/Rectangle','PHET_CORE/inherit','SCENERY_PHET/PhetFont','JOIST/PhetButton','JOIST/NavigationBarScreenButton'],function( require ) {
          
        
          var Node = require( 'SCENERY/nodes/Node' );
          var HBox = require( 'SCENERY/nodes/HBox' );
          var Text = require( 'SCENERY/nodes/Text' );
          var HomeButton = require( 'JOIST/HomeButton' );
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
          var inherit = require( 'PHET_CORE/inherit' );
          var PhetFont = require( 'SCENERY_PHET/PhetFont' );
          var PhetButton = require( 'JOIST/PhetButton' );
          var NavigationBarScreenButton = require( 'JOIST/NavigationBarScreenButton' );
        
          /**
           * Create a nav bar.  Layout assumes all of the screen widths are the same.
           * @param {Sim} sim
           * @param {Array<Screen>} screens
           * @param {PropertySet} model see joist.Sim
           * @param {Boolean} whiteColorScheme true if the color scheme should be white, false if it should be black
           * @constructor
           */
          function NavigationBar( sim, screens, model, whiteColorScheme ) {
        
            var thisNode = this;
            this.screens = screens;
        
            this.navBarHeight = 40;
            this.navBarScale = 1;
            this.navBarWidth = 768;
        
            //Renderer must be specified here because the node is added directly to the scene (instead of to some other node that already has svg renderer
            Node.call( this, {renderer: 'svg'} );
            this.background = new Rectangle( 0, 0, 0, 0, {fill: whiteColorScheme ? 'white' : 'black', pickable: false} );
            this.addChild( this.background );
        
            this.phetButton = new PhetButton( sim, whiteColorScheme, false );
            this.addChild( this.phetButton );
        
            this.titleLabel = new Text( sim.name, {font: new PhetFont( 18 ), fill: whiteColorScheme ? 'black' : 'white', pickable: false} );
            this.addChild( this.titleLabel );
        
            if ( screens.length > 1 ) {
        
              //Create buttons once so we can get their dimensions
              var buttons = _.map( screens, function( screen ) {
                return new NavigationBarScreenButton( sim, screen, thisNode.navBarHeight, whiteColorScheme, 0 );
              } );
              var maxWidth = Math.max( 50, _.max( buttons, function( button ) {return button.width;} ).width );
        
              //Create buttons again with equivalent sizes
              buttons = _.map( screens, function( screen ) {
                return new NavigationBarScreenButton( sim, screen, thisNode.navBarHeight, whiteColorScheme, maxWidth );
              } );
        
              this.buttonHBox = new HBox( {children: buttons, spacing: 4} );
              this.addChild( this.buttonHBox );
        
              //add the home icon
              this.homeIcon = new HomeButton( whiteColorScheme ? '#222' : 'white', whiteColorScheme ? '#444' : 'gray', whiteColorScheme );
              this.homeIcon.addListener( function() {model.showHomeScreen = true;} );
              this.homeIcon.addPeer( '<input type="button" aria-label="Home Screen">', {click: function() {model.showHomeScreen = true;}, tabIndex: 100} );
              this.addChild( this.homeIcon );
            }
          }
        
          return inherit( Node, NavigationBar, {
            relayout: function() {
              var navigationBar = this;
              navigationBar.background.rectHeight = this.navBarHeight;
              navigationBar.background.rectWidth = this.navBarWidth;
        
              if ( this.buttonHBox ) {
                this.buttonHBox.setScaleMagnitude( navigationBar.navBarScale );
              }
        
              var titleInset = 10;
              var distanceBetweenTitleAndFirstScreenIcon = 20;
              this.titleLabel.setScaleMagnitude( this.navBarScale );
              this.titleLabel.centerY = this.navBarHeight / 2;
              this.titleLabel.left = titleInset;
        
              //Lay out the components from left to right
              if ( this.screens.length !== 1 ) {
        
                //put the center right in the middle
                this.buttonHBox.centerX = this.navBarWidth / 2;
                this.buttonHBox.top = 2;
        
                //Center the home icon vertically and make it a bit larger than the icons and text, see https://github.com/phetsims/joist/issues/127
                navigationBar.homeIcon.setScaleMagnitude( this.navBarScale * 1.1 );
                navigationBar.homeIcon.centerY = navigationBar.background.rectHeight / 2;
                navigationBar.homeIcon.left = navigationBar.buttonHBox.right + 15;
        
                //If the title overlaps the screen icons, scale it down.  See #128
                var availableSpace = this.buttonHBox.left - titleInset - distanceBetweenTitleAndFirstScreenIcon;
                var size = this.titleLabel.width;
                if ( size > availableSpace ) {
                  this.titleLabel.setScaleMagnitude( this.navBarScale * availableSpace / size );
                }
              }
              this.phetButton.setScaleMagnitude( this.navBarScale );
              this.phetButton.right = this.navBarWidth - PhetButton.HORIZONTAL_INSET;
              this.phetButton.bottom = this.navBarHeight - PhetButton.VERTICAL_INSET;
            },
            layout: function( scale, width, height, windowHeight ) {
              this.navBarScale = scale;
              this.navBarWidth = width;
              this.navBarHeight = height;
              this.relayout();
            }} );
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Decorative frame around the selected node
         *
         * @author Sam Reid
         */
        define( 'JOIST/Frame',['require','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','SCENERY/util/LinearGradient'],function( require ) {
          
        
          // modules
          var inherit = require( 'PHET_CORE/inherit' );
          var Node = require( 'SCENERY/nodes/Node' );
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
          var LinearGradient = require( 'SCENERY/util/LinearGradient' );
        
          /**
           * @param {Node} content
           * @param {object} options
           * @constructor
           */
          function Frame( content, options ) {
        
            var thisNode = this;
        
            // default options
            options = _.extend( {
              xMargin1: 6,
              yMargin1: 6,
              cornerRadius: 0 // radius of the rounded corners on the background
            }, options );
        
            Node.call( thisNode );
        
            var width1 = content.width + 2 * options.xMargin1;
            var height1 = content.height + 2 * options.yMargin1;
        
            this.gradient = new LinearGradient( 0, 0, width1, 0 ).addColorStop( 0, '#fbff41' ).addColorStop( 118 / 800.0, '#fef98b' ).addColorStop( 372 / 800.0, '#feff40' ).addColorStop( 616 / 800, '#fffccd' ).addColorStop( 1, '#fbff41' );
            this.rectangle = new Rectangle( 0, 0, width1, height1, options.cornerRadius, options.cornerRadius, {stroke: this.gradient, lineWidth: 3, x: content.x - options.xMargin1, y: content.y - options.yMargin1} );
            this.addChild( this.rectangle );
        
            // Apply options after the layout is done, so that options that use the bounds will work properly.
            this.mutate( options );
            this.width1 = width1;
            this.height1 = height1;
          }
        
          inherit( Node, Frame, {
            setHighlighted: function( highlighted ) {
              this.rectangle.lineWidth = highlighted ? 4.5 : 3;
        
              //Make the frame larger when highlighted, but only so that it expands out
              if ( highlighted ) {
                this.rectangle.setRect( -1.5 / 2, -1.5 / 2, this.width1 + 1.5, this.height1 + 1.5 );
              }
              else {
                this.rectangle.setRect( 0, 0, this.width1, this.height1 );
              }
            }
          } );
        
          return Frame;
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Shows a button that changes the simulation to full screen.  This feature is not available on iPad.
         *
         * @author Sam Reid
         */
        define( 'JOIST/FullScreenButton',['require','SCENERY/nodes/Node','SUN/FontAwesomeNode','PHET_CORE/inherit'],function( require ) {
          
        
          var Node = require( 'SCENERY/nodes/Node' );
          var FontAwesomeNode = require( 'SUN/FontAwesomeNode' );
          var inherit = require( 'PHET_CORE/inherit' );
        
          function requestFullScreen( element ) {
        
            // Supports most browsers and their versions.
            var requestMethod = element.requestFullScreen || element.webkitRequestFullScreen || element.mozRequestFullScreen || element.msRequestFullScreen;
        
            if ( requestMethod ) { // Native full screen.
              requestMethod.call( element );
            }
            else if ( typeof window.ActiveXObject !== "undefined" ) { // Older IE.
              var wscript = new ActiveXObject( "WScript.Shell" );
              if ( wscript !== null ) {
                wscript.SendKeys( "{F11}" );
              }
            }
          }
        
          var fullScreener = function() {
            requestFullScreen( document.body );
          };
        
          function FullScreenButton( options ) {
            Node.call( this, {cursor: 'pointer'} );
            this.addChild( new FontAwesomeNode( 'fullscreen', {fill: '#fff', scale: 0.8} ) );
            this.mutate( _.extend( {cursor: 'pointer'}, options ) );//TODO: pointer not going through here
        
            this.addInputListener( {down: function() {
              $( 'body' ).one( 'mouseup', fullScreener );
            }} );
        
            this.mouseArea = this.bounds;
            this.touchArea = this.bounds;
          }
        
          return inherit( Node, FullScreenButton );
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Shows the home screen for a multi-screen simulation, which lets the user see all of the screens and select one.
         *
         * @author Sam Reid
         */
        define( 'JOIST/HomeScreen',['require','JOIST/PhetButton','SCENERY/nodes/Node','SCENERY/nodes/HBox','SCENERY/nodes/VBox','SCENERY/nodes/Text','KITE/Shape','PHET_CORE/inherit','PHET_CORE/platform','JOIST/ScreenView','JOIST/Frame','AXON/Property','JOIST/FullScreenButton','SCENERY_PHET/PhetFont','SCENERY/nodes/Rectangle'],function( require ) {
          
        
          var PhetButton = require( 'JOIST/PhetButton' );
          var Node = require( 'SCENERY/nodes/Node' );
          var HBox = require( 'SCENERY/nodes/HBox' );
          var VBox = require( 'SCENERY/nodes/VBox' );
          var Text = require( 'SCENERY/nodes/Text' );
          var Shape = require( 'KITE/Shape' );
          var inherit = require( 'PHET_CORE/inherit' );
          var platform = require( 'PHET_CORE/platform' );
          var ScreenView = require( 'JOIST/ScreenView' );
          var Frame = require( 'JOIST/Frame' );
          var Property = require( 'AXON/Property' );
          var FullScreenButton = require( 'JOIST/FullScreenButton' );
          var PhetFont = require( 'SCENERY_PHET/PhetFont' );
          var Rectangle = require( 'SCENERY/nodes/Rectangle' );
        
          var HEIGHT = 70;
          var TITLE_FONT_FAMILY = 'Century Gothic, Futura';
        
          function HomeScreen( sim, options ) {
            var homeScreen = this;
        
            options = _.extend( {
              showSmallHomeScreenIconFrame: false
            }, options );
        
            //Rendering in SVG seems to solve the problem that the home screen consumes 100% disk and crashes, see https://github.com/phetsims/joist/issues/17
            //Also makes it more responsive (and crisper on retina displays)
            //Renderer must be specified here because the node is added directly to the scene (instead of to some other node that already has svg renderer
            ScreenView.call( this, {renderer: 'svg'} );
        
            this.backgroundColor = 'black';
        
            //iPad doesn't support Century Gothic, so fall back to Futura, see http://wordpress.org/support/topic/font-not-working-on-ipad-browser
            var title = new Text( sim.name, {
              font: new PhetFont( {size: 52, family: TITLE_FONT_FAMILY } ),
              fill: 'white',
              y: 110 } );
            this.addChild( title );
            title.scale( Math.min( 1, 0.9 * this.layoutBounds.width / title.width ) );
            title.centerX = this.layoutBounds.centerX;
        
            //Keep track of which screen is highlighted so the same screen can remain highlighted even if nodes are replaced (say when one grows larger or smaller)
            var highlightedIndex = new Property( -1 );
        
            var screenChildren = _.map( sim.screens, function( screen ) {
              var index = sim.screens.indexOf( screen );
              var largeIcon = new Node( {children: [screen.homeScreenIcon], scale: HEIGHT / screen.homeScreenIcon.height * 2} );
              var frame = new Frame( largeIcon );
        
              highlightedIndex.link( function( highlightedIndex ) { frame.setHighlighted( highlightedIndex === index ); } );
        
              var largeIconWithFrame = new Node( {children: [ frame, largeIcon]} );
              var largeText = new Text( screen.name, { font: new PhetFont( 42 ), fill: '#f2e916'} );//Color match with the PhET Logo yellow
        
              //Shrink the text if it goes beyond the edge of the image
              if ( largeText.width > largeIconWithFrame.width ) {
                largeText.scale( largeIconWithFrame.width / largeText.width );
              }
              var large = new VBox( {
                //Don't resize the VBox or it will shift down when the border becomes thicker
                resize: false,
        
                cursor: 'pointer', children: [
                  largeIconWithFrame,
                  largeText
                ]} );
        
              //TODO: Switch to buttonListener, but make sure you test it because on 7/17/2013 there is a problem where ButtonListener won't fire if a node has appeared under the pointer
              large.addInputListener( {
                down: function() {
                  sim.simModel.showHomeScreen = false;
                  highlightedIndex.value = -1;
                }
              } );
        
              //Show a small (unselected) screen icon.  In some cases (if the icon has a black background), a border may be shown around it as well.  See https://github.com/phetsims/color-vision/issues/49
              var smallIconContent = new Node( {opacity: 0.5, children: [screen.homeScreenIcon], scale: sim.screens.length === 4 ? HEIGHT / screen.homeScreenIcon.height :
                                                                                                        sim.screens.length === 3 ? 1.25 * HEIGHT / screen.homeScreenIcon.height :
                                                                                                        sim.screens.length === 2 ? 1.75 * HEIGHT / screen.homeScreenIcon.height :
                                                                                                        HEIGHT / screen.homeScreenIcon.height} );
        
              var smallFrame = new Rectangle( 0, 0, smallIconContent.width, smallIconContent.height, {stroke: options.showSmallHomeScreenIconFrame ? '#dddddd' : null, lineWidth: 0.7} );
              var smallIcon = new Node( {opacity: 0.5, children: [smallFrame, smallIconContent]} );
        
              var smallText = new Text( screen.name, { font: new PhetFont( 18 ), fill: 'gray'} );
        
              //Shrink the text if it goes beyond the edge of the image
              if ( smallText.width > smallIcon.width ) {
                smallText.scale( smallIcon.width / smallText.width );
              }
        
              var small = new VBox( {spacing: 3, cursor: 'pointer', children: [
                smallIcon,
                smallText
              ]} );
              small.mouseArea = small.touchArea = Shape.bounds( small.bounds ); //cover the gap in the vbox
              small.addInputListener( {
                down: function() { sim.simModel.screenIndex = index; },
        
                //On the home screen if you touch an inactive screen thumbnail, it grows.  If then without lifting your finger you swipe over
                // to the next thumbnail, that one would grow.
                over: function( event ) {
                  if ( !event.pointer.isMouse ) {
                    sim.simModel.screenIndex = index;
                  }
                }
              } );
        
              var highlightListener = {
                over: function( event ) {
                  if ( event.pointer.isMouse ) {
                    highlightedIndex.value = index;
        
                    //TODO: use named children instead of child indices?
                    small.children[0].opacity = 1;
                    small.children[1].fill = 'white';
                  }
                },
                out: function( event ) {
                  if ( event.pointer.isMouse ) {
                    highlightedIndex.value = -1;
                    small.children[0].opacity = 0.5;
                    small.children[1].fill = 'gray';
                  }
                }
              };
              small.addInputListener( highlightListener );
        
              large.addInputListener( highlightListener );
              large.mouseArea = large.touchArea = Shape.bounds( large.bounds ); //cover the gap in the vbox
        
              //TODO: Add accessibility peers
              //      screenChild.addPeer( '<input type="button" aria-label="' + screenChild.screen.name + '">', {click: function() {
        //        var screen = screenChild.screen;
        //        if ( sim.simModel.screenIndex === screen.index ) {
        //          sim.simModel.showHomeScreen = false;
        //        }
        //        else {
        //          sim.simModel.screenIndex = screen.index;
        //        }
        //      }} );
        //    } );
        
              return {screen: screen, small: small, large: large, index: index};
            } );
        
            var center = new Node( {y: 170} );
            homeScreen.addChild( center );
            sim.simModel.screenIndexProperty.link( function( screenIndex ) {
        
              //Space the icons out more if there are fewer, so they will be spaced nicely
              //Cannot have only 1 screen because for 1-screen sims there is no home screen.
              var spacing = sim.screens.length === 2 ? 60 :
                            sim.screens.length === 3 ? 60 :
                            33;
        
              var icons = _.map( screenChildren, function( screenChild ) {return screenChild.index === screenIndex ? screenChild.large : screenChild.small;} );
              center.children = [new HBox( {spacing: spacing, children: icons, align: 'top', resize: false} )];
              center.centerX = homeScreen.layoutBounds.width / 2;
            } );
        
            //Only show the full screen button on supported platforms
            var showFullScreenButton = !platform.android && !platform.mobileSafari && !platform.ie; // might work on IE11 in the future
            if ( showFullScreenButton && false ) {
              var fullScreenButton = new FullScreenButton();
              this.addChild( new HBox( {spacing: 10, children: [fullScreenButton, new PhetButton( sim )], right: this.layoutBounds.maxX - 5, bottom: this.layoutBounds.maxY - 5} ) );
            }
            else {
              this.phetButton = new PhetButton( sim, false, true );
              this.addChild( this.phetButton );
            }
          }
        
          return inherit( ScreenView, HomeScreen, {
              layoutWithScale: function( scale, width, height ) {
                HomeScreen.prototype.layout.call( this, width, height );
        
                //Position the phetButton.
                //It is tricky since it is in the coordinate frame of the HomeScreen (which is a ScreenView, and hence translated and scaled)
                //We want to match its location with the location in the NavigationBar
                this.phetButton.right = (width - PhetButton.HORIZONTAL_INSET) / scale;
                this.phetButton.bottom = (height - PhetButton.VERTICAL_INSET) / scale;
        
                //Undo the vertical centering done in ScreenView so the button can be positioned globally
                if ( scale === width / this.layoutBounds.width ) {
                  this.phetButton.translate( 0, -(height - this.layoutBounds.height * scale) / 2 / scale );
                }
        
                //Undo the horizontal centering done in ScreenView so the button can be positioned globally
                else if ( scale === height / this.layoutBounds.height ) {
                  this.phetButton.translate( -(width - this.layoutBounds.width * scale) / 2 / scale, 0 );
                }
              }
            },
        
            //statics
            {
              TITLE_FONT_FAMILY: TITLE_FONT_FAMILY
            }
          );
        } );
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Accessibility peer, which is added to the dom for focus and keyboard navigation.
         *
         * @author Sam Reid
         */
        
        define( 'SCENERY/util/AccessibilityPeer',['require','SCENERY/scenery'],function( require ) {
          
        
          var scenery = require( 'SCENERY/scenery' );
          
          var AccessibilityPeer = scenery.AccessibilityPeer = function AccessibilityPeer( instance, element, options ) {
            var peer = this;
            
            options = options || {};
        
            //Defaulting to 0 would mean using the document order, which can easily be incorrect for a PhET simulation.
            //For any of the nodes to use a nonzero tabindex, they must all use a nonzero tabindex, see #40
            options.tabIndex = options.tabIndex || 1;
            
            // TODO: if element is a DOM element, verify that no other accessibility peer is using it! (add a flag, and remove on disposal)
            this.element = ( typeof element === 'string' ) ? $( element )[0] : element;
        
            if ( options.label ) {
              this.peerElement = document.createElement( 'div' );
              this.element.id = 'peer-' + instance.trail.getUniqueId();
              var label = document.createElement('label');
              label.appendChild(document.createTextNode(options.label));
              label.setAttribute('for',this.element.id);
              this.peerElement.appendChild(label);
              this.peerElement.appendChild(this.element);
            } else{
              this.peerElement = this.element;
            }
        
            this.instance = instance;
            this.trail = instance.trail;
            
            this.element.setAttribute( 'tabindex', options.tabIndex );
            this.element.style.position = 'absolute';
            
            // TODO: batch these also if the Scene is batching events
            var scene = instance.getScene();
            this.clickListener = function PeerClickListener( event ) {
              sceneryAccessibilityLog && sceneryAccessibilityLog( 'peer click on ' + instance.toString() + ': ' + instance.getNode().constructor.name );
              if ( options.click ) { options.click( event ); }
            };
            this.focusListener = function PeerFocusListener( event ) {
              sceneryAccessibilityLog && sceneryAccessibilityLog( 'peer focused: ' + instance.toString() + ': ' + instance.getNode().constructor.name );
              scene.focusPeer( peer );
            };
            this.blurListener = function PeerBlurListener( event ) {
              sceneryAccessibilityLog && sceneryAccessibilityLog( 'peer blurred: ' + instance.toString() + ': ' + instance.getNode().constructor.name );
              scene.blurPeer( peer );
            };
            this.element.addEventListener( 'click', this.clickListener );
            this.element.addEventListener( 'focus', this.focusListener );
            this.element.addEventListener( 'blur', this.blurListener );
        
            this.keepPeerBoundsInSync = true;
            if ( this.keepPeerBoundsInSync ) {
              this.boundsSyncListener = this.syncBounds.bind( this );
        
              instance.getNode().addEventListener( 'bounds', this.boundsSyncListener );
              this.syncBounds();
        
              //When the scene resizes, update the peer bounds
              instance.getScene().addEventListener( 'resize', this.boundsSyncListener );
        
              //Initial layout
              window.setTimeout( this.syncBounds.bind( this ), 30 );
            }
          };
        
          AccessibilityPeer.prototype = {
            constructor: AccessibilityPeer,
            
            dispose: function() {
              this.element.removeEventListener( 'click', this.clickListener );
              this.element.removeEventListener( 'focus', this.focusListener );
              this.element.removeEventListener( 'blur', this.blurListener );
              
              // don't leak memory
              if ( this.keepPeerBoundsInSync ) {
                this.instance.getNode().removeEventListener( 'bounds', this.boundsSyncListener );
                this.instance.getScene().removeEventListener( 'resize', this.boundsSyncListener );
              }
            },
            
            getGlobalBounds: function() {
              return this.trail.parentToGlobalBounds( this.trail.lastNode().getBounds() ).roundedOut();
            },
            
            syncBounds: function() {
              var globalBounds = this.getGlobalBounds();
              this.element.style.left = globalBounds.x + 'px';
              this.element.style.top = globalBounds.y + 'px';
              this.element.style.width = globalBounds.width + 'px';
              this.element.style.height = globalBounds.height + 'px';
            }
          };
          
          return AccessibilityPeer;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Live region is used with accessibility to read out changes in model state.
         * Should conform to the Axon property interface to make it easy to interchange.
         *
         * @author Sam Reid
         */
        
        define( 'SCENERY/util/LiveRegion',['require','SCENERY/scenery'],function( require ) {
          
        
          var scenery = require( 'SCENERY/scenery' );
        
          var LiveRegion = scenery.LiveRegion = function LiveRegion( instance, property, options ) {
            var liveRegion = this;
            this.property = property;
            options = options || {};
        
            //Defaulting to 0 would mean using the document order, which can easily be incorrect for a PhET simulation.
            //For any of the nodes to use a nonzero tabindex, they must all use a nonzero tabindex, see #40
            options.tabIndex = options.tabIndex || 1;
        
            // TODO: if element is a DOM element, verify that no other accessibility liveRegion is using it! (add a flag, and remove on disposal)
        //    this.element = '<div role="region" id="bird-info" aria-live="polite">';
            this.element = document.createElement( 'div' );
            this.element.setAttribute( 'aria-live', 'polite' );
            this.element.setAttribute( 'role', 'region' );
            this.textNode = document.createTextNode( '' );
            this.element.appendChild( this.textNode );
        
            //Just setting the text causes NVDA to read deltas, you have to replace the node to have it read the text
            this.listener = function( newText ) {
              liveRegion.element.removeChild( liveRegion.textNode );
              liveRegion.textNode = document.createTextNode( newText );
              liveRegion.element.appendChild( liveRegion.textNode );
            };
            property.link( this.listener );
          };
        
          LiveRegion.prototype = {
            constructor: scenery.LiveRegion,
            dispose: function() { this.property.unlink( this.listener ); }
          };
        
          return LiveRegion;
        } );
        // Copyright 2002-2013, University of Colorado
        
        /**
         * An Instance of a Node in the expanded tree form.
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/util/Instance',['require','SCENERY/scenery','SCENERY/util/AccessibilityPeer','SCENERY/util/LiveRegion'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          require( 'SCENERY/util/AccessibilityPeer' );
          require( 'SCENERY/util/LiveRegion' );
          
          var accessibility = window.has && window.has( 'scenery.accessibility' );
          
          // layer should be null if the trail isn't to a painted node
          scenery.Instance = function Instance( trail, layer, parent ) {
            this.trail = trail; // trail may be assumed to be stale, for performance reasons
            this.layer = layer;
            this.oldLayer = layer; // used during stitching
            
            // assertion not enabled, since at the start we don't specify a layer (it will be constructed later)
            // assert && assert( trail.lastNode().isPainted() === ( layer !== null ), 'Has a layer iff is painted' );
            
            // TODO: SVG layer might want to put data (group/fragment) references here (indexed by layer ID)
            this.data = {};
            
            // TODO: ensure that we can track this? otherwise remove it for memory and speed
            this.parent = parent;
            this.children = [];
            
            this.peers = []; // list of AccessibilityPeer instances attached to this trail
            this.liveRegions = []; // list of LiveRegion instances attached to this trail
            
            // TODO: track these? should significantly accelerate subtree-changing operations
            this.startAffectedLayer = null;
            this.endAffectedLayer = null;
            
            trail.setImmutable(); // make sure our Trail doesn't change from under us
            
            if ( accessibility ) {
              this.addPeers();
              this.addLiveRegions();
            }
            
            phetAllocation && phetAllocation( 'Instance' );
          };
          var Instance = scenery.Instance;
          
          Instance.prototype = {
            constructor: Instance,
            
            getScene: function() {
              return this.trail.rootNode();
            },
            get scene() { return this.getScene(); },
            
            getNode: function() {
              return this.trail.lastNode();
            },
            get node() { return this.getNode(); },
            
            changeLayer: function( newLayer ) {
              // NOTE: DO NOT change _layerTrails somehow in this function. we don't make a defensive copy of that array during stitching!
              if ( newLayer !== this.layer ) {
                sceneryLayerLog && sceneryLayerLog( 'changing instance ' + this.trail.toString() + ' to layer ' + ( newLayer ? '#' + newLayer.id : 'null' ) );
                this.layer && ( this.layer._instanceCount -= 1 );
                this.layer = newLayer;
                this.layer && ( this.layer._instanceCount += 1 );
              }
            },
            
            updateLayer: function() {
              if ( this.layer !== this.oldLayer ) {
                // we may have stale indices
                this.reindex();
                
                if ( sceneryLayerLog ) {
                  if ( this.oldLayer && this.layer ) {
                    sceneryLayerLog( 'moving instance ' + this.trail.toString() + ' from layer #' + this.oldLayer.id + ' to layer #' + this.layer.id );
                  } else if ( this.layer ) {
                    sceneryLayerLog( 'adding instance ' + this.trail.toString() + ' to layer #' + this.layer.id );
                  } else {
                    sceneryLayerLog( 'remove instance ' + this.trail.toString() + ' from layer #' + this.oldLayer.id );
                  }
                }
                if ( this.oldLayer ) {
                  this.oldLayer.removeInstance( this );
                }
                if ( this.layer ) {
                  this.layer.addInstance( this );
                }
                this.oldLayer = this.layer;
              }
            },
            
            createChild: function( childNode, index ) {
              var childTrail = this.trail.copy().addDescendant( childNode );
              var childInstance = new scenery.Instance( childTrail, null, this );
              sceneryLayerLog && sceneryLayerLog( 'Instance.createChild: ' + childInstance.toString() );
              this.insertInstance( index, childInstance );
              childInstance.getNode().addInstance( childInstance );
              
              return childInstance;
            },
            
            addInstance: function( instance ) {
              assert && assert( instance, 'Instance.addInstance cannot have falsy parameter' );
              this.children.push( instance );
            },
            
            insertInstance: function( index, instance ) {
              assert && assert( instance, 'Instance.insert cannot have falsy instance parameter' );
              assert && assert( index >= 0 && index <= this.children.length, 'Instance.insert has bad index ' + index + ' for length ' + this.children.length );
              this.children.splice( index, 0, instance );
            },
            
            removeInstance: function( index ) {
              assert && assert( typeof index === 'number' );
              this.children.splice( index, 1 );
            },
            
            reindex: function() {
              this.trail.reindex();
            },
            
            // TODO: rename, so that it indicates that it removes the instance from the node
            dispose: function() {
              if ( this.layer ) {
                this.changeLayer( null );
                this.updateLayer();
              }
              this.parent = null;
              this.children.length = 0;
              this.getNode().removeInstance( this );
              
              if ( accessibility ) {
                this.removePeers();
                this.removeLiveRegions();
              }
            },
            
            equals: function( other ) {
              assert && assert( ( this === other ) === this.trail.equals( other.trail ), 'We assume a 1-1 mapping from trails to instances' );
              return this === other;
            },
            
            // standard -1,0,1 comparison with another instance, as a total ordering from the render order
            compare: function( other ) {
              return this.trail.compare( other.trail );
            },
            
            getLayerString: function() {
              return this.layer ? ( this.layer.getName() + '#' + this.layer.getId() ) : '-';
            },
            
            getTrailString: function() {
              return this.trail.toString();
            },
            
            toString: function() {
              return '{' + this.getTrailString() + ', ' + this.getLayerString() + '}';
            },
            
            getAffectedLayers: function() {
              // TODO: optimize this using pre-recorded versions?
              this.reindex();
              return this.getScene().affectedLayers( this.trail );
            },
            
            addPeers: function() {
              var node = this.getNode();
              var scene = this.getScene();
              
              var len = node._peers.length;
              if ( len ) {
                for ( var i = 0; i < len; i++ ) {
                  var desc = node._peers[i];
                  var peer = new scenery.AccessibilityPeer( this, desc.element, desc.options );
                  scene.addPeer( peer );
                  this.peers.push( peer );
                }
              }
            },
            
            removePeers: function() {
              var scene = this.getScene();
              
              var i = this.peers.length;
              while ( i-- ) {
                var peer = this.peers[i];
                scene.removePeer( peer );
                peer.dispose();
              }
              
              this.peers.length = 0; // clear this.peers
            },
        
            addLiveRegions: function() {
              var thisInstance = this;
              var node = this.getNode();
              var scene = this.getScene();
        
              if ( node._liveRegions.length ) {
                _.each( node._liveRegions, function( item ) {
                  var liveRegion = new scenery.LiveRegion( thisInstance, item.property, item.options );
                  scene.addLiveRegion( liveRegion );
                  thisInstance.liveRegions.push( liveRegion );
                } );
              }
            },
        
            removeLiveRegions: function() {
              var scene = this.getScene();
        
              _.each( this.liveRegions, function( liveRegion ) {
                scene.removeLiveRegion( liveRegion );
                liveRegion.dispose();
              } );
              
              this.peers.length = 0; // clear this.peers
            },
            
            /*---------------------------------------------------------------------------*
            * Events from the Node
            *----------------------------------------------------------------------------*/
            
            notifyVisibilityChange: function() {
              sceneryEventLog && sceneryEventLog( 'notifyVisibilityChange: ' + this.trail.toString() + ', ' + this.getLayerString() );
              
              var affectedLayers = this.getAffectedLayers();
              var i = affectedLayers.length;
              while ( i-- ) {
                affectedLayers[i].notifyVisibilityChange( this );
              }
            },
            
            notifyOpacityChange: function() {
              sceneryEventLog && sceneryEventLog( 'notifyOpacityChange: ' + this.trail.toString() + ', ' + this.getLayerString() );
              
              var affectedLayers = this.getAffectedLayers();
              var i = affectedLayers.length;
              while ( i-- ) {
                affectedLayers[i].notifyOpacityChange( this );
              }
            },
            
            notifyClipChange: function() {
              sceneryEventLog && sceneryEventLog( 'notifyClipChange: ' + this.trail.toString() + ', ' + this.getLayerString() );
              
              var affectedLayers = this.getAffectedLayers();
              var i = affectedLayers.length;
              while ( i-- ) {
                affectedLayers[i].notifyClipChange( this );
              }
            },
            
            notifyBeforeSelfChange: function() {
              sceneryEventLog && sceneryEventLog( 'notifyBeforeSelfChange: ' + this.trail.toString() + ', ' + this.getLayerString() );
              // TODO: Canvas will only need to be notified of these once in-between scene updates
              // TODO: walk up the "tree" to see if any ancestors did this (in which case we don't need to)
              // e.g. this.oldPaint = true, etc.
              this.layer.notifyBeforeSelfChange( this );
            },
            
            notifyBeforeSubtreeChange: function() {
              sceneryEventLog && sceneryEventLog( 'notifyBeforeSubtreeChange: ' + this.trail.toString() + ', ' + this.getLayerString() );
              
              var affectedLayers = this.getAffectedLayers();
              var i = affectedLayers.length;
              while ( i-- ) {
                affectedLayers[i].notifyBeforeSubtreeChange( this );
              }
            },
            
            notifyDirtySelfPaint: function() {
              sceneryEventLog && sceneryEventLog( 'notifyDirtySelfPaint: ' + this.trail.toString() + ', ' + this.getLayerString() );
              assert && assert( this.getNode().isPainted(), 'Instance needs to be painted for notifyDirtySelfPaint' );
              this.layer.notifyDirtySelfPaint( this );
            },
            
            // TODO: consider special post-transform type?
            notifyDirtySubtreePaint: function() {
              sceneryEventLog && sceneryEventLog( 'notifyDirtySubtreePaint: ' + this.trail.toString() + ', ' + this.getLayerString() );
              
              var affectedLayers = this.getAffectedLayers();
              var i = affectedLayers.length;
              while ( i-- ) {
                affectedLayers[i].notifyDirtySubtreePaint( this );
              }
            },
            
            notifyDirtySubtreeBounds: function() {
              sceneryEventLog && sceneryEventLog( 'notifyDirtySubtreeBounds: ' + this.trail.toString() + ', ' + this.getLayerString() );
              
              var affectedLayers = this.getAffectedLayers();
              var i = affectedLayers.length;
              while ( i-- ) {
                affectedLayers[i].notifyDirtySubtreeBounds( this );
              }
            },
            
            notifyTransformChange: function() {
              sceneryEventLog && sceneryEventLog( 'notifyTransformChange: ' + this.trail.toString() + ', ' + this.getLayerString() );
              
              var affectedLayers = this.getAffectedLayers();
              var i = affectedLayers.length;
              while ( i-- ) {
                affectedLayers[i].notifyTransformChange( this );
              }
            },
            
            notifyBoundsAccuracyChange: function() {
              sceneryEventLog && sceneryEventLog( 'notifyBoundsAccuracyChange: ' + this.trail.toString() + ', ' + this.getLayerString() );
              this.layer.notifyBoundsAccuracyChange( this );
            },
            
            notifyStitch: function( match ) {
              sceneryEventLog && sceneryEventLog( 'notifyStitch: ' + this.trail.toString() + ' match:' + match + ', ' + this.getLayerString() );
              this.getScene().stitch( match );
            },
            
            markForLayerRefresh: function() {
              sceneryEventLog && sceneryEventLog( 'markForLayerRefresh: ' + this.trail.toString() + ', ' + this.getLayerString() );
              this.getScene().markSceneForLayerRefresh( this );
            },
            
            markForInsertion: function( child, index ) {
              sceneryEventLog && sceneryEventLog( 'markForInsertion: ' + this.trail.toString() + ' child:' + child.id + ', index: ' + index + ', ' + this.getLayerString() );
              
              this.reindex();
              this.getScene().markSceneForInsertion( this, child, index );
            },
            
            markForRemoval: function( child, index ) {
              sceneryEventLog && sceneryEventLog( 'markForRemoval: ' + this.trail.toString() + ' child:' + child.id + ', index: ' + index + ', ' + this.getLayerString() );
              
              this.reindex();
              this.getScene().markSceneForRemoval( this, child, index );
            }
          };
          
          return Instance;
        } );
        
        
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * An interval between two Trails. A trail being null means either 'from the start' or 'to the end', depending
         * on whether it is the first or second parameter to the constructor.
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/util/RenderInterval',['require','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          require( 'SCENERY/util/Trail' );
          
          // start and end are of type {Trail} or null (indicates all the way to the start / end)
          scenery.RenderInterval = function RenderInterval( start, end ) {
            assert && assert( !start || !end || start.compare( end ) <= 0, 'RenderInterval parameters must not be out of order' );
            
            this.start = start;
            this.end = end;
          };
          var RenderInterval = scenery.RenderInterval;
          
          // assumes the intervals are disjoint, so we can just compare the start instance
          RenderInterval.compareDisjoint = function( x, y ) {
            // if they are both falsy, they should be the same
            if ( !x.start && !y.start ) { return 0; }
            
            // otherwise, since we are comparing the starts, null would signify 'before anything'
            if ( !x.start || !y.start ) { return x.start ? 1 : -1; }
            
            // otherwise our standard comparison
            return x.start.compare( y.start );
          };
          
          RenderInterval.prototype = {
            constructor: RenderInterval,
            
            reindex: function() {
              this.start && this.start.reindex();
              this.end && this.end.reindex();
            },
            
            isValidExclusive: function() {
              // like construction, but with strict inequality
              return !this.start || !this.end || this.start.compare( this.end ) < 0;
            },
            
            /*
             * Whether the union of this and the specified interval doesn't include any additional trails, when
             * both are treated as exclusive endpoints (exclusive between a and b). We also make the assumption
             * that a !== b || a === null for either interval, since otherwise it is not well defined.
             */
            exclusiveUnionable: function( interval ) {
              assert && assert ( this.isValidExclusive(), 'exclusiveUnionable requires exclusive intervals' );
              assert && assert ( interval.isValidExclusive(), 'exclusiveUnionable requires exclusive intervals' );
              return ( !this.start || !interval.end || this.start.compare( interval.end ) === -1 ) &&
                     ( !this.end || !interval.start || this.end.compare( interval.start ) === 1 );
            },
            
            exclusiveContains: function( trail ) {
              assert && assert( trail );
              return ( !this.start || this.start.compare( trail ) < 0 ) && ( !this.end || this.end.compare( trail ) > 0 );
            },
            
            union: function( interval ) {
              // falsy checks since if a or b is null, we want that bound to be null
              var thisA = ( !this.start || ( interval.start && this.start.compare( interval.start ) === -1 ) );
              var thisB = ( !this.end || ( interval.end && this.end.compare( interval.end ) === 1 ) );
              
              return new RenderInterval(
                thisA ? this.start : interval.start,
                thisB ? this.end : interval.end
              );
            },
            
            toString: function() {
              return '[' + ( this.start ? this.start.toString() : this.start ) + ',' + ( this.end ? this.end.toString() : this.end ) + ']';
            }
          };
          
          return RenderInterval;
        } );
        
        
        
        // Copyright 2002-2013, University of Colorado
        
        /*
         * A pointer is an abstraction that includes a mouse and touch points (and possibly keys).
         *
         * TODO: add state tracking (dragging/panning/etc.) to pointer for convenience
         * TODO: consider an 'active' flag?
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/input/Pointer',['require','SCENERY/scenery'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          
          scenery.Pointer = function Pointer() {
            this.listeners = [];
            
            phetAllocation && phetAllocation( 'Pointer' );
            
            this.active = false; // whether a control is being actively manipulated by this pointer
          };
          var Pointer = scenery.Pointer;
          
          Pointer.prototype = {
            constructor: Pointer,
            
            addInputListener: function( listener ) {
              assert && assert( !_.contains( this.listeners, listener ) );
              
              this.listeners.push( listener );
            },
            
            removeInputListener: function( listener ) {
              var index = _.indexOf( this.listeners, listener );
              assert && assert( index !== -1 );
              
              this.listeners.splice( index, 1 );
            },
            
            // for mouse/touch/pen
            hasPointChanged: function( point ) {
              return this.point !== point && ( !point || !this.point || !this.point.equals( point ) );
            }
          };
          
          return Pointer;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Tracks the mouse state
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/input/Mouse',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/input/Pointer'],function( require ) {
          
          
          var inherit = require( 'PHET_CORE/inherit' );
          var scenery = require( 'SCENERY/scenery' );
          
          var Pointer = require( 'SCENERY/input/Pointer' ); // inherits from Pointer
          
          scenery.Mouse = function Mouse() {
            Pointer.call( this );
            
            this.point = null;
            
            this.leftDown = false;
            this.middleDown = false;
            this.rightDown = false;
            
            this.isMouse = true;
            
            this.trail = null;
            
            this.isDown = false;
            
            // overrides the cursor of whatever is under it when set
            this._cursor = null;
            
            this.type = 'mouse';
          };
          var Mouse = scenery.Mouse;
          
          inherit( Pointer, Mouse, {
            set cursor( value ) { return this.setCursor( value ); },
            get cursor() { return this._cursor; },
            
            setCursor: function( value ) {
              this._cursor = value;
              return this; // allow chaining
            },
            
            clearCursor: function() {
              this.setCursor( null );
            },
            
            down: function( point, event ) {
              var pointChanged = this.hasPointChanged( point );
              sceneryEventLog && point && sceneryEventLog( 'mouse down at ' + point.toString() );
              // if ( this.point ) { this.point.freeToPool(); }
              this.point = point;
              this.isDown = true;
              switch( event.button ) {
                case 0: this.leftDown = true; break;
                case 1: this.middleDown = true; break;
                case 2: this.rightDown = true; break;
              }
              return pointChanged;
            },
            
            up: function( point, event ) {
              var pointChanged = this.hasPointChanged( point );
              sceneryEventLog && point && sceneryEventLog( 'mouse up at ' + point.toString() );
              // if ( this.point ) { this.point.freeToPool(); }
              this.point = point;
              this.isDown = false;
              switch( event.button ) {
                case 0: this.leftDown = false; break;
                case 1: this.middleDown = false; break;
                case 2: this.rightDown = false; break;
              }
              return pointChanged;
            },
            
            move: function( point, event ) {
              var pointChanged = this.hasPointChanged( point );
              sceneryEventLog && point && sceneryEventLog( 'mouse move at ' + point.toString() );
              // if ( this.point ) { this.point.freeToPool(); }
              this.point = point;
              return pointChanged;
            },
            
            over: function( point, event ) {
              var pointChanged = this.hasPointChanged( point );
              sceneryEventLog && point && sceneryEventLog( 'mouse over at ' + point.toString() );
              // if ( this.point ) { this.point.freeToPool(); }
              this.point = point;
              return pointChanged;
            },
            
            out: function( point, event ) {
              var pointChanged = this.hasPointChanged( point );
              sceneryEventLog && point && sceneryEventLog( 'mouse out at ' + point.toString() );
              // if ( this.point ) { this.point.freeToPool(); }
              // TODO: how to handle the mouse out-of-bounds
              this.point = null;
              return pointChanged;
            },
            
            toString: function() {
              return 'Mouse';
            }
          } );
          
          return Mouse;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Tracks a single touch point
         *
         * IE guidelines for Touch-friendly sites: http://blogs.msdn.com/b/ie/archive/2012/04/20/guidelines-for-building-touch-friendly-sites.aspx
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/input/Touch',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/input/Pointer'],function( require ) {
          
          
          var inherit = require( 'PHET_CORE/inherit' );
          var scenery = require( 'SCENERY/scenery' );
          
          var Pointer = require( 'SCENERY/input/Pointer' ); // extends Pointer
          
          scenery.Touch = function Touch( id, point, event ) {
            Pointer.call( this );
            
            this.id = id;
            this.point = point;
            this.isTouch = true;
            this.trail = null;
            
            this.isDown = true; // touches always start down
            
            this.type = 'touch';
          };
          var Touch = scenery.Touch;
          
          inherit( Pointer, Touch, {
            move: function( point, event ) {
              var pointChanged = this.hasPointChanged( point );
              // if ( this.point ) { this.point.freeToPool(); }
              this.point = point;
              return pointChanged;
            },
            
            end: function( point, event ) {
              var pointChanged = this.hasPointChanged( point );
              // if ( this.point ) { this.point.freeToPool(); }
              this.point = point;
              this.isDown = false;
              return pointChanged;
            },
            
            cancel: function( point, event ) {
              var pointChanged = this.hasPointChanged( point );
              // if ( this.point ) { this.point.freeToPool(); }
              this.point = point;
              this.isDown = false;
              return pointChanged;
            },
            
            toString: function() {
              return 'Touch#' + this.id;
            }
          } );
          
          return Touch;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Tracks a stylus ('pen') or something with tilt and pressure information
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/input/Pen',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/input/Pointer'],function( require ) {
          
          
          var inherit = require( 'PHET_CORE/inherit' );
          var scenery = require( 'SCENERY/scenery' );
          
          var Pointer = require( 'SCENERY/input/Pointer' ); // extends Pointer
          
          scenery.Pen = function Pen( id, point, event ) {
            Pointer.call( this );
            
            this.id = id;
            this.point = point;
            this.isPen = true;
            this.trail = null;
            
            this.isDown = true; // pens always start down? TODO: is this true with pointer events?
            
            this.type = 'pen';
          };
          var Pen = scenery.Pen;
          
          inherit( Pointer, Pen, {
            move: function( point, event ) {
              var pointChanged = this.hasPointChanged( point );
              // if ( this.point ) { this.point.freeToPool(); }
              this.point = point;
              return pointChanged;
            },
            
            end: function( point, event ) {
              var pointChanged = this.hasPointChanged( point );
              // if ( this.point ) { this.point.freeToPool(); }
              this.point = point;
              this.isDown = false;
              return pointChanged;
            },
            
            cancel: function( point, event ) {
              var pointChanged = this.hasPointChanged( point );
              // if ( this.point ) { this.point.freeToPool(); }
              this.point = point;
              this.isDown = false;
              return pointChanged;
            },
            
            toString: function() {
              return 'Pen#' + this.id;
            }
          } );
          
          return Pen;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Tracks a single key-press
         *
         * TODO: general key-press implementation
         * TODO: consider separate handling for keys in general.
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/input/Key',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/input/Pointer'],function( require ) {
          
          
          var inherit = require( 'PHET_CORE/inherit' );
          var scenery = require( 'SCENERY/scenery' );
          
          var Pointer = require( 'SCENERY/input/Pointer' ); // Inherits from Pointer
          
          scenery.Key = function Key( event ) {
            Pointer.call( this );
            
            this.event = event; // event.keyCode event.charCode
            this.isKey = true; // compared to isMouse/isPen/isTouch
            this.trail = null;
            this.type = 'key';
          };
          var Key = scenery.Key;
          
          inherit( Pointer, Key, {
            
          } );
          
          return Key;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /*
         * An event in Scenery that has similar event-handling characteristics to DOM events.
         * The original DOM event (if any) is available as event.domEvent.
         *
         * Multiple events can be triggered by a single domEvent, so don't assume it is unique.
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
         
        define( 'SCENERY/input/Event',['require','SCENERY/scenery'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          
          scenery.Event = function Event( args ) {
            // ensure that all of the required args are supplied
            assert && assert( args.trail &&
                              args.type &&
                              args.pointer &&
                              args.target, 'Missing required scenery.Event argument' );
            
            this.handled = false;
            this.aborted = false;
            
            // {Trail} path to the leaf-most node, ordered list, from root to leaf
            this.trail = args.trail;
            
            // {String} what event was triggered on the listener
            this.type = args.type;
            
            // {Pointer}
            this.pointer = args.pointer;
            
            // raw DOM InputEvent (TouchEvent, PointerEvent, MouseEvent,...)
            this.domEvent = args.domEvent;
            
            // {Node} whatever node you attached the listener to, or null when firing events on a Pointer
            this.currentTarget = args.currentTarget;
            
            // {Node} leaf-most node in trail
            this.target = args.target;
            
            // TODO: add extended information based on an event here?
          };
          var Event = scenery.Event;
          
          Event.prototype = {
            constructor: Event,
            
            // like DOM Event.stopPropagation(), but named differently to indicate it doesn't fire that behavior on the underlying DOM event
            handle: function() {
              this.handled = true;
            },
            
            // like DOM Event.stopImmediatePropagation(), but named differently to indicate it doesn't fire that behavior on the underlying DOM event
            abort: function() {
              this.handled = true;
              this.aborted = true;
            }
          };
          
          return Event;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * API for handling mouse / touch / keyboard events.
         *
         * A 'pointer' is an abstract way of describing either the mouse, a single touch point, or a key being pressed.
         * touch points and key presses go away after being released, whereas the mouse 'pointer' is persistent.
         *
         * Events will be called on listeners with a single event object. Supported event types are:
         * 'up', 'down', 'out', 'over', 'enter', 'exit', 'move', and 'cancel'. Scenery also supports more specific event
         * types that constrain the type of pointer, so 'mouse' + type, 'touch' + type and 'pen' + type will fire
         * on each listener before the generic event would be fined. E.g. for mouse movement, listener.mousemove will be
         * fired before listener.move.
         *
         * DOM Level 3 events spec: http://www.w3.org/TR/DOM-Level-3-Events/
         * Touch events spec: http://www.w3.org/TR/touch-events/
         * Pointer events spec draft: https://dvcs.w3.org/hg/pointerevents/raw-file/tip/pointerEvents.html
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/input/Input',['require','SCENERY/scenery','SCENERY/util/Trail','SCENERY/input/Mouse','SCENERY/input/Touch','SCENERY/input/Pen','SCENERY/input/Key','SCENERY/input/Event'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          
          require( 'SCENERY/util/Trail' );
          require( 'SCENERY/input/Mouse' );
          require( 'SCENERY/input/Touch' );
          require( 'SCENERY/input/Pen' );
          require( 'SCENERY/input/Key' );
          require( 'SCENERY/input/Event' );
          
          // listenerTarget is the DOM node (window/document/element) to which DOM event listeners will be attached
          scenery.Input = function Input( scene, listenerTarget, batchDOMEvents ) {
            this.scene = scene;
            this.listenerTarget = listenerTarget;
            this.batchDOMEvents = batchDOMEvents;
            
            this.batchedCallbacks = []; // cleared every frame
        
            //Pointer for mouse, only created lazily on first mouse event, so no mouse is allocated on tablets
            this.mouse = null;
        
            this.pointers = [];
            
            this.listenerReferences = [];
            
            this.eventLog = [];     // written when recording event input. can be overwritten to the empty array to reset. Strings relative to this class (prefix "scene.input.")
            this.logEvents = false; // can be set to true to cause Scenery to record all input calls to eventLog
        
            this.pointerAddedListeners = [];
          };
          var Input = scenery.Input;
          
          Input.prototype = {
            constructor: Input,
        
            addPointer: function( pointer ) {
              this.pointers.push( pointer );
        
              //Callback for showing pointer events.  Optimized for performance.
              if ( this.pointerAddedListeners.length ) {
                for ( var i = 0; i < this.pointerAddedListeners.length; i++ ) {
                  this.pointerAddedListeners[i]( pointer );
                }
              }
            },
        
            addPointerAddedListener: function( listener ) {
              this.pointerAddedListeners.push(listener);
            },
        
            removePointerAddedListener: function( listener ) {
              var index = this.pointerAddedListeners.indexOf( listener );
              if ( index !== -1 ) {
                this.pointerAddedListeners.splice( index, index + 1 );
              }
            },
            
            removePointer: function( pointer ) {
              // sanity check version, will remove all instances
              for ( var i = this.pointers.length - 1; i >= 0; i-- ) {
                if ( this.pointers[i] === pointer ) {
                  this.pointers.splice( i, 1 );
                }
              }
            },
            
            findTouchById: function( id ) {
              var i = this.pointers.length;
              while ( i-- ) {
                var pointer = this.pointers[i];
                if ( pointer.id === id ) {
                  return pointer;
                }
              }
              return undefined;
            },
            
            findKeyByEvent: function( event ) {
              assert && assert( event.hasOwnProperty( 'keyCode' ) && event.hasOwnProperty('charCode'), 'Assumes the KeyboardEvent has keyCode and charCode properties' );
              var result = _.find( this.pointers, function( pointer ) {
                // TODO: also check location (if that exists), so we don't mix up left and right shift, etc.
                return pointer.keyCode === event.keyCode && pointer.charCode === event.charCode;
              } );
              // assert && assert( result, 'No key found for the combination of key:' + event.key + ' and location:' + event.location );
              return result;
            },
        
            //Init the mouse on the first mouse event (if any!)
            initMouse: function() {
              this.mouse = new scenery.Mouse();
              this.addPointer( this.mouse );
            },
            
            mouseDown: function( point, event ) {
              if ( this.logEvents ) { this.eventLog.push( 'mouseDown(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
              if ( !this.mouse ) { this.initMouse(); }
              var pointChanged = this.mouse.down( point, event );
              if ( pointChanged ) {
                this.moveEvent( this.mouse, event );
              }
              this.downEvent( this.mouse, event );
            },
            
            mouseUp: function( point, event ) {
              if ( this.logEvents ) { this.eventLog.push( 'mouseUp(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
              if ( !this.mouse ) { this.initMouse(); }
              var pointChanged = this.mouse.up( point, event );
              if ( pointChanged ) {
                this.moveEvent( this.mouse, event );
              }
              this.upEvent( this.mouse, event );
            },
            
            mouseUpImmediate: function( point, event ) {
              if ( this.logEvents ) { this.eventLog.push( 'mouseUpImmediate(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
              if ( !this.mouse ) { this.initMouse(); }
              if ( this.mouse.point ) {
                // if the pointer's point hasn't been initialized yet, ignore the immediate up
                this.upImmediateEvent( this.mouse, event );
              }
            },
            
            mouseMove: function( point, event ) {
              if ( this.logEvents ) { this.eventLog.push( 'mouseMove(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
              if ( !this.mouse ) { this.initMouse(); }
              this.mouse.move( point, event );
              this.moveEvent( this.mouse, event );
            },
            
            mouseOver: function( point, event ) {
              if ( this.logEvents ) { this.eventLog.push( 'mouseOver(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
              if ( !this.mouse ) { this.initMouse(); }
              this.mouse.over( point, event );
              // TODO: how to handle mouse-over (and log it)
            },
            
            mouseOut: function( point, event ) {
              if ( this.logEvents ) { this.eventLog.push( 'mouseOut(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
              if ( !this.mouse ) { this.initMouse(); }
              this.mouse.out( point, event );
              // TODO: how to handle mouse-out (and log it)
            },
            
            keyDown: function( event ) {
              if ( this.logEvents ) { this.eventLog.push( 'keyDown(' + Input.serializeDomEvent( event ) + ');' ); }
              var key = new scenery.Key( event );
              this.addPointer( key );
              
              var trail = this.scene.getTrailFromKeyboardFocus();
              this.dispatchEvent( trail, 'keyDown', key, event, true );
            },
            
            keyUp: function( event ) {
              if ( this.logEvents ) { this.eventLog.push( 'keyUp(' + Input.serializeDomEvent( event ) + ');' ); }
              var key = this.findKeyByEvent( event );
              if ( key ) {
                this.removePointer( key );
                
                var trail = this.scene.getTrailFromKeyboardFocus();
                this.dispatchEvent( trail, 'keyUp', key, event, true );
              }
            },
            
            keyPress: function( event ) {
              if ( this.logEvents ) { this.eventLog.push( 'keyPress(' + Input.serializeDomEvent( event ) + ');' ); }
              // NOTE: do we even need keyPress?
            },
            
            // called for each touch point
            touchStart: function( id, point, event ) {
              if ( this.logEvents ) { this.eventLog.push( 'touchStart(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
              var touch = new scenery.Touch( id, point, event );
              this.addPointer( touch );
              this.downEvent( touch, event );
            },
            
            touchEnd: function( id, point, event ) {
              if ( this.logEvents ) { this.eventLog.push( 'touchEnd(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
              var touch = this.findTouchById( id );
              if ( touch ) {
                var pointChanged = touch.end( point, event );
                if ( pointChanged ) {
                  this.moveEvent( touch, event );
                }
                this.removePointer( touch );
                this.upEvent( touch, event );
              } else {
                assert && assert( false, 'Touch not found for touchEnd: ' + id );
              }
            },
            
            touchEndImmediate: function( id, point, event ) {
              if ( this.logEvents ) { this.eventLog.push( 'touchEndImmediate(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
              var touch = this.findTouchById( id );
              if ( touch ) {
                this.upImmediateEvent( touch, event );
              } else {
                assert && assert( false, 'Touch not found for touchEndImmediate: ' + id );
              }
            },
            
            touchMove: function( id, point, event ) {
              if ( this.logEvents ) { this.eventLog.push( 'touchMove(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
              var touch = this.findTouchById( id );
              if ( touch ) {
                touch.move( point, event );
                this.moveEvent( touch, event );
              } else {
                assert && assert( false, 'Touch not found for touchMove: ' + id );
              }
            },
            
            touchCancel: function( id, point, event ) {
              if ( this.logEvents ) { this.eventLog.push( 'touchCancel(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
              var touch = this.findTouchById( id );
              if ( touch ) {
                var pointChanged = touch.cancel( point, event );
                if ( pointChanged ) {
                  this.moveEvent( touch, event );
                }
                this.removePointer( touch );
                this.cancelEvent( touch, event );
              } else {
                assert && assert( false, 'Touch not found for touchCancel: ' + id );
              }
            },
            
            // called for each touch point
            penStart: function( id, point, event ) {
              if ( this.logEvents ) { this.eventLog.push( 'penStart(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
              var pen = new scenery.Pen( id, point, event );
              this.addPointer( pen );
              this.downEvent( pen, event );
            },
            
            penEnd: function( id, point, event ) {
              if ( this.logEvents ) { this.eventLog.push( 'penEnd(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
              var pen = this.findTouchById( id );
              if ( pen ) {
                var pointChanged = pen.end( point, event );
                if ( pointChanged ) {
                  this.moveEvent( pen, event );
                }
                this.removePointer( pen );
                this.upEvent( pen, event );
              } else {
                assert && assert( false, 'Pen not found for penEnd: ' + id );
              }
            },
            
            penEndImmediate: function( id, point, event ) {
              if ( this.logEvents ) { this.eventLog.push( 'penEndImmediate(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
              var pen = this.findTouchById( id );
              if ( pen ) {
                this.upImmediateEvent( pen, event );
              } else {
                assert && assert( false, 'Pen not found for penEndImmediate: ' + id );
              }
            },
            
            penMove: function( id, point, event ) {
              if ( this.logEvents ) { this.eventLog.push( 'penMove(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
              var pen = this.findTouchById( id );
              if ( pen ) {
                pen.move( point, event );
                this.moveEvent( pen, event );
              } else {
                assert && assert( false, 'Pen not found for penMove: ' + id );
              }
            },
            
            penCancel: function( id, point, event ) {
              if ( this.logEvents ) { this.eventLog.push( 'penCancel(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
              var pen = this.findTouchById( id );
              if ( pen ) {
                var pointChanged = pen.cancel( point, event );
                if ( pointChanged ) {
                  this.moveEvent( pen, event );
                }
                this.removePointer( pen );
                this.cancelEvent( pen, event );
              } else {
                assert && assert( false, 'Pen not found for penCancel: ' + id );
              }
            },
            
            pointerDown: function( id, type, point, event ) {
              switch ( type ) {
                case 'mouse':
                  this.mouseDown( point, event );
                  break;
                case 'touch':
                  this.touchStart( id, point, event );
                  break;
                case 'pen':
                  this.penStart( id, point, event );
                  break;
                default:
                  if ( console.log ) {
                    console.log( 'Unknown pointer type: ' + type );
                  }
              }
            },
            
            pointerUp: function( id, type, point, event ) {
              switch ( type ) {
                case 'mouse':
                  this.mouseUp( point, event );
                  break;
                case 'touch':
                  this.touchEnd( id, point, event );
                  break;
                case 'pen':
                  this.penEnd( id, point, event );
                  break;
                default:
                  if ( console.log ) {
                    console.log( 'Unknown pointer type: ' + type );
                  }
              }
            },
            
            pointerUpImmediate: function( id, type, point, event ) {
              switch ( type ) {
                case 'mouse':
                  this.mouseUpImmediate( point, event );
                  break;
                case 'touch':
                  this.touchEndImmediate( id, point, event );
                  break;
                case 'pen':
                  this.penEndImmediate( id, point, event );
                  break;
                default:
                  if ( console.log ) {
                    console.log( 'Unknown pointer type: ' + type );
                  }
              }
            },
            
            pointerCancel: function( id, type, point, event ) {
              switch ( type ) {
                case 'mouse':
                  if ( console && console.log ) {
                    console.log( 'WARNING: Pointer mouse cancel was received' );
                  }
                  break;
                case 'touch':
                  this.touchCancel( id, point, event );
                  break;
                case 'pen':
                  this.penCancel( id, point, event );
                  break;
                default:
                  if ( console.log ) {
                    console.log( 'Unknown pointer type: ' + type );
                  }
              }
            },
            
            pointerMove: function( id, type, point, event ) {
              switch ( type ) {
                case 'mouse':
                  this.mouseMove( point, event );
                  break;
                case 'touch':
                  this.touchMove( id, point, event );
                  break;
                case 'pen':
                  this.penMove( id, point, event );
                  break;
                default:
                  if ( console.log ) {
                    console.log( 'Unknown pointer type: ' + type );
                  }
              }
            },
            
            pointerOver: function( id, type, point, event ) {
              
            },
            
            pointerOut: function( id, type, point, event ) {
              
            },
            
            pointerEnter: function( id, type, point, event ) {
              
            },
            
            pointerLeave: function( id, type, point, event ) {
              
            },
            
            upEvent: function( pointer, event ) {
              var trail = this.scene.trailUnderPointer( pointer ) || new scenery.Trail( this.scene );
              
              this.dispatchEvent( trail, 'up', pointer, event, true );
              
              // touch pointers are transient, so fire exit/out to the trail afterwards
              if ( pointer.isTouch ) {
                this.exitEvents( pointer, event, trail, 0, true );
              }
              
              pointer.trail = trail;
            },
            
            upImmediateEvent: function( pointer, event ) {
              var trail = this.scene.trailUnderPointer( pointer ) || new scenery.Trail( this.scene );
              
              this.dispatchEvent( trail, 'upImmediate', pointer, event, true );
            },
            
            downEvent: function( pointer, event ) {
              var trail = this.scene.trailUnderPointer( pointer ) || new scenery.Trail( this.scene );
              
              // touch pointers are transient, so fire enter/over to the trail first
              if ( pointer.isTouch ) {
                this.enterEvents( pointer, event, trail, 0, true );
              }
              
              this.dispatchEvent( trail, 'down', pointer, event, true );
              
              pointer.trail = trail;
            },
            
            moveEvent: function( pointer, event ) {
              var changed = this.branchChangeEvents( pointer, event, true );
              if ( changed ) {
                sceneryEventLog && sceneryEventLog( 'branch change due to move event' );
              }
            },
            
            cancelEvent: function( pointer, event ) {
              var trail = this.scene.trailUnderPointer( pointer ) || new scenery.Trail( this.scene );
              
              this.dispatchEvent( trail, 'cancel', pointer, event, true );
              
              // touch pointers are transient, so fire exit/out to the trail afterwards
              if ( pointer.isTouch ) {
                this.exitEvents( pointer, event, trail, 0, true );
              }
              
              pointer.trail = trail;
            },
            
            // return whether there was a change
            branchChangeEvents: function( pointer, event, isMove ) {
              var trail = this.scene.trailUnderPointer( pointer ) || new scenery.Trail( this.scene );
              sceneryEventLog && sceneryEventLog( 'checking branch change: ' + trail.toString() + ' at ' + pointer.point.toString() );
              var oldTrail = pointer.trail || new scenery.Trail( this.scene ); // TODO: consider a static trail reference
              
              var lastNodeChanged = oldTrail.lastNode() !== trail.lastNode();
              if ( !lastNodeChanged && !isMove ) {
                // bail out if nothing needs to be done
                return false;
              }
              
              var branchIndex = scenery.Trail.branchIndex( trail, oldTrail );
              var isBranchChange = branchIndex !== trail.length || branchIndex !== oldTrail.length;
              sceneryEventLog && isBranchChange && sceneryEventLog( 'branch change from ' + oldTrail.toString() + ' to ' + trail.toString() );
              
              // event order matches http://www.w3.org/TR/DOM-Level-3-Events/#events-mouseevent-event-order
              if ( isMove ) {
                this.dispatchEvent( trail, 'move', pointer, event, true );
              }
              
              // we want to approximately mimic http://www.w3.org/TR/DOM-Level-3-Events/#events-mouseevent-event-order
              // TODO: if a node gets moved down 1 depth, it may see both an exit and enter?
              this.exitEvents( pointer, event, oldTrail, branchIndex, lastNodeChanged );
              this.enterEvents( pointer, event, trail, branchIndex, lastNodeChanged );
              
              pointer.trail = trail;
              return isBranchChange;
            },
            
            enterEvents: function( pointer, event, trail, branchIndex, lastNodeChanged ) {
              if ( trail.length > branchIndex ) {
                for ( var newIndex = trail.length - 1; newIndex >= branchIndex; newIndex-- ) {
                  this.dispatchEvent( trail.slice( 0, newIndex + 1 ), 'enter', pointer, event, false );
                }
              }
              
              if ( lastNodeChanged ) {
                this.dispatchEvent( trail, 'over', pointer, event, true );
              }
            },
            
            exitEvents: function( pointer, event, trail, branchIndex, lastNodeChanged ) {
              if ( lastNodeChanged ) {
                this.dispatchEvent( trail, 'out', pointer, event, true );
              }
              
              if ( trail.length > branchIndex ) {
                for ( var oldIndex = branchIndex; oldIndex < trail.length; oldIndex++ ) {
                  this.dispatchEvent( trail.slice( 0, oldIndex + 1 ), 'exit', pointer, event, false );
                }
              }
            },
            
            validatePointers: function() {
              var that = this;
              
              var i = this.pointers.length;
              while ( i-- ) {
                var pointer = this.pointers[i];
                if ( pointer.point ) {
                  var changed = that.branchChangeEvents( pointer, null, false );
                  if ( changed ) {
                    sceneryEventLog && sceneryEventLog( 'branch change due validatePointers' );
                  }
                }
              }
            },
            
            dispatchEvent: function( trail, type, pointer, event, bubbles ) {
              sceneryEventLog && sceneryEventLog( 'Input: ' + type + ' on ' + trail.toString() + ' for pointer ' + pointer.toString() + ' at ' + pointer.point.toString() );
              if ( !trail ) {
                try {
                  throw new Error( 'falsy trail for dispatchEvent' );
                } catch ( e ) {
                  console.log( e.stack );
                  throw e;
                }
              }
              
              // TODO: is there a way to make this event immutable?
              var inputEvent = new scenery.Event( {
                trail: trail, // {Trail} path to the leaf-most node, ordered list, from root to leaf
                type: type, // {String} what event was triggered on the listener
                pointer: pointer, // {Pointer}
                domEvent: event, // raw DOM InputEvent (TouchEvent, PointerEvent, MouseEvent,...)
                currentTarget: null, // {Node} whatever node you attached the listener to, null when passed to a Pointer,
                target: trail.lastNode() // {Node} leaf-most node in trail
              } );
              
              // first run through the pointer's listeners to see if one of them will handle the event
              this.dispatchToPointer( type, pointer, inputEvent );
              
              // if not yet handled, run through the trail in order to see if one of them will handle the event
              // at the base of the trail should be the scene node, so the scene will be notified last
              this.dispatchToTargets( trail, pointer, type, inputEvent, bubbles );
              
              // TODO: better interactivity handling?
              if ( !trail.lastNode().interactive && !pointer.isKey && event && event.preventDefault ) {
                event.preventDefault();
              }
            },
            
            // TODO: reduce code sharing between here and dispatchToTargets!
            dispatchToPointer: function( type, pointer, inputEvent ) {
              if ( inputEvent.aborted || inputEvent.handled ) {
                return;
              }
              
              var specificType = pointer.type + type; // e.g. mouseup, touchup, keyup
              
              var pointerListeners = pointer.listeners.slice( 0 ); // defensive copy
              for ( var i = 0; i < pointerListeners.length; i++ ) {
                var listener = pointerListeners[i];
                
                // if a listener returns true, don't handle any more
                var aborted = false;
                
                if ( !aborted && listener[specificType] ) {
                  listener[specificType]( inputEvent );
                  aborted = inputEvent.aborted;
                }
                if ( !aborted && listener[type] ) {
                  listener[type]( inputEvent );
                  aborted = inputEvent.aborted;
                }
                
                // bail out if the event is aborted, so no other listeners are triggered
                if ( aborted ) {
                  return;
                }
              }
            },
            
            dispatchToTargets: function( trail, pointer, type, inputEvent, bubbles ) {
              if ( inputEvent.aborted || inputEvent.handled ) {
                return;
              }
              
              var specificType = pointer.type + type; // e.g. mouseup, touchup, keyup
              
              for ( var i = trail.length - 1; i >= 0; bubbles ? i-- : i = -1 ) {
                var target = trail.nodes[i];
                inputEvent.currentTarget = target;
                
                var listeners = target.getInputListeners();
                
                for ( var k = 0; k < listeners.length; k++ ) {
                  var listener = listeners[k];
                  
                  // if a listener returns true, don't handle any more
                  var aborted = false;
                  
                  if ( !aborted && listener[specificType] ) {
                    listener[specificType]( inputEvent );
                    aborted = inputEvent.aborted;
                  }
                  if ( !aborted && listener[type] ) {
                    listener[type]( inputEvent );
                    aborted = inputEvent.aborted;
                  }
                  
                  // bail out if the event is aborted, so no other listeners are triggered
                  if ( aborted ) {
                    return;
                  }
                }
                
                // if the input event was handled, don't follow the trail down another level
                if ( inputEvent.handled ) {
                  return;
                }
              }
            },
            
            addListener: function( type, callback, useCapture ) {
              var input = this;
              
              //Cancel propagation of mouse events but not key events.  Key Events need to propagate for tab navigability
              var usePreventDefault = type !== 'keydown' && type !== 'keyup' && type !== 'keypress';
              
              // work around iOS Safari 7 not sending touch events to Scenes contained in an iframe
              if ( this.listenerTarget === window ) {
                document.addEventListener( type, function( domEvent ) {} );
              }
              
              if ( this.batchDOMEvents ) {
                var batchedCallback = function batchedEvent( domEvent ) {
                  sceneryEventLog && sceneryEventLog( 'Batching event for ' + type );
                  
                  if ( usePreventDefault ) {
                    domEvent.preventDefault(); // TODO: should we batch the events in a different place so we don't preventDefault on something bad?
                  }
                  input.batchedCallbacks.push( function batchedEventCallback() {
                    // process whether anything under the pointers changed before running additional input events
                    sceneryEventLog && sceneryEventLog( 'validatePointers from batched event' );
                    input.validatePointers();
                    if ( input.logEvents ) { input.eventLog.push( 'validatePointers();' ); }
                    
                    callback( domEvent );
                  } );
                };
                this.listenerTarget.addEventListener( type, batchedCallback, useCapture );
                this.listenerReferences.push( { type: type, callback: batchedCallback, useCapture: useCapture } );
              } else {
                this.listenerTarget.addEventListener( type, callback, useCapture );
                this.listenerReferences.push( { type: type, callback: function synchronousEvent( domEvent ) {
                  sceneryEventLog && sceneryEventLog( 'Running event for ' + type );
                  
                  // process whether anything under the pointers changed before running additional input events
                  sceneryEventLog && sceneryEventLog( 'validatePointers from non-batched event' );
                  input.validatePointers();
                  if ( input.logEvents ) { input.eventLog.push( 'validatePointers();' ); }
                  
                  callback( domEvent );
                }, useCapture: useCapture } );
              }
            },
            
            // temporary, for mouse events
            addImmediateListener: function( type, callback, useCapture ) {
              this.listenerTarget.addEventListener( type, callback, useCapture );
              this.listenerReferences.push( { type: type, callback: function immediateEvent( domEvent ) {
                sceneryEventLog && sceneryEventLog( 'Running immediate event for ' + type );
                
                // process whether anything under the pointers changed before running additional input events
                // input.validatePointers();
                // if ( input.logEvents ) { input.eventLog.push( 'validatePointers();' ); }
                
                callback( domEvent );
              }, useCapture: useCapture } );
            },
            
            disposeListeners: function() {
              var input = this;
              _.each( this.listenerReferences, function( ref ) {
                input.listenerTarget.removeEventListener( ref.type, ref.callback, ref.useCapture );
              } );
            },
            
            fireBatchedEvents: function() {
              if ( this.batchedCallbacks.length ) {
                sceneryEventLog && sceneryEventLog( 'Input.fireBatchedEvents length:' + this.batchedCallbacks.length );
                var len = this.batchedCallbacks.length;
                for ( var i = 0; i < len; i++ ) {
                  this.batchedCallbacks[i]();
                }
                this.batchedCallbacks.length = 0;
              }
            }
          };
          
          Input.serializeDomEvent = function serializeDomEvent( domEvent ) {
            var lines = [];
            for ( var prop in domEvent ) {
              if ( domEvent.hasOwnProperty( prop ) ) {
                // stringifying dom event object properties can cause circular references, so we avoid that completely
                if ( prop === 'touches' || prop === 'targetTouches' || prop === 'changedTouches' ) {
                  var arr = [];
                  for ( var i = 0; i < domEvent[prop].length; i++ ) {
                    // according to spec (http://www.w3.org/TR/touch-events/), this is not an Array, but a TouchList
                    var touch = domEvent[prop].item( i );
                    
                    arr.push( serializeDomEvent( touch ) );
                  }
                  lines.push( prop + ':[' + arr.join( ',' ) + ']' );
                } else {
                  lines.push( prop + ':' + ( ( typeof domEvent[prop] === 'object' ) && ( domEvent[prop] !== null ) ? '{}' : JSON.stringify( domEvent[prop] ) ) );
                }
              }
            }
            return '{' + lines.join( ',' ) + '}';
          };
          
          Input.serializeVector2 = function( vector ) {
            return 'dot(' + vector.x + ',' + vector.y + ')';
          };
          
          return Input;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * A conceptual boundary between layers, where it is optional to have information about a previous or next layer.
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/layers/LayerBoundary',['require','SCENERY/scenery'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          
          scenery.LayerBoundary = function LayerBoundary() {
            // layer types before and after the boundary. null indicates the lack of information (first or last layer)
            this.previousLayerType = null;
            this.nextLayerType = null;
            
            // trails to the closest nodes with isPainted() === true before and after the boundary
            this.previousPaintedTrail = null;
            this.nextPaintedTrail = null;
          };
          var LayerBoundary = scenery.LayerBoundary;
          
          LayerBoundary.prototype = {
            constructor: LayerBoundary,
            
            hasPrevious: function() {
              return !!this.previousPaintedTrail;
            },
            
            hasNext: function() {
              return !!this.nextPaintedTrail;
            },
            
            // reindexes the trails
            reindex: function() {
              this.previousPaintedTrail && this.previousPaintedTrail.reindex();
              this.nextPaintedTrail && this.nextPaintedTrail.reindex();
            },
            
            // assumes that trail is reindexed
            equivalentPreviousTrail: function( trail ) {
              if ( this.previousPaintedTrail && trail ) {
                this.previousPaintedTrail.reindex();
                return this.previousPaintedTrail.equals( trail );
              } else {
                // check that handles null versions properly
                return this.previousPaintedTrail === trail;
              }
            },
            
            equivalentNextTrail: function( trail ) {
              if ( this.nextPaintedTrail && trail ) {
                this.nextPaintedTrail.reindex();
                return this.nextPaintedTrail.equals( trail );
              } else {
                // check that handles null versions properly
                return this.nextPaintedTrail === trail;
              }
            },
            
            toString: function() {
              return 'boundary:' +
                     '\n    types:    ' +
                          ( this.previousLayerType ? this.previousLayerType.name : '' ) +
                          ' => ' +
                          ( this.nextLayerType ? this.nextLayerType.name : '' ) +
                     '\n    trails:   ' +
                          ( this.previousPaintedTrail ? this.previousPaintedTrail.getUniqueId() : '' ) +
                          ' => ' +
                          ( this.nextPaintedTrail ? this.nextPaintedTrail.getUniqueId() : '' );
            }
          };
          
          return LayerBoundary;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Controls the underlying layer behavior around a node. The node's LayerStrategy's enter() and exit() will be
         * called in a depth-first order during the layer building process, and will modify a LayerBuilder to signal any
         * layer-specific signals.
         *
         * This generally ensures that a layer containing the proper renderer and settings to support its associated node
         * will be created.
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/layers/LayerStrategy',['require','SCENERY/scenery'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          
          /*
           * If the node specifies a renderer, we will always push a preferred type. That type will be fresh (if rendererOptions are specified), otherwise
           * the top matching preferred type for that renderer will be used. This allows us to always pop in the exit().
           *
           * Specified as such, since there is no needed shared state (we can have node.layerStrategy = scenery.LayerStrategy for many nodes)
           */
          scenery.LayerStrategy = {
            // true iff enter/exit will push/pop a layer type to the preferred stack. currently limited to only one layer type per level.
            hasPreferredLayerType: function( pointer, layerBuilder ) {
              return pointer.trail.lastNode().hasRenderer();
            },
            
            getPreferredLayerType: function( pointer, layerBuilder ) {
              assert && assert( this.hasPreferredLayerType( pointer, layerBuilder ) ); // sanity check
              
              var node = pointer.trail.lastNode();
              var preferredLayerType;
              
              if ( node.hasRendererLayerType() ) {
                preferredLayerType = node.getRendererLayerType();
              } else {
                preferredLayerType = layerBuilder.bestPreferredLayerTypeFor( node.getRenderer().bitmask );
                if ( !preferredLayerType ) {
                  // there was no preferred layer type matching, just use the default
                  preferredLayerType = node.getRenderer().defaultLayerType;
                }
              }
              
              return preferredLayerType;
            },
            
            enter: function( pointer, layerBuilder ) {
              var trail = pointer.trail;
              var node = trail.lastNode();
              var preferredLayerType;
              
              // if the node has a renderer, always push a layer type, so that we can pop on the exit() and ensure consistent behavior
              if ( node.hasRenderer() ) {
                preferredLayerType = this.getPreferredLayerType( pointer, layerBuilder );
                
                // push the preferred layer type
                layerBuilder.pushPreferredLayerType( preferredLayerType );
                if ( layerBuilder.getCurrentLayerType() !== preferredLayerType ) {
                  layerBuilder.switchToType( pointer, preferredLayerType );
                }
              } else if ( node.isPainted() ) {
                // node doesn't specify a renderer, but isPainted.
                
                var currentType = layerBuilder.getCurrentLayerType();
                preferredLayerType = layerBuilder.bestPreferredLayerTypeFor( node._rendererBitmask );
                
                // If any of the preferred types are compatible, use the top one. This allows us to support caching and hierarchical layer types
                if ( preferredLayerType ) {
                  if ( currentType !== preferredLayerType ) {
                    layerBuilder.switchToType( pointer, preferredLayerType );
                  }
                } else {
                  // if no preferred types are compatible, only switch if the current type is also incompatible
                  if ( !currentType || !currentType.supportsNode( node ) ) {
                    layerBuilder.switchToType( pointer, node.pickARenderer().defaultLayerType );
                  }
                }
              }
              
              if ( node.isLayerSplit() || this.hasSplitFlags( node ) ) {
                layerBuilder.switchToType( pointer, layerBuilder.getCurrentLayerType() );
              }
              
              if ( node.isPainted() ) {
                // trigger actual layer creation if necessary (allow collapsing of layers otherwise)
                layerBuilder.markPainted( pointer );
              }
            },
            
            // afterSelf: function( trail, layerBuilder ) {
            //   // no-op, and possibly not used
            // },
            
            // betweenChildren: function( trail, layerBuilder ) {
            //   // no-op, and possibly not used
            // },
            
            exit: function( pointer, layerBuilder ) {
              var trail = pointer.trail;
              var node = trail.lastNode();
              
              if ( node.hasRenderer() ) {
                layerBuilder.popPreferredLayerType();
                
                // switch down to the next lowest preferred layer type, if any. if null, pass the null to switchToType
                // this allows us to not 'leak' the renderer information, and the temporary layer type is most likely collapsed and ignored
                // NOTE: disabled for now, since this prevents us from having adjacent children sharing the same layer type
                // if ( layerBuilder.getCurrentLayerType() !== layerBuilder.getPreferredLayerType() ) {
                //   layerBuilder.switchToType( pointer, layerBuilder.getPreferredLayerType() );
                // }
              }
              
              if ( node.isLayerSplit() || this.hasSplitFlags( node ) ) {
                layerBuilder.switchToType( pointer, layerBuilder.getCurrentLayerType() );
              }
            },
            
            // whether splitting before and after the node is required
            hasSplitFlags: function( node ) {
              // currently, only enforce splitting if we are using CSS transforms
              var rendererOptions = node.getRendererOptions();
              return node.hasRenderer() && rendererOptions && (
                rendererOptions.cssTranslation ||
                rendererOptions.cssRotation ||
                rendererOptions.cssScale ||
                rendererOptions.cssTransform
              );
            }
          };
          var LayerStrategy = scenery.LayerStrategy;
          
          return LayerStrategy;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * A layer state is used to construct layer information (and later, layers), and is a state machine
         * that layer strategies from each node modify. Iterating through all of the nodes in a depth-first
         * manner will modify the LayerBuilder so that layer information can be retrieved.
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/layers/LayerBuilder',['require','SCENERY/scenery','SCENERY/layers/LayerBoundary','SCENERY/util/Trail','SCENERY/util/TrailPointer','SCENERY/layers/LayerStrategy'],function( require ) {
          
          
          var scenery = require( 'SCENERY/scenery' );
          require( 'SCENERY/layers/LayerBoundary' );
          require( 'SCENERY/util/Trail' );
          require( 'SCENERY/util/TrailPointer' );
          var LayerStrategy = require( 'SCENERY/layers/LayerStrategy' ); // used to set the default layer strategy on the prototype
          
          /*
           * Builds layer information between trails
           *
           * previousLayerType should be null if there is no previous layer.
           */
          scenery.LayerBuilder = function LayerBuilder( scene, previousLayerType, previousPaintedTrail, nextPaintedTrail ) {
            
            /*---------------------------------------------------------------------------*
            * Initial state
            *----------------------------------------------------------------------------*/
            
            this.layerTypeStack = [];
            this.boundaries = [];
            this.pendingBoundary = new scenery.LayerBoundary();
            this.pendingBoundary.previousLayerType = previousLayerType;
            this.pendingBoundary.previousPaintedTrail = previousPaintedTrail;
            
            /*
             * The current layer type active, and whether it has been 'used' yet. A node with isPainted() will trigger a 'used' action,
             * and if the layer hasn't been used, it will actually trigger a boundary creation. We want to collapse 'unused' layers
             * and boundaries together, so that every created layer has a node that displays something.
             */
            this.currentLayerType = previousLayerType;
            this.layerChangePending = previousPaintedTrail === null;
            
            /*---------------------------------------------------------------------------*
            * Start / End pointers
            *----------------------------------------------------------------------------*/
            
            if ( previousPaintedTrail ) {
              // Move our start pointer just past the previousPaintedTrail, since our previousLayerType is presumably for that trail's node's self.
              // Anything after that self could have been collapsed, so we need to start there.
              this.startPointer = new scenery.TrailPointer( previousPaintedTrail.copy(), true );
              this.startPointer.nestedForwards();
            } else {
              this.startPointer = new scenery.TrailPointer( new scenery.Trail( scene ), true );
            }
            
            if ( nextPaintedTrail ) {
              // include the nextPaintedTrail's 'before' in our iteration, so we can stitch properly with the next layer
              this.endPointer = new scenery.TrailPointer( nextPaintedTrail.copy(), true );
            } else {
              this.endPointer = new scenery.TrailPointer( new scenery.Trail( scene ), false );
            }
            
            this.includesEndTrail = nextPaintedTrail !== null;
            
            /*
             * LayerBoundary properties and assurances:
             *
             * previousLayerType  - initialized in constructor (in case there are no layer changes)
             *                      set in layerChange for "fresh" pending boundary
             * nextLayerType      - set and overwrites in switchToType, for collapsing layers
             *                      not set anywhere else, so we can leave it null
             * previousPaintedTrail  - initialized in constructor
             *                      updated in markPainted if there is no pending change (don't set if there is a pending change)
             * nextPaintedTrail      - set on layerChange for "stale" boundary
             *                      stays null if nextPaintedTrail === null
             */
          };
          var LayerBuilder = scenery.LayerBuilder;
          
          LayerBuilder.prototype = {
            constructor: LayerBuilder,
            
            // walks part of the state up to just before the startPointer. we want the preferred layer stack to be in place, but the rest is not important
            prepareLayerStack: function() {
              var pointer = new scenery.TrailPointer( new scenery.Trail( this.startPointer.trail.rootNode() ), true );
              
              // if the start pointer is going to execute an exit() instead of an enter() on its trail node, we need to bump up the layer stack an additional step
              var targetLength = this.startPointer.trail.length - ( this.startPointer.isBefore ? 1 : 0 );
              
              while ( pointer.trail.length <= targetLength ) {
                if ( LayerStrategy.hasPreferredLayerType( pointer, this ) ) {
                  this.pushPreferredLayerType( LayerStrategy.getPreferredLayerType( pointer, this ) );
                }
                if ( pointer.trail.length < this.startPointer.trail.nodes.length ) {
                  pointer.trail.addDescendant( this.startPointer.trail.nodes[pointer.trail.length] );
                } else {
                  // TODO: a cleaner way of doing this, since we were adding undefined into a trail to cause the loop to exit
                  break;
                }
              }
            },
            
            run: function() {
              var builder = this;
              
              // push preferred layers for ancestors of our start pointer
              this.prepareLayerStack();
              
              // console.log( '         stack: ' + _.map( builder.layerTypeStack, function( type ) { return type.name; } ).join( ', ' ) );
              
              builder.startPointer.depthFirstUntil( builder.endPointer, function( pointer ) {
                if ( pointer.isBefore ) {
                  // console.log( 'builder: enter ' + pointer.toString() );
                  LayerStrategy.enter( pointer, builder );
                } else {
                  // console.log( 'builder: exit ' + pointer.toString() );
                  LayerStrategy.exit( pointer, builder );
                }
                // console.log( '         stack: ' + _.map( builder.layerTypeStack, function( type ) { return type.name; } ).join( ', ' ) );
              }, false ); // include the endpoints
              
              // special case handling if we are at the 'end' of the scene, so that we create another 'wrapping' boundary
              if ( !this.includesEndTrail ) {
                // console.log( 'builder: not including end trail' );
                this.layerChange( null );
              }
            },
            
            // allows paintedPointer === null at the end if the main iteration's nextPaintedTrail === null (i.e. we are at the end of the scene)
            layerChange: function( paintedPointer ) {
              this.layerChangePending = false;
              
              var confirmedBoundary = this.pendingBoundary;
              
              confirmedBoundary.nextPaintedTrail = paintedPointer ? paintedPointer.trail.copy() : null;
              
              this.boundaries.push( confirmedBoundary );
              
              this.pendingBoundary = new scenery.LayerBoundary();
              this.pendingBoundary.previousLayerType = confirmedBoundary.nextLayerType;
              this.pendingBoundary.previousPaintedTrail = confirmedBoundary.nextPaintedTrail;
              // console.log( 'builder:   added boundary' );
            },
            
            /*---------------------------------------------------------------------------*
            * API for layer strategy or other interaction
            *----------------------------------------------------------------------------*/
            
            switchToType: function( pointer, layerType ) {
              this.currentLayerType = layerType;
              
              this.pendingBoundary.nextLayerType = layerType;
              
              this.layerChangePending = true; // we wait until the first markPainted() call to create a boundary
            },
            
            // called so that we can finalize a layer switch (instead of collapsing unneeded layers)
            markPainted: function( pointer ) {
              if ( this.layerChangePending ) {
                this.layerChange( pointer );
              } else {
                // TODO: performance-wise, don't lookup indices on this copy? make a way to create a lightweight copy?
                this.pendingBoundary.previousPaintedTrail = pointer.trail.copy();
              }
            },
            
            // can be null to indicate that there is no current layer type
            getCurrentLayerType: function() {
              return this.currentLayerType;
            },
            
            pushPreferredLayerType: function( layerType ) {
              this.layerTypeStack.push( layerType );
            },
            
            popPreferredLayerType: function() {
              this.layerTypeStack.pop();
            },
            
            getPreferredLayerType: function() {
              if ( this.layerTypeStack.length !== 0 ) {
                return this.layerTypeStack[this.layerTypeStack.length - 1];
              } else {
                return null;
              }
            },
            
            bestPreferredLayerTypeFor: function( bitmask ) {
              for ( var i = this.layerTypeStack.length - 1; i >= 0; i-- ) {
                var preferredType = this.layerTypeStack[i];
                
                if ( preferredType.supportsBitmask( bitmask ) ) {
                  return preferredType;
                }
              }
              
              // none of our stored preferred layer types are able to support any of the default type options
              return null;
            }
          };
          
          return LayerBuilder;
        } );
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Displays mouse and touch areas when they are customized. Expensive to display!
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/overlays/PointerAreaOverlay',['require','KITE/Shape','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
          
        
          var Shape = require( 'KITE/Shape' );
        
          var scenery = require( 'SCENERY/scenery' );
          require( 'SCENERY/util/Trail' );
        
          scenery.PointerAreaOverlay = function PointerAreaOverlay( scene ) {
            this.scene = scene;
            
            var svg = this.svg = document.createElementNS( scenery.svgns, 'svg' );
            svg.style.position = 'absolute';
            svg.className = 'mouseTouchAreaOverlay';
            svg.style.top = 0;
            svg.style.left = 0;
            svg.style['pointer-events'] = 'none';
            
            function resize( width, height ) {
              svg.setAttribute( 'width', width );
              svg.setAttribute( 'height', height );
              svg.style.clip = 'rect(0px,' + width + 'px,' + height + 'px,0px)';
            }
            scene.addEventListener( 'resize', function( args ) {
              resize( args.width, args.height );
            } );
            resize( scene.getSceneWidth(), scene.getSceneHeight() );
            
            scene.$main[0].appendChild( svg );
            
            scene.reindexLayers();
          };
          var PointerAreaOverlay = scenery.PointerAreaOverlay;
        
          PointerAreaOverlay.prototype = {
            dispose: function() {
              this.scene.$main[0].removeChild( this.svg );
            },
        
            reindex: function( index ) {
              this.svg.style.zIndex = index;
            },
            
            addShape: function( shape, color, isOffset ) {
              var path = document.createElementNS( scenery.svgns, 'path' );
              var svgPath = shape.getSVGPath();
              
              // temporary workaround for https://bugs.webkit.org/show_bug.cgi?id=78980
              // and http://code.google.com/p/chromium/issues/detail?id=231626 where even removing
              // the attribute can cause this bug
              if ( !svgPath ) { svgPath = 'M0 0'; }
              
              if ( svgPath ) {
                // only set the SVG path if it's not the empty string
                path.setAttribute( 'd', svgPath );
              } else if ( path.hasAttribute( 'd' ) ) {
                path.removeAttribute( 'd' );
              }
              
              path.setAttribute( 'style', 'fill: none; stroke: ' + color + '; stroke-dasharray: 5, 3; stroke-dashoffset: ' + ( isOffset ? 5 : 0 ) + '; stroke-width: 3;' );
              this.svg.appendChild( path );
            },
            
            update: function() {
              var that = this;
              var svg = this.svg;
              var scene = this.scene;
              
              while ( svg.childNodes.length ) {
                svg.removeChild( svg.childNodes[svg.childNodes.length-1] );
              }
              
              new scenery.Trail( scene ).eachTrailUnder( function( trail ) {
                var node = trail.lastNode();
                if ( !node.isVisible() ) {
                  // skip this subtree if the node is invisible
                  return true;
                }
                if ( ( node._mouseArea || node._touchArea ) && trail.isVisible() ) {
                  var transform = trail.getTransform();
                  
                  if ( node._mouseArea ) {
                    that.addShape( transform.transformShape( node._mouseArea.isBounds ? Shape.bounds( node._mouseArea ) : node._mouseArea ), 'rgba(0,0,255,0.8)', true );
                  }
                  if ( node._touchArea ) {
                    that.addShape( transform.transformShape( node._touchArea.isBounds ? Shape.bounds( node._touchArea ) : node._touchArea ), 'rgba(255,0,0,0.8)', false );
                  }
                }
              } );
            }
          };
        
          return PointerAreaOverlay;
        } );
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * The PointerOverlay shows pointer locations in the scene.  This is useful when recording a session for interviews or when a teacher is broadcasting
         * a tablet session on an overhead projector.  See https://github.com/phetsims/scenery/issues/111
         *
         * Each pointer is rendered in a different <svg> so that CSS3 transforms can be used to make performance smooth on iPad.
         *
         * @author Sam Reid
         */
        
        define( 'SCENERY/overlays/PointerOverlay',['require','DOT/Matrix3','SCENERY/scenery','SCENERY/util/Trail','SCENERY/util/Util'],function( require ) {
          
        
          var Matrix3 = require( 'DOT/Matrix3' );
        
          var scenery = require( 'SCENERY/scenery' );
          require( 'SCENERY/util/Trail' );
        
          var Util = require( 'SCENERY/util/Util' );
        
          scenery.PointerOverlay = function PointerOverlay( scene ) {
            var pointerOverlay = this;
            this.scene = scene;
        
            // add element to show the pointers
            this.pointerSVGContainer = document.createElement( 'div' );
            this.pointerSVGContainer.style.position = 'absolute';
            this.pointerSVGContainer.style.top = 0;
            this.pointerSVGContainer.style.left = 0;
            this.pointerSVGContainer.style['pointer-events'] = 'none';
        
            var innerRadius = 10;
            var strokeWidth = 1;
            var diameter = (innerRadius + strokeWidth / 2) * 2;
            var radius = diameter / 2;
        
            //Resize the parent div when the scene is resized
            scene.addEventListener( 'resize', function( args ) {
              pointerOverlay.pointerSVGContainer.setAttribute( 'width', args.width );
              pointerOverlay.pointerSVGContainer.setAttribute( 'height', args.height );
              pointerOverlay.pointerSVGContainer.style.clip = 'rect(0px,' + args.width + 'px,' + args.height + 'px,0px)';
            }, false );
        
            //Display a pointer that was added.  Use a separate SVG layer for each pointer so it can be hardware accelerated, otherwise it is too slow just setting svg internal attributes
            var pointerAdded = this.pointerAdded = function( pointer ) {
        
              if ( pointer.isKey ) { return; }
        
              var svg = document.createElementNS( scenery.svgns, 'svg' );
              svg.style.position = 'absolute';
              svg.style.top = 0;
              svg.style.left = 0;
              svg.style['pointer-events'] = 'none';
        
              //Fit the size to the display
              svg.setAttribute( 'width', diameter );
              svg.setAttribute( 'height', diameter );
        
              var circle = document.createElementNS( scenery.svgns, 'circle' );
        
              //use css transform for performance?
              circle.setAttribute( 'cx', innerRadius + strokeWidth / 2 );
              circle.setAttribute( 'cy', innerRadius + strokeWidth / 2 );
              circle.setAttribute( 'r', innerRadius );
              circle.setAttribute( 'style', 'fill:black;' );
              circle.setAttribute( 'opacity', 0.4 );
        
              //Add a move listener to the pointer to update position when it has moved
              var pointerRemoved = function() {
        
                //For touches that get a touch up event, remove them.  But when the mouse button is released, don't stop showing the mouse location
                if ( pointer.isTouch ) {
                  pointerOverlay.pointerSVGContainer.removeChild( svg );
                  pointer.removeInputListener( moveListener );
                }
              };
              var moveListener = {
                move: function() {
        
                  //TODO: Why is point sometimes null?
                  if ( pointer.point ) {
        
                    //TODO: this allocates memory when pointers are dragging, perhaps rewrite to remove allocations
                    Util.applyCSSTransform( Matrix3.translation( pointer.point.x - radius, pointer.point.y - radius ), svg );
                  }
                },
        
                up: pointerRemoved,
                cancel: pointerRemoved
              };
              pointer.addInputListener( moveListener );
        
              moveListener.move();
              svg.appendChild( circle );
              pointerOverlay.pointerSVGContainer.appendChild( svg );
            };
            scene.input.addPointerAddedListener( pointerAdded );
        
            //if there is already a mouse, add it here
            //TODO: if there already other non-mouse touches, could be added here
            if ( scene.input && scene.input.mouse ) {
              pointerAdded( scene.input.mouse );
            }
        
            scene.reindexLayers();
            scene.$main[0].appendChild( this.pointerSVGContainer );
          };
          var PointerOverlay = scenery.PointerOverlay;
        
          PointerOverlay.prototype = {
            dispose: function() {
              this.scene.$main[0].removeChild( this.pointerSVGContainer );
              this.scene.input.removePointerAddedListener( this.pointerAdded );
            },
        
            reindex: function( index ) {
              this.pointerSVGContainer.style.zIndex = index; //Make sure it is in front of enough other things!
            }
          };
        
          return PointerOverlay;
        } );
        
        // Copyright 2002-2013, University of Colorado
        
        /**
         * Main scene, that is also a Node.
         *
         * TODO: documentation!
         *
         * @author Jonathan Olson <olsonsjc@gmail.com>
         */
        
        define( 'SCENERY/Scene',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Vector2','DOT/Matrix3','KITE/Shape','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/util/Instance','SCENERY/util/Trail','SCENERY/util/RenderInterval','SCENERY/util/TrailPointer','SCENERY/input/Input','SCENERY/layers/LayerBuilder','SCENERY/layers/Renderer','SCENERY/overlays/PointerAreaOverlay','SCENERY/overlays/PointerOverlay','SCENERY/util/Util'],function( require ) {
          
          
          var inherit = require( 'PHET_CORE/inherit' );
          
          var Bounds2 = require( 'DOT/Bounds2' );
          var Vector2 = require( 'DOT/Vector2' );
          var Matrix3 = require( 'DOT/Matrix3' );
          
          var Shape = require( 'KITE/Shape' );
          
          var scenery = require( 'SCENERY/scenery' );
          
          var Node = require( 'SCENERY/nodes/Node' ); // inherits from Node
          require( 'SCENERY/util/Instance' );
          require( 'SCENERY/util/Trail' );
          require( 'SCENERY/util/RenderInterval' );
          require( 'SCENERY/util/TrailPointer' );
          require( 'SCENERY/input/Input' );
          require( 'SCENERY/layers/LayerBuilder' );
          require( 'SCENERY/layers/Renderer' );
          require( 'SCENERY/overlays/PointerAreaOverlay' );
          require( 'SCENERY/overlays/PointerOverlay' );
        
          var Util = require( 'SCENERY/util/Util' );
        
          var accessibility = window.has && window.has( 'scenery.accessibility' );
          
          // debug flag to disable matching of layers when in 'match' mode
          var forceNewLayers = true; // DEBUG
          
          // constructs all sub-trees for the specified instance. used from markSceneForInsertion
          function buildInstances( instance ) {
            var node = instance.getNode();
            var len = node._children.length;
            for ( var i = 0; i < len; i++ ) {
              buildInstances( instance.createChild( node._children[i], i ) );
            }
          }
          
          /*
           * $main should be a block-level element with a defined width and height. scene.resize() should be called whenever
           * it is resized.
           *
           * Valid parameters in the parameter object:
           * {
           *   allowSceneOverflow: false,           // usually anything displayed outside of this $main (DOM/CSS3 transformed SVG) is hidden with CSS overflow
           *   allowCSSHacks: true,                 // applies styling that prevents mobile browser graphical issues
           *   allowDevicePixelRatioScaling: false, // allows underlying canvases (Canvas, WebGL) to increase in size to maintain sharpness on high-density displays
           *   enablePointerEvents: true,           // allows pointer events / MSPointerEvent to be used on supported platforms.
           *   preferredSceneLayerType: ...,        // sets the preferred type of layer to be created if there are multiple options
           *   width: <current main width>,         // override the main container's width
           *   height: <current main height>,       // override the main container's height
           * }
           */
          scenery.Scene = function Scene( $main, options ) {
            assert && assert( $main[0], 'A main container is required for a scene' );
            this.$main = $main;
            this.main = $main[0];
            
            // add a self reference to aid in debugging. this generally shouldn't lead to a memory leak
            this.main.scene = this;
            
            // add a reference to the API for debugging
            this.scenery = scenery;
            
            // defaults
            options = _.extend( {
              allowSceneOverflow: false,
              allowCSSHacks: true,
              allowDevicePixelRatioScaling: false,
              enablePointerEvents: true,
              preferredSceneLayerType: scenery.CanvasDefaultLayerType,
              width: $main.width(),
              height: $main.height()
            }, options || {} );
            
            // TODO: consider using a pushed preferred layer to indicate this information, instead of as a specific option
            this.backingScale = options.allowDevicePixelRatioScaling ? Util.backingScale( document.createElement( 'canvas' ).getContext( '2d' ) ) : 1;
            this.enablePointerEvents = options.enablePointerEvents;
            
            Node.call( this, options );
        
            var scene = this;
            window.debugScene = scene;
            
            // layering data
            this.layers = [];               // main layers in a scene
            this.layerChangeIntervals = []; // array of {RenderInterval}s indicating what parts need to be stitched together. cleared after each stitching
            
            this.lastCursor = null;
            this.defaultCursor = $main.css( 'cursor' );
            
            // resize the main container as a sanity check
            this.setSize( options.width, options.height );
            
            this.sceneBounds = new Bounds2( 0, 0, options.width, options.height );
            
            // set up the root instance for this scene
            // only do this after Node.call has been invoked, since Trail.addDescendant uses a few things
            this.rootInstance = new scenery.Instance( new scenery.Trail( this ), null, null );
            this.addInstance( this.rootInstance );
            
            // default to a canvas layer type, but this can be changed
            this.preferredSceneLayerType = options.preferredSceneLayerType;
            
            applyCSSHacks( $main, options );
        
            // TODO: Does this need to move to where inputEvents are hooked up so that it doesn't get run each time Node.toImage is called?
            if ( accessibility ) {
              this.activePeer = null;
              
              this.accessibilityLayer = document.createElement( 'div' );
              this.accessibilityLayer.className = "accessibility-layer";
              
              //Put the accessibility layer behind the background so it cannot be seen.  Change this to some high number like 9999 to show it for debugging purposes.
              this.accessibilityLayer.style.zIndex = -1;
              this.accessibilityLayer.style.position = 'relative';
              $main[0].appendChild( this.accessibilityLayer );
              
              this.focusRingSVGContainer = document.createElementNS( scenery.svgns, 'svg' );
              this.focusRingSVGContainer.style.position = 'absolute';
              this.focusRingSVGContainer.style.top = 0;
              this.focusRingSVGContainer.style.left = 0;
              this.focusRingSVGContainer.style['pointer-events'] = 'none';
              this.resizeFocusRingSVGContainer( options.width, options.height );
              this.focusRingPath = document.createElementNS( scenery.svgns, 'path' );
              this.focusRingPath.setAttribute( 'style', 'fill: none; stroke: blue; stroke-width: 5;' );
              this.focusRingPath.setAttribute( 'id', 'p1' );
              this.focusRingSVGContainer.appendChild( this.focusRingPath );
              $main[0].appendChild( this.focusRingSVGContainer );
              
              this.updateFocusRing = function() {
                // TODO: move into prototype definitions, this doesn't need to be private, and isn't a closure over anything in the constructor
                assert && assert( scene.activePeer, 'scene should have an active peer when changing the focus ring bounds' );
                scene.focusRingPath.setAttribute( 'd', Shape.bounds( scene.activePeer.getGlobalBounds() ).getSVGPath() );
              };
        
              //Put the live region layer behind the accessibility peer layer to make debugging easier (if we need to see the accessibility layer)
              this.liveRegionLayer = document.createElement( 'div' );
              this.liveRegionLayer.className = 'live-region-layer';
              this.liveRegionLayer.style.zIndex = -2;
              this.liveRegionLayer.style.position = 'relative';
              $main[0].appendChild( this.liveRegionLayer );
            }
          };
          var Scene = scenery.Scene;
          
          inherit( Node, Scene, {
            
            updateScene: function( args ) {
              // sceneryLayerLog && sceneryLayerLog( 'Scene: updateScene' );
              
              var scene = this;
              
              // check to see whether contents under pointers changed (and if so, send the enter/exit events) to maintain consistent state
              if ( this.input ) {
                sceneryEventLog && sceneryEventLog( 'validatePointers from updateScene' );
                this.input.validatePointers();
              }
              
              // validating bounds, similar to Piccolo2d
              this.validateBounds();
              this.validatePaint();
              
              // bail if there are no layers. consider a warning?
              if ( !this.layers.length ) {
                return;
              }
              
              var i = this.layers.length;
              while ( i-- ) {
                this.layers[i].render( scene, args );
              }
              
              this.updateCursor();
              
              if ( this.mouseTouchAreaOverlay ) {
                this.mouseTouchAreaOverlay.update();
              }
              
              // if ( this.accessibilityLayer ) {
          //      for ( var i = 0; i < accessibleNodes.length; i++ ) {
          //        if ( accessibleNodes[i]._element === activeElement ) {
          //          if ( accessibleNodes[i].origin ) {
          //            var b = accessibleNodes[i].origin.globalBounds;
          //            var rect = Shape.bounds( b );
          //
          //            //Animation is a bit buggy, but I left this code in in case we want to pick it up later.
          //            var animateTheRect = false;
          //            if ( animateTheRect ) {
          //              if ( !this.focusRingPath.lastSVGPath ) {
          //                this.focusRingPath.setAttribute( 'd', rect.getSVGPath() );
          //                this.focusRingPath.lastSVGPath = rect.getSVGPath();
          //              } else {
          //                var animate = document.createElementNS( scenery.svgns, 'animate' );
          //                animate.setAttribute( 'attributeType', 'XML' );
          //                animate.setAttribute( 'xlink:href', '#p1' );
          //                animate.setAttribute( 'attributeName', 'd' );
          //                animate.setAttribute( 'from', this.focusRingPath.lastSVGPath );
          //                animate.setAttribute( 'to', rect.getSVGPath() );
          //                animate.setAttribute( 'dur', '4s' );
          //
          //                $( this.focusRingPath ).empty();
          //                this.focusRingPath.appendChild( animate );
          //                this.focusRingPath.lastSVGPath = rect.getSVGPath();
          //              }
          //            } else {
          //              this.focusRingPath.setAttribute( 'd', rect.getSVGPath() );
          //            }
          //
          //            found = true;
          //          }
          //        }
          //        if ( !found ) {
          //          this.focusRingPath.removeAttribute( 'd' );
          //        }
          //      }
              // }
            },
            
            renderScene: function() {
              // TODO: for now, go with the same path. possibly add options later
              this.updateScene();
            },
            
            addPeer: function( peer ) {
              this.accessibilityLayer.appendChild( peer.peerElement );
            },
            
            removePeer: function( peer ) {
              this.accessibilityLayer.removeChild( peer.peerElement );
            },
        
            addLiveRegion: function( liveRegion ) {
              this.liveRegionLayer.appendChild( liveRegion.element );
            },
        
            removeLiveRegion: function( liveRegion ) {
              this.liveRegionLayer.removeChild( liveRegion.element );
            },
            
            setActivePeer: function( peer ) {
              if ( this.activePeer !== peer ) {
        
                //Remove bounds listener from old active peer
                if ( this.activePeer ) {
                  this.activePeer.instance.node.removeEventListener( 'bounds', this.updateFocusRing );
                }
                
                this.activePeer = peer;
                
                if ( peer ) {
                  this.activePeer.instance.node.addEventListener( 'bounds', this.updateFocusRing );
                  this.updateFocusRing();
                } else {
                  this.focusRingPath.setAttribute( 'd', "M 0 0" );
                }
              }
            },
            
            getActivePeer: function( peer ) {
              return this.activePeer;
            },
            
            focusPeer: function( peer ) {
              this.setActivePeer( peer );
            },
            
            blurPeer: function( peer ) {
              assert && assert( this.getActivePeer() === peer, 'Can only blur an active peer' );
              this.setActivePeer( null );
            },
            
            markInterval: function( affectedTrail ) {
              // TODO: maybe reindexing sooner is better? are we covering up a bug here?
              affectedTrail.reindex();
              
              // since this is marked while the child is still connected, we can use our normal trail handling.
              
              // find the closest before and after self trails that are not affected
              var beforeTrail = affectedTrail.previousPainted(); // easy for the before trail
              
              var afterTrailPointer = new scenery.TrailPointer( affectedTrail.copy(), false );
              while ( afterTrailPointer.hasTrail() && ( !afterTrailPointer.isBefore || !afterTrailPointer.trail.isPainted() ) ) {
                afterTrailPointer.nestedForwards();
              }
              var afterTrail = afterTrailPointer.trail;
              
              // sanity checks
              assert && assert( !beforeTrail || beforeTrail.areIndicesValid(), 'beforeTrail needs to be valid' );
              assert && assert( !afterTrail || afterTrail.areIndicesValid(), 'afterTrail needs to be valid' );
              assert && assert( !beforeTrail || !afterTrail || beforeTrail.compare( afterTrail ) !== 0, 'Marked interval needs to be exclusive' );
              
              // store the layer of the before/after trails so that it is easy to access later
              this.addLayerChangeInterval( new scenery.RenderInterval( beforeTrail, afterTrail ) );
            },
            
            // convenience function for layer change intervals
            addLayerChangeInterval: function( interval ) {
              if ( sceneryLayerLog ) {
                sceneryLayerLog( 'adding interval: ' + interval.toString() + ' to intervals:' );
                _.each( this.layerChangeIntervals, function( interval ) {
                  sceneryLayerLog( '  ' + interval.toString() );
                } );
              }
              
              // TODO: replace with a binary-search-like version that may be faster. this includes a full scan
              
              // attempt to merge this interval with another if possible.
              for ( var i = 0; i < this.layerChangeIntervals.length; i++ ) {
                var other = this.layerChangeIntervals[i];
                other.reindex(); // sanity check, although for most use-cases this should be unnecessary
                
                if ( interval.exclusiveUnionable( other ) ) {
                  // the interval can be unioned without including other nodes. do this, and remove the other interval from consideration
                  interval = interval.union( other );
                  this.layerChangeIntervals.splice( i--, 1 ); // decrement to stay at the same index
                  sceneryLayerLog && sceneryLayerLog( 'removing interval: ' + other.toString() );
                }
              }
              
              this.layerChangeIntervals.push( interval );
              
              if ( sceneryLayerLog ) {
                sceneryLayerLog( 'new intervals: ' );
                _.each( this.layerChangeIntervals, function( interval ) {
                  sceneryLayerLog( '  ' + interval.toString() );
                } );
                sceneryLayerLog( '---' );
              }
            },
            
            createLayer: function( layerType, layerArgs, startBoundary, endBoundary ) {
              var layer = layerType.createLayer( _.extend( {
                startBoundary: startBoundary,
                endBoundary: endBoundary
              }, layerArgs ) );
              layer.type = layerType;
              sceneryLayerLog && sceneryLayerLog( 'created layer: ' + layer.getId() + ' of type ' + layer.type.name );
              return layer;
            },
            
            // insert a layer into the proper place (from its starting boundary)
            insertLayer: function( layer ) {
              for ( var i = 0; i < this.layers.length; i++ ) {
                if ( layer.endPaintedTrail.isBefore( this.layers[i].startPaintedTrail ) ) {
                  this.layers.splice( i, 0, layer ); // insert the layer here
                  return;
                }
              }
              
              // it is after all other layers
              this.layers.push( layer );
            },
            
            getBoundaries: function() {
              // TODO: store these more efficiently!
              return [ this.layers[0].startBoundary ].concat( _.pluck( this.layers, 'endBoundary' ) );
            },
            
            calculateBoundaries: function( beforeLayerType, beforeTrail, afterTrail ) {
              sceneryLayerLog && sceneryLayerLog( 'build between ' + ( beforeTrail ? beforeTrail.toString() : beforeTrail ) + ',' + ( afterTrail ? afterTrail.toString() : afterTrail ) + ' with beforeType: ' + ( beforeLayerType ? beforeLayerType.name : null ) );
              var builder = new scenery.LayerBuilder( this, beforeLayerType, beforeTrail, afterTrail );
              
              // push the preferred layer type before we push that for any nodes
              if ( this.preferredSceneLayerType ) {
                builder.pushPreferredLayerType( this.preferredSceneLayerType );
              }
              
              builder.run();
              
              return builder.boundaries;
            },
            
            stitch: function( match ) {
              var scene = this;
              
              var i;
              
              sceneryLayerLog && sceneryLayerLog( '-----------------------------------\nbeginning stitch' );
              
              // bail out if there are no changes to stitch (stitch is called multiple times)
              if ( !this.layerChangeIntervals.length ) {
                return;
              }
              
              // data to be shared across all of the individually stitched intervals
              var stitchData = {
                // all instances that are affected, in no particular order (and may contain duplicates)
                affectedInstances: [],
                
                // fresh layers that should be added into the scene
                newLayers: []
              };
              
              // default arguments for constructing layers
              var layerArgs = {
                $main: this.$main,
                scene: this,
                baseNode: this
              };
              
              // reindex intervals, since their endpoints indices may need to be updated
              i = this.layerChangeIntervals.length;
              while ( i-- ) {
                this.layerChangeIntervals[i].reindex();
              }
              
              /*
               * Sort our intervals, so that when we need to 'unglue' a layer into two separate layers, we will have passed
               * all of the parts where we would need to use the 'before' layer, so we can update our layer map with the 'after'
               * layer.
               */
              this.layerChangeIntervals.sort( scenery.RenderInterval.compareDisjoint );
              
              sceneryLayerLog && sceneryLayerLog( 'stitching on intervals: \n' + this.layerChangeIntervals.join( '\n' ) );
              
              for ( i = 0; i < this.layerChangeIntervals.length; i++ ) {
                var interval = this.layerChangeIntervals[i];
                
                sceneryLayerLog && sceneryLayerLog( 'stitch on interval ' + interval.toString() );
                var beforeTrail = interval.start;
                var afterTrail = interval.end;
                
                var beforeInstance = beforeTrail ? beforeTrail.getInstance() : null;
                var afterInstance = afterTrail ? afterTrail.getInstance() : null;
                
                var beforeLayer = beforeInstance ? beforeInstance.layer : null;
                var afterLayer = afterInstance ? afterInstance.layer : null;
                
                // TODO: calculate boundaries based on the instances?
                var boundaries = this.calculateBoundaries( beforeLayer ? beforeLayer.type : null, beforeTrail, afterTrail );
                
                this.stitchInterval( stitchData, layerArgs, beforeTrail, afterTrail, beforeLayer, afterLayer, boundaries, match );
              }
              
              // clean up state that was set leading up to the stitching, and do it early so
              // if we do things later that cause side-effects we won't clear intervals that haven't been stitched
              this.layerChangeIntervals.length = 0;
              
              sceneryLayerLog && sceneryLayerLog( '------ finished intervals in stitching' );
              
              // reindex all of the relevant layer trails, and dispose/add as necessary
              i = this.layers.length;
              while ( i-- ) {
                var layer = this.layers[i];
                layer.startBoundary.reindex();
                layer.endBoundary.reindex(); // TODO: performance: this repeats some work, verify in layer audit that we are sharing boundaries properly, then only reindex end boundary on last layer
                
                // remove necessary layers. do this before adding layers, since insertLayer currently does not gracefully handle weird overlapping cases
                // layers with zero trails should be removed
                if ( layer._instanceCount === 0 ) {
                  sceneryLayerLog && sceneryLayerLog( 'disposing layer: ' + layer.getId() );
                  this.disposeLayer( layer );
                }
              }
              i = stitchData.newLayers.length;
              while ( i-- ) {
                var newLayer = stitchData.newLayers[i];
                newLayer.startBoundary.reindex();
                newLayer.endBoundary.reindex(); // TODO: performance: this repeats some work, verify in layer audit that we are sharing boundaries properly, then only reindex end boundary on last layer
                
                // add new layers. we do this before the add/remove trails, since those can trigger layer side effects
                assert && assert( newLayer._instanceCount, 'ensure we are not adding empty layers' );
                
                sceneryLayerLog && sceneryLayerLog( 'inserting layer: ' + newLayer.getId() );
                scene.insertLayer( newLayer );
              }
              
              // set the layers' elements' z-indices, and reindex their trails so they are in a consistent state
              // TODO: performance: don't reindex layers if no layers were added or removed?
              this.reindexLayers();
              
              sceneryLayerLog && sceneryLayerLog( '------ updating layer references' );
              
              // add/remove trails from their necessary layers
              var affectedLen = stitchData.affectedInstances.length;
              for ( i = 0; i < affectedLen; i++ ) {
                stitchData.affectedInstances[i].updateLayer();
              }
              
              assertSlow && assertSlow( this.layerAudit() );
              
              sceneryLayerLog && sceneryLayerLog( 'finished stitch\n-----------------------------------' );
            },
            
            /*
             * Stitching intervals has essentially two specific modes:
             * non-matching: handles added or removed nodes (and this can span multiple, even adjacent trails)
             * matching: handles in-place layer refreshes (no nodes removed or added, but something like a renderer was changed)
             *
             * This separation occurs since for matching, we want to match old layers with possible new layers, so we can keep trails in their
             * current layer instead of creating an identical layer and moving the trails to that layer.
             *
             * The stitching basically re-does the layering between a start and end trail, attempting to minimize the amount of changes made.
             * It can include 'gluing' layers together (a node that caused layer splits was removed, and before/after layers are joined),
             * 'ungluing' layers (an inserted node causes a layer split in an existing layer, and it is separated into a before/after),
             * or normal updating of the interior.
             *
             * The beforeTrail and afterTrail should be outside the modifications, and if the modifications are to the start/end of the graph,
             * they should be passed as null to indicate 'before everything' and 'after everything' respectively.
             *
             * Here be dragons!
             */
            stitchInterval: function( stitchData, layerArgs, beforeTrail, afterTrail, beforeLayer, afterLayer, boundaries, match ) {
              var scene = this;
              
              // make sure our beforeTrail and afterTrail are immutable
              beforeTrail && beforeTrail.setImmutable();
              afterTrail && afterTrail.setImmutable();
              
              // need a reference to this, since it may change
              var afterLayerEndBoundary = afterLayer ? afterLayer.endBoundary : null;
              
              var beforePointer = beforeTrail ? new scenery.TrailPointer( beforeTrail, true ) : new scenery.TrailPointer( new scenery.Trail( this ), true );
              var afterPointer = afterTrail ? new scenery.TrailPointer( afterTrail, true ) : new scenery.TrailPointer( new scenery.Trail( this ), false );
              
              sceneryLayerLog && sceneryLayerLog( '\nstitching with boundaries:\n' + _.map( boundaries, function( boundary ) { return boundary.toString(); } ).join( '\n' ) );
              sceneryLayerLog && sceneryLayerLog( '               layers: ' + ( beforeLayer ? beforeLayer.getId() : '-' ) + ' to ' + ( afterLayer ? afterLayer.getId() : '-' ) );
              sceneryLayerLog && sceneryLayerLog( '               trails: ' + ( beforeTrail ? beforeTrail.toString() : '-' ) + ' to ' + ( afterTrail ? afterTrail.toString() : '-' ) );
              sceneryLayerLog && sceneryLayerLog( '               match: ' + match );
              
              /*---------------------------------------------------------------------------*
              * State
              *----------------------------------------------------------------------------*/
              
              var nextBoundaryIndex = 0;
              var nextBoundary = boundaries[nextBoundaryIndex];
              var instancesToAddToLayer = [];
              var currentTrail = beforeTrail;
              var currentLayer = beforeLayer;
              var currentLayerType = beforeLayer ? beforeLayer.type : null;
              var currentStartBoundary = null;
              var matchingLayer = null; // set whenever a trail has a matching layer, cleared after boundary
              
              function addPendingTrailsToLayer() {
                // add the necessary nodes to the layer
                var len = instancesToAddToLayer.length;
                for ( var i = 0; i < len; i++ ) {
                  var instance = instancesToAddToLayer[i];
                  instance.changeLayer( currentLayer );
                  stitchData.affectedInstances.push( instance );
                }
                instancesToAddToLayer.length = 0;
              }
              
              function addAndCreateLayer( startBoundary, endBoundary ) {
                currentLayer = scene.createLayer( currentLayerType, layerArgs, startBoundary, endBoundary );
                stitchData.newLayers.push( currentLayer );
              }
              
              function step( trail, isEnd ) {
                sceneryLayerLog && sceneryLayerLog( 'step: ' + ( trail ? trail.toString() : trail ) );
                trail && trail.setImmutable(); // we don't want our trail to be modified, so we can store direct references to it
                // check for a boundary at this step between currentTrail and trail
                
                // if there is no next boundary, don't bother checking anyways
                if ( nextBoundary && nextBoundary.equivalentPreviousTrail( currentTrail ) ) { // at least one null check
                  assert && assert( nextBoundary.equivalentNextTrail( trail ) );
                  
                  sceneryLayerLog && sceneryLayerLog( nextBoundary.toString() );
                  
                  // we are at a boundary change. verify that we are at the end of a layer
                  if ( currentLayer || currentStartBoundary ) {
                    if ( currentLayer ) {
                      sceneryLayerLog && sceneryLayerLog( 'has currentLayer: ' + currentLayer.getId() );
                      // existing layer, reposition its endpoint
                      currentLayer.setEndBoundary( nextBoundary );
                    } else {
                      assert && assert( currentStartBoundary );
                      
                      if ( matchingLayer ) {
                        sceneryLayerLog && sceneryLayerLog( 'matching layer used: ' + matchingLayer.getId() );
                        matchingLayer.setStartBoundary( currentStartBoundary );
                        matchingLayer.setEndBoundary( nextBoundary );
                        currentLayer = matchingLayer;
                      } else {
                        sceneryLayerLog && sceneryLayerLog( 'creating layer' );
                        addAndCreateLayer( currentStartBoundary, nextBoundary ); // sets currentLayer
                      }
                    }
                    // sanity checks
                    assert && assert( currentLayer.startPaintedTrail );
                    assert && assert( currentLayer.endPaintedTrail );
                    
                    addPendingTrailsToLayer();
                  } else {
                    // if not at the end of a layer, sanity check that we should have no accumulated pending trails
                    sceneryLayerLog && sceneryLayerLog( 'was first layer' );
                    assert && assert( instancesToAddToLayer.length === 0 );
                  }
                  currentLayer = null;
                  currentLayerType = nextBoundary.nextLayerType;
                  currentStartBoundary = nextBoundary;
                  matchingLayer = null;
                  nextBoundaryIndex++;
                  nextBoundary = boundaries[nextBoundaryIndex];
                }
                if ( trail && !isEnd ) {
                  // TODO: performance: handle instances natively, don't just convert here
                  instancesToAddToLayer.push( trail.getInstance() );
                }
                if ( match && !isEnd ) { // TODO: verify this condition with test cases
                  // if the node's old layer is compatible
                  // TODO: performance: don't use getInstance() here, use instances natively
                  var layer = trail.getInstance().layer; // lookup should return the old layer from the system
                  if ( layer.type === currentLayerType && !forceNewLayers ) {
                    // TODO: we need to handle compatibility with layer splits. using forceNewLayers flag to temporarily disable
                    matchingLayer = layer;
                  }
                }
                currentTrail = trail;
              }
              
              function startStep( trail ) {
                sceneryLayerLog && sceneryLayerLog( 'startStep: ' + ( trail ? trail.toString() : trail ) );
              }
              
              function middleStep( trail ) {
                sceneryLayerLog && sceneryLayerLog( 'middleStep: ' + trail.toString() );
                step( trail, false );
              }
              
              function endStep( trail ) {
                sceneryLayerLog && sceneryLayerLog( 'endStep: ' + ( trail ? trail.toString() : trail ) );
                step( trail, true );
                
                if ( beforeLayer !== afterLayer && boundaries.length === 0 ) {
                  // glue the layers together
                  sceneryLayerLog && sceneryLayerLog( 'gluing layer' );
                  sceneryLayerLog && sceneryLayerLog( 'endBoundary: ' + afterLayer.endBoundary.toString() );
                  beforeLayer.setEndBoundary( afterLayer.endBoundary );
                  currentLayer = beforeLayer;
                  addPendingTrailsToLayer();
                  
                  // move over all of afterLayer's trails to beforeLayer
                  var len = afterLayer._layerTrails.length;
                  for ( var i = 0; i < len; i++ ) {
                    var endTrail = afterLayer._layerTrails[i];
                    
                    endTrail.reindex();
                    var instance = endTrail.getInstance();
                    instance.changeLayer( beforeLayer ); // TODO: performance: handle instances natively
                    stitchData.affectedInstances.push( instance );
                  }
                  
                } else if ( beforeLayer && beforeLayer === afterLayer && boundaries.length > 0 ) {
                  // need to 'unglue' and split the layer
                  sceneryLayerLog && sceneryLayerLog( 'ungluing layer' );
                  assert && assert( currentStartBoundary );
                  addAndCreateLayer( currentStartBoundary, afterLayerEndBoundary ); // sets currentLayer
                  addPendingTrailsToLayer();
                  
                  currentLayer.endPaintedTrail.reindex(); // currentLayer's trails may be stale at this point
                  scenery.Trail.eachPaintedTrailBetween( afterTrail, currentLayer.endPaintedTrail, function( subtrail ) {
                    var instance = subtrail.getInstance();
                    instance.changeLayer( currentLayer );
                    stitchData.affectedInstances.push( instance );
                  }, false, scene );
                } else if ( !beforeLayer && !afterLayer && boundaries.length === 1 && !boundaries[0].hasNext() && !boundaries[0].hasPrevious() ) {
                  // TODO: why are we generating a boundary here?!?
                } else {
                  currentLayer = afterLayer;
                  // TODO: check concepts on this guard, since it seems sketchy
                  if ( currentLayer && currentStartBoundary ) {
                    currentLayer.setStartBoundary( currentStartBoundary );
                  }
                  
                  addPendingTrailsToLayer();
                }
              }
              
              // iterate from beforeTrail up to BEFORE the afterTrail. does not include afterTrail
              startStep( beforeTrail );
              beforePointer.eachTrailBetween( afterPointer, function( trail ) {
                // ignore non-self trails
                if ( !trail.isPainted() || ( beforeTrail && trail.equals( beforeTrail ) ) ) {
                  return;
                }
                
                middleStep( trail.copy() );
              } );
              endStep( afterTrail );
            },
            
            rebuildLayers: function() {
              sceneryLayerLog && sceneryLayerLog( 'Scene: rebuildLayers' );
              
              // mark the entire scene 
              this.markInterval( new scenery.Trail( this ) );
              
              // then stitch with match=true
              this.stitch( true );
            },
            
            // after layer changes, the layers should have their zIndex updated, and updates their trails
            reindexLayers: function() {
              sceneryLayerLog && sceneryLayerLog( 'Scene: reindexLayers' );
              
              var index = 1; // don't start below 1
              if ( accessibility && this.accessibiltyLayer ) {
                this.accessibilityLayer.style.zIndex = 9999; // TODO: a better way than 9999, SR says probably unnecessary
                index++;
              }
              
              var len = this.layers.length;
              for ( var i = 0; i < len; i++ ) {
                index = this.layers[i].reindex( index );
              }
              
              if ( accessibility ) {
                if ( this.focusRingSVGContainer ) {
                  this.focusRingSVGContainer.style.zIndex = index++;
                }
              }
              
              if ( this.mouseTouchAreaOverlay ){
                this.mouseTouchAreaOverlay.reindex( index++ );
              }
              
              if ( this.pointerOverlay ){
                this.pointerOverlay.reindex( index++ );
              }
            },
            
            dispose: function() {
              this.disposeLayers();
              if ( this.input ) {
                this.input.disposeListeners();
              }
              
              // remove self reference from the container
              delete this.main.scene;
              
              // TODO: clear event handlers if added
              //throw new Error( 'unimplemented dispose: clear event handlers if added' );
            },
            
            disposeLayer: function( layer ) {
              // NOTE: stitching relies on this not changing this.layers except for removing the specific layer
              layer.dispose();
              this.layers.splice( _.indexOf( this.layers, layer ), 1 ); // TODO: better removal code!
            },
            
            disposeLayers: function() {
              var i = this.layers.length;
              while ( i-- ) {
                this.disposeLayer( this.layers[i] );
              }
            },
            
            // all layers whose start or end points lie inclusively in the range from the trail's before and after
            affectedLayers: function( trail ) {
              // midpoint search and result depends on the order of layers being in render order (bottom to top)
              
              assert && assert( !( trail.isEmpty() || trail.nodes[0] !== this ), 'layerLookup root matches' );
              
              var n = this.layers.length;
              if ( n === 0 ) {
                assert && assert( !trail.lastNode().isPainted(), 'There should be at least one layer for a painted trail' );
                return [];
              }
              
              assert && assert( trail.areIndicesValid() );
              
              var layers = this.layers;
              
              // from layers 0 to n-1, notAfter goes from false to true, notBefore goes from true to false
              var low = -1;
              var high = n;
              var mid;
              
              // midpoint search to see where our trail's start isn't after a layer's end
              while ( high - 1 > low ) {
                mid = ( high + low ) >> 1;
                var endTrail = layers[mid].endPaintedTrail;
                assert && assert( endTrail.areIndicesValid() );
                // NOTE TO SELF: don't change this flag to true again. think it through
                // trail,true points to the beginning of the node, right before it would be rendered
                var notAfter = scenery.TrailPointer.compareNested( trail, true, endTrail, true ) !== 1;
                if ( notAfter ) {
                  high = mid;
                } else {
                  low = mid;
                }
              }
              
              // store result and reset bound
              var firstIndex = high;
              low = -1;
              high = n;
              
              // midpoint search to see where our trail's end isn't before a layer's start
              while ( high - 1 > low ) {
                mid = ( high + low ) >> 1;
                var startTrail = layers[mid].startPaintedTrail;
                startTrail.reindex();
                assert && assert( startTrail.areIndicesValid() );
                var notBefore = scenery.TrailPointer.compareNested( trail, false, startTrail, true ) !== -1;
                if ( notBefore ) {
                  low = mid;
                } else {
                  high = mid;
                }
              }
              
              var lastIndex = low;
              
              return layers.slice( firstIndex, lastIndex + 1 );
            },
            
            // attempt to render everything currently visible in the scene to an external canvas. allows copying from canvas layers straight to the other canvas
            renderToCanvas: function( canvas, context, callback ) {
              var count = 0;
              var started = false; // flag guards against asynchronous tests that call back synchronously (immediate increment and decrement)
              var delayCounts = {
                increment: function() {
                  count++;
                },
                
                decrement: function() {
                  count--;
                  if ( count === 0 && callback && started ) {
                    callback();
                  }
                }
              };
              
              context.clearRect( 0, 0, canvas.width, canvas.height );
              var len = this.layers.length;
              for ( var i = 0; i < len; i++ ) {
                this.layers[i].renderToCanvas( canvas, context, delayCounts );
              }
              
              if ( count === 0 ) {
                // no asynchronous layers, callback immediately
                if ( callback ) {
                  callback();
                }
              } else {
                started = true;
              }
            },
            
            // TODO: consider SVG data URLs
            canvasDataURL: function( callback ) {
              this.canvasSnapshot( function( canvas ) {
                callback( canvas.toDataURL() );
              } );
            },
            
            // renders what it can into a Canvas (so far, Canvas and SVG layers work fine)
            canvasSnapshot: function( callback ) {
              var canvas = document.createElement( 'canvas' );
              canvas.width = this.sceneBounds.getWidth();
              canvas.height = this.sceneBounds.getHeight();
              
              var context = canvas.getContext( '2d' );
              this.renderToCanvas( canvas, context, function() {
                callback( canvas, context.getImageData( 0, 0, canvas.width, canvas.height ) );
              } );
            },
            
            // TODO: Note that this is private, better name?
            setSize: function( width, height ) {
              // resize our main container
              this.$main.width( width );
              this.$main.height( height );
              
              // set the container's clipping so anything outside won't show up
              // TODO: verify this clipping doesn't reduce performance!
              this.$main.css( 'clip', 'rect(0px,' + width + 'px,' + height + 'px,0px)' );
              
              this.sceneBounds = new Bounds2( 0, 0, width, height );
            },
            
            resize: function( width, height ) {
              if ( this.sceneBounds.width !== width || this.sceneBounds.height !== height ) {
                this.setSize( width, height );
                this.rebuildLayers(); // TODO: why? - change this to resize individual layers
        
                if ( accessibility ) {
                  this.resizeAccessibilityLayer( width, height );
                  this.resizeFocusRingSVGContainer( width, height );
                  
                  //Update the focus ring when the scene resizes.  Note: as of 5/10/2013 this only works properly when scaling up, and is buggy (off by a translation) when scaling down
                  if ( this.updateFocusRing && this.activePeer) {
                    // this.updateScene();
                    this.updateFocusRing();
                  }
                }
                
                if ( this.input ) {
                  sceneryEventLog && sceneryEventLog( 'validatePointers from scene resize' );
                  this.input.validatePointers();
                }
                
                this.fireEvent( 'resize', { width: width, height: height } );
              }
            },
        
            // TODO: Refactor the following methods into one to avoid code duplication.
            resizeAccessibilityLayer: function( width, height ) {
              if ( this.accessibilityLayer ) {
                this.accessibilityLayer.setAttribute( 'width', width );
                this.accessibilityLayer.setAttribute( 'height', height );
                this.accessibilityLayer.style.clip = 'rect(0px,' + width + 'px,' + height + 'px,0px)';
              }
            },
            
            resizeFocusRingSVGContainer: function( width, height ) {
              if ( this.focusRingSVGContainer ) {
                this.focusRingSVGContainer.setAttribute( 'width', width );
                this.focusRingSVGContainer.setAttribute( 'height', height );
                this.focusRingSVGContainer.style.clip = 'rect(0px,' + width + 'px,' + height + 'px,0px)';
              }
            },
        
            getSceneWidth: function() {
              return this.sceneBounds.getWidth();
            },
            
            getSceneHeight: function() {
              return this.sceneBounds.getHeight();
            },
            
            markSceneForLayerRefresh: function( instance ) {
              sceneryLayerLog && sceneryLayerLog( 'Scene: marking layer refresh: ' + instance.trail.toString() );
              this.markInterval( instance.trail );
            },
            
            markSceneForInsertion: function( instance, child, index ) {
              var affectedTrail = instance.trail.copy().addDescendant( child );
              sceneryLayerLog && sceneryLayerLog( 'Scene: marking insertion: ' + affectedTrail.toString() );
              
              sceneryLayerLog && sceneryLayerLog( 'inserting instances onto ' + instance.toString() + ' with child ' + child.id + ' and index ' + index );
              var baseInstance = instance.createChild( child, index );
              
              buildInstances( baseInstance );
              
              this.markInterval( affectedTrail );
            },
            
            markSceneForRemoval: function( instance, child, index ) {
              // mark the interval
              var affectedTrail = instance.trail.copy().addDescendant( child );
              sceneryLayerLog && sceneryLayerLog( 'Scene: marking removal: ' + affectedTrail.toString() );
              this.markInterval( affectedTrail );
              
              // remove the necessary instances
              var toRemove = [ instance.children[index] ];
              instance.removeInstance( index );
              while ( toRemove.length ) {
                var item = toRemove.pop();
                assert && assert( item, 'item instance should always exist' );
                
                // add its children
                Array.prototype.push.apply( toRemove, item.children );
                
                item.dispose(); // removes it from the node and sets it up for easy GC
              }
            },
            
            updateCursor: function() {
              if ( this.input && this.input.mouse && this.input.mouse.point ) {
                if ( this.input.mouse.cursor ) {
                  return this.setSceneCursor( this.input.mouse.cursor );
                }
                
                var mouseTrail = this.trailUnderPoint( this.input.mouse.point, { isMouse: true } );
                
                if ( mouseTrail ) {
                  for ( var i = mouseTrail.length - 1; i >= 0; i-- ) {
                    var cursor = mouseTrail.nodes[i].getCursor();
                    
                    if ( cursor ) {
                      return this.setSceneCursor( cursor );
                    }
                  }
                }
              }
              
              // fallback case
              this.setSceneCursor( this.defaultCursor );
            },
            
            setSceneCursor: function( cursor ) {
              if ( cursor !== this.lastCursor ) {
                this.lastCursor = cursor;
                var customCursors = Scene.customCursors[cursor];
                if ( customCursors ) {
                  // go backwards, so the most desired cursor sticks
                  for ( var i = customCursors.length - 1; i >= 0; i-- ) {
                    this.main.style.cursor = customCursors[i];
                  }
                } else {
                  this.main.style.cursor = cursor;
                }
              }
            },
            
            updateOnRequestAnimationFrame: function( element ) {
              var scene = this;
              (function step() {
                window.requestAnimationFrame( step, element );
                scene.updateScene();
              })();
            },
            
            initializeStandaloneEvents: function( parameters ) {
              // TODO extract similarity between standalone and fullscreen!
              var element = this.$main[0];
              this.initializeEvents( _.extend( {}, {
                listenerTarget: element,
                pointFromEvent: function pointFromEvent( evt ) {
                  var mainBounds = element.getBoundingClientRect();
                  return Vector2.createFromPool( evt.clientX - mainBounds.left, evt.clientY - mainBounds.top );
                }
              }, parameters ) );
            },
            
            initializeFullscreenEvents: function( parameters ) {
              var element = this.$main[0];
              this.initializeEvents( _.extend( {}, {
                listenerTarget: document,
                pointFromEvent: function pointFromEvent( evt ) {
                  var mainBounds = element.getBoundingClientRect();
                  return Vector2.createFromPool( evt.clientX - mainBounds.left, evt.clientY - mainBounds.top );
                }
              }, parameters ) );
            },
            
            initializeWindowEvents: function( parameters ) {
              this.initializeEvents( _.extend( {}, {
                listenerTarget: window,
                pointFromEvent: function pointFromEvent( evt ) {
                  return Vector2.createFromPool( evt.clientX, evt.clientY );
                }
              }, parameters ) );
            },
            
            initializeEvents: function( parameters ) {
              var scene = this;
              
              if ( scene.input ) {
                throw new Error( 'Attempt to attach events twice to the scene' );
              }
              
              // TODO: come up with more parameter names that have the same string length, so it looks creepier
              var pointFromEvent = parameters.pointFromEvent;
              var listenerTarget = parameters.listenerTarget;
              var batchDOMEvents = parameters.batchDOMEvents;
              
              var input = new scenery.Input( scene, listenerTarget, !!batchDOMEvents );
              scene.input = input;
              
              // maps the current MS pointer types onto the pointer spec
              function msPointerType( evt ) {
                if ( evt.pointerType === window.MSPointerEvent.MSPOINTER_TYPE_TOUCH ) {
                  return 'touch';
                } else if ( evt.pointerType === window.MSPointerEvent.MSPOINTER_TYPE_PEN ) {
                  return 'pen';
                } else if ( evt.pointerType === window.MSPointerEvent.MSPOINTER_TYPE_MOUSE ) {
                  return 'mouse';
                } else {
                  return evt.pointerType; // hope for the best
                }
              }
              
              function forEachChangedTouch( evt, callback ) {
                for ( var i = 0; i < evt.changedTouches.length; i++ ) {
                  // according to spec (http://www.w3.org/TR/touch-events/), this is not an Array, but a TouchList
                  var touch = evt.changedTouches.item( i );
                  
                  callback( touch.identifier, pointFromEvent( touch ) );
                }
              }
              
              // TODO: massive boilerplate reduction! closures should help tons!
              
              var implementsPointerEvents = window.navigator && window.navigator.pointerEnabled; // W3C spec for pointer events
              var implementsMSPointerEvents = window.navigator && window.navigator.msPointerEnabled; // MS spec for pointer event
              if ( this.enablePointerEvents && implementsPointerEvents ) {
                sceneryEventLog && sceneryEventLog( 'Detected pointer events support, using that instead of mouse/touch events' );
                // accepts pointer events corresponding to the spec at http://www.w3.org/TR/pointerevents/
                input.addListener( 'pointerdown', function pointerDownCallback( domEvent ) {
                  input.pointerDown( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );
                } );
                input.addListener( 'pointerup', function pointerUpCallback( domEvent ) {
                  input.pointerUp( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );
                } );
                input.addListener( 'pointermove', function pointerMoveCallback( domEvent ) {
                  input.pointerMove( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );
                } );
                input.addListener( 'pointerover', function pointerOverCallback( domEvent ) {
                  input.pointerOver( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );
                } );
                input.addListener( 'pointerout', function pointerOutCallback( domEvent ) {
                  input.pointerOut( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );
                } );
                input.addListener( 'pointercancel', function pointerCancelCallback( domEvent ) {
                  input.pointerCancel( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );
                } );
                // immediate version
                input.addImmediateListener( 'pointerup', function pointerUpCallback( domEvent ) {
                  input.pointerUpImmediate( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );
                } );
              } else if ( this.enablePointerEvents && implementsMSPointerEvents ) {
                sceneryEventLog && sceneryEventLog( 'Detected MS pointer events support, using that instead of mouse/touch events' );
                input.addListener( 'MSPointerDown', function msPointerDownCallback( domEvent ) {
                  input.pointerDown( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );
                } );
                input.addListener( 'MSPointerUp', function msPointerUpCallback( domEvent ) {
                  input.pointerUp( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );
                } );
                input.addListener( 'MSPointerMove', function msPointerMoveCallback( domEvent ) {
                  input.pointerMove( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );
                } );
                input.addListener( 'MSPointerOver', function msPointerOverCallback( domEvent ) {
                  input.pointerOver( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );
                } );
                input.addListener( 'MSPointerOut', function msPointerOutCallback( domEvent ) {
                  input.pointerOut( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );
                } );
                input.addListener( 'MSPointerCancel', function msPointerCancelCallback( domEvent ) {
                  input.pointerCancel( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );
                } );
                // immediate version
                input.addImmediateListener( 'MSPointerUp', function msPointerUpCallback( domEvent ) {
                  input.pointerUpImmediate( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );
                } );
              } else {
                sceneryEventLog && sceneryEventLog( 'No pointer events support detected, using mouse/touch events' );
                input.addListener( 'mousedown', function mouseDownCallback( domEvent ) {
                  input.mouseDown( pointFromEvent( domEvent ), domEvent );
                } );
                input.addListener( 'mouseup', function mouseUpCallback( domEvent ) {
                  input.mouseUp( pointFromEvent( domEvent ), domEvent );
                } );
                input.addListener( 'mousemove', function mouseMoveCallback( domEvent ) {
                  input.mouseMove( pointFromEvent( domEvent ), domEvent );
                } );
                input.addListener( 'mouseover', function mouseOverCallback( domEvent ) {
                  input.mouseOver( pointFromEvent( domEvent ), domEvent );
                } );
                input.addListener( 'mouseout', function mouseOutCallback( domEvent ) {
                  input.mouseOut( pointFromEvent( domEvent ), domEvent );
                } );
                // immediate version
                input.addImmediateListener( 'mouseup', function mouseUpCallback( domEvent ) {
                  input.mouseUpImmediate( pointFromEvent( domEvent ), domEvent );
                } );
                
                input.addListener( 'touchstart', function touchStartCallback( domEvent ) {
                  sceneryEventLog && sceneryEventLog( 'touchstart (multiple events)' );
                  forEachChangedTouch( domEvent, function touchStartTouch( id, point ) {
                    input.touchStart( id, point, domEvent );
                  } );
                } );
                input.addListener( 'touchend', function touchEndCallback( domEvent ) {
                  sceneryEventLog && sceneryEventLog( 'touchend (multiple events)' );
                  forEachChangedTouch( domEvent, function touchEndTouch( id, point ) {
                    input.touchEnd( id, point, domEvent );
                  } );
                } );
                input.addListener( 'touchmove', function touchMoveCallback( domEvent ) {
                  sceneryEventLog && sceneryEventLog( 'touchmove (multiple events)' );
                  forEachChangedTouch( domEvent, function touchMoveTouch( id, point ) {
                    input.touchMove( id, point, domEvent );
                  } );
                } );
                input.addListener( 'touchcancel', function touchCancelCallback( domEvent ) {
                  sceneryEventLog && sceneryEventLog( 'touchcancel (multiple events)' );
                  forEachChangedTouch( domEvent, function touchCancelTouch( id, point ) {
                    input.touchCancel( id, point, domEvent );
                  } );
                } );
                // immediate version
                input.addImmediateListener( 'touchend', function touchEndCallback( domEvent ) {
                  sceneryEventLog && sceneryEventLog( 'touchend immediate (multiple events)' );
                  forEachChangedTouch( domEvent, function touchEndTouch( id, point ) {
                    input.touchEndImmediate( id, point, domEvent );
                  } );
                } );
              }
              
              input.addListener( 'keyup', function keyUpCallback( domEvent ) {
                input.keyUp( domEvent );
              } );
              input.addListener( 'keydown', function keyDownCallback( domEvent ) {
                input.keyDown( domEvent );
              } );
              input.addListener( 'keypress', function keyPressCallback( domEvent ) {
                input.keyPress( domEvent );
              } );
            },
            
            setPointerDisplayVisible: function( visible ) {
              if ( visible && !this.pointerOverlay ) {
                this.pointerOverlay = new scenery.PointerOverlay( this );
              } else if ( !visible && this.pointerOverlay ) {
                this.pointerOverlay.dispose();
                delete this.pointerOverlay;
              }
            },
            
            setPointerAreaDisplayVisible: function( visible ) {
              if ( visible && !this.mouseTouchAreaOverlay ) {
                this.mouseTouchAreaOverlay = new scenery.PointerAreaOverlay( this );
              } else if ( !visible && this.mouseTouchAreaOverlay ) {
                this.mouseTouchAreaOverlay.dispose();
                delete this.mouseTouchAreaOverlay;
              }
            },
            
            getTrailFromKeyboardFocus: function() {
              // return the root (scene) trail by default
              // TODO: fill in with actual keyboard focus
              return new scenery.Trail( this );
            },
            
            fireBatchedEvents: function() {
              this.input.fireBatchedEvents();
            },
            
            resizeOnWindowResize: function() {
              var scene = this;
              
              var resizer = function() {
                scene.resize( window.innerWidth, window.innerHeight );
              };
              $( window ).resize( resizer );
              resizer();
            },
            
            // in-depth check to make sure everything is layered properly
            layerAudit: function() {
              var scene = this;
              
              var boundaries = this.calculateBoundaries( null, null, null );
              assert && assert( boundaries.length === this.layers.length + 1, 'boundary count (' + boundaries.length + ') does not match layer count (' + this.layers.length + ') + 1' );
              
              // count how many 'self' trails there are
              var eachTrailUnderPaintedCount = 0;
              new scenery.Trail( this ).eachTrailUnder( function( trail ) {
                if ( trail.isPainted() ) {
                  eachTrailUnderPaintedCount++;
                  
                  assert && assert( trail.getInstance(), 'every painted trail must have an instance' );
                }
                
                assert && assert( trail.getInstance() && trail.getInstance().trail.equals( trail ), 'every trail must have a single corresponding instance' );
              } );
              
              var layerPaintedCount = 0;
              _.each( this.layers, function( layer ) {
                layerPaintedCount += layer.getLayerTrails().length;
                
                // reindex now so we don't have problems later
                layer.startPaintedTrail.reindex();
                layer.endPaintedTrail.reindex();
              } );
              
              var layerIterationPaintedCount = 0;
              _.each( this.layers, function( layer ) {
                var selfCount = 0;
                scenery.Trail.eachPaintedTrailBetween( layer.startPaintedTrail, layer.endPaintedTrail, function( trail ) {
                  selfCount++;
                }, false, scene );
                assert && assert( selfCount > 0, 'every layer must have at least one self trail' );
                layerIterationPaintedCount += selfCount;
              } );
              
              assert && assert( eachTrailUnderPaintedCount === layerPaintedCount, 'cross-referencing self trail counts: layerPaintedCount, ' + eachTrailUnderPaintedCount + ' vs ' + layerPaintedCount );
              assert && assert( eachTrailUnderPaintedCount === layerIterationPaintedCount, 'cross-referencing self trail counts: layerIterationPaintedCount, ' + eachTrailUnderPaintedCount + ' vs ' + layerIterationPaintedCount );
              
              _.each( this.layers, function( layer ) {
                assert && assert( layer.startPaintedTrail.compare( layer.endPaintedTrail ) <= 0, 'proper ordering on layer trails' );
              } );
              
              for ( var i = 1; i < this.layers.length; i++ ) {
                assert && assert( this.layers[i-1].endPaintedTrail.compare( this.layers[i].startPaintedTrail ) === -1, 'proper ordering of layer trail boundaries in scene.layers array' );
                assert && assert( this.layers[i-1].endBoundary === this.layers[i].startBoundary, 'proper sharing of boundaries' );
              }
              
              _.each( this.layers, function( layer ) {
                // a list of trails that the layer tracks
                var layerTrails = layer.getLayerTrails();
                
                // a list of trails that the layer should be tracking (between painted trails)
                var computedTrails = [];
                scenery.Trail.eachPaintedTrailBetween( layer.startPaintedTrail, layer.endPaintedTrail, function( trail ) {
                  computedTrails.push( trail.copy() );
                }, false, scene );
                
                // verify that the layer has an identical record of trails compared to the trails inside its boundaries
                assert && assert( layerTrails.length === computedTrails.length, 'layer has incorrect number of tracked trails' );
                _.each( layerTrails, function( trail ) {
                  assert && assert( _.some( computedTrails, function( otherTrail ) { return trail.equals( otherTrail ); } ), 'layer has a tracked trail discrepancy' );
                } );
                
                // verify that each trail has the same (or null) renderer as the layer
                scenery.Trail.eachTrailBetween( layer.startPaintedTrail, layer.endPaintedTrail, function( trail ) {
                  var node = trail.lastNode();
                  assert && assert( !node.renderer || node.renderer.name === layer.type.name, 'specified renderers should match the layer renderer' );
                }, false, scene );
              } );
              
              // verify layer splits
              new scenery.Trail( this ).eachTrailUnder( function( trail ) {
                var beforeSplitTrail;
                var afterSplitTrail;
                if ( trail.lastNode().layerSplit ) {
                  // for the "before" split
                  beforeSplitTrail = trail.previousPainted();
                  afterSplitTrail = trail.lastNode().isPainted() ? trail : trail.nextPainted();
                  assert && assert( !beforeSplitTrail || !afterSplitTrail || beforeSplitTrail.getInstance().layer !== afterSplitTrail.getInstance().layer, 'layerSplit layers need to be different' );
                  
                  //for the "after" split
                  // shift a pointer from the (nested) end of the trail to the next isBefore (if available)
                  var ptr = new scenery.TrailPointer( trail.copy(), false );
                  while ( ptr && ptr.isAfter ) {
                    ptr = ptr.nestedForwards();
                  }
                  
                  // if !ptr, we walked off the end of the graph (nothing after layer split, automatically ok)
                  if ( ptr ) {
                    beforeSplitTrail = ptr.trail.previousPainted();
                    afterSplitTrail = ptr.trail.lastNode().isPainted() ? ptr.trail : ptr.trail.nextPainted();
                    assert && assert( !beforeSplitTrail || !afterSplitTrail || beforeSplitTrail.getInstance().layer !== afterSplitTrail.getInstance().layer, 'layerSplit layers need to be different' );
                  }
                }
              } );
              
              return true; // so we can assert( layerAudit() )
            },
            
            getDebugHTML: function() {
              var startPointer = new scenery.TrailPointer( new scenery.Trail( this ), true );
              var endPointer = new scenery.TrailPointer( new scenery.Trail( this ), false );
              
              function str( ob ) {
                return ob ? ob.toString() : ob;
              }
              
              var depth = 0;
              
              var result = '';
              
              var layerStartEntries = {};
              var layerEndEntries = {};
              _.each( this.layers, function( layer ) {
                var startIdx = layer.startPaintedTrail.getUniqueId();
                var endIndex = layer.endPaintedTrail.getUniqueId();
                layerStartEntries[startIdx] = '';
                layerEndEntries[endIndex] = '';
                layer.startPaintedTrail.reindex();
                layer.endPaintedTrail.reindex();
                var layerInfo = layer.getId() + ' <strong>' + layer.type.name + '</strong>' +
                                ' trails: ' + ( layer.startPaintedTrail ? str( layer.startPaintedTrail ) : layer.startPaintedTrail ) +
                                ',' + ( layer.endPaintedTrail ? str( layer.endPaintedTrail ) : layer.endPaintedTrail );
                layerInfo += '<span style="color: #008">';
                if ( layer.canUseDirtyRegions && !layer.canUseDirtyRegions() ) { layerInfo += ' dirtyRegionsDisabled'; }
                if ( layer.cssTranslation ) { layerInfo += ' cssTranslation'; }
                if ( layer.cssRotation ) { layerInfo += ' cssTranslation'; }
                if ( layer.cssScale ) { layerInfo += ' cssTranslation'; }
                if ( layer.cssTransform ) { layerInfo += ' cssTranslation'; }
                if ( layer.dirtyBounds && layer.dirtyBounds.isFinite() ) { layerInfo += ' dirtyBounds:' + layer.dirtyBounds.toString(); }
                layerInfo += '</span>';
                layerStartEntries[startIdx] += '<div style="color: #080">+Layer ' + layerInfo + '</div>';
                layerEndEntries[endIndex] += '<div style="color: #800">-Layer ' + layerInfo + '</div>';
              } );
              
              startPointer.depthFirstUntil( endPointer, function( pointer ) {
                var div;
                var node = pointer.trail.lastNode();
                
                function addQualifier( text ) {
                    div += ' <span style="color: #008">' + text + '</span>';
                  }
                
                if ( pointer.isBefore && layerStartEntries[pointer.trail.getUniqueId()] ) {
                  result += layerStartEntries[pointer.trail.getUniqueId()];
                }
                if ( pointer.isBefore ) {
                  div = '<div style="margin-left: ' + ( depth * 20 ) + 'px">';
                  if ( node.constructor.name ) {
                    div += ' ' + node.constructor.name; // see http://stackoverflow.com/questions/332422/how-do-i-get-the-name-of-an-objects-type-in-javascript
                  }
                  div += ' <span style="font-weight: ' + ( node.isPainted() ? 'bold' : 'normal' ) + '">' + pointer.trail.lastNode().getId() + '</span>';
                  div += ' <span style="color: #888">' + str( pointer.trail ) + '</span>';
                  if ( !node._visible ) {
                    addQualifier( 'invisible' );
                  }
                  if ( node._pickable === true ) {
                    addQualifier( 'pickable' );
                  }
                  if ( node._pickable === false ) {
                    addQualifier( 'unpickable' );
                  }
                  if ( pointer.trail.isPickable() ) {
                    addQualifier( '<span style="color: #808">hits</span>' );
                  }
                  if ( node._clipArea ) {
                    addQualifier( 'clipArea' );
                  }
                  if ( node._mouseArea ) {
                    addQualifier( 'mouseArea' );
                  }
                  if ( node._touchArea ) {
                    addQualifier( 'touchArea' );
                  }
                  if ( node._inputListeners.length ) {
                    addQualifier( 'inputListeners' );
                  }
                  if ( node._renderer ) {
                    addQualifier( 'renderer:' + node._renderer.name );
                  }
                  if ( node._rendererOptions ) {
                    // addQualifier( 'rendererOptions:' + _.each( node._rendererOptions, function( option, key ) { return key + ':' + str( option ); } ).join( ',' ) );
                  }
                  if ( node._layerSplit ) {
                    addQualifier( 'layerSplit' );
                  }
                  if ( node._opacity < 1 ) {
                    addQualifier( 'opacity:' + node._opacity );
                  }
                  
                  var transformType = '';
                  switch ( node.transform.getMatrix().type ) {
                    case Matrix3.Types.IDENTITY:       transformType = '';           break;
                    case Matrix3.Types.TRANSLATION_2D: transformType = 'translated'; break;
                    case Matrix3.Types.SCALING:        transformType = 'scale';      break;
                    case Matrix3.Types.AFFINE:         transformType = 'affine';     break;
                    case Matrix3.Types.OTHER:          transformType = 'other';      break;
                  }
                  if ( transformType ) {
                    div += ' <span style="color: #88f" title="' + node.transform.getMatrix().toString().replace( '\n', '&#10;' ) + '">' + transformType + '</span>';
                  }
                  div += '</div>';
                  result += div;
                }
                if ( pointer.isAfter && layerEndEntries[pointer.trail.getUniqueId()] ) {
                  result += layerEndEntries[pointer.trail.getUniqueId()];
                }
                depth += pointer.isBefore ? 1 : -1;
              }, false );
              
              return result;
            },
            
            popupDebug: function() {
              var htmlContent = '<!DOCTYPE html>' +
                                '<html lang="en">' +
                                '<head><title>Scenery Debug Snapshot</title></head>' +
                                '<body>' + this.getDebugHTML() + '</body>' +
                                '</html>';
              window.open( 'data:text/html;charset=utf-8,' + encodeURIComponent( htmlContent ) );
            },
            
            getBasicConstructor: function( propLines ) {
              return 'new scenery.Scene( $( \'#main\' ), {' + propLines + '} )';
            },
            
            toStringWithChildren: function( mutateScene ) {
              var scene = this;
              var result = '';
              
              var nodes = this.getTopologicallySortedNodes().slice( 0 ).reverse(); // defensive slice, in case we store the order somewhere
              
              function name( node ) {
                return node === scene ? 'scene' : ( ( node.constructor.name ? node.constructor.name.toLowerCase() : '(node)' ) + node.id );
              }
              
              _.each( nodes, function( node ) {
                if ( result ) {
                  result += '\n';
                }
                
                if ( mutateScene && node === scene ) {
                  var props = scene.getPropString( '  ', false );
                  result += 'scene.mutate( {' + ( props ? ( '\n' + props + '\n' ) : '' ) + '} )';
                } else {
                  result += 'var ' + name( node ) + ' = ' + node.toString( '', false );
                }
                
                _.each( node.children, function( child ) {
                  result += '\n' + name( node ) + '.addChild( ' + name( child ) + ' );';
                } );
              } );
              
              return result;
            }
          } );
          
          Scene.customCursors = {
            'scenery-grab-pointer': ['grab', '-moz-grab', '-webkit-grab', 'pointer'],
            'scenery-grabbing-pointer': ['grabbing', '-moz-grabbing', '-webkit-grabbing', 'pointer']
          };
          
          function applyCSSHacks( $main, options ) {
            // to use CSS3 transforms for performance, hide anything outside our bounds by default
            if ( !options.allowSceneOverflow ) {
              $main.css( 'overflow', 'hidden' );
            }
            
            // forward all pointer events
            $main.css( '-ms-touch-action', 'none' );
            
            if ( options.allowCSSHacks ) {
              // some css hacks (inspired from https://github.com/EightMedia/hammer.js/blob/master/hammer.js)
              (function() {
                var prefixes = [ '-webkit-', '-moz-', '-ms-', '-o-', '' ];
                var properties = {
                  userSelect: 'none',
                  touchCallout: 'none',
                  touchAction: 'none',
                  userDrag: 'none',
                  tapHighlightColor: 'rgba(0,0,0,0)'
                };
                
                _.each( prefixes, function( prefix ) {
                  _.each( properties, function( propertyValue, propertyName ) {
                    $main.css( prefix + propertyName, propertyValue );
                  } );
                } );
              })();
            }
          }
          
          return Scene;
        } );
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Returns version identifier for the simulation.
         * TODO: generate this file at build time, reading package.json
         */
        define( 'version',[],function() {
          
          return function() { return '1.0.0'; };
        } );
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Main class that represents one simulation.
         * Provides default initialization, such as polyfills as well.
         * If the simulation has only one screen, then there is no homescreen, home icon or screen icon in the navigation bar.
         *
         * @author Sam Reid
         */
        define( 'JOIST/Sim',['require','SCENERY/util/Util','JOIST/NavigationBar','JOIST/HomeScreen','SCENERY/Scene','DOT/Vector2','DOT/Bounds2','version','AXON/PropertySet','AXON/Property','PHET_CORE/platform','JOIST/Timer','JOIST/SimJSON','SCENERY/nodes/Path','KITE/Shape'],function( require ) {
          
        
          var Util = require( 'SCENERY/util/Util' );
          var NavigationBar = require( 'JOIST/NavigationBar' );
          var HomeScreen = require( 'JOIST/HomeScreen' );
          var Scene = require( 'SCENERY/Scene' );
          var Vector2 = require( 'DOT/Vector2' );
          var Bounds2 = require( 'DOT/Bounds2' );
          var version = require( 'version' );
          var PropertySet = require( 'AXON/PropertySet' );
          var Property = require( 'AXON/Property' );
          var platform = require( 'PHET_CORE/platform' );
          var Timer = require( 'JOIST/Timer' );
          var SimJSON = require( 'JOIST/SimJSON' );
          var Path = require( 'SCENERY/nodes/Path' );
          var Shape = require( 'KITE/Shape' );
        
          /**
           * @param {String} name
           * @param {Array<Screen>} screens
           * @param options optional parameters for starting screen and home values, so that developers can easily specify the startup scenario for quick development
           * @constructor
           */
          function Sim( name, screens, options ) {
        
            assert && assert( window.phetJoistSimLauncher, 'Sim must be launched using SimLauncher, see https://github.com/phetsims/joist/issues/142' );
        
            options = _.extend( {
              showHomeScreen: true,
              screenIndex: 0,
              standalone: false,
              credits: {},
        
              //The screen display strategy chooses which way to switch screens, using setVisible or setChildren.
              //setVisible is faster in scenery 0.1 but crashes some apps due to memory restrictions, so some apps need to specify 'setChildren'
              //See https://github.com/phetsims/joist/issues/96
              screenDisplayStrategy: 'setVisible',
              showSaveAndLoad: false,
              showSmallHomeScreenIconFrame: false
            }, options );
            this.options = options; // store this for access from prototype functions, assumes that it won't be changed later
        
            this.destroyed = false;
            var sim = this;
            window.sim = sim;
        
            sim.name = name;
            sim.version = version();
            sim.credits = options.credits;
        
            sim.frameCounter = 0; // number of animation frames that have occurred
        
            sim.inputEventLog = []; // used to store input events and requestAnimationFrame cycles
            sim.inputEventBounds = Bounds2.NOTHING;
        
            // state for mouse event fuzzing
            sim.fuzzMouseAverage = 10; // average number of mouse events to synthesize per frame
            sim.fuzzMouseIsDown = false;
            sim.fuzzMousePosition = new Vector2(); // start at 0,0
            sim.fuzzMouseLastMoved = false; // whether the last mouse event was a move (we skew probabilities based on this)
        
            //Set the HTML page title to the localized title
            //TODO: When a sim is embedded on a page, we shouldn't retitle the page
            $( 'title' ).html( name + ' ' + sim.version ); //TODO i18n of order
        
            //if nothing else specified, try to use the options for showHomeScreen & screenIndex from query parameters, to facilitate testing easily in different screens
            function stringToBoolean( string ) { return string === 'true'; }
        
            // Query parameters override options.
            if ( window.phetcommon && window.phetcommon.getQueryParameter && window.phetcommon.getQueryParameter( 'showHomeScreen' ) ) {
              options.showHomeScreen = stringToBoolean( window.phetcommon.getQueryParameter( 'showHomeScreen' ) );
            }
        
            // Option for profiling
            if ( window.phetcommon && window.phetcommon.getQueryParameter && window.phetcommon.getQueryParameter( 'profile' ) ) {
              options.profile = true;
            }
        
            if ( window.phetcommon && window.phetcommon.getQueryParameter && window.phetcommon.getQueryParameter( 'screenIndex' ) ) {
              options.screenIndex = parseInt( window.phetcommon.getQueryParameter( 'screenIndex' ), 10 );
            }
            if ( window.phetcommon && window.phetcommon.getQueryParameter && window.phetcommon.getQueryParameter( 'recordInputEventLog' ) ) {
              // enables recording of Scenery's input events, request animation frames, and dt's so the sim can be played back
              options.recordInputEventLog = true;
              options.inputEventLogName = window.phetcommon.getQueryParameter( 'recordInputEventLog' );
            }
            if ( window.phetcommon && window.phetcommon.getQueryParameter && window.phetcommon.getQueryParameter( 'playbackInputEventLog' ) ) {
              // instead of loading like normal, download a previously-recorded event sequence and play it back (unique to the browser and window size)
              options.playbackInputEventLog = true;
              options.inputEventLogName = window.phetcommon.getQueryParameter( 'playbackInputEventLog' );
            }
            if ( window.phetcommon && window.phetcommon.getQueryParameter && window.phetcommon.getQueryParameter( 'fuzzMouse' ) ) {
              // ignore any user input events, and instead fire mouse events randomly in an effort to cause an exception
              options.fuzzMouse = true;
              if ( window.phetcommon.getQueryParameter( 'fuzzMouse' ) !== 'undefined' ) {
                sim.fuzzMouseAverage = parseFloat( window.phetcommon.getQueryParameter( 'fuzzMouse' ) );
              }
            }
            if ( window.phetcommon && window.phetcommon.getQueryParameter && window.phetcommon.getQueryParameter( 'fuzzTouches' ) ) {
              // ignore any user input events, and instead fire touch events randomly in an effort to cause an exception
              options.fuzzTouches = true;
            }
        
            //If specifying 'standalone' then filter the screens array so that it is just the selected screenIndex
            if ( window.phetcommon && window.phetcommon.getQueryParameter && window.phetcommon.getQueryParameter( 'standalone' ) ) {
              options.standalone = true;
              screens = [screens[options.screenIndex]];
              options.screenIndex = 0;
            }
        
            //If specifying 'screens' then use 1-based (not zero-based) and "." delimited string such as "1.3.4" to get the 1st, 3rd and 4th screen
            if ( window.phetcommon && window.phetcommon.getQueryParameter && window.phetcommon.getQueryParameter( 'screens' ) ) {
              var screensValueString = window.phetcommon.getQueryParameter( 'screens' );
              screens = screensValueString.split( '.' ).map( function( screenString ) {
                return screens[parseInt( screenString, 10 ) - 1];
              } );
              options.screenIndex = 0;
            }
        
            //Default values are to show the home screen with the 1st screen selected
            var showHomeScreen = ( _.isUndefined( options.showHomeScreen ) ) ? true : options.showHomeScreen;
        
            //If there is only one screen, do not show the home screen
            if ( screens.length === 1 ) {
              showHomeScreen = false;
            }
        
            sim.screens = screens;
        
            //This model represents where the simulation is, whether it is on the home screen or a screen, and which screen it is on or is highlighted in the homescreen
            sim.simModel = new PropertySet( {showHomeScreen: showHomeScreen, screenIndex: options.screenIndex || 0 } );
        
            var $body = $( 'body' );
            $body.css( 'padding', '0' ).css( 'margin', '0' ).css( 'overflow', 'hidden' ); // prevent scrollbars
        
            // check to see if the sim div already exists in the DOM under the body. This is the case for https://github.com/phetsims/scenery/issues/174 (iOS offline reading list)
            if ( document.getElementById( 'sim' ) && document.getElementById( 'sim' ).parentNode === document.body ) {
              document.body.removeChild( document.getElementById( 'sim' ) );
            }
        
            //Add a div for the sim to the DOM
            // default cursor is initially checked by Scenery and used as the default value. We don't want 'auto', since then DOM Text will show the text selection cursor
            var $simDiv = $( '<div>' ).attr( 'id', 'sim' ).css( 'position', 'absolute' ).css( 'left', 0 ).css( 'top', 0 ).css( 'cursor', 'default' );
            $body.append( $simDiv );
            this.$simDiv = $simDiv;
        
            //Create the scene
            //Leave accessibility as a flag while in development
            sim.scene = new Scene( $simDiv, {allowDevicePixelRatioScaling: false, accessible: true} );
            sim.scene.sim = sim; // add a reference back to the simulation
            sim.scene.initializeWindowEvents( { batchDOMEvents: true } ); // sets up listeners on the document with preventDefault(), and forwards those events to our scene
            if ( options.recordInputEventLog ) {
              sim.scene.input.logEvents = true; // flag Scenery to log all input events
            }
            window.simScene = sim.scene; // make the scene available for debugging
        
            var showPointers = window.phetcommon && window.phetcommon.getQueryParameter && window.phetcommon.getQueryParameter( 'showPointers' );
            this.showPointersProperty = new Property( showPointers );
            this.showPointersProperty.link( function( showPointers ) {
              sim.scene.setPointerDisplayVisible( showPointers );
            } );
        
            var showPointerAreas = window.phetcommon && window.phetcommon.getQueryParameter && window.phetcommon.getQueryParameter( 'showPointerAreas' );
            this.showPointerAreasProperty = new Property( showPointerAreas );
            this.showPointerAreasProperty.link( function( showPointerAreas ) {
              sim.scene.setPointerAreaDisplayVisible( showPointerAreas );
            } );
        
            function sleep( millis ) {
              var date = new Date();
              var curDate;
              do {
                curDate = new Date();
              } while ( curDate - date < millis );
            }
        
            window.makeEverythingSlow = function() {
              window.setInterval( function() { sleep( 64 ); }, 16 );
            };
            window.makeRandomSlowness = function() {
              window.setInterval( function() { sleep( Math.ceil( 100 + Math.random() * 200 ) ); }, Math.ceil( 100 + Math.random() * 200 ) );
            };
        
            var whiteNavBar = screens[0].backgroundColor === 'black' || screens[0].backgroundColor === '#000' || screens[0].backgroundColor === '#000000';
            sim.navigationBar = new NavigationBar( sim, screens, sim.simModel, whiteNavBar );
        
            if ( screens.length > 1 ) {
              sim.homeScreen = new HomeScreen( sim, {
                showSmallHomeScreenIconFrame: options.showSmallHomeScreenIconFrame
              } );
        
              // Show the layoutBounds, see #145
              if ( window.phetcommon.getQueryParameter( 'dev' ) ) {
                sim.homeScreen.addChild( new Path( Shape.bounds( sim.homeScreen.layoutBounds ), { stroke: 'red', lineWidth: 3, pickable: false } ) );
              }
            }
        
            var updateBackground = function() {
              if ( sim.simModel.showHomeScreen ) {
                $simDiv.css( 'background', 'black' );
              }
              else {
                var backgroundColor = screens[sim.simModel.screenIndex].backgroundColor || 'white';
                var cssColor = ( typeof backgroundColor === 'string' ) ? backgroundColor : backgroundColor.toCSS();
                $simDiv.css( 'background', cssColor );
              }
            };
        
            //Instantiate the screens
            //Currently this is done eagerly, but this pattern leaves open the door for loading things in the background.
            _.each( screens, function( screen, index ) {
        
              //Create each model & view, and keep track of the amount of time it took to create each, which is displayed if 'profile' is enabled as a query parameter
              var start = Date.now();
        
              screen.model = screen.createModel();
              var modelCreated = Date.now();
        
              screen.view = screen.createView( screen.model );
        
              // Show the layoutBounds, see #145
              if ( window.phetcommon.getQueryParameter( 'dev' ) ) {
                screen.view.addChild( new Path( Shape.bounds( screen.view.layoutBounds ), { stroke: 'red', lineWidth: 3, pickable: false } ) );
              }
        
              var viewCreated = Date.now();
        
              if ( options.profile ) {
                console.log( 'screen ' + index + ' created, total time: ' + (viewCreated - start) + 'ms, model: ' + (modelCreated - start) + 'ms, view: ' + (viewCreated - modelCreated) + 'ms' );
              }
            } );
        
            // this will hold the view for the current screen, and is initialized in the screenIndexProperty.link below
            var currentScreenNode;
        
            //ModuleIndex should always be defined.  On startup screenIndex=0 to highlight the 1st screen.
            //When moving from a screen to the homescreen, the previous screen should be highlighted
        
            //Choose the strategy for switching screens.  See options.screenDisplayStrategy documentation above
            if ( options.screenDisplayStrategy === 'setVisible' ) {
        
              if ( screens.length > 1 ) {
                sim.scene.addChild( sim.homeScreen );
              }
              _.each( screens, function( screen ) {
                sim.scene.addChild( screen.view );
              } );
              sim.scene.addChild( sim.navigationBar );
              sim.simModel.multilink( ['screenIndex', 'showHomeScreen'], function( screenIndex, showHomeScreen ) {
                if ( sim.homeScreen ) {
                  sim.homeScreen.setVisible( showHomeScreen );
                }
                for ( var i = 0; i < screens.length; i++ ) {
                  screens[i].view.setVisible( !showHomeScreen && screenIndex === i );
                }
                sim.navigationBar.setVisible( !showHomeScreen );
                updateBackground();
              } );
            }
            else if ( options.screenDisplayStrategy === 'setChildren' ) {
              //On startup screenIndex=0 to highlight the 1st screen.
              //When moving from a screen to the homescreen, the previous screen should be highlighted
              //When the user selects a different screen, show it.
              sim.simModel.screenIndexProperty.link( function( screenIndex ) {
                var newScreenNode = screens[screenIndex].view;
                var oldIndex = currentScreenNode ? sim.scene.indexOfChild( currentScreenNode ) : -1;
        
                // swap out the views if the old one is displayed. if not, we are probably in the home screen
                if ( oldIndex >= 0 ) {
                  sim.scene.removeChild( currentScreenNode );
                  sim.scene.insertChild( oldIndex, newScreenNode ); // same place in the tree, so nodes behind/in front stay that way.
                }
        
                currentScreenNode = newScreenNode;
                updateBackground();
              } );
        
              //When the user presses the home icon, then show the homescreen, otherwise show the screen and navbar
              sim.simModel.showHomeScreenProperty.link( function( showHomeScreen ) {
                var idx = 0;
                if ( showHomeScreen ) {
                  if ( sim.scene.isChild( currentScreenNode ) ) {
                    sim.scene.removeChild( currentScreenNode );
                  }
                  if ( sim.scene.isChild( sim.navigationBar ) ) {
                    // place the home screen where the navigation bar was, if possible
                    idx = sim.scene.indexOfChild( sim.navigationBar );
                    sim.scene.removeChild( sim.navigationBar );
                  }
                  sim.scene.insertChild( idx, sim.homeScreen ); // same place in tree, to preserve nodes in front or behind
                }
                else {
                  if ( sim.homeScreen && sim.scene.isChild( sim.homeScreen ) ) {
                    // place the view / navbar at the same index as the homescreen if possible
                    idx = sim.scene.indexOfChild( sim.homeScreen );
                    sim.scene.removeChild( sim.homeScreen );
                  }
        
                  // same place in tree, to preserve nodes in front or behind
                  sim.scene.insertChild( idx, currentScreenNode );
                  sim.scene.insertChild( idx + 1, sim.navigationBar );
                }
                updateBackground();
              } );
            }
        
            updateBackground();
        
            //Fit to the window and render the initial scene
            $( window ).resize( function() { sim.resizeToWindow(); } );
            sim.resizeToWindow();
          }
        
          Sim.prototype = {
            constructor: Sim,
        
            resizeToWindow: function() {
              this.resize( window.innerWidth, window.innerHeight );
            },
        
            resize: function( width, height ) {
              var sim = this;
        
              //Use Mobile Safari layout bounds to size the home screen and navigation bar
              var scale = Math.min( width / 768, height / 504 );
        
              //40 px high on Mobile Safari
              var navBarHeight = scale * 40;
              sim.navigationBar.layout( scale, width, navBarHeight, height );
              sim.navigationBar.y = height - navBarHeight;
              sim.scene.resize( width, height );
        
              //Layout each of the screens
              _.each( sim.screens, function( m ) { m.view.layout( width, height - sim.navigationBar.height ); } );
        
              if ( sim.homeScreen ) {
                sim.homeScreen.layoutWithScale( scale, width, height );
              }
              //Startup can give spurious resizes (seen on ipad), so defer to the animation loop for painting
        
              sim.scene.input.eventLog.push( 'scene.sim.resize(' + width + ',' + height + ');' );
        
              //Fixes problems where the div would be way off center on iOS7
              if ( platform.mobileSafari ) {
                window.scrollTo( 0, 0 );
              }
            },
        
            start: function() {
              var sim = this;
        
              // if the playback flag is set, don't start up like normal. instead download our event log from the server and play it back.
              // if direct playback (copy-paste) is desired, please directly call sim.startInputEventPlayback( ... ) instead of sim.start().
              if ( this.options.playbackInputEventLog ) {
                var request = new XMLHttpRequest();
                request.open( 'GET', this.getEventLogLocation(), true );
                request.onload = function( e ) {
                  // we create functions, so eval is necessary. we go to the loaded domain on a non-standard port, so cross-domain issues shouldn't present themselves
                  /* jshint -W061 */
                  sim.startInputEventPlayback( eval( request.responseText ) );
                };
                request.send();
                return;
              }
        
              //Keep track of the previous time for computing dt, and initially signify that time hasn't been recorded yet.
              var lastTime = -1;
        
              //Make sure requestAnimationFrame is defined
              Util.polyfillRequestAnimationFrame();
        
              //Record the pointers (if logging is enabled)
        //    var logPointers = new LogPointers();
        //    logPointers.startLogging();
        //
        //    //For debugging, display the pointers
        //    logPointers.showPointers();
        
              // place the rAF *before* the render() to assure as close to 60fps with the setTimeout fallback.
              //http://paulirish.com/2011/requestanimationframe-for-smart-animating/
              (function animationLoop() {
                var dt, screen;
        
                // increment this before we can have an exception thrown, to see if we are missing frames
                sim.frameCounter++;
        
                if ( !sim.destroyed ) {
                  window.requestAnimationFrame( animationLoop );
                }
        
                phetAllocation && phetAllocation( 'loop' );
        
                // fire or synthesize input events
                if ( sim.options.fuzzMouse ) {
                  sim.fuzzMouseEvents();
                }
                else if ( sim.options.fuzzTouches ) {
                  // TODO: we need more state tracking of individual touch points to do this properly
                }
                else {
                  // if any input events were received and batched, fire them now.
                  sim.scene.fireBatchedEvents();
                }
        
                //Compute the elapsed time since the last frame, or guess 1/60th of a second if it is the first frame
                var time = Date.now();
                var elapsedTimeMilliseconds = (lastTime === -1) ? (1000.0 / 60.0) : (time - lastTime);
                lastTime = time;
        
                //Convert to seconds
                dt = elapsedTimeMilliseconds / 1000.0;
        
                //Update the active screen, but not if the user is on the home screen
                if ( !sim.simModel.showHomeScreen ) {
                  // step model and view (both optional)
                  screen = sim.screens[sim.simModel.screenIndex];
                  if ( screen.model.step ) {
                    screen.model.step( dt );
                  }
                  if ( screen.view.step ) {
                    screen.view.step( dt );
                  }
                }
        
                Timer.step( dt );
        
                //If using the TWEEN animation library, then update all of the tweens (if any) before rendering the scene.
                //Update the tweens after the model is updated but before the scene is redrawn.
                if ( window.TWEEN ) {
                  window.TWEEN.update();
                }
                if ( sim.options.recordInputEventLog ) {
                  // push a frame entry into our inputEventLog
                  var entry = {
                    dt: dt,
                    events: sim.scene.input.eventLog,
                    id: sim.frameCounter,
                    time: Date.now()
                  };
                  if ( !sim.inputEventBounds.equals( sim.scene.sceneBounds ) ) {
                    sim.inputEventBounds = sim.scene.sceneBounds.copy();
        
                    entry.width = sim.scene.sceneBounds.width;
                    entry.height = sim.scene.sceneBounds.height;
                  }
                  sim.inputEventLog.push( entry );
                  sim.scene.input.eventLog = []; // clears the event log so that future actions will fill it
                }
                sim.scene.updateScene();
              })();
        
              //If state was specified, load it now
              if ( window.phetcommon && window.phetcommon.getQueryParameter && window.phetcommon.getQueryParameter( 'state' ) ) {
                var stateString = window.phetcommon.getQueryParameter( 'state' );
                var decoded = decodeURIComponent( stateString );
                sim.setState( JSON.parse( decoded, SimJSON.reviver ) );
              }
            },
        
            // Plays back input events and updateScene() loops based on recorded data. data should be an array of objects (representing frames) with dt and fireEvents( scene, dot )
            startInputEventPlayback: function( data ) {
              var sim = this;
        
              var index = 0; // our index into our frame data.
        
              //Make sure requestAnimationFrame is defined
              Util.polyfillRequestAnimationFrame();
        
              if ( data.length && data[0].width ) {
                sim.resize( data[0].width, data[0].height );
              }
        
              var startTime = Date.now();
        
              (function animationLoop() {
                var frame = data[index++];
        
                // when we have aready played the last frame
                if ( frame === undefined ) {
                  var endTime = Date.now();
        
                  var elapsedTime = endTime - startTime;
                  var fps = data.length / ( elapsedTime / 1000 );
        
                  // replace the page with a performance message
                  document.body.innerHTML = '<div style="text-align: center; font-size: 16px;">' +
                                            '<h1>Performance results:</h1>' +
                                            '<p>Approximate frames per second: <strong>' + fps.toFixed( 1 ) + '</strong></p>' +
                                            '<p>Average time per frame (ms/frame): <strong>' + (elapsedTime / index).toFixed( 1 ) + '</strong></p>' +
                                            '<p>Elapsed time: <strong>' + elapsedTime + 'ms</strong></p>' +
                                            '<p>Number of frames: <strong>' + index + '</strong></p>' +
                                            '</div>';
        
                  // ensure that the black text is readable (chipper-built sims have a black background right now)
                  document.body.style.backgroundColor = '#fff';
        
                  // bail before the requestAnimationFrame if we are at the end (stops the frame loop)
                  return;
                }
        
                window.requestAnimationFrame( animationLoop );
        
                // we don't fire batched input events (prevents them from affecting unit/performance tests).
                // instead, we fire pre-recorded events for the scene if it exists (left out for brevity when not necessary)
                if ( frame.fireEvents ) { frame.fireEvents( sim.scene, function( x, y ) { return new Vector2( x, y ); } ); }
        
                //Update the active screen, but not if the user is on the home screen
                if ( !sim.simModel.showHomeScreen ) {
                  sim.screens[sim.simModel.screenIndex].model.step( frame.dt ); // use the pre-recorded dt to ensure lack of variation between runs
                }
        
                //If using the TWEEN animation library, then update all of the tweens (if any) before rendering the scene.
                //Update the tweens after the model is updated but before the scene is redrawn.
                if ( window.TWEEN ) {
                  window.TWEEN.update();
                }
                sim.scene.updateScene();
              })();
            },
        
            addChild: function( node ) {
              this.scene.addChild( node );
            },
        
            // A string that should be evaluated as JavaScript containing an array of "frame" objects, with a dt and an optional fireEvents function
            getRecordedInputEventLogString: function() {
              return '[\n' + _.map( this.inputEventLog, function( item ) {
                var fireEvents = 'fireEvents:function(scene,dot){' + _.map( item.events, function( str ) { return 'scene.input.' + str; } ).join( '' ) + '}';
                return '{dt:' + item.dt + ( item.events.length ? ',' + fireEvents : '' ) + ( item.width ? ',width:' + item.width : '' ) + ( item.height ? ',height:' + item.height : '' ) +
                       ',id:' + item.id + ',time:' + item.time + '}';
              } ).join( ',\n' ) + '\n]';
            },
        
            // For recording and playing back input events, we use a unique combination of the user agent, width and height, so the same
            // server can test different recorded input events on different devices/browsers (desired, because events and coordinates are different)
            getEventLogName: function() {
              var name = this.options.inputEventLogName;
              if ( name === 'browser' ) {
                name = window.navigator.userAgent;
              }
              return ( this.name + '_' + name ).replace( /[^a-zA-Z0-9]/g, '_' );
            },
        
            // protocol-relative URL to the same-origin on a different port, for loading/saving recorded input events and frames
            getEventLogLocation: function() {
              var host = window.location.host.split( ':' )[0]; // grab the hostname without the port
              return '//' + host + ':8083/' + this.getEventLogName();
            },
        
            // submits a recorded event log to the same-origin server (run scenery/tests/event-logs/server/server.js with Node, from the same directory)
            submitEventLog: function() {
              // if we aren't recording data, don't submit any!
              if ( !this.options.recordInputEventLog ) { return; }
        
              var data = this.getRecordedInputEventLogString();
        
              var xmlhttp = new XMLHttpRequest();
              xmlhttp.open( 'POST', this.getEventLogLocation(), true ); // use a protocol-relative port to send it to Scenery's local event-log server
              xmlhttp.setRequestHeader( 'Content-type', 'text/javascript' );
              xmlhttp.send( data );
            },
        
            // submits a recorded event log to the same-origin server (run scenery/tests/event-logs/server/server.js with Node, from the same directory)
            mailEventLog: function() {
              // if we aren't recording data, don't submit any!
              if ( !this.options.recordInputEventLog ) { return; }
        
              var data = this.getRecordedInputEventLogString();
        
              window.open( 'mailto:phethelp@colorado.edu?subject=' + encodeURIComponent( this.name + ' input event log at ' + Date.now() ) + '&body=' + encodeURIComponent( data ) );
            },
        
            fuzzMouseEvents: function() {
              var sim = this;
        
              var chance;
              // run a variable number of events, with a certain chance of bailing out (so no events are possible)
              // models a geometric distribution of events
              while ( ( chance = Math.random() ) < 1 - 1 / sim.fuzzMouseAverage ) {
                var domEvent;
                if ( chance < ( sim.fuzzMouseLastMoved ? 0.02 : 0.4 ) ) {
                  // toggle up/down
                  domEvent = document.createEvent( 'MouseEvent' ); // not 'MouseEvents' according to DOM Level 3 spec
        
                  // technically deprecated, but DOM4 event constructors not out yet. people on #whatwg said to use it
                  domEvent.initMouseEvent( sim.fuzzMouseIsDown ? 'mouseup' : 'mousedown', true, true, window, 1, // click count
                    sim.fuzzMousePosition.x, sim.fuzzMousePosition.y, sim.fuzzMousePosition.x, sim.fuzzMousePosition.y,
                    false, false, false, false,
                    0, // button
                    null );
        
                  sim.scene.input.validatePointers();
        
                  if ( sim.fuzzMouseIsDown ) {
                    sim.scene.input.mouseUp( sim.fuzzMousePosition, domEvent );
                    sim.fuzzMouseIsDown = false;
                  }
                  else {
                    sim.scene.input.mouseDown( sim.fuzzMousePosition, domEvent );
                    sim.fuzzMouseIsDown = true;
                  }
                }
                else {
                  // change the mouse position
                  sim.fuzzMousePosition = new Vector2(
                    Math.floor( Math.random() * sim.scene.sceneBounds.width ),
                    Math.floor( Math.random() * sim.scene.sceneBounds.height )
                  );
        
                  // our move event
                  domEvent = document.createEvent( 'MouseEvent' ); // not 'MouseEvents' according to DOM Level 3 spec
        
                  // technically deprecated, but DOM4 event constructors not out yet. people on #whatwg said to use it
                  domEvent.initMouseEvent( 'mousemove', true, true, window, 0, // click count
                    sim.fuzzMousePosition.x, sim.fuzzMousePosition.y, sim.fuzzMousePosition.x, sim.fuzzMousePosition.y,
                    false, false, false, false,
                    0, // button
                    null );
        
                  sim.scene.input.validatePointers();
                  sim.scene.input.mouseMove( sim.fuzzMousePosition, domEvent );
                }
              }
            },
        
            //Destroy a sim so that it will no longer consume any resources.  Used by sim nesting in Smorgasbord
            destroy: function() {
              this.destroyed = true;
              this.$simDiv.remove();
            },
        
            //For save/load
            getState: function() {
              var state = {};
              for ( var i = 0; i < this.screens.length; i++ ) {
                state['screen' + i] = this.screens[i].getState();
              }
              state.simModel = this.simModel.get();
        
              return state;
            },
        
            setState: function( state ) {
              for ( var i = 0; i < this.screens.length; i++ ) {
                this.screens[i].setState( state['screen' + i] );
              }
              this.simModel.set( state.simModel );
            }
          };
        
          return Sim;
        } );
        
        // Copyright 2002-2013, University of Colorado Boulder
        /**
         * Launches a PhET Simulation, after preloading the specified images.
         *
         * @author Sam Reid
         */
        define( 'JOIST/SimLauncher',[],function() {
          
        
          return {
            /**
             * Launch the Sim by preloading the images and calling the callback.
             *
             * TODO: add an awesome loading screen
             *
             * @param callback the callback function which should create and start the sim, given that the images are loaded
             */
            launch: function( callback ) {
        
              assert && assert( !window.phetJoistSimLauncher, 'Tried to launch twice' );
        
              //Signify that the SimLauncher was called, see https://github.com/phetsims/joist/issues/142
              window.phetJoistSimLauncher = true;
        
              // image elements to remove once we are fully loaded
              var elementsToRemove = [];
        
              function doneLoadingImages() {
                $( '#splash' ).remove();
                callback();
              }
        
              // if image dimensions exist, immediately fire the "all images loaded" event
              var loaded = 0;
        
              //For the images that were written to base64 format using requirejs, make sure they are loaded.
              //img.src = base64 is asynchronous on IE10 and OSX/Safari, so we have to make sure they loaded before returning.
              if ( window.phetImages ) {
                for ( var i = 0; i < window.phetImages.length; i++ ) {
                  var phetImage = window.phetImages[i];
                  phetImage.onload = function() {
                    loaded++;
                    if ( loaded === window.phetImages.length ) {
                      doneLoadingImages();
                    }
                  };
                }
              }
              else {
                doneLoadingImages();
              }
        
              $( window ).load( function() {
                // if images were not loaded immediately, signal the "all images loaded" event
        
                // we wait for here to remove the images from the DOM, otherwise IE9/10 treat the images as completely blank!
                _.each( elementsToRemove, function( element ) {
        
                  //TODO: Why is this null sometimes?
                  if ( element.parentNode ) {
                    element.parentNode.removeChild( element );
                  }
                } );
              } );
            }};
        } );
        
        define("image!FORCES_AND_MOTION_BASICS/Tug_Icon.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/Motion_Icon.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/Friction_Icon.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("image!FORCES_AND_MOTION_BASICS/Acceleration_Icon.png", function(){ var img = new Image();
        window.phetImages = window.phetImages || []
        window.phetImages.push(img);
        img.src='data:image/png;base64,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';
        return img;});
        
        
        define("string!FORCES_AND_MOTION_BASICS/forces-and-motion-basics.name",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/forces-and-motion-basics.name");});
        
        
        define("string!FORCES_AND_MOTION_BASICS/tugOfWar",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/tugOfWar");});
        
        
        define("string!FORCES_AND_MOTION_BASICS/motion",function(){return window.phetStrings.get("FORCES_AND_MOTION_BASICS/motion");});
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        /**
         * Entry point for PhET Interactive Simulation's Forces and Motion: Basics application.
         *
         * @author Sam Reid
         */
        define( 'forces-and-motion-basics-main',['require','FORCES_AND_MOTION_BASICS/tugofwar/model/TugOfWarModel','FORCES_AND_MOTION_BASICS/tugofwar/view/TugOfWarView','FORCES_AND_MOTION_BASICS/motion/model/MotionModel','FORCES_AND_MOTION_BASICS/motion/view/MotionView','SCENERY/nodes/Image','JOIST/Screen','JOIST/Sim','JOIST/SimLauncher','image!FORCES_AND_MOTION_BASICS/Tug_Icon.png','image!FORCES_AND_MOTION_BASICS/Motion_Icon.png','image!FORCES_AND_MOTION_BASICS/Friction_Icon.png','image!FORCES_AND_MOTION_BASICS/Acceleration_Icon.png','string!FORCES_AND_MOTION_BASICS/forces-and-motion-basics.name','string!FORCES_AND_MOTION_BASICS/tugOfWar','string!FORCES_AND_MOTION_BASICS/motion','string!FORCES_AND_MOTION_BASICS/friction','string!FORCES_AND_MOTION_BASICS/acceleration'],function( require ) {
          
        
          var
            TugOfWarModel = require( 'FORCES_AND_MOTION_BASICS/tugofwar/model/TugOfWarModel' ),
            TugOfWarView = require( 'FORCES_AND_MOTION_BASICS/tugofwar/view/TugOfWarView' ),
            MotionModel = require( 'FORCES_AND_MOTION_BASICS/motion/model/MotionModel' ),
            MotionView = require( 'FORCES_AND_MOTION_BASICS/motion/view/MotionView' ),
            Image = require( 'SCENERY/nodes/Image' ),
            Screen = require( 'JOIST/Screen' ),
            Sim = require( 'JOIST/Sim' ),
            SimLauncher = require( 'JOIST/SimLauncher' ),
            TugIcon = require( 'image!FORCES_AND_MOTION_BASICS/Tug_Icon.png' ),
            MotionIcon = require( 'image!FORCES_AND_MOTION_BASICS/Motion_Icon.png' ),
            FrictionIcon = require( 'image!FORCES_AND_MOTION_BASICS/Friction_Icon.png' ),
            AccelerationIcon = require( 'image!FORCES_AND_MOTION_BASICS/Acceleration_Icon.png' ),
            titleString = require( 'string!FORCES_AND_MOTION_BASICS/forces-and-motion-basics.name' ),
            tugOfWarString = require( 'string!FORCES_AND_MOTION_BASICS/tugOfWar' ),
            motionString = require( 'string!FORCES_AND_MOTION_BASICS/motion' ),
            frictionString = require( 'string!FORCES_AND_MOTION_BASICS/friction' ),
            accelerationString = require( 'string!FORCES_AND_MOTION_BASICS/acceleration' );
        
          var simOptions = {
            credits: {
              leadDesign: 'Noah Podolefsky',
              softwareDevelopment: 'Sam Reid',
              designTeam: 'Ariel Paul, Kathy Perkins, Trish Loeblein',
              interviews: 'Noah Podolefsky'
            }
          };
        
          SimLauncher.launch( function() {
        
            //Create and start the sim
            new Sim( titleString, [
              new Screen( tugOfWarString, new Image( TugIcon ),
                function() {return new TugOfWarModel();},
                function( model ) {return new TugOfWarView( model );}
              ),
              new Screen( motionString, new Image( MotionIcon ),
                function() {return new MotionModel( 'motion' );},
                function( model ) {return new MotionView( model );}
              ),
              new Screen( frictionString, new Image( FrictionIcon ),
                function() {return new MotionModel( 'friction' );},
                function( model ) {return new MotionView( model );}
              ),
              new Screen( accelerationString, new Image( AccelerationIcon ),
                function() {return new MotionModel( 'acceleration' );},
                function( model ) {return new MotionView( model );}
              )
            ], simOptions ).start();
          } );
        } );
        
        // Copyright 2002-2013, University of Colorado Boulder
        
        require.config( {
          deps: ['forces-and-motion-basics-main'],
        
          paths: {
        
            //Load dependencies from sibling directories
            ASSERT: '../../assert/js',
            AXON: '../../axon/js',
            BRAND: '../../brand/js',
            DOT: '../../dot/js',
            SCENERY: '../../scenery/js',
            SCENERY_PHET: '../../scenery-phet/js',
            KITE: '../../kite/js',
            PHET_CORE: '../../phet-core/js',
            PHETCOMMON: '../../phetcommon/js',
            SUN: '../../sun/js',
            JOIST: '../../joist/js',
            FORCES_AND_MOTION_BASICS: '../../forces-and-motion-basics/js',
            VIBE: '../../vibe/js',
            SHERPA: '../../sherpa/',
        
            //Load plugins
            image: '../../chipper/requirejs-plugins/image',
            audio: '../../chipper/requirejs-plugins/audio',
            string: '../../chipper/requirejs-plugins/string',
        
            text: '../../sherpa/text'
          },
        
          urlArgs: new Date().getTime() // add cache buster query string to make browser refresh actually reload everything
        } );
        
        define("forces-and-motion-basics-config", function(){});
        
        }());]]></script>
    </body>
</html>
